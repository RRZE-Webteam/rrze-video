{"version":3,"file":"299.js","mappings":"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","sources":["webpack://rrze-video/./node_modules/vidstack/prod/chunks/vidstack-DSYpsFWk.js","webpack://rrze-video/./node_modules/vidstack/prod/providers/vidstack-google-cast.js"],"sourcesContent":["import { isUndefined, isNumber } from './vidstack-CRlI3Mh7.js';\n\nclass RAFLoop {\n  #id;\n  #callback;\n  constructor(callback) {\n    this.#callback = callback;\n  }\n  start() {\n    if (!isUndefined(this.#id)) return;\n    this.#loop();\n  }\n  stop() {\n    if (isNumber(this.#id)) window.cancelAnimationFrame(this.#id);\n    this.#id = void 0;\n  }\n  #loop() {\n    this.#id = window.requestAnimationFrame(() => {\n      if (isUndefined(this.#id)) return;\n      this.#callback();\n      this.#loop();\n    });\n  }\n}\n\nexport { RAFLoop };\n","import { listenEvent, effect, untrack, createScope, keysOf, onDispose, DOMEvent, peek } from '../chunks/vidstack-CRlI3Mh7.js';\nimport { TimeRange } from '../chunks/vidstack-BmMUBVGQ.js';\nimport { RAFLoop } from '../chunks/vidstack-DSYpsFWk.js';\nimport { ListSymbol } from '../chunks/vidstack-D5EzK014.js';\nimport { getCastSessionMedia, getCastContext, getCastSession, hasActiveCastSession, listenCastContextEvent, getCastErrorMessage } from '../chunks/vidstack-IHrfMzpQ.js';\n\nclass GoogleCastMediaInfoBuilder {\n  #info;\n  constructor(src) {\n    this.#info = new chrome.cast.media.MediaInfo(src.src, src.type);\n  }\n  build() {\n    return this.#info;\n  }\n  setStreamType(streamType) {\n    if (streamType.includes(\"live\")) {\n      this.#info.streamType = chrome.cast.media.StreamType.LIVE;\n    } else {\n      this.#info.streamType = chrome.cast.media.StreamType.BUFFERED;\n    }\n    return this;\n  }\n  setTracks(tracks) {\n    this.#info.tracks = tracks.map(this.#buildCastTrack);\n    return this;\n  }\n  setMetadata(title, poster) {\n    this.#info.metadata = new chrome.cast.media.GenericMediaMetadata();\n    this.#info.metadata.title = title;\n    this.#info.metadata.images = [{ url: poster }];\n    return this;\n  }\n  #buildCastTrack(track, trackId) {\n    const castTrack = new chrome.cast.media.Track(trackId, chrome.cast.media.TrackType.TEXT);\n    castTrack.name = track.label;\n    castTrack.trackContentId = track.src;\n    castTrack.trackContentType = \"text/vtt\";\n    castTrack.language = track.language;\n    castTrack.subtype = track.kind.toUpperCase();\n    return castTrack;\n  }\n}\n\nconst REMOTE_TRACK_TEXT_TYPE = chrome.cast.media.TrackType.TEXT, REMOTE_TRACK_AUDIO_TYPE = chrome.cast.media.TrackType.AUDIO;\nclass GoogleCastTracksManager {\n  #cast;\n  #ctx;\n  #onNewLocalTracks;\n  constructor(cast, ctx, onNewLocalTracks) {\n    this.#cast = cast;\n    this.#ctx = ctx;\n    this.#onNewLocalTracks = onNewLocalTracks;\n  }\n  setup() {\n    const syncRemoteActiveIds = this.syncRemoteActiveIds.bind(this);\n    listenEvent(this.#ctx.audioTracks, \"change\", syncRemoteActiveIds);\n    listenEvent(this.#ctx.textTracks, \"mode-change\", syncRemoteActiveIds);\n    effect(this.#syncLocalTracks.bind(this));\n  }\n  getLocalTextTracks() {\n    return this.#ctx.$state.textTracks().filter((track) => track.src && track.type === \"vtt\");\n  }\n  #getLocalAudioTracks() {\n    return this.#ctx.$state.audioTracks();\n  }\n  #getRemoteTracks(type) {\n    const tracks = this.#cast.mediaInfo?.tracks ?? [];\n    return type ? tracks.filter((track) => track.type === type) : tracks;\n  }\n  #getRemoteActiveIds() {\n    const activeIds = [], activeLocalAudioTrack = this.#getLocalAudioTracks().find((track) => track.selected), activeLocalTextTracks = this.getLocalTextTracks().filter((track) => track.mode === \"showing\");\n    if (activeLocalAudioTrack) {\n      const remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteAudioTrack = this.#findRemoteTrack(remoteAudioTracks, activeLocalAudioTrack);\n      if (remoteAudioTrack) activeIds.push(remoteAudioTrack.trackId);\n    }\n    if (activeLocalTextTracks?.length) {\n      const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);\n      if (remoteTextTracks.length) {\n        for (const localTrack of activeLocalTextTracks) {\n          const remoteTextTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);\n          if (remoteTextTrack) activeIds.push(remoteTextTrack.trackId);\n        }\n      }\n    }\n    return activeIds;\n  }\n  #syncLocalTracks() {\n    const localTextTracks = this.getLocalTextTracks();\n    if (!this.#cast.isMediaLoaded) return;\n    const remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);\n    for (const localTrack of localTextTracks) {\n      const hasRemoteTrack = this.#findRemoteTrack(remoteTextTracks, localTrack);\n      if (!hasRemoteTrack) {\n        untrack(() => this.#onNewLocalTracks?.());\n        break;\n      }\n    }\n  }\n  syncRemoteTracks(event) {\n    if (!this.#cast.isMediaLoaded) return;\n    const localAudioTracks = this.#getLocalAudioTracks(), localTextTracks = this.getLocalTextTracks(), remoteAudioTracks = this.#getRemoteTracks(REMOTE_TRACK_AUDIO_TYPE), remoteTextTracks = this.#getRemoteTracks(REMOTE_TRACK_TEXT_TYPE);\n    for (const remoteAudioTrack of remoteAudioTracks) {\n      const hasLocalTrack = this.#findLocalTrack(localAudioTracks, remoteAudioTrack);\n      if (hasLocalTrack) continue;\n      const localAudioTrack = {\n        id: remoteAudioTrack.trackId.toString(),\n        label: remoteAudioTrack.name,\n        language: remoteAudioTrack.language,\n        kind: remoteAudioTrack.subtype ?? \"main\",\n        selected: false\n      };\n      this.#ctx.audioTracks[ListSymbol.add](localAudioTrack, event);\n    }\n    for (const remoteTextTrack of remoteTextTracks) {\n      const hasLocalTrack = this.#findLocalTrack(localTextTracks, remoteTextTrack);\n      if (hasLocalTrack) continue;\n      const localTextTrack = {\n        id: remoteTextTrack.trackId.toString(),\n        src: remoteTextTrack.trackContentId,\n        label: remoteTextTrack.name,\n        language: remoteTextTrack.language,\n        kind: remoteTextTrack.subtype.toLowerCase()\n      };\n      this.#ctx.textTracks.add(localTextTrack, event);\n    }\n  }\n  syncRemoteActiveIds(event) {\n    if (!this.#cast.isMediaLoaded) return;\n    const activeIds = this.#getRemoteActiveIds(), editRequest = new chrome.cast.media.EditTracksInfoRequest(activeIds);\n    this.#editTracksInfo(editRequest).catch((error) => {\n    });\n  }\n  #editTracksInfo(request) {\n    const media = getCastSessionMedia();\n    return new Promise((resolve, reject) => media?.editTracksInfo(request, resolve, reject));\n  }\n  #findLocalTrack(localTracks, remoteTrack) {\n    return localTracks.find((localTrack) => this.#isMatch(localTrack, remoteTrack));\n  }\n  #findRemoteTrack(remoteTracks, localTrack) {\n    return remoteTracks.find((remoteTrack) => this.#isMatch(localTrack, remoteTrack));\n  }\n  // Note: we can't rely on id matching because they will differ between local/remote. A local\n  // track id might not even exist.\n  #isMatch(localTrack, remoteTrack) {\n    return remoteTrack.name === localTrack.label && remoteTrack.language === localTrack.language && remoteTrack.subtype.toLowerCase() === localTrack.kind.toLowerCase();\n  }\n}\n\nclass GoogleCastProvider {\n  $$PROVIDER_TYPE = \"GOOGLE_CAST\";\n  scope = createScope();\n  #player;\n  #ctx;\n  #tracks;\n  #currentSrc = null;\n  #state = \"disconnected\";\n  #currentTime = 0;\n  #played = 0;\n  #seekableRange = new TimeRange(0, 0);\n  #timeRAF = new RAFLoop(this.#onAnimationFrame.bind(this));\n  #playerEventHandlers;\n  #reloadInfo = null;\n  #isIdle = false;\n  constructor(player, ctx) {\n    this.#player = player;\n    this.#ctx = ctx;\n    this.#tracks = new GoogleCastTracksManager(player, ctx, this.#onNewLocalTracks.bind(this));\n  }\n  get type() {\n    return \"google-cast\";\n  }\n  get currentSrc() {\n    return this.#currentSrc;\n  }\n  /**\n   * The Google Cast remote player.\n   *\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.RemotePlayer}\n   */\n  get player() {\n    return this.#player;\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}\n   */\n  get cast() {\n    return getCastContext();\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastSession}\n   */\n  get session() {\n    return getCastSession();\n  }\n  /**\n   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/chrome.cast.media.Media}\n   */\n  get media() {\n    return getCastSessionMedia();\n  }\n  /**\n   * Whether the current Google Cast session belongs to this provider.\n   */\n  get hasActiveSession() {\n    return hasActiveCastSession(this.#currentSrc);\n  }\n  setup() {\n    this.#attachCastContextEventListeners();\n    this.#attachCastPlayerEventListeners();\n    this.#tracks.setup();\n    this.#ctx.notify(\"provider-setup\", this);\n  }\n  #attachCastContextEventListeners() {\n    listenCastContextEvent(\n      cast.framework.CastContextEventType.CAST_STATE_CHANGED,\n      this.#onCastStateChange.bind(this)\n    );\n  }\n  #attachCastPlayerEventListeners() {\n    const Event2 = cast.framework.RemotePlayerEventType, handlers = {\n      [Event2.IS_CONNECTED_CHANGED]: this.#onCastStateChange,\n      [Event2.IS_MEDIA_LOADED_CHANGED]: this.#onMediaLoadedChange,\n      [Event2.CAN_CONTROL_VOLUME_CHANGED]: this.#onCanControlVolumeChange,\n      [Event2.CAN_SEEK_CHANGED]: this.#onCanSeekChange,\n      [Event2.DURATION_CHANGED]: this.#onDurationChange,\n      [Event2.IS_MUTED_CHANGED]: this.#onVolumeChange,\n      [Event2.VOLUME_LEVEL_CHANGED]: this.#onVolumeChange,\n      [Event2.IS_PAUSED_CHANGED]: this.#onPausedChange,\n      [Event2.LIVE_SEEKABLE_RANGE_CHANGED]: this.#onProgress,\n      [Event2.PLAYER_STATE_CHANGED]: this.#onPlayerStateChange\n    };\n    this.#playerEventHandlers = handlers;\n    const handler = this.#onRemotePlayerEvent.bind(this);\n    for (const type of keysOf(handlers)) {\n      this.#player.controller.addEventListener(type, handler);\n    }\n    onDispose(() => {\n      for (const type of keysOf(handlers)) {\n        this.#player.controller.removeEventListener(type, handler);\n      }\n    });\n  }\n  async play() {\n    if (!this.#player.isPaused && !this.#isIdle) return;\n    if (this.#isIdle) {\n      await this.#reload(false, 0);\n      return;\n    }\n    this.#player.controller?.playOrPause();\n  }\n  async pause() {\n    if (this.#player.isPaused) return;\n    this.#player.controller?.playOrPause();\n  }\n  getMediaStatus(request) {\n    return new Promise((resolve, reject) => {\n      this.media?.getStatus(request, resolve, reject);\n    });\n  }\n  setMuted(muted) {\n    const hasChanged = muted && !this.#player.isMuted || !muted && this.#player.isMuted;\n    if (hasChanged) this.#player.controller?.muteOrUnmute();\n  }\n  setCurrentTime(time) {\n    this.#player.currentTime = time;\n    this.#ctx.notify(\"seeking\", time);\n    this.#player.controller?.seek();\n  }\n  setVolume(volume) {\n    this.#player.volumeLevel = volume;\n    this.#player.controller?.setVolumeLevel();\n  }\n  async loadSource(src) {\n    if (this.#reloadInfo?.src !== src) this.#reloadInfo = null;\n    if (hasActiveCastSession(src)) {\n      this.#resumeSession();\n      this.#currentSrc = src;\n      return;\n    }\n    this.#ctx.notify(\"load-start\");\n    const loadRequest = this.#buildLoadRequest(src), errorCode = await this.session.loadMedia(loadRequest);\n    if (errorCode) {\n      this.#currentSrc = null;\n      this.#ctx.notify(\"error\", Error(getCastErrorMessage(errorCode)));\n      return;\n    }\n    this.#currentSrc = src;\n  }\n  destroy() {\n    this.#reset();\n    this.#endSession();\n  }\n  #reset() {\n    if (!this.#reloadInfo) {\n      this.#played = 0;\n      this.#seekableRange = new TimeRange(0, 0);\n    }\n    this.#timeRAF.stop();\n    this.#currentTime = 0;\n    this.#reloadInfo = null;\n  }\n  #resumeSession() {\n    const resumeSessionEvent = new DOMEvent(\"resume-session\", { detail: this.session });\n    this.#onMediaLoadedChange(resumeSessionEvent);\n    const { muted, volume, savedState } = this.#ctx.$state, localState = savedState();\n    this.setCurrentTime(Math.max(this.#player.currentTime, localState?.currentTime ?? 0));\n    this.setMuted(muted());\n    this.setVolume(volume());\n    if (localState?.paused === false) this.play();\n  }\n  #endSession() {\n    this.cast.endCurrentSession(true);\n    const { remotePlaybackLoader } = this.#ctx.$state;\n    remotePlaybackLoader.set(null);\n  }\n  #disconnectFromReceiver() {\n    const { savedState } = this.#ctx.$state;\n    savedState.set({\n      paused: this.#player.isPaused,\n      currentTime: this.#player.currentTime\n    });\n    this.#endSession();\n  }\n  #onAnimationFrame() {\n    this.#onCurrentTimeChange();\n  }\n  #onRemotePlayerEvent(event) {\n    this.#playerEventHandlers[event.type].call(this, event);\n  }\n  #onCastStateChange(data) {\n    const castState = this.cast.getCastState(), state = castState === cast.framework.CastState.CONNECTED ? \"connected\" : castState === cast.framework.CastState.CONNECTING ? \"connecting\" : \"disconnected\";\n    if (this.#state === state) return;\n    const detail = { type: \"google-cast\", state }, trigger = this.#createEvent(data);\n    this.#state = state;\n    this.#ctx.notify(\"remote-playback-change\", detail, trigger);\n    if (state === \"disconnected\") {\n      this.#disconnectFromReceiver();\n    }\n  }\n  #onMediaLoadedChange(event) {\n    const hasLoaded = !!this.#player.isMediaLoaded;\n    if (!hasLoaded) return;\n    const src = peek(this.#ctx.$state.source);\n    Promise.resolve().then(() => {\n      if (src !== peek(this.#ctx.$state.source) || !this.#player.isMediaLoaded) return;\n      this.#reset();\n      const duration = this.#player.duration;\n      this.#seekableRange = new TimeRange(0, duration);\n      const detail = {\n        provider: this,\n        duration,\n        buffered: new TimeRange(0, 0),\n        seekable: this.#getSeekableRange()\n      }, trigger = this.#createEvent(event);\n      this.#ctx.notify(\"loaded-metadata\", void 0, trigger);\n      this.#ctx.notify(\"loaded-data\", void 0, trigger);\n      this.#ctx.notify(\"can-play\", detail, trigger);\n      this.#onCanControlVolumeChange();\n      this.#onCanSeekChange(event);\n      const { volume, muted } = this.#ctx.$state;\n      this.setVolume(volume());\n      this.setMuted(muted());\n      this.#timeRAF.start();\n      this.#tracks.syncRemoteTracks(trigger);\n      this.#tracks.syncRemoteActiveIds(trigger);\n    });\n  }\n  #onCanControlVolumeChange() {\n    this.#ctx.$state.canSetVolume.set(this.#player.canControlVolume);\n  }\n  #onCanSeekChange(event) {\n    const trigger = this.#createEvent(event);\n    this.#ctx.notify(\"stream-type-change\", this.#getStreamType(), trigger);\n  }\n  #getStreamType() {\n    const streamType = this.#player.mediaInfo?.streamType;\n    return streamType === chrome.cast.media.StreamType.LIVE ? this.#player.canSeek ? \"live:dvr\" : \"live\" : \"on-demand\";\n  }\n  #onCurrentTimeChange() {\n    if (this.#reloadInfo) return;\n    const currentTime = this.#player.currentTime;\n    if (currentTime === this.#currentTime) return;\n    this.#ctx.notify(\"time-change\", currentTime);\n    if (currentTime > this.#played) {\n      this.#played = currentTime;\n      this.#onProgress();\n    }\n    if (this.#ctx.$state.seeking()) {\n      this.#ctx.notify(\"seeked\", currentTime);\n    }\n    this.#currentTime = currentTime;\n  }\n  #onDurationChange(event) {\n    if (!this.#player.isMediaLoaded || this.#reloadInfo) return;\n    const duration = this.#player.duration, trigger = this.#createEvent(event);\n    this.#seekableRange = new TimeRange(0, duration);\n    this.#ctx.notify(\"duration-change\", duration, trigger);\n  }\n  #onVolumeChange(event) {\n    if (!this.#player.isMediaLoaded) return;\n    const detail = {\n      muted: this.#player.isMuted,\n      volume: this.#player.volumeLevel\n    }, trigger = this.#createEvent(event);\n    this.#ctx.notify(\"volume-change\", detail, trigger);\n  }\n  #onPausedChange(event) {\n    const trigger = this.#createEvent(event);\n    if (this.#player.isPaused) {\n      this.#ctx.notify(\"pause\", void 0, trigger);\n    } else {\n      this.#ctx.notify(\"play\", void 0, trigger);\n    }\n  }\n  #onProgress(event) {\n    const detail = {\n      seekable: this.#getSeekableRange(),\n      buffered: new TimeRange(0, this.#played)\n    }, trigger = event ? this.#createEvent(event) : void 0;\n    this.#ctx.notify(\"progress\", detail, trigger);\n  }\n  #onPlayerStateChange(event) {\n    const state = this.#player.playerState, PlayerState = chrome.cast.media.PlayerState;\n    this.#isIdle = state === PlayerState.IDLE;\n    if (state === PlayerState.PAUSED) return;\n    const trigger = this.#createEvent(event);\n    switch (state) {\n      case PlayerState.PLAYING:\n        this.#ctx.notify(\"playing\", void 0, trigger);\n        break;\n      case PlayerState.BUFFERING:\n        this.#ctx.notify(\"waiting\", void 0, trigger);\n        break;\n      case PlayerState.IDLE:\n        this.#timeRAF.stop();\n        this.#ctx.notify(\"pause\");\n        this.#ctx.notify(\"end\");\n        break;\n    }\n  }\n  #getSeekableRange() {\n    return this.#player.liveSeekableRange ? new TimeRange(this.#player.liveSeekableRange.start, this.#player.liveSeekableRange.end) : this.#seekableRange;\n  }\n  #createEvent(detail) {\n    return detail instanceof Event ? detail : new DOMEvent(detail.type, { detail });\n  }\n  #buildMediaInfo(src) {\n    const { streamType, title, poster } = this.#ctx.$state;\n    return new GoogleCastMediaInfoBuilder(src).setMetadata(title(), poster()).setStreamType(streamType()).setTracks(this.#tracks.getLocalTextTracks()).build();\n  }\n  #buildLoadRequest(src) {\n    const mediaInfo = this.#buildMediaInfo(src), request = new chrome.cast.media.LoadRequest(mediaInfo), savedState = this.#ctx.$state.savedState();\n    request.autoplay = (this.#reloadInfo?.paused ?? savedState?.paused) === false;\n    request.currentTime = this.#reloadInfo?.time ?? savedState?.currentTime ?? 0;\n    return request;\n  }\n  async #reload(paused, time) {\n    const src = peek(this.#ctx.$state.source);\n    this.#reloadInfo = { src, paused, time };\n    await this.loadSource(src);\n  }\n  #onNewLocalTracks() {\n    this.#reload(this.#player.isPaused, this.#player.currentTime).catch((error) => {\n    });\n  }\n}\n\nexport { GoogleCastProvider };\n"],"names":["RAFLoop","constructor","callback","this","start","stop","window","cancelAnimationFrame","requestAnimationFrame","GoogleCastMediaInfoBuilder","src","chrome","cast","media","MediaInfo","type","build","setStreamType","streamType","includes","StreamType","LIVE","BUFFERED","setTracks","tracks","map","setMetadata","title","poster","metadata","GenericMediaMetadata","images","url","track","trackId","castTrack","Track","TrackType","TEXT","name","label","trackContentId","trackContentType","language","subtype","kind","toUpperCase","REMOTE_TRACK_TEXT_TYPE","REMOTE_TRACK_AUDIO_TYPE","AUDIO","GoogleCastTracksManager","ctx","onNewLocalTracks","setup","syncRemoteActiveIds","bind","audioTracks","textTracks","getLocalTextTracks","$state","filter","mediaInfo","activeIds","activeLocalAudioTrack","find","selected","activeLocalTextTracks","mode","remoteAudioTracks","remoteAudioTrack","push","length","remoteTextTracks","localTrack","remoteTextTrack","localTextTracks","isMediaLoaded","syncRemoteTracks","event","localAudioTracks","localAudioTrack","id","toString","add","localTextTrack","toLowerCase","editRequest","EditTracksInfoRequest","catch","error","request","Promise","resolve","reject","editTracksInfo","localTracks","remoteTrack","remoteTracks","GoogleCastProvider","$$PROVIDER_TYPE","scope","player","currentSrc","session","hasActiveSession","notify","framework","CastContextEventType","CAST_STATE_CHANGED","Event2","RemotePlayerEventType","handlers","IS_CONNECTED_CHANGED","IS_MEDIA_LOADED_CHANGED","CAN_CONTROL_VOLUME_CHANGED","CAN_SEEK_CHANGED","DURATION_CHANGED","IS_MUTED_CHANGED","VOLUME_LEVEL_CHANGED","IS_PAUSED_CHANGED","LIVE_SEEKABLE_RANGE_CHANGED","PLAYER_STATE_CHANGED","handler","controller","addEventListener","removeEventListener","play","isPaused","playOrPause","pause","getMediaStatus","getStatus","setMuted","muted","isMuted","muteOrUnmute","setCurrentTime","time","currentTime","seek","setVolume","volume","volumeLevel","setVolumeLevel","loadSource","loadRequest","errorCode","loadMedia","Error","destroy","resumeSessionEvent","detail","savedState","localState","Math","max","paused","endCurrentSession","remotePlaybackLoader","set","call","data","castState","getCastState","state","CastState","CONNECTED","CONNECTING","trigger","source","then","duration","provider","buffered","seekable","canSetVolume","canControlVolume","canSeek","seeking","playerState","PlayerState","IDLE","PAUSED","PLAYING","BUFFERING","liveSeekableRange","end","Event","LoadRequest","autoplay"],"sourceRoot":""}