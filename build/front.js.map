{"version":3,"file":"front.js","mappings":";;;;;;;;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAsU;AAChR;;AAEtD;AACA;AACA;AACA;AACA,IAAI;AACJ,mBAAmB,+DAAW;AAC9B,wBAAwB,oEAAgB;AACxC,sBAAsB,iEAAa;AACnC,eAAe,2DAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gEAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,kBAAkB,4BAA4B;AAC9C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,EAAE,4DAAQ;AACd,wBAAwB,oEAAgB;AACxC;AACA;AACA,6BAA6B,oEAAgB;AAC7C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,4BAA4B,oEAAgB;AAC5C;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM,EAAE,4DAAQ;AAChB;AACA;AACA;AACA,0BAA0B,oEAAgB;AAC1C;AACA;AACA;AACA;AACA,iBAAiB,oEAAgB;AACjC,mBAAmB,iEAAa;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,uDAAG;AAC1B,uBAAuB,uDAAG;;AAE1B;AACA;AACA;AACA;AACA;AACA,mBAAmB,yDAAK;;AAExB;AACA;AACA;AACA;AACA,qDAAqD,gEAAY;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,CAAC;;AAED;AACA,mGAAmG,gEAAY,qEAAqE,gEAAY,oEAAoE,2DAAO;AAC3Q;AACA;AACA,aAAa,gEAAY,8CAA8C,iFAA6B;AACpG;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,4BAA4B,0DAAU;AACtC;AACA;AACA,QAAQ,EAAE,4DAAQ;AAClB,4EAA4E,0DAAU;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qEAAiB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,2DAAO;AAChD;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,gEAAY;AACtC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM,gEAAY;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE,4DAAQ;;AAElB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,2DAAO;AAC1B,8BAA8B,+DAAW;AACzC,8BAA8B,2DAAO;AACrC;AACA,sGAAsG,wEAAoB,sBAAsB,yEAAqB;AACrK;AACA;AACA,mCAAmC,6EAAyB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qEAAiB;AACvC;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,+DAAW;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qDAAK;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ,EAAE,4DAAQ;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,eAAe,uDAAG;AAClB,eAAe,uDAAG;AAClB,eAAe,uDAAG;AAClB,eAAe,uDAAG;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,4BAA4B,oEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,+BAA+B,KAAK;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,EAAE,4DAAQ;AAClB;AACA;AACA,uBAAuB,oEAAgB;AACvC,4BAA4B,oEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,+DAAW;AACzB;AACA;AACA,0BAA0B,2DAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAO;AACpC,2BAA2B,uDAAG;AAC9B,0BAA0B,uDAAG;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,eAAe,2DAAO;AACtB,oBAAoB,gEAAY;AAChC,qBAAqB,+DAAW;AAChC;AACA;AACA,mBAAmB,4DAAQ;;AAE3B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ,EAAE,4DAAQ;AAClB;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAW,CAAC,2DAAO;AAC3C,uBAAuB,mEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,yDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,yDAAK;AAC9B;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ,EAAE,4DAAQ;AAClB;AACA;AACA;AACA;AACA,wBAAwB,+DAAW;AACnC,uBAAuB,mEAAe;AACtC;AACA;AACA,wBAAwB,4DAAQ;AAChC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,2DAAO;AAC7D;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,wBAAwB;AACxB;AACA,QAAQ,EAAE,4DAAQ;AAClB;AACA,mBAAmB,2DAAO;AAC1B,wBAAwB,gEAAY;AACpC,sBAAsB,+DAAW;AACjC;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,sCAAsC,uDAAG;AACzC,qCAAqC,uDAAG;AACxC;AACA;AACA;AACA;AACA,gDAAgD,uDAAG;AACnD,QAAQ;AACR,iDAAiD,uDAAG;AACpD;AACA;AACA,qBAAqB,uDAAG;AACxB,qBAAqB,uDAAG;AACxB,qBAAqB,uDAAG;AACxB,qBAAqB,uDAAG;AACxB;AACA,iFAAiF,uDAAG;AACpF,UAAU;AACV,mFAAmF,uDAAG;AACtF;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsH;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3gCmM;AAC/O;AACkP;AAC9P;;AAE9D;AACA,cAAc,wEAAgB;AAC9B;AACA;AACA;AACA;AACA,oBAAoB,qEAAa;AACjC;AACA;AACA,yBAAyB,yDAAK,2BAA2B,yDAAK;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,iEAAS;AACnB;;AAEA;AACA;AACA,OAAO,qEAAa;AACpB,WAAW,gEAAY;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,eAAe,yDAAK;AACpB,eAAe,yDAAK;;AAEpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,gEAAY;AAC3C;AACA,cAAc,iEAAS;AACvB,OAAO,gEAAQ;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE,iEAAS;AAC5E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gEAAY;AAC1B;AACA;AACA,UAAU,iEAAS;AACnB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,2HAA2H,gEAAY;AACvI;AACA;AACA;AACA;AACA;AACA,gBAAgB,iEAAS;AACzB,sCAAsC,iEAAS,iBAAiB,iEAAS;AACzE;AACA,wBAAwB,uEAAe;AACvC;AACA;AACA;AACA,kBAAkB,wEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAS;AAC5B,sBAAsB,uEAAe;AACrC;AACA;AACA,SAAS,oEAAgB;AACzB;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,0BAA0B,0EAAkB;AAC5C,8BAA8B,kEAAU;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gEAAY;AAC1B,kBAAkB,gEAAY;AAC9B,kCAAkC,qEAAa;AAC/C;AACA,QAAQ,mEAAW,6BAA6B,yEAAiB;AACjE,eAAe,qEAAa;AAC5B;AACA,QAAQ,qEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,+BAA+B,0EAAkB,kBAAkB,qEAAa;AAChF;;AAEA;AACA;AACA;AACA,eAAe,0EAAkB;AACjC,iBAAiB,qEAAa;AAC9B;AACA,gBAAgB,uDAAG;AACnB,iBAAiB,uDAAG;AACpB;AACA;AACA,MAAM,wEAAgB;AACtB,SAAS,uDAAG;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAc,iEAAS;AACvB,eAAe,0EAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gEAAQ;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAgB,qEAAa,gCAAgC,gEAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,2BAA2B,0EAAkB;AAC7C,IAAI,SAAS,iEAAS;AACtB;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,oEAAgB;AACzB;AACA;AACA,qBAAqB,qEAAa;AAClC,kCAAkC,iEAAS,gBAAgB,6EAAqB;AAChF;AACA;AACA,SAAS,wEAAgB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,4EAAoB,kCAAkC,iEAAS,QAAQ,mEAAW;AACjG;AACA,yBAAyB,wEAAgB;AACzC,qCAAqC,qEAAa;;AAElD;AACA,SAAS,iEAAS,kBAAkB,6EAAqB;AACzD,0BAA0B,wEAAgB;AAC1C,oCAAoC,yEAAiB;AACrD;AACA;AACA;AACA,kTAAkT,yEAAiB;AACnU;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,kBAAkB,qEAAa;AAC/B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,sEAAsE,kEAAU;AAChF;AACA;AACA;AACA;AACA,kBAAkB,uDAAG;AACrB,oBAAoB,uDAAG;AACvB,qBAAqB,uDAAG;AACxB,mBAAmB,uDAAG;AACtB;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA,kCAAkC,qEAAa;AAC/C,0BAA0B,0EAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,gEAAY;AAC9B;AACA,QAAQ,mEAAW,6BAA6B,yEAAiB;AACjE,eAAe,qEAAa;AAC5B;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,wEAAgB;AACzB;;AAEA;AACA,OAAO,qEAAa,aAAa,wEAAgB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAc,iEAAS;AACvB,MAAM,kEAAU;AAChB;AACA;AACA,OAAO,qEAAa;AACpB,0BAA0B,qEAAa;AACvC,+BAA+B,6EAAqB;AACpD,UAAU,iEAAS;AACnB;AACA;AACA,wBAAwB,qEAAa;AACrC;AACA;AACA;AACA;AACA,yBAAyB,sEAAc;AACvC;AACA;AACA,sBAAsB,6EAAqB,uDAAuD,yEAAiB;AACnH;AACA;AACA,yBAAyB,0EAAkB;AAC3C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,wEAAgB;AACzB;;AAEA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;;AAEA;AACA;AACA;AACA;AACA,eAAe,0EAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,yDAAK;AAC1B,uBAAuB,yDAAK;AAC5B,wBAAwB,yDAAK;AAC7B,sBAAsB,yDAAK;AAC3B;AACA;AACA;AACA,iBAAiB,uDAAG,IAAI,uDAAG;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,0EAA0E,4EAAoB,wBAAwB,4EAAoB;AAC1I;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAgB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAQ;;AAEvB;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4DAAe;;AAErC;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAO;;AAErB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mDAAM;;AAEnB;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mDAAM;;AAEnB;AACA;AACA;AACA;AACA;AACA,aAAa,mDAAM;;AAEnB;AACA;AACA;AACA;AACA;AACA,cAAc,oDAAO;;AAErB;AACA;AACA;AACA;AACA;AACA,eAAe,qDAAQ;;AAEvB;AACA;AACA;AACA,mBAAmB,yDAAY;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,kEAAiB;AAC1B;AACA;AACA,GAAG;AACH;;AAE4I;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/rB5I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEgV;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7IhV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEyW;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzIzW;AACA;AACA;;AAEA,kBAAkB;;AAElB;AACA;;AAEA;AACA;AACA,uFAAuF,iBAAiB;AACxG;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA,EAAE;AACF,EAAE;;AAEF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG;;AAEJ;AACA,+DAA+D,8BAA8B;AAC7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG;;AAEJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uCAAuC,KAAK;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,GAAG,sBAAsB,SAAS;AACtF,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,IAAI,sCAAsC,iBAAiB;AAC9G;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kEAAkE,oCAAoC;AACtG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA,0EAA0E,mCAAmC;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;;AAEA;AACA,yEAAyE,2BAA2B;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,kBAAkB;AAC3C;AACA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,UAAU;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,UAAU,MAAM;AAC/C;AACA;AACA,KAAK;AACL;AACA,+BAA+B,UAAU,MAAM;AAC/C;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa,YAAY,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,aAAa,YAAY,GAAG;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,QAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA,oBAAoB;AACpB;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,oBAAoB,oBAAoB,wBAAwB,KAAK,mBAAmB;AAChJ;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA,6CAA6C,aAAa,qBAAqB,UAAU;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,wBAAwB,QAAQ;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,YAAY;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc,eAAe;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,oBAAoB;AACzC,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,YAAY;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,QAAQ;AAC3B;AACA;AACA;AACA;;AAEA,sCAAsC,oBAAoB;AAC1D;AACA;AACA;AACA;AACA;AACA,wCAAwC,IAAI;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+IAA+I,aAAa;AAC5J;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,4BAA4B,KAAK,gDAAgD,UAAU;AAC3F;AACA,MAAM;AACN,0GAA0G,cAAc;AACxH;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,mIAAmI,KAAK;AACxI,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,kJAAkJ,OAAO;AACzJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,KAAK,KAAK,UAAU,MAAM;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8DAA8D;;AAE9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,+EAA+E,WAAW;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,KAAK;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB,gEAAgE,OAAO;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,gBAAgB;AAChB,uEAAuE,OAAO;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,qCAAqC,YAAY,GAAG,MAAM;AAC1D,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,OAAO;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,KAAK;AACpB;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,mEAAmE,aAAa,WAAW,cAAc,QAAQ,WAAW;;AAE5H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,aAAa;AACvF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,8BAA8B;AAC9B;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA,oFAAoF,YAAY;;AAEhG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,+BAA+B,qFAAqF,yBAAyB,aAAa;AAC1J;AACA,sBAAsB,eAAe,MAAM,WAAW;AACtD,MAAM;AACN,yBAAyB,YAAY,aAAa,gBAAgB;AAClE;AACA;AACA,sCAAsC,QAAQ;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,IAAI;AACrD;AACA,MAAM;AACN,yCAAyC,IAAI;AAC7C;AACA;AACA;AACA;AACA,QAAQ;AACR,gFAAgF,KAAK;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,IAAI;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,SAAS;AAC9D;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,qEAAqE,EAAE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,uBAAuB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,mBAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,IAAI;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;;AAEA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,QAAQ;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI;AACnD;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,4EAA4E,yCAAyC;AACrH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU;AACrD;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,UAAU;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,sBAAsB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,gCAAgC;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,MAAM,GAAG,aAAa,GAAG,gBAAgB,GAAG,qCAAqC,GAAG,UAAU;AAC3I;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,QAAQ;AACR,kCAAkC,IAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,gDAAgD,sBAAsB;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,iBAAiB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,YAAY,QAAQ,aAAa;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA,UAAU;AACV,2EAA2E,MAAM;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAkC,OAAO,EAAE,4HAA4H;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,4BAA4B,MAAM,aAAa,qBAAqB,YAAY;AAC1I;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,kBAAkB,kBAAkB,wBAAwB,UAAU,aAAa,UAAU,UAAU,UAAU,KAAK;AAC/J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,uCAAuC,OAAO,KAAK,sCAAsC;AACzF;AACA,0BAA0B;AAC1B,qBAAqB;AACrB,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B,2BAA2B;AAC3B,4BAA4B,4BAA4B;AACxD;;AAEA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,eAAe,GAAG,yBAAyB,SAAS,aAAa;AAChH;AACA,QAAQ;AACR;AACA;AACA;AACA,+CAA+C,eAAe,GAAG,yBAAyB,SAAS,aAAa,OAAO,MAAM;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,mDAAmD,SAAS;AAC5D;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,6BAA6B;AACxE;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA,iBAAiB,aAAa,GAAG,YAAY,GAAG,2BAA2B,EAAE,+BAA+B,GAAG,MAAM,GAAG,+BAA+B;AACvJ;AACA;AACA,iBAAiB,eAAe,EAAE,mCAAmC,GAAG,MAAM;AAC9E;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,0CAA0C;AACnD;AACA;AACA;AACA,SAAS,iFAAiF;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ,iCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,0BAA0B,wBAAwB,UAAU;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,qBAAqB;AAC/F;AACA;AACA;AACA;AACA,uEAAuE,oBAAoB,yCAAyC,oCAAoC;AACxK;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oEAAoE,yBAAyB,eAAe,UAAU;AACtH;AACA;AACA;AACA,mEAAmE,4BAA4B,eAAe,aAAa;AAC3H;AACA;AACA;AACA,kFAAkF,6BAA6B;AAC/G;AACA;AACA;AACA,+DAA+D,wBAAwB,oBAAoB,cAAc;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,QAAQ,oBAAoB,OAAO;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,4BAA4B,GAAG;AAC/B;AACA;AACA;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,8BAA8B;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,QAAQ,EAAE,mCAAmC,WAAW,YAAY;AACxG,6BAA6B,kCAAkC;AAC/D,kDAAkD,4BAA4B;AAC9E,sDAAsD,qCAAqC;AAC3F,uBAAuB,UAAU;AACjC,6BAA6B,yDAAyD;AACtF,yBAAyB,0BAA0B;AACnD,2BAA2B,eAAe,IAAI,0BAA0B;AACxE;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,uBAAuB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kGAAkG,YAAY,aAAa,QAAQ;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,qBAAqB,GAAG,qCAAqC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,oCAAoC,8CAA8C,uCAAuC;AACxK;AACA;AACA;AACA;AACA;AACA,yBAAyB,mEAAmE,0BAA0B,UAAU;AAChI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,4CAA4C,0BAA0B;AACtE,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,mBAAmB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,mBAAmB,cAAc,OAAO,EAAE,6BAA6B;AACjJ,cAAc;AACd,+FAA+F,OAAO,EAAE,6BAA6B;AACrI;AACA,+DAA+D,MAAM;AACrE;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,yBAAyB,KAAK,cAAc,mCAAmC,gCAAgC,IAAI,sCAAsC,uBAAuB,aAAa,IAAI,kBAAkB;AACtQ;AACA,gDAAgD,mBAAmB,IAAI,GAAG,aAAa,uBAAuB,YAAY,kCAAkC,OAAO,4BAA4B,cAAc,wBAAwB,mBAAmB,6BAA6B,gBAAgB,0BAA0B,iBAAiB,gBAAgB,WAAW,iBAAiB,aAAa,mBAAmB,gBAAgB,UAAU;AACtb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,IAAI;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,8BAA8B,IAAI;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc,GAAG,eAAe,GAAG,YAAY;AAC3D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,sBAAsB,qBAAqB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2FAA2F,YAAY;AACvG;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAwC;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,0BAA0B;AAC/E;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2CAA2C,eAAe,EAAE,cAAc;AAC1E;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,2CAA2C,eAAe,EAAE,cAAc;AAC1E;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,qBAAqB;AACnE;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gCAAgC;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,uBAAuB,mBAAmB;AAC1C;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,aAAa;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uBAAuB;;AAEvB;AACA;AACA;AACA,IAAI,IAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,0EAA0E,SAAS,IAAI,YAAY;AACnG;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,IAAI;AACnC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B,iBAAiB,sBAAsB,GAAG,oBAAoB;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,UAAU;AACpD,4CAA4C,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iCAAiC,mEAAmE,WAAW,MAAM;AACrH;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,QAAQ,EAAE,2CAA2C,WAAW,YAAY;AAC1G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,SAAS,WAAW,WAAW;AACnE;AACA;;AAEA,yCAAyC;AACzC;AACA,KAAK;AACL;AACA;AACA;AACA,+BAA+B,qDAAqD;AACpF;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,yBAAyB,WAAW,MAAM,QAAQ,EAAE,oCAAoC,KAAK,kEAAkE,EAAE,YAAY,SAAS,6EAA6E,GAAG,uEAAuE,aAAa,4EAA4E;AACta;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,qBAAqB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,yBAAyB;AAClF;AACA;AACA;AACA,kCAAkC,SAAS,MAAM,gBAAgB,GAAG,cAAc,KAAK,8DAA8D,EAAE,WAAW;AAClK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,SAAS,KAAK,YAAY,MAAM,SAAS,eAAe,gBAAgB,GAAG,cAAc,aAAa,UAAU,GAAG,oBAAoB,IAAI,6DAA6D,IAAI,WAAW,YAAY,wCAAwC;AAClT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS,MAAM,SAAS,EAAE,qEAAqE,EAAE,6DAA6D,IAAI,WAAW,YAAY,wCAAwC;AAClQ;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,oEAAoE,IAAI,WAAW,WAAW;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,mEAAmE,QAAQ,UAAU,wBAAwB;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,aAAa,6BAA6B,QAAQ;AACjG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gFAAgF,6BAA6B;AAC7G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mFAAmF,QAAQ;AAC3F;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA,mFAAmF,QAAQ;AAC3F;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,wBAAwB,4DAA4D,IAAI,2BAA2B,4BAA4B;AAChL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,yCAAyC,gCAAgC,YAAY,iDAAiD,IAAI,iBAAiB,WAAW,uCAAuC,aAAa,OAAO;AACjO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,iBAAiB,WAAW,yDAAyD,oCAAoC,cAAc;AAC7K;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,EAAE,mCAAmC,WAAW,YAAY;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,UAAU,IAAI,kFAAkF;AACpK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,4BAA4B,SAAS,KAAK,YAAY,EAAE,YAAY,eAAe,aAAa,qBAAqB,eAAe,GAAG,yBAAyB,KAAK,MAAM;AAC3K;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,uBAAuB,cAAc,iCAAiC,WAAW;AACjF;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sFAAsF,cAAc;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,sEAAsE,cAAc,WAAW,gBAAgB;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,SAAS,EAAE,MAAM,qBAAqB,eAAe;AACrG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA,4DAA4D,SAAS,WAAW,YAAY;AAC5F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS,YAAY,UAAU;AACxE,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,cAAc,IAAI,UAAU;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,mBAAmB;AACrC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,YAAY,iBAAiB,mBAAmB,KAAK,gBAAgB,GAAG,iCAAiC,QAAQ;AAC/J;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,KAAK;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAA2D,kBAAkB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,+BAA+B,WAAW,cAAc,eAAe,kBAAkB,kBAAkB;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,YAAY,SAAS,kBAAkB,aAAa,oBAAoB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,oBAAoB,GAAG,YAAY,GAAG,gBAAgB;AAChH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,+BAA+B,WAAW,QAAQ,OAAO,uBAAuB,YAAY,GAAG,oBAAoB,GAAG,iBAAiB,WAAW,QAAQ;AAC1J;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wGAAwG;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,mCAAmC;AACnC,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,eAAe;AACf;;AAEA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mDAAmD;AACnD,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA,0BAA0B;AAC1B,+BAA+B,uCAAuC;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B;AACA;;AAEA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,6BAA6B;AAC7B,MAAM;AACN,gCAAgC;AAChC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC,iBAAiB;AACjB,iBAAiB;AACjB,iBAAiB;AACjB,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,QAAQ;;AAER,iBAAiB;AACjB,iBAAiB;AACjB,mBAAmB;AACnB;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA,iBAAiB;AACjB,MAAM;AACN,mBAAmB;AACnB,gBAAgB;AAChB,gBAAgB;AAChB;AACA,kBAAkB,oCAAoC;AACtD;AACA,QAAQ;AACR;AACA,eAAe;AACf,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,OAAO;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B,oCAAoC;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,qCAAqC;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E,WAAW;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,YAAY;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC,aAAa;AAC9C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO,qBAAqB,WAAW,gCAAgC,YAAY;AACvI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,yDAAyD,gBAAgB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,kBAAkB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,OAAO;AACzE,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,cAAc;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gBAAgB,MAAM;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,sCAAsC;AAC/D;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,aAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,iBAAiB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;;AAE9B,6DAA6D;AAC7D,yDAAyD;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,gBAAgB,sBAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,4EAA4E,uBAAuB;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,SAAS;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,oBAAoB,SAAS,QAAQ;AACvF;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,mEAAmE,QAAQ;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,kCAAkC,MAAM,MAAM,0CAA0C,sBAAsB;AAC5I,UAAU;AACV,8BAA8B,mCAAmC,MAAM,MAAM,iDAAiD,sBAAsB;AACpJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,oCAAoC,GAAG,oCAAoC,WAAW,kCAAkC;AACjL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,SAAS;AACvD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA,yDAAyD,aAAa;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA,6DAA6D,sBAAsB,wBAAwB,iBAAiB,wBAAwB;AACpJ,YAAY;AACZ;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,sDAAsD,SAAS;AAC/D;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gDAAgD;AAChD;;AAEA;AACA;AACA,8CAA8C,yBAAyB;AACvE;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC,kCAAkC,6BAA6B,2CAA2C;AACnJ;AACA;AACA,UAAU;;AAEV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,SAAS,gBAAgB,sCAAsC,WAAW,2CAA2C;AACvK,0BAA0B,aAAa;AACvC;AACA;AACA;AACA,2FAA2F;AAC3F;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,gBAAgB;AACtE;AACA;AACA;AACA;AACA,mGAAmG;AACnG;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS;AAC7D,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mHAAmH;AACnH;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gBAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,uCAAuC;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC,YAAY,6CAA6C,OAAO;AACvG;AACA;AACA;AACA;AACA,wCAAwC,YAAY;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,cAAc;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,oDAAoD,aAAa,EAAE,oDAAoD,WAAW,gBAAgB;AAClJ;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qBAAqB;;AAErB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,UAAU;AACtB,YAAY,GAAG;AACf,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,iBAAiB;AAC7B,YAAY,UAAU;AACtB,YAAY,GAAG;AACf,YAAY,SAAS;AACrB,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,cAAc;AAC1B,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,cAAc,OAAO;AACrB;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,2DAA2D,OAAO;AAClE;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,cAAc,QAAQ;AACtB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,cAAc,SAAS;AACvB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,2CAA2C,SAAS;AACpD;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA,6DAA6D;AAC7D,iEAAiE;AACjE,qEAAqE;AACrE,yEAAyE;AACzE;AACA,4DAA4D,SAAS;AACrE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,UAAU;AACtB,YAAY,GAAG;AACf,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,UAAU;AACtB,YAAY,GAAG;AACf,cAAc,cAAc;AAC5B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,YAAY,UAAU;AACtB,YAAY,GAAG;AACf,YAAY,SAAS;AACrB,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,6DAA6D,YAAY;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,cAAc,cAAc;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;;AAEF;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,mBAAmB,OAAO,GAAG;AAC1E;AACA,YAAY;AACZ,oDAAoD,GAAG;AACvD;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,uCAAuC,gBAAgB,GAAG,eAAe,GAAG,aAAa;AACzF;AACA,qCAAqC,GAAG;AACxC;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV,2CAA2C,GAAG;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,UAAU,2CAA2C,cAAc,KAAK,gBAAgB,SAAS,iBAAiB,MAAM;AACnK,yBAAyB;AACzB,uBAAuB;AACvB,sBAAsB;AACtB,8BAA8B;AAC9B,sBAAsB;AACtB,6BAA6B,kBAAkB;AAC/C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,qDAAqD,6BAA6B;AAClF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,IAAI,mBAAmB,QAAQ;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D,2BAA2B;AAC1F;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA,+CAA+C,QAAQ,qCAAqC,kBAAkB;AAC9G;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ,MAAM,YAAY,wCAAwC,gBAAgB;AACnI;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,+DAA+D,QAAQ;AACvE;AACA;AACA,4BAA4B,SAAS,UAAU,mBAAmB,GAAG,iBAAiB,GAAG,iCAAiC,sBAAsB,GAAG,yBAAyB,QAAQ,YAAY,yBAAyB;AACzN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,yFAAyF,SAAS,WAAW,YAAY;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iCAAiC,IAAI,MAAM,iBAAiB,GAAG,cAAc,UAAU,QAAQ;AAC/F;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA,MAAM;AACN,2CAA2C,QAAQ,qDAAqD,SAAS,MAAM,iBAAiB,GAAG,cAAc,UAAU,QAAQ;AAC3K;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0EAA0E;AAC1E,4BAA4B,QAAQ,EAAE,iCAAiC,WAAW,YAAY,8CAA8C,WAAW,iBAAiB,yDAAyD;AACjO;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE;AACvE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gBAAgB,0BAA0B,mBAAmB,GAAG,YAAY;AACzH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,gEAAgE,SAAS,+CAA+C,SAAS,WAAW,aAAa;AACzJ;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,uCAAuC,IAAI,YAAY,SAAS,4BAA4B,iEAAiE;AAC7J;AACA;AACA;AACA;AACA,4BAA4B,IAAI,GAAG,wBAAwB,SAAS,yBAAyB,QAAQ,SAAS,UAAU,gBAAgB,GAAG,cAAc;AACzJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yCAAyC,oBAAoB,8BAA8B,qDAAqD;AAChJ;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,0FAA0F,8EAA8E,eAAe,mBAAmB;AAC1M;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA2C,MAAM;AACjD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,OAAO,GAAG,WAAW,SAAS,YAAY,QAAQ,eAAe,WAAW,eAAe;AACpI;AACA;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA,sBAAsB,wBAAwB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iFAAiF,MAAM;AACvF;AACA;AACA;AACA,+CAA+C,IAAI,GAAG,gBAAgB,SAAS,iBAAiB,QAAQ,QAAQ;AAChH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,6BAA6B;;AAE7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,oBAAoB;AAC5C;AACA;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA,kEAAkE,QAAQ;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,SAAS,UAAU,mBAAmB,GAAG,iBAAiB,GAAG,iCAAiC,sBAAsB,GAAG,yBAAyB,QAAQ,YAAY,yBAAyB;AAC5N;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,qBAAqB,SAAS,IAAI,YAAY;AAC9C;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK,yCAAyC,MAAM,uCAAuC,OAAO;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,0CAA0C,IAAI,YAAY,SAAS,4BAA4B,iEAAiE;AAChK;AACA;AACA;AACA;AACA,+BAA+B,IAAI,GAAG,wBAAwB,SAAS,yBAAyB,QAAQ,SAAS,UAAU,gBAAgB,GAAG,cAAc;AAC5J;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C,uBAAuB,qBAAqB,2DAA2D;AACnJ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iFAAiF,MAAM;AACvF;AACA;AACA,mDAAmD,GAAG;AACtD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,kBAAkB,kBAAkB,kBAAkB;AACxH;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8CAA8C,MAAM;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,MAAM,kBAAkB,WAAW,SAAS,YAAY,QAAQ,cAAc;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB;AACvB,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,sEAAsE,KAAK,4BAA4B,MAAM;AAC7G;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,+EAA+E,YAAY,IAAI,SAAS;AACxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,gCAAgC;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,2EAA2E;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,yCAAyC,aAAa;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,iCAAiC,KAAK;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,WAAW,SAAS,WAAW;AAC/D;AACA,wCAAwC,kBAAkB,KAAK,WAAW;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,2BAA2B,gCAAgC,qBAAqB;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,+BAA+B,MAAM,uBAAuB,SAAS;AACrE;AACA;AACA;AACA,OAAO;AACP,uBAAuB;AACvB,0BAA0B;AAC1B;AACA,sCAAsC,MAAM;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yEAAyE,WAAW,UAAU,MAAM,QAAQ,QAAQ;AACpH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,gDAAgD,MAAM;AACtD,OAAO;AACP;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,8BAA8B,iBAAiB,GAAG,gCAAgC,8BAA8B,KAAK;AACrH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,iEAAiE,kBAAkB,KAAK,gBAAgB,MAAM,MAAM;AACpH,OAAO;AACP;AACA,kEAAkE,kBAAkB,KAAK,gBAAgB,MAAM,MAAM;AACrH;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA,2CAA2C,MAAM;AACjD;AACA,KAAK;AACL;AACA;AACA,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,oFAAoF,WAAW,SAAS,YAAY,MAAM,QAAQ;AAClI;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,MAAM;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,UAAU;AACV;AACA;AACA,0FAA0F,uBAAuB;AACjH;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;;AAEX;AACA;AACA;AACA;AACA,aAAa;AACb,YAAY;AACZ,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,mCAAmC,MAAM;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,oDAAoD,yBAAyB;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,qBAAqB,8BAA8B,MAAM,GAAG,IAAI;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,UAAU;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,iBAAiB,SAAS,MAAM;AAC5D,0CAA0C,SAAS;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,gEAAgE,YAAY;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,MAAM,8CAA8C,yFAAyF;AAC5K,kBAAkB,MAAM;AACxB;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,iDAAiD,MAAM;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,YAAY,GAAG,UAAU,aAAa,MAAM;AACxE;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,oDAAoD;AACpD;AACA;AACA;AACA;AACA,uDAAuD,MAAM;AAC7D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN,qDAAqD,SAAS;AAC9D;AACA;AACA,yEAAyE,aAAa,SAAS;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW,GAAG,SAAS,IAAI,EAAE;AACjD;AACA;AACA;AACA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,gBAAgB;AACjD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,aAAa;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,eAAe,SAAS;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,uCAAuC;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,sBAAsB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,uDAAuD;AACvD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL,qDAAqD;AACrD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,mDAAmD;AACnD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gDAAgD;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,kDAAkD;AAClD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,oDAAoD;AACpD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,uDAAuD;AACvD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL,gDAAgD;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,qDAAqD;AACrD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oDAAoD;AACpD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,yDAAyD;AACzD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,gDAAgD;AAChD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,iDAAiD;AACjD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,EAAE,MAAM,EAAE;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,cAAc;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,IAAI;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,WAAW;AAC/D;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA,yBAAyB,GAAG,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE;;AAEpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,IAAI;AAC7C;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,KAAK;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,IAAI;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA,6CAA6C;AAC7C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,0EAA0E,4BAA4B;AACtG;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,mBAAmB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,2CAA2C,MAAM;AACjD;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,6CAA6C,MAAM;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,oBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,SAAS,IAAI,wBAAwB,IAAI,0BAA0B,YAAY,gBAAgB,GAAG,iBAAiB;AACvK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wEAAwE,UAAU;AAClF;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN,8DAA8D,UAAU;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,YAAY;AACZ;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,mFAAmF,gCAAgC;AACnH;AACA,sGAAsG,kBAAkB;AACxH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,UAAU,mCAAmC,sCAAsC;AACjI;AACA;AACA;AACA;AACA;AACA,2DAA2D,UAAU,KAAK,MAAM;AAChF,OAAO;AACP;AACA,2CAA2C,+BAA+B;AAC1E;AACA,2CAA2C,UAAU;AACrD;AACA,8CAA8C,UAAU;AACxD;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA,yDAAyD,UAAU,EAAE,IAAI,MAAM;AAC/E,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,6CAA6C,UAAU,WAAW,qCAAqC;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,qBAAqB,cAAc;AACzE,QAAQ,gBAAgB,8BAA8B;AACtD;AACA;AACA;AACA,uDAAuD;AACvD;AACA,0DAA0D,SAAS,EAAE,UAAU,IAAI,WAAW,gBAAgB,sBAAsB;AACpI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,UAAU;AACV,oEAAoE,UAAU;AAC9E;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,kCAAkC,OAAO,WAAW,sBAAsB,YAAY,oBAAoB,OAAO,gBAAgB;AACjI,yCAAyC,WAAW;AACpD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,+CAA+C,cAAc,EAAE,eAAe,IAAI,iBAAiB,YAAY,WAAW;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,sDAAsD;AAC7D;AACA,OAAO,EAAE;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,2BAA2B,WAAW,4BAA4B,aAAa;AAC/E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,qBAAqB,YAAY,wBAAwB,MAAM;AAC/D;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC,UAAU;AACV,+BAA+B,YAAY,MAAM,gFAAgF;AACjI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,oBAAoB,6BAA6B;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,sCAAsC,UAAU;AAChD;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,OAAO;AAC3D;AACA;AACA;AACA,oDAAoD,OAAO,KAAK,OAAO,mBAAmB,cAAc,UAAU,sCAAsC;AACxJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,mBAAmB,YAAY,+BAA+B,qBAAqB,kBAAkB,mBAAmB;AACxH;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA,QAAQ;AACR,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,mBAAmB,kBAAkB,MAAM;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA;AACA;AACA;AACA,WAAW,4BAA4B,UAAU;AACjD,UAAU;AACV;AACA,UAAU;AACV,oDAAoD,UAAU;AAC9D;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,qDAAqD,sGAAsG,WAAW,MAAM;AAC5K,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,OAAO,2CAA2C,MAAM;AACxD,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,qCAAqC,OAAO,2BAA2B,2HAA2H,iBAAiB,6EAA6E,OAAO,uCAAuC;AAC9U;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW,MAAM,UAAU,gCAAgC,IAAI,aAAa,eAAe,GAAG,cAAc;AAC5G,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,MAAM,UAAU,mCAAmC,IAAI;AAClE,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,yCAAyC,8CAA8C,GAAG,wCAAwC,QAAQ,UAAU;AACpJ;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,SAAS;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,kDAAkD,IAAI;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qDAAqD;AAC9F;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iCAAiC,IAAI,aAAa,YAAY,GAAG,eAAe;AAC/F,cAAc;AACd;AACA,qDAAqD,cAAc;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL,iEAAiE,MAAM;AACvE,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,yDAAyD,sBAAsB;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,6DAA6D,2BAA2B;AACxF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,MAAM;AACpD,OAAO;AACP;AACA,OAAO;AACP,6CAA6C,MAAM;AACnD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,oCAAoC;;AAErC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8CAA8C;;AAE/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,0CAA0C;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,QAAQ,GAAG,YAAY,OAAO,KAAK;AACnE;AACA,GAAG;AACH;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,yCAAyC;;AAEzC;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,oBAAoB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC;AACtD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C;AAC9C;AACA;AACA;AACA;AACA,sDAAsD,YAAY;AAClE;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iEAAiE;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,kDAAkD;AAC/D;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,EAAE,kBAAkB,GAAG;AACtC;AACA,aAAa,EAAE,kBAAkB,GAAG,yBAAyB;AAC7D,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,+BAA+B,EAAE,8BAA8B;AAC7E,IAAI;AACJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,yCAAyC,GAAG,8BAA8B;AACvF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,GAAG,WAAW,mBAAmB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA,kIAAkI;AAClI;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,IAAI;AACP;AACA;AACA;AACA,GAAG,IAAI;AACP;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uCAAuC;AACvC;AACA;AACA;AACA;AACA,YAAY,WAAW,GAAG,2BAA2B;AACrD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,IAAI,EAAE,UAAU,EAAE,MAAM;AACpC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,OAAO,IAAI;AACX;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,cAAc,IAAI,mBAAmB,wCAAwC,cAAc,UAAU,iCAAiC,cAAc,iCAAiC,aAAa,uCAAuC;AAClR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,eAAe,gCAAgC,UAAU;AACtG;AACA;AACA;AACA;AACA,wBAAwB,qBAAqB,GAAG,eAAe,qBAAqB,eAAe;AACnG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,UAAU;AAClD;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,8DAA8D,uBAAuB,KAAK,yBAAyB;AACnH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,iBAAiB,SAAS,QAAQ;AAC5F,iEAAiE,qBAAqB,SAAS,QAAQ;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,0BAA0B,kCAAkC;AAC5D,+CAA+C,yBAAyB,SAAS,QAAQ;AACzF;AACA;AACA;AACA,0BAA0B,qCAAqC;AAC/D,8CAA8C,4BAA4B,SAAS,QAAQ;AAC3F;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,yDAAyD,IAAI;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,IAAI;AACnD;AACA;AACA,uCAAuC,sBAAsB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,YAAY;AACZ;AACA,sEAAsE,UAAU;AAChF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,qDAAqD,YAAY,EAAE,YAAY,GAAG,YAAY;AAC9F;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,aAAa;AACrD;AACA;AACA;AACA,OAAO;AACP;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA,8CAA8C,IAAI;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ,4BAA4B,QAAQ,gBAAgB,YAAY;AAChE;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,2CAA2C,oEAAoE;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,mBAAmB,8CAA8C,gBAAgB,uCAAuC,aAAa,YAAY,GAAG,yBAAyB,KAAK,gBAAgB;AAClM;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,KAAK;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,GAAG;AACnC;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+BAA+B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,sBAAsB;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,uBAAuB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,0BAA0B,qCAAqC;AAC/D;AACA;AACA;AACA,mCAAmC,KAAK,SAAS,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,qCAAqC,oBAAoB,oCAAoC,WAAW,KAAK,uCAAuC;AACpJ;AACA,GAAG;AACH,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,IAAI;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,uCAAuC,eAAe;AACtD,0BAA0B,sBAAsB,EAAE,oBAAoB,GAAG,WAAW,GAAG,UAAU,GAAG,OAAO,GAAG,YAAY,GAAG,KAAK;AAClI;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,sEAAsE,qCAAqC;AAC3G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,wBAAwB,2BAA2B;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA,qCAAqC,eAAe,iCAAiC,kBAAkB;AACvG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,UAAU,GAAG,wCAAwC,EAAE,+CAA+C,EAAE,2CAA2C,GAAG,cAAc,GAAG,+CAA+C,aAAa,eAAe,EAAE,sDAAsD;AAC7U;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,iBAAiB;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,uCAAuC,MAAM;AAC7C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV,iFAAiF,MAAM;AACvF;AACA;AACA;AACA,sCAAsC,kBAAkB,EAAE,qJAAqJ,MAAM,0CAA0C,EAAE,IAAI;;AAErQ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gHAAgH,gBAAgB;AAChI;AACA;AACA;AACA;AACA,sHAAsH,IAAI;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6IAA6I,mBAAmB;AAChK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA,oGAAoG,eAAe,cAAc,cAAc;AAC/I;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,YAAY,UAAU,6BAA6B;AACxG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,uDAAuD,mBAAmB,qBAAqB,2BAA2B;AAC1H;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,aAAa,KAAK,WAAW;AAC9F;AACA;AACA;AACA;AACA,qFAAqF,aAAa,KAAK,WAAW;AAClH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,aAAa,KAAK,WAAW;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,uFAAuF,aAAa,QAAQ,sBAAsB;AAClI;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA,2BAA2B;;AAE3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,2BAA2B;AAC5F;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;;AAEN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC,OAAO,aAAa,WAAW;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,6BAA6B,SAAS,WAAW,YAAY;AAC7D;AACA,QAAQ;AACR;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;;AAEA;AACA;AACA;AACA,gEAAgE,sCAAsC;AACtG;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,yDAAyD,WAAW;AACpE;AACA;AACA,sBAAsB,YAAY,UAAU,mBAAmB,GAAG,iBAAiB,GAAG,iCAAiC,sBAAsB,GAAG,yBAAyB,QAAQ,QAAQ,mBAAmB,IAAI,iBAAiB,aAAa,SAAS;AACvP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA,mFAAmF,SAAS,WAAW,YAAY;AACnH;AACA;AACA;AACA;AACA;AACA,qCAAqC,SAAS,WAAW,YAAY;AACrE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,+BAA+B,SAAS,MAAM,iBAAiB,GAAG,cAAc,UAAU,WAAW,OAAO,QAAQ;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,6CAA6C,KAAK;AAClD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,QAAQ,EAAE,iCAAiC,WAAW,YAAY,8CAA8C,WAAW;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,cAAc,uBAAuB,YAAY;AACvF;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,OAAO;AACvD;AACA;AACA;AACA,gDAAgD,eAAe,oBAAoB,YAAY;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,MAAM;AACN;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,WAAW;AAC7D;AACA;AACA,mDAAmD,wBAAwB,SAAS,WAAW;AAC/F;AACA;AACA;AACA,+CAA+C,gBAAgB,mCAAmC,iBAAiB,GAAG,8BAA8B,GAAG,YAAY;AACnK;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB,0BAA0B,8BAA8B,GAAG,YAAY;AACtI;AACA;AACA,oDAAoD,qBAAqB,0BAA0B,oBAAoB,GAAG,iBAAiB;AAC3I;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,6BAA6B,cAAc;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD;AAChD,QAAQ;AACR;AACA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,yCAAyC,SAAS;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,iCAAiC,IAAI;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE4oB;AAC5oB;;;;;;;;;;;;;;;;;;;;ACp73BA;AACA;AACA;AACA;AACA;AAC4D;AACP;AACtB;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8EAA8E;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qBAAqB,yBAAyB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mDAAQ;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,6BAA6B,oDAAS;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,yEAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrPA;AACA;AACA;AACA;AACA;AACA;AACsC;AACtC,QAAQ,wBAAwB,EAAE,8CAAI;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACA;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D;AAC9D;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;;;;;;;;;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC/CA;AACA;AACA;AACA;AACA;AACyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACO,0EAA0E,iDAAO;AACxF;;;;;;;;;;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACyC;AACe;AACI;AAC5D,oBAAoB,oDAAS;AAC7B;AACA;AACA,mBAAmB,iDAAO;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,cAAc,wDAAS;AAC9B;;;;;;;;;;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACyC;AACyB;AAClE;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,+DAAc;AACzC;AACA,eAAe,iDAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,iDAAO;AACtB;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA,wBAAwB,cAAc;AACtC;AACA;AACO,YAAY,8DAAS;AAC5B;;;;;;;;;;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACmD;AACc;AACjE;AACO,kCAAkC,oDAAS;AAClD;AACA;AACA,sBAAsB,iDAAO;AAC7B,8BAA8B,mDAAQ;AACtC,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA,sBAAsB,iDAAO;AAC7B;AACA;AACA;AACA,sBAAsB,kDAAQ;AAC9B;AACA;AACA;AACA,+BAA+B,+BAA+B;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,mBAAmB,wDAAS;AACnC;;;;;;;;;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AAC4C;AACW;AACvD;AACA,iCAAiC,gEAAmB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,kBAAkB,wDAAS;AAClC;;;;;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,+BAA+B;AACrD;AACA;AACA;AACA;AACA,uBAAuB,YAAY;AACnC;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,WAAW,MAAM,UAAU,KAAK,WAAW,IAAI,WAAW,MAAM,gBAAgB;AACpH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,MAAM;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,iBAAiB;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0DAA0D,gBAAgB;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+BAA+B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,IAAI;AAChF,+EAA+E,KAAK;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,eAAe;AACvD;AACA;AACA;AACA,yCAAyC,sCAAsC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,sCAAsC;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,MAAM,SAAS,kBAAkB;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oDAAoD,MAAM;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,+BAA+B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,EAAE;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,kBAAkB,eAAe,KAAK;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,cAAc;AACzB;AACA;AACA,2BAA2B,KAAK;AAChC;AACA;AACA;AACA;AACA,kBAAkB,0BAA0B;AAC5C,WAAW,gBAAgB,IAAI,cAAc;AAC7C;AACA;AACA;AACA;AACA,uBAAuB,yBAAyB;AAChD;AACA,IAAI;AACJ;AACO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,uEAAuE,UAAU;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,qLAAqL;AACrL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;ACx8C8E;AACV;AACX;;AAEzD,mCAAmC,2DAAI,cAAc,gEAAa;AAClE;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,6DAAM;AAChB,oBAAoB,2BAA2B;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,YAAY,mEAAY;AACxB,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,IAAI,6DAAM;AACV,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,sCAAsC,kCAAkC,+DAAQ,oDAAoD,+DAAQ;AACxJ,IAAI,6DAAM;AACV,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,KAAK;AACL;AACA;AACA;AACA,kHAAkH,iBAAiB;AACnI,IAAI,6DAAM,OAAO,mEAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,2OAAgC,SAAS,eAAe;AAC5D;AACA,KAAK;AACL;AACA;AACA;;AAEA,iCAAiC,2DAAI,cAAc,8DAAW;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEoD;;;;;;;;;;;;;;;;;ACvGiE;;AAErH,gBAAgB,6DAAM;AACtB;AACA,EAAE,kEAAW;AACb;AACA,GAAG;AACH,EAAE,kEAAW;AACb;AACA;AACA,GAAG;AACH;AACA,qCAAqC,iEAAc;AACnD,aAAa,6DAAM;AACnB;AACA,IAAI,6DAAM;AACV,yBAAyB,mEAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,mEAAY;AACd,EAAE,mEAAY;AACd;AACA;AACA,EAAE,mEAAY;AACd,EAAE,mEAAY;AACd;;AAE6C;;;;;;;;;;;;;;;;;;;;ACxD2B;;AAExE;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAO;AACf;AACA,MAAM,UAAU,kEAAW,YAAY,kEAAW;AAClD;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,+DAAQ;AACf;AACA,4BAA4B,OAAO,yCAAyC,MAAM,uCAAuC,IAAI;AAC7H;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEwG;;;;;;;;;;;;;;;;AC1FxG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEyC;;;;;;;;;;;;;;;;;;;;;ACjB6C;AACtB;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sDAAsD,IAAI;AAC1D,OAAO,6DAAM;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe,mDAAmD,IAAI;AACxF,OAAO,6DAAM;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,+DAAQ;AACjE;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,cAAc,gEAAS,0CAA0C,+DAAQ;AACzE,6BAA6B,oBAAoB;AACjD;AACA;AACA,WAAW,gEAAS,eAAe,+DAAQ;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,SAAS,+DAAQ,2CAA2C,iEAAU,SAAS,iEAAU;AACzF;;AAE6F;;;;;;;;;;;;;;;AChE7F;AACA;AACA;AACA;AACA;;AAEyB;;;;;;;;;;;;;;;;;ACN2C;AACpB;AAChB;AACA;AACA;;AAEhC,iCAAiC,2DAAI,cAAc,yDAAM;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wBAAwB;AACpC,IAAI,6DAAM;AACV,cAAc,kBAAkB;AAChC;AACA,KAAK;AACL,IAAI,6DAAM;AACV,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,KAAK;AACL;AACA;AACA;AACA;AACA;;AAE8B;;;;;;;;;;;;;;;;;;;AChCmD;;AAEjF;AACA,qCAAqC,SAAS;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mCAAmC,+DAAQ;AAC3C;AACA,kBAAkB,+DAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM,6DAAM;AACZ,oBAAoB,kEAAW;AAC/B;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,YAAY;AACZ;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,SAAS,kEAAW;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kEAAW;AACf,GAAG;AACH;;AAEgF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzDJ;AACqK;;AAEjP;AACA;AACA,SAAS,gEAAS;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA,EAAE,EAAE;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,iEAAU;AACjB,IAAI,mEAAY;AAChB;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA,EAAE,6DAAM;AACR;AACA;AACA;AACA;AACA;AACA;AACA,iEAAiE,8CAA8C;AAC/G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,mEAAgB;AAC7B;AACA,GAAG;AACH,QAAQ,sEAAe;AACvB,GAAG;AACH;AACA;AACA,SAAS,mEAAY;AACrB;AACA;AACA,cAAc,+DAAQ;AACtB,IAAI,6DAAM;AACV;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,gEAAS;AACX,oBAAoB,qBAAqB;AACzC,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,EAAE,+DAAQ;AACV;AACA;AACA,mEAAmE,EAAE,8CAA8C,EAAE;AACrH,SAAS,4DAAU;AACnB,IAAI,iEAAe;AACnB;AACA;AACA;AACA,QAAQ,sDAAI,GAAG,sDAAsD;AACrE,QAAQ,uDAAK;AACb;AACA;AACA,KAAK,UAAU,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,UAAU,IAAI;AACnC,8CAA8C,cAAc;AAC5D,UAAU;AACV,sBAAsB,UAAU,IAAI;AACpC,8CAA8C,cAAc;AAC5D,UAAU;AACV,OAAO;AACP,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6DAAM;AACxB,EAAE,6DAAM;AACR;AACA;AACA,QAAQ,mEAAgB;AACxB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,6EAAsB;AAC9D;AACA;AACA;AACA,EAAE,6DAAM;AACR;AACA;AACA;AACA;AACA,SAAS,+DAAQ;AACjB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,wBAAwB,6DAAM;AAC9B,EAAE,6DAAM;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB,GAAG;AACH;AACA;AACA;AACA,qBAAqB,6DAAM;AAC3B,EAAE,6DAAM;AACR;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,EAAE,kEAAW;AACb;AACA;AACA;AACA,EAAE,6DAAM;AACR;AACA;AACA;AACA,MAAM,6DAAM;AACZ;AACA;AACA;AACA,GAAG;AACH;AACA,IAAI,kEAAW;AACf,IAAI,kEAAW;AACf;AACA;;AAE6V;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClPiF;AACrX;AAC0F;AAC2F;AACnK;AACJ;AACxB;AAC4B;AACf;;AAE5D,6BAA6B,4DAAS;AACtC;AACA;AACA;AACA,qBAAqB,wDAAK;AAC1B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,YAAY,OAAO;AACnB;AACA;AACA,KAAK;AACL;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,2DAAI;AACR;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA,8CAA8C,gDAAgD,IAAI,0BAA0B;AAC5H;AACA;AACA;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA,wBAAwB,2DAAI;AAC5B;AACA,4EAA4E,uEAAgB;AAC5F;AACA,eAAe,+DAA+D,EAAE,WAAW;AAC3F;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN,+BAA+B,2DAAI;AACnC;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA,eAAe,mEAAY;AAC3B,QAAQ,+DAAQ;AAChB,gCAAgC,gBAAgB;AAChD;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA,uBAAuB,4DAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,IAAI,6DAAM;AACV;AACA;AACA,YAAY,+BAA+B;AAC3C,IAAI,+DAAQ;AACZ,IAAI,0EAAmB;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,6DAAM;AACV,gCAAgC,2BAA2B;AAC3D,KAAK;AACL,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA,QAAQ,+DAAQ,gBAAgB,KAAK,0CAA0C,KAAK;AACpF;AACA,KAAK;AACL;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B,IAAI,mEAAY;AAChB,IAAI,+DAAQ;AACZ;AACA;AACA,YAAY,WAAW,wBAAwB,8BAA8B;AAC7E;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;;AAEA,4BAA4B,4DAAS;AACrC;AACA,iCAAiC,+DAAQ;AACzC;AACA;;AAEA,uBAAuB,oEAAa;;AAEpC;AACA,sBAAsB,4DAAS;AAC/B;AACA;AACA;AACA,yBAAyB,KAAK;AAC9B,aAAa,6DAAM;AACnB,aAAa,6DAAM;AACnB,aAAa,6DAAM;AACnB;AACA;AACA,QAAQ,yEAAsB;AAC9B,YAAY,YAAY;AACxB,QAAQ,yDAAM;AACd;AACA;AACA;AACA;AACA,QAAQ,6DAAM;AACd,cAAc,gEAAS,IAAI,kEAAW;AACtC,UAAU,kEAAW;AACrB,SAAS;AACT,YAAY,mEAAgB,yDAAyD,gBAAgB;AACrG,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,qEAAc;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,0CAA0C,YAAY;AACtD;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,0EAAmB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,mEAAY;AAClB;AACA;AACA,YAAY,mEAAY;AACxB;AACA;AACA;AACA;;AAEA,6BAA6B,4DAAS;AACtC;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA;AACA,IAAI,gEAAS;AACb,MAAM,kFAA2B;AACjC;AACA;AACA,wBAAwB,iEAAU;AAClC,QAAQ,gEAAS;AACjB;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,gDAAgD,iEAAU;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,4DAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B,YAAY,YAAY;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,oBAAoB,iEAAU;AAC9B,IAAI,gEAAS;AACb,IAAI,gEAAS;AACb,MAAM,kFAA2B;AACjC;AACA,QAAQ,6DAAM;AACd,OAAO;AACP;AACA;AACA;AACA,oBAAoB,iEAAU;AAC9B;AACA;AACA;AACA,YAAY,UAAU,EAAE,iEAAU;AAClC;AACA,YAAY,6CAA6C;AACzD,WAAW,oEAAa;AACxB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,iEAAU;AACrB;AACA;;AAEA,2BAA2B,4DAAS;AACpC;AACA;AACA;AACA;AACA,aAAa,6DAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA,KAAK;AACL;AACA;AACA;AACA,2DAAI;;AAEJ,+BAA+B,4DAAS;AACxC,iBAAiB,yEAAsB;AACvC;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,0BAA0B,sBAAsB;AAChD;AACA;;AAEA,0BAA0B,4DAAS;AACnC;AACA;AACA;AACA;AACA,qBAAqB,wDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,mBAAmB,+DAAQ,CAAC,yDAAM;AAClC;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA,YAAY,MAAM,iBAAiB,UAAU;AAC7C;AACA;AACA;AACA,YAAY,+BAA+B,iBAAiB,gCAAgC,iBAAiB,gCAAgC;AAC7I;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,6DAAM;AAClB;AACA;AACA,YAAY,cAAc,iBAAiB,oBAAoB;AAC/D;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA,gCAAgC,gBAAgB;AAChD;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA,6BAA6B,gBAAgB;AAC7C;AACA;AACA,YAAY,iBAAiB,iBAAiB,WAAW,wBAAwB,cAAc;AAC/F;AACA;AACA;AACA;AACA;AACA;AACA,2DAAI;;AAEJ,8BAA8B,4DAAS;AACvC;AACA,OAAO,mEAAgB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAW;AAC5B;AACA;AACA,kBAAkB,sEAAe;AACjC,IAAI,qEAAc,CAAC,2EAAwB;AAC3C;AACA;AACA,eAAe,4DAAK;AACpB;AACA,KAAK;AACL,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA,IAAI,0EAAmB;AACvB,YAAY,kBAAkB;AAC9B;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA,oCAAoC,eAAe;AACnD;AACA;AACA,YAAY,WAAW,iBAAiB,kBAAkB;AAC1D;AACA;AACA;AACA;AACA,iBAAiB,4DAAK;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,4DAAS;AACnC;AACA,OAAO,mEAAgB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,8DAAW;AAC5B;AACA;AACA,kBAAkB,sEAAe;AACjC,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA,IAAI,0EAAmB;AACvB,YAAY,qBAAqB;AACjC;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA;AACA,WAAW,4DAAK;AAChB;AACA;AACA,YAAY,WAAW,iBAAiB,qBAAqB;AAC7D;AACA;AACA,0BAA0B,uEAAgB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,4DAAS;AACrC;AACA,OAAO,mEAAgB;AACvB;AACA;AACA;AACA;AACA,iBAAiB,8DAAW;AAC5B;AACA,qBAAqB,+DAAQ;AAC7B,YAAY,YAAY;AACxB,WAAW,yEAAkB;AAC7B,GAAG;AACH;AACA,kBAAkB,sEAAe;AACjC,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA,IAAI,0EAAmB;AACvB,YAAY,2BAA2B,mCAAmC,+DAAQ;AAClF;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA,YAAY,kBAAkB,uDAAuD,4BAA4B;AACjH,uBAAuB,OAAO,GAAG,mBAAmB,YAAY,QAAQ;AACxE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,UAAU;AACpB;AACA,oCAAoC,eAAe;AACnD;AACA;AACA,YAAY,WAAW,iBAAiB,2BAA2B;AACnE;AACA;AACA,4BAA4B,uEAAgB;AAC5C;AACA;AACA,YAAY,YAAY,yBAAyB,2DAAI;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,6BAA6B,4DAAS;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAM;AAClB,WAAW,6DAAM;AACjB,iBAAiB,6DAAM;AACvB,wBAAwB,6DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,wBAAwB,+DAAQ,CAAC,6DAAU;AAC3C;AACA;AACA,IAAI,2EAAoB;AACxB,IAAI,6DAAM;AACV;AACA;AACA,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,6DAAM,0CAA0C,kEAAW;AACjE;AACA;AACA;AACA,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,SAAS;AACrB;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA,eAAe,6BAA6B;AAC5C,oBAAoB,iBAAiB;AACrC;AACA;AACA,+DAA+D,4DAAK;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oCAAoC,wBAAwB,qBAAqB,sFAAsF,2DAAI;AACrL;AACA,sEAAsE,2DAAI;AAC1E;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2BAA2B;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B,6BAA6B,iBAAiB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,6EAAsB;AACjD,yCAAyC,gBAAgB;AACzD,sCAAsC,uBAAuB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,qBAAqB,+DAAQ;AAC7B;AACA,YAAY,wBAAwB;AACpC,WAAW,4DAAK;AAChB;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4DAAK;AACX;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,uCAAuC;AAChE;AACA;AACA;AACA;AACA;AACA,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mEAAgB;AAC1B,MAAM,6DAAM;AACZ;AACA;AACA,wBAAwB,6DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,uEAAgB;AAClC;AACA,oBAAoB,2DAAI;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,6DAAM;;AAEN,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAoB;AAC/C;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA,+CAA+C,wBAAwB;AACvE;AACA;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;;AAEJ,oBAAoB,4DAAS;AAC7B;AACA;AACA;AACA,aAAa,6DAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA,sBAAsB,gEAAS;AAC/B,KAAK;AACL;AACA;AACA,uBAAuB,yEAAkB,CAAC,8DAAW;AACrD,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,6DAAM;AACV;AACA;AACA;AACA,IAAI,8DAAO;AACX,IAAI,gEAAS;AACb;AACA;AACA,IAAI,6DAAM;AACV,oBAAoB,iEAAU,CAAC,yEAAsB;AACrD;AACA,KAAK;AACL;AACA;AACA,kBAAkB,iEAAU,CAAC,yEAAsB;AACnD;AACA;AACA;AACA,YAAY,QAAQ;AACpB,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA,QAAQ,2DAAI;AACZ;AACA;AACA,+BAA+B,2DAAI;AACnC;AACA;AACA,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA,8BAA8B,SAAS;AACvC;AACA;AACA;AACA,2DAAI;;AAEJ;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA,iCAAiC,4DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,6DAAM;AACjB,UAAU,6DAAM;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAoB;AAC/C;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,QAAQ,yEAAkB,CAAC,8DAAW;AACtC,mBAAmB,iEAAU,CAAC,8DAAW;AACzC;AACA,YAAY,aAAa;AACzB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA,iBAAiB,iEAAU;AAC3B,gBAAgB,uEAAgB;AAChC;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,2DAAI;AACR;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,2EAAoB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,8CAA8C,mKAAmK,kEAAW;AACxO;AACA;AACA,MAAM,kFAA2B;AACjC;AACA;AACA,iBAAiB,+DAAQ,sBAAsB,4DAAK;AACpD,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,gBAAgB;AACjE,QAAQ,+DAAQ;AAChB;AACA;AACA,gCAAgC,8BAA8B;AAC9D;AACA;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,EAAE,yDAAM;AACR;;AAEA;AACA,kCAAkC,4DAAS;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ,iBAAiB,kBAAkB;AACvD;AACA;AACA;AACA;AACA,2BAA2B,uEAAoB;AAC/C;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,QAAQ,yEAAkB,CAAC,8DAAW;AACtC,mBAAmB,iEAAU,CAAC,8DAAW;AACzC;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc,iBAAiB,YAAY;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;AACJ,6DAAM;;AAEN,sBAAsB,4DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kEAAW;AACf;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAc,6DAA6D,mEAAY,qCAAqC,wEAAiB;AAC/K;AACA;AACA;AACA;AACA,sBAAsB,2DAAI;AAC1B;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,2DAAI;AAChC;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,qEAAc,WAAW,mEAAY,WAAW,mEAAY;AACpE,oBAAoB,mEAAY;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,2DAAQ;AACzC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,8BAA8B,2DAAI;AAClC,MAAM;AACN,yBAAyB,uEAAgB;AACzC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAgB;AACvC;AACA;AACA,iEAAiE,YAAY;AAC7E,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA,uBAAuB,4DAAS;AAChC;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAM;AACrB;AACA,kBAAkB,sEAAe;AACjC;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,+MAAwB;AAC9B;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,8CAA8C;AAC1D,gFAAgF,yEAAkB;AAClG;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,IAAI,kEAAW;AACf,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B,wBAAwB,qBAAqB,yBAAyB,2DAAI,gCAAgC,2DAAI;AACvJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB,wBAAwB,yBAAyB;AAC/E;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kEAAW;AACf;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;;AAE0S;;;;;;;;;;;;;;;;;;ACzjDvO;;AAEnE,qBAAqB,oEAAa;AAClC;AACA,SAAS,iEAAU;AACnB;AACA;AACA;AACA;;AAEwD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACV2W;AAC1W;AACc;AAC8K;AACzL;AACI;AAChB;AACe;AACuB;AACxB;;AAE9D,+BAA+B,iEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB,EAAE,sEAAe;AAChD;AACA;AACA;AACA,QAAQ,gEAAS;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,oBAAoB,8DAAO,oCAAoC,+DAAQ;AACvE,2CAA2C,8DAAO;AAClD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,QAAQ,EAAE,IAAI;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,iEAAiE,IAAI;AACrG,UAAU,oCAAoC,gHAAgH,6DAAM,oKAAoK,sCAAsC,kBAAkB,cAAc,GAAG,cAAc,EAAE,SAAS;AAC1a,mCAAmC,YAAY,GAAG,KAAK;AACvD;AACA;AACA;AACA,UAAU,0BAA0B;AACpC;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA,wBAAwB,SAAS;AACjC;AACA;AACA;;AAEA,qBAAqB,iEAAc;AACnC;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,2DAAI;AACV,KAAK;AACL;AACA;AACA;AACA,IAAI,2DAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,mEAAY;AACvC;AACA;AACA,uBAAuB,kEAAW,oCAAoC,YAAY;AAClF;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,iEAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB;AACA;AACA,mBAAmB,8DAAO;AAC1B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW,+DAAQ;AACnB;AACA;AACA,QAAQ,oEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,4DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA,YAAY,0CAA0C;AACtD;AACA;AACA;AACA,YAAY,sBAAsB;AAClC,sBAAsB,sBAAsB;AAC5C;AACA;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;;AAEA,4BAA4B,4DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,sBAAsB,yEAAkB;AACxC;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;;AAEA,+BAA+B,4DAAS;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,aAAa;AACzB;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,4DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,UAAU,wBAAwB,UAAU;AACxD;AACA;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB;AACA,IAAI,mEAAY;AAChB;AACA;AACA,IAAI,8DAAO;AACX;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA,YAAY,UAAU;AACtB,mBAAmB,wCAAwC,EAAE,WAAW;AACxE;AACA;AACA,YAAY,oBAAoB;AAChC;AACA,YAAY,cAAc;AAC1B;AACA;AACA;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,WAAW,iBAAiB,iBAAiB;AACzD;AACA;AACA;AACA,uBAAuB,gEAAS;AAChC,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB;AACA;AACA;AACA,IAAI,8DAAO;AACX;AACA;AACA,YAAY,WAAW,iBAAiB,WAAW;AACnD;AACA;AACA;AACA;;AAEA,wBAAwB,wDAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA,6CAA6C,iEAAc;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,sBAAsB,oEAAa;AACnC,8BAA8B,oEAAa;;AAE3C;AACA,SAAS,kEAAW,MAAM,4DAAK,QAAQ,+EAAwB;AAC/D;AACA;AACA,oBAAoB,kEAAW;AAC/B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,iEAAc;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAkB;AAC1B,uBAAuB,iEAAU;AACjC;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,qCAAqC,6DAAM;AAC3C;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA,KAAK,mDAAmD,gBAAgB;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAM,iBAAiB,wEAAiB;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,QAAQ,mEAAgB;AACxB;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA,QAAQ,mEAAgB,oEAAoE,eAAe;AAC3G;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,4BAA4B;AACxC;AACA;AACA,qDAAqD,+BAA+B;AACpF;AACA;AACA;AACA,6DAA6D,+BAA+B;AAC5F;AACA;AACA;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA,4CAA4C,wBAAwB;AACpE;AACA;AACA;AACA;AACA;AACA,qEAAqE,WAAW;AAChF;AACA,cAAc,2CAA2C;AACzD;AACA,MAAM;AACN,yBAAyB,+DAAQ;AACjC,gBAAgB,QAAQ;AACxB;AACA,QAAQ;AACR,gBAAgB,qCAAqC;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA,mDAAmD,wBAAwB;AAC3E;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA,iDAAiD,wBAAwB;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB,SAAS,6DAAM;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,6DAAM;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,WAAW;AACtC;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,YAAY,qBAAqB;AACjC,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uEAAgB;AAC3C;AACA;AACA,KAAK;AACL;AACA,MAAM;AACN;AACA;;AAEA,iCAAiC,oEAAa,UAAU;;AAExD,+BAA+B,iEAAc;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAM;AACrB,oBAAoB,6DAAM;AAC1B;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,sBAAsB,yEAAsB;AAC5C;AACA;AACA,SAAS,yEAAkB;AAC3B,MAAM,qEAAc;AACpB;AACA,OAAO;AACP;AACA,IAAI,qEAAc;AAClB;AACA;AACA,eAAe,6DAAM;AACrB,KAAK;AACL,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,6DAAM;AACV;AACA;AACA,IAAI,gEAAS,CAAC,wEAAiB;AAC/B,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA,YAAY,4BAA4B;AACxC,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,+DAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc,iBAAiB,6BAA6B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,8BAA8B;AAC1C,2BAA2B,4DAAK,oBAAoB,4DAAK;AACzD;AACA,sBAAsB,6EAAsB;AAC5C;AACA;AACA,GAAG;AACH;;AAEA,qBAAqB,4DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,aAAa;AACzB,WAAW,4DAAK;AAChB;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAM;AAClB;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA,QAAQ,+DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,+DAAQ;AACvB;AACA;AACA;AACA;AACA;AACA,2BAA2B,4EAAqB;AAChD,aAAa;AACb;AACA;AACA,kBAAkB,8DAAO;AACzB;AACA;AACA,kBAAkB;AAClB,kCAAkC,iBAAiB;AACnD;AACA,oBAAoB,6DAAM,CAAC,+DAAQ,wCAAwC,EAAE;AAC7E,oBAAoB,6DAAM;AAC1B,wCAAwC,+DAAQ;AAChD,sEAAsE,EAAE;AACxE;AACA,oBAAoB,6DAAM;AAC1B,8CAA8C,+DAAQ;AACtD,4EAA4E,EAAE;AAC9E;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,YAAY,+MAAwB,eAAe,eAAe;AAClE;AACA,wBAAwB,OAAO;AAC/B;AACA,gBAAgB;AAChB;AACA;AACA,aAAa;AACb,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT,cAAc,+DAAQ;AACtB,SAAS;AACT;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM,SAAS,8DAAO;AACtB;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,6DAAM;AACZ,mBAAmB,+DAAQ;AAC3B,wDAAwD,EAAE;AAC1D;AACA,MAAM,6DAAM;AACZ,8BAA8B,+DAAQ;AACtC,8DAA8D,EAAE;AAChE;AACA;AACA;AACA,aAAa,+DAAQ;AACrB;AACA,KAAK;AACL;AACA;AACA,IAAI,6DAAM,CAAC,+DAAQ;AACnB,IAAI,6DAAM,CAAC,8DAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB,OAAO;AACP;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,MAAM,6DAAM;AACZ,8BAA8B,+DAAQ;AACtC,8DAA8D,EAAE;AAChE;AACA,MAAM,6DAAM;AACZ,yBAAyB,+DAAQ;AACjC,yDAAyD,EAAE;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,+DAAQ,YAAY,+DAAQ,aAAa,uBAAuB;AACxF,OAAO;AACP;AACA;AACA;AACA;AACA,kBAAkB,2DAAI;AACtB,SAAS,+DAAQ;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sBAAsB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,4DAAS;AACjC;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,iBAAiB,sEAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA,YAAY,+BAA+B,iBAAiB,gCAAgC,iBAAiB,gCAAgC;AAC7I;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,6DAAM;AAClB;AACA;AACA,YAAY,SAAS,iBAAiB,WAAW;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,uBAAuB;AACxD,oCAAoC,QAAQ;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,iDAAiD,eAAe;AAChE,mCAAmC,2BAA2B;AAC9D,oCAAoC,4BAA4B;AAChE;AACA;AACA;AACA,uCAAuC,2BAA2B,OAAO,2BAA2B;AACpG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,4DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,+DAAQ;AAC3B,mBAAmB,iEAAU;AAC7B,iBAAiB,+DAAQ;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iBAAiB,6CAA6C;AACpE;AACA;AACA;AACA;AACA,sCAAsC,wDAAK;AAC3C,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,6DAAM;;AAEN,4BAA4B,4DAAS;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,iEAAU;AAC7B,YAAY,SAAS,EAAE,+DAAQ;AAC/B;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,UAAU;AACtB;AACA,IAAI,gEAAS;AACb,IAAI,6DAAM;AACV;AACA;AACA,IAAI,gEAAS;AACb;AACA,qBAAqB,6EAAsB;AAC3C,YAAY,wBAAwB;AACpC;AACA,0BAA0B,kBAAkB;AAC5C;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,+GAA+G,OAAO;AACtH;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D,MAAM;AACN,iEAAiE,UAAU,mCAAmC,MAAM;AACpH,2BAA2B,UAAU,IAAI,WAAW;AACpD;AACA,IAAI;AACJ;AACA;AACA,sDAAsD,WAAW;AACjE,MAAM;AACN,8BAA8B,WAAW,mCAAmC,WAAW,oCAAoC,OAAO;AAClI,6BAA6B,SAAS,IAAI,YAAY;AACtD;AACA;AACA;AACA;;AAEA,2BAA2B,4DAAS;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,YAAY,YAAY;AACxB,IAAI,qEAAc;AAClB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL,IAAI,6DAAM;AACV;AACA;AACA;AACA,IAAI,0EAAmB;AACvB,YAAY,eAAe;AAC3B;AACA;AACA,qBAAqB,gEAAS;AAC9B,KAAK;AACL;AACA;AACA,YAAY,QAAQ,iBAAiB,YAAY;AACjD;AACA;AACA;AACA,YAAY,aAAa,iBAAiB,YAAY;AACtD,WAAW,4DAAK;AAChB;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA,YAAY,WAAW,iBAAiB,eAAe;AACvD;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,oCAAoC,kBAAkB;AACtD;AACA,0BAA0B,uEAAgB;AAC1C;AACA;AACA,wBAAwB,4DAAK;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,6DAAM;AACnB;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC,IAAI,qEAAc;AAClB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA,IAAI,0EAAmB;AACvB;AACA;AACA,IAAI,6DAAM;AACV,IAAI,2EAAoB;AACxB;AACA;AACA,YAAY,wBAAwB;AACpC,WAAW,4DAAK;AAChB;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA,4BAA4B,uEAAgB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,SAAS,2DAAI;AACb;AACA,sCAAsC,kBAAkB;AACxD;AACA;AACA;AACA,4CAA4C,UAAU,EAAE,iEAAU;AAClE,2BAA2B,mEAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB,SAAS,2DAAI;AACb;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAK;AAChB;AACA;AACA,YAAY,WAAW,iBAAiB,UAAU;AAClD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA,6DAA6D,WAAW;AACxE,sCAAsC,wBAAwB,SAAS,6BAA6B;AACpG;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB,WAAW,4DAAK;AAChB;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE,sCAAsC,qBAAqB,EAAE,qCAAqC;AAClG;AACA;;AAEA,oBAAoB,oEAAa;;AAEjC;AACA,kBAAkB,wDAAC;AACnB,eAAe,qBAAqB;AACpC,iBAAiB,uCAAuC;AACxD;AACA;AACA,0CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,SAAS;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kEAAW;AACf;AACA,IAAI,gEAAS;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB,IAAI,gEAAS;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,qBAAqB;AACzD;AACA,MAAM;AACN,wBAAwB,qBAAqB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAkB;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oEAAa;AACvB,MAAM,sEAAe;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iDAAiD,QAAQ;AACzD;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4DAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6DAAM;AACpB,cAAc,6DAAM;AACpB,aAAa,6DAAM;AACnB,aAAa,6DAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,6DAAM;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA,QAAQ,8DAAO;AACf;AACA;AACA,SAAS;AACT;AACA;AACA,UAAU,8DAAO;AACjB;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA,iCAAiC,eAAe;AAChD,8CAA8C,eAAe;AAC7D;AACA;AACA,KAAK;AACL,QAAQ,yEAAkB;AAC1B,yBAAyB,iEAAU;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,qEAAc;AAClB;AACA;AACA;AACA,YAAY,6DAAM;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAS;AACjB;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,yEAAkB,0BAA0B,iEAAU;AAC7G,IAAI,qEAAc;AAClB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,cAAc,SAAS;AACvB,iBAAiB,+DAAQ;AACzB,KAAK;AACL;AACA;AACA,IAAI,kEAAW;AACf;AACA;AACA,wEAAwE,gEAAS;AACjF,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB;AACA,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB;AACA,IAAI,6DAAM;AACV;AACA,IAAI,gEAAS;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB;AACA,IAAI,gEAAS;AACb,6BAA6B,mEAAY;AACzC,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,2DAAI;AACxB,iBAAiB,mEAAY,yBAAyB,+DAAQ;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,sEAAe;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,MAAM,mEAAY;AAClB,MAAM,mEAAY,2BAA2B,+DAAQ;AACrD;AACA,iBAAiB,mEAAY;AAC7B;AACA;AACA,IAAI,2DAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,mDAAmD,gBAAgB;AACnE;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oEAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C,oEAAa;AACxD;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,sEAAe;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,6EAAsB;AACpC,oBAAoB,2DAAI;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,oEAAa;AACvB;AACA,QAAQ;AACR;AACA,QAAQ,SAAS,oEAAa;AAC9B,aAAa,uEAAgB;AAC7B;AACA;AACA;AACA;AACA,IAAI,+DAAQ;AACZ,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,MAAM,mEAAY;AAClB;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAI;AACZ;AACA,IAAI,2DAAI;AACR;AACA;AACA,SAAS,2DAAI;AACb;AACA,IAAI,2DAAI;AACR;AACA;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,EAAE,uDAAI;AACN;AACA;AACA,EAAE,yDAAM;AACR;AACA;AACA,EAAE,yDAAM;AACR;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA,YAAY,6DAAM;AAClB;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B;AACA;AACA,iBAAiB,iEAAU;AAC3B;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,0EAAmB;AACvB;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,4BAA4B,gEAAgE;AAC5F,IAAI,gEAAS;AACb,IAAI,8DAAO;AACX,gCAAgC,SAAS;AACzC,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAAI;;AAEJ;AACA;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,IAAI,qEAAc;AAClB;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kFAA2B;AAC/B,MAAM,kFAA2B;AACjC;AACA,QAAQ,6DAAM;AACd,OAAO;AACP,KAAK;AACL;AACA;AACA,YAAY,aAAa,wBAAwB,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,QAAQ,oEAAa;AACrB;AACA;AACA;AACA,0BAA0B,oEAAa;;AAEvC,wBAAwB,4DAAS;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,yEAAsB;AAC9B,YAAY,YAAY;AACxB;AACA;AACA,KAAK;AACL;AACA;AACA,iBAAiB,iEAAU;AAC3B;AACA,QAAQ,yEAAkB;AAC1B,qBAAqB,iEAAU;AAC/B;AACA,QAAQ,qEAAc;AACtB;AACA,QAAQ,gEAAS;AACjB;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,YAAY,kCAAkC;AAC9C,IAAI,gEAAS;AACb,MAAM,oEAAa;AACnB;AACA;AACA;AACA,OAAO;AACP;AACA,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,oEAAa;;AAE5C,mCAAmC,iEAAc;AACjD;AACA,WAAW,6DAAM;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,qEAAc;AAClB;AACA;AACA,KAAK;AACL;AACA;AACA,uBAAuB,yEAAkB;AACzC,qBAAqB,0EAAmB;AACxC,yBAAyB,oBAAoB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,2DAAI;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,2DAAI;AAC3B;AACA;AACA;AACA;;AAEA,8BAA8B,4DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,QAAQ,yEAAkB;AAC1B,mBAAmB,iEAAU;AAC7B;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,iBAAiB,aAAa;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;AACJ,6DAAM;;AAEN,iCAAiC,4DAAS;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,QAAQ,yEAAkB;AAC1B,mBAAmB,iEAAU;AAC7B;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA,YAAY,WAAW,iBAAiB,aAAa;AACrD;AACA,QAAQ,+BAA+B;AACvC,6BAA6B,qEAAkB;AAC/C;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW,iBAAiB,YAAY;AACpD;AACA,eAAe,yEAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY;AACxB,oBAAoB,yEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,uBAAuB;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;AACJ,6DAAM;;AAEN;AACA,8BAA8B,4DAAS;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,QAAQ,iBAAiB,qBAAqB;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,QAAQ,yEAAkB;AAC1B,mBAAmB,iEAAU;AAC7B;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc,iBAAiB,eAAe;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,eAAe;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,uBAAuB;AACrD;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;AACJ,6DAAM;;AAEN,gCAAgC,4DAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA,qBAAqB,+DAAQ;AAC7B,YAAY,OAAO,iBAAiB,YAAY;AAChD,WAAW,yEAAkB;AAC7B,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,QAAQ,yEAAkB;AAC1B,mBAAmB,iEAAU;AAC7B;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA,YAAY,yBAAyB;AACrC;AACA,QAAQ,iCAAiC;AACzC;AACA,qEAAqE,4DAAK,4BAA4B;AACtG;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,YAAY,iBAAiB,uBAAuB;AAChE;AACA,uEAAuE,YAAY;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,yBAAyB;AACzD;AACA;AACA,YAAY,YAAY,8BAA8B,2DAAI;AAC1D;AACA,sBAAsB,2DAAI;AAC1B;AACA,gCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA,YAAY,uBAAuB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;AACJ,6DAAM;;AAEN,mBAAmB,4DAAS;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAK;AAC1B;AACA;AACA,GAAG;AACH;AACA,YAAY,6DAAM;AAClB,eAAe,6DAAM;AACrB,oBAAoB,6DAAM;AAC1B;AACA,kBAAkB,sEAAe;AACjC;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,kCAAkC,6DAAM;AACxC,IAAI,6DAAM;AACV;AACA;AACA,IAAI,gEAAS,CAAC,wEAAiB;AAC/B,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,8DAAO;AACb;AACA;AACA;AACA,YAAY,mBAAmB,iBAAiB,WAAW;AAC3D;AACA,YAAY,wCAAwC;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB;AACA;AACA,YAAY,qCAAqC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAE8mB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC71FthB;;AAExF;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B,iEAAU;AACxC;AACA;AACA,UAAU,kEAAW,gCAAgC,kEAAW;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,iEAAU,2CAA2C,iEAAU;AACxE;AACA;AACA;AACA;AACA,QAAQ,kEAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kEAAW;AACjB,yCAAyC,iEAAU,yEAAyE;AAC5H;AACA,8BAA8B,kEAAW,mBAAmB,kEAAW,4BAA4B,iEAAU,yCAAyC,iEAAU;AAChK;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,WAAW;AACjC,SAAS,+DAAQ;AACjB;AACA;AACA,SAAS,+DAAQ;AACjB;AACA,oBAAoB,WAAW;AAC/B,SAAS,+DAAQ;AACjB;AACA,qBAAqB,WAAW;AAChC,SAAS,+DAAQ;AACjB;AACA;AACA,SAAS,+DAAQ;AACjB;AACA;AACA;AACA;;AAE4c;;;;;;;;;;;;;;;;;;;AChH3U;AACxE;;AAEzD,0BAA0B,oEAAa;AACvC;AACA,SAAS,iEAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,4DAAS;AAClC;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,IAAI,qEAAc;AAClB;AACA,mBAAmB,6DAAM;AACzB,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,wEAAiB;AACpC;AACA,iBAAiB,6DAAM;AACvB;AACA;AACA,IAAI,6DAAM;AACV,6BAA6B,WAAW;AACxC;AACA;AACA,KAAK;AACL,IAAI,6DAAM;AACV,cAAc,YAAY,oDAAoD,sCAAsC;AACpH;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEkE;;;;;;;;;;;;;;;;AC1GhC;;AAElC;AACA;AACA;AACA,oBAAoB,gDAAM;AAC1B;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,IAAI,gDAAM;AACV;AACA;;AAEsB;;;;;;;;;;;;;;;;;;ACjBoF;AACjD;AACL;;AAEpD,qBAAqB,4DAAS;AAC9B;AACA;AACA;AACA;AACA;AACA,qBAAqB,wDAAK;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA,YAAY,QAAQ;AACpB,YAAY,6DAAM;AAClB;AACA;AACA,YAAY,wBAAwB;AACpC,sCAAsC,iEAAU;AAChD;AACA;AACA,YAAY,MAAM,iBAAiB,yBAAyB;AAC5D,eAAe,mEAAY;AAC3B;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA;AACA,YAAY,wBAAwB,wBAAwB,gDAAgD;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM,iBAAiB,MAAM,iBAAiB,SAAS;AACnE;AACA;AACA;AACA,YAAY,+BAA+B,iBAAiB,gCAAgC,iBAAiB,6CAA6C;AAC1J;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB,iBAAiB,wBAAwB;AACtE;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;;AAEkB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC1G8G;AACmL;AAC1P;AACG;AAC5B;AACyG;AACrF;AACqB;AACR;;AAEjE,mCAAmC,2DAAI,cAAc,2DAAQ;AAC7D;AACA;;AAEA,kCAAkC,2DAAI,cAAc,0DAAO;AAC3D;AACA;;AAEA,oCAAoC,2DAAI,cAAc,iEAAc;AACpE;AACA;;AAEA,mCAAmC,2DAAI,cAAc,2DAAQ;AAC7D;AACA;;AAEA,wCAAwC,2DAAI,cAAc,gEAAa;AACvE;AACA;;AAEA,oBAAoB,4DAAS;AAC7B;AACA,gCAAgC,2DAAI;AACpC;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA,2BAA2B,4DAAS;AACpC;AACA;AACA;AACA;AACA,uCAAuC,2DAAI;AAC3C;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,yBAAyB,6DAAM;AAC/B;AACA;AACA;AACA,IAAI,yEAAkB;AACtB,IAAI,6DAAM;AACV;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;;AAEA,sBAAsB,4DAAS;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,kFAA2B;AAC/B;AACA;AACA,MAAM,6DAAM;AACZ,KAAK;AACL;AACA;AACA,YAAY,gCAAgC;AAC5C,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB;AACA;AACA,kCAAkC,2DAAI,CAAC,6DAAU;AACjD;AACA;AACA,WAAW,8CAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0BAA0B,4DAAS;AACnC;AACA;AACA;AACA;AACA,iCAAiC,2DAAI;AACrC;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,2HAA2H,gEAAS,gBAAgB,+DAAQ;AAC5J;AACA;AACA;AACA;AACA,QAAQ,SAAS,oEAAa;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,SAAS,oEAAa;AAC5B;AACA;AACA;AACA;;AAEA,2CAA2C,2DAAI,cAAc,mEAAgB;AAC7E;AACA;;AAEA,uCAAuC,2DAAI,cAAc,+DAAY;AACrE;AACA;;AAEA,kCAAkC,2DAAI,cAAc,0DAAO;AAC3D;AACA;;AAEA,yCAAyC,2DAAI,cAAc,iEAAc;AACzE;AACA;AACA;AACA;AACA;;AAEA,yCAAyC,2DAAI,cAAc,iEAAc;AACzE;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;AACA;AACA;AACA,YAAY,+DAAQ;AACpB;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,2DAAI,cAAc,qEAAkB;AACjF;AACA;AACA,IAAI,8EAAuB;AAC3B,cAAc,2BAA2B;AACzC;AACA;AACA;AACA;AACA,QAAQ,6DAAM;AACd;AACA;AACA;AACA,YAAY,SAAS,+DAAQ;AAC7B;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA,8CAA8C,2DAAI,cAAc,sEAAmB;AACnF;AACA;AACA,IAAI,8EAAuB;AAC3B;AACA;;AAEA,gCAAgC,2DAAI,cAAc,wDAAK;AACvD;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;;AAEA,iCAAiC,2DAAI,cAAc,yDAAM;AACzD;AACA;;AAEA,sCAAsC,qEAAc;AACpD,mEAAmE;AACnE;AACA,sCAAsC,2DAAI,cAAc,8DAAW;AACnE;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA,YAAY,UAAU,wBAAwB,mBAAmB;AACjE;AACA;AACA;AACA,IAAI,6DAAM;AACV,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,KAAK;AACL;AACA;AACA,WAAW,2EAAoB;AAC/B;AACA;;AAEA,0CAA0C,2DAAI,cAAc,kEAAe;AAC3E;AACA;;AAEA,sCAAsC,2DAAI,cAAc,8DAAW;AACnE;AACA;;AAEA,wCAAwC,2DAAI,cAAc,gEAAa;AACvE;AACA;;AAEA,yCAAyC,2DAAI,cAAc,iEAAc;AACzE;AACA;AACA;AACA,IAAI,kFAA2B;AAC/B;AACA;AACA;AACA;AACA,QAAQ,6DAAM;AACd;AACA,KAAK;AACL;AACA;AACA;AACA,qBAAqB,oEAAa;AAClC;AACA;AACA;;AAEA,0BAA0B,4DAAS;AACnC;AACA,sCAAsC,2DAAI;AAC1C;AACA;AACA;AACA,IAAI,kFAA2B;AAC/B;AACA;AACA,0BAA0B,6DAAM;AAChC,KAAK;AACL;AACA;AACA;AACA,YAAY,iBAAiB,EAAE,+DAAQ,CAAC,8DAAW;AACnD,IAAI,oEAAa;AACjB;AACA;;AAE+oB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC5S/oB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,oBAAoB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC,QAAQ;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8CAA8C,QAAQ;AACtD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,QAAQ;AACvD;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,SAAS;AACvB;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,4BAA4B;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,yEAAyE;AACzE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,0BAA0B;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA,sBAAsB,QAAQ;;AAE9B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,6BAA6B;AACnD;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,wCAAwC,0BAA0B;AAClE;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,4BAA4B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,IAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4DAA4D,KAAK;AACjE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,KAAK;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6BAA6B,mCAAmC;AACpF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB;AACpB;;AAEA;AACA,yBAAyB;AACzB;;AAEA;AACA,sBAAsB;AACtB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA,UAAU,iFAAiF;AAC3F;AACA;AACA;AACA,SAAS,cAAc;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,kMAAkM,yBAAyB,YAAY,4DAA4D,gCAAgC,uCAAuC;AAC1W;AACA,aAAa;AACb,GAAG;AACH;AACA;AACA,mBAAmB,eAAe;AAClC,wBAAwB,kEAAkE;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,gCAAgC;AAC9C;AACA;AACA,aAAa,2BAA2B;AACxC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,gCAAgC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,8EAA8E,aAAa;AAC3F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEunC;;;;;;;;;;;;;;;;ACpmDvnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEiC;;;;;;;;;;;;;;;;;;;;;ACT4D;AAC9B;AACV;;AAErD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,wBAAwB,+DAAY;AACpC;AACA,kBAAkB,WAAW,GAAG,WAAW,GAAG,gCAAgC;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,8EAA8E,SAAS;AACvF;AACA;AACA;AACA;AACA,gBAAgB,YAAY;AAC5B;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAQ,cAAc,sBAAsB;AACvE,QAAQ,kEAAW;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2DAAQ,iBAAiB,sBAAsB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA,MAAM;AACN;AACA;AACA,2BAA2B,2DAAQ,kBAAkB,uBAAuB;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,YAAY;AAC5D;AACA,UAAU,kEAAW;AACrB;AACA;AACA;AACA,sBAAsB,uBAAuB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+MAAwB,SAAS,8BAA8B;AACnE,WAAW,+DAAQ;AACnB;AACA;AACA,QAAQ;AACR,kCAAkC,iBAAiB,UAAU,eAAe;AAC5E;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2BAA2B,2DAAQ;AACnC;AACA;AACA;AACA;AACA;AACA,cAAc,mCAAmC,QAAQ,+MAAwB;AACjF;AACA,0CAA0C,qCAAqC;AAC/E,qBAAqB,4EAAqB;AAC1C,OAAO;AACP;AACA;AACA,QAAQ;AACR,gBAAgB,kCAAkC;AAClD;AACA;AACA,SAAS;AACT;AACA;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,2DAAQ;AAClC;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAQ,YAAY,eAAe;AAC9D;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B;AACA;AACA,MAAM;AACN;AACA,wEAAwE,SAAS;;AAEjF;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAQ,iBAAiB,SAAS;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAQ;AAC1B;AACA;AACA;AACA;AACA,sBAAsB,8DAAO;AAC7B,YAAY,8DAAO,yDAAyD,+DAAQ,wBAAwB,+DAAQ;AACpH;AACA,WAAW;AACX;;AAEiF;;;;;;;;;;;;;;;;;ACtPjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEwD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACV+Z;AAChZ;AACqK;AAC9H;AACtB;AACpC;AACG;AACA;AACoB;AACoB;AACnC;AACI;;AAEhE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA,qBAAqB,aAAa;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA;AACA,kBAAkB;AAClB,OAAO;AACP;AACA;AACA;;AAEA,mBAAmB,+DAAY;AAC/B;AACA;AACA,GAAG,6DAAU;AACb;AACA;AACA;AACA;AACA,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,6DAAU;AACb;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,2BAA2B,2DAAQ,UAAU,uBAAuB;AACpE;AACA;AACA,GAAG,6DAAU;AACb;AACA;AACA,WAAW,6DAAU;AACrB;AACA,6BAA6B,2DAAQ,aAAa,uBAAuB;AACzE;AACA;AACA;AACA,GAAG,6DAAU;AACb,6CAA6C,6DAAU;AACvD;AACA,SAAS,6DAAU;AACnB,SAAS,6DAAU;AACnB;AACA;AACA,GAAG,6DAAU;AACb,aAAa,6DAAU;AACvB,SAAS,6DAAU;AACnB,2BAA2B,2DAAQ,sBAAsB,2BAA2B;AACpF;AACA;;AAEA,uBAAuB,0DAAO;AAC9B,mCAAmC,iEAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB,CAAC,0DAAO;AAChC,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,gCAAgC;AACzE;AACA;AACA;AACA,wCAAwC,8BAA8B;AACtE;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,0DAAO;AACpB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,0DAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,0DAAO;AACb;AACA;AACA;AACA,MAAM,0DAAO;AACb;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,0CAA0C,iEAAc;AACxD,UAAU,6DAAM;AAChB,YAAY,6DAAM;AAClB;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,sEAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,kEAAW;AACjB,MAAM;AACN;AACA;AACA,MAAM,gEAAS;AACf;AACA,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAI;AACzB;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA,SAAS,2DAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAU,+DAAQ,8CAA8C,+DAAQ,eAAe,+DAAQ;AAC/F;;AAEA,uBAAuB,wDAAK;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA;AACA;AACA,mBAAmB,sEAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,4DAAS,yDAAyD,0DAAO;AACpF,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,cAAc,4DAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,4DAAS;AACzB;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA;AACA;AACA,kCAAkC,qEAAkB;AACpD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,kBAAkB,yEAAkB;AACpC;AACA,GAAG;AACH;AACA,gBAAgB,uEAAgB;AAChC;AACA,GAAG;AACH;AACA,kBAAkB,yEAAkB;AACpC;AACA,GAAG;AACH;AACA,+BAA+B,uEAAgB;AAC/C;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,2DAAI;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,6BAA6B;AAC7B,gCAAgC;AAChC,+BAA+B;AAC/B,gCAAgC;AAChC,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC,mCAAmC;AACnC,qCAAqC;AACrC,mCAAmC;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC,kCAAkC;AAClC,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,yEAAkB;AAC7C;AACA;AACA;AACA,0CAA0C,yEAAkB;AAC5D;AACA;AACA,0CAA0C,yEAAkB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,2DAAQ;AAChC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,oCAAoC,4DAAS;AAC7C;AACA;AACA;AACA,mCAAmC,OAAO,gBAAgB,KAAK;AAC/D;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,OAAO;AACpE;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;AACA;AACA,kCAAkC,6BAA6B;AAC/D;AACA;AACA,sBAAsB,uEAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kEAAe;AACzB,UAAU,kEAAe;AACzB;AACA;AACA;AACA,4BAA4B,kEAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,kEAAe;AACpC,QAAQ,oEAAa;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,gEAAS;AACb,QAAQ,mEAAgB;AACxB;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAO;AACX;AACA;AACA;AACA;AACA,IAAI,8DAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,SAAS,yEAAkB;AAC3B;AACA;AACA;AACA,SAAS,yEAAkB;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,kEAAe;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kEAAe;AAClB;AACA;AACA;AACA;AACA,iEAAiE,yEAAkB;AACnF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,4DAAS,+BAA+B,4DAAS;AACrF;AACA;AACA,SAAS,6DAAU;AACnB,UAAU,kEAAe,qBAAqB,kEAAe;AAC7D,6BAA6B,kEAAe;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,kEAAe;AACzB;AACA,SAAS,6DAAU;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,kEAAe;AAClB;AACA,0CAA0C,kEAAe;AACzD;AACA;AACA;AACA,kBAAkB,uEAAgB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,8DAAO;AAClC,8EAA8E,yEAAkB;AAChG;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,yBAAyB,yEAAkB;AAC3C;AACA;AACA;AACA,oBAAoB,yEAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,6DAAU;AACb,SAAS,6DAAU;AACnB;AACA;AACA,GAAG,6DAAU;AACb;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,aAAa,6DAAU;AACvB,aAAa,6DAAU;AACvB;AACA,KAAK;AACL,UAAU,6DAAU;AACpB;AACA;AACA,GAAG,6DAAU;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2DAAQ;AACpB;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG,gEAAa;AAChB;AACA,GAAG,6DAAU;AACb,SAAS,gEAAa;AACtB;AACA;AACA,GAAG,6DAAU;AACb,SAAS,gEAAa;AACtB,SAAS,gEAAa;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,gEAAa;AAC1D,SAAS,gEAAa;AACtB,SAAS,gEAAa;AACtB;AACA;AACA;AACA;AACA;AACA,GAAG,gEAAa;AAChB;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,oCAAoC,iEAAc;AAClD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,yBAAyB;AACrC;AACA,4EAA4E,6DAAM;AAClF;AACA,UAAU,mEAAgB;AAC1B;AACA,OAAO;AACP,MAAM;AACN,WAAW,2DAAI;AACf,MAAM,kEAAW;AACjB;AACA;AACA,OAAO;AACP;AACA,IAAI,6DAAM;AACV;AACA,UAAU,mEAAgB,iJAAiJ,eAAe;AAC1L,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,gBAAgB;AAC1B,SAAS,+DAAQ,YAAY,8DAAO;AACpC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,sEAAe;AAC/D;AACA;AACA,UAAU,gBAAgB;AAC1B,SAAS,+DAAQ,YAAY,8DAAO;AACpC;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,8DAAO,4BAA4B,+DAAQ;AAC7F,4BAA4B,8DAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAsB,6DAAM;AAC5B,oBAAoB,6DAAM;AAC1B;AACA,aAAa,6DAAM;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA,YAAY,2BAA2B;AACvC;AACA,uBAAuB,mEAAgB;AACvC;AACA,MAAM,6DAAM;AACZ;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA,IAAI,6DAAM;AACV;AACA,0FAA0F,mEAAgB;AAC1G;AACA,4CAA4C,gBAAgB;AAC5D;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,wEAAiB;AACtE;AACA;AACA;AACA,QAAQ,sEAAe;AACvB;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,qBAAqB;AAC9C,OAAO;AACP;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,iEAAU;AACnB,YAAY,+DAAQ,iCAAiC,uEAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gYAAwC;AAC9D;AACA;;AAEA;AACA;AACA;AACA;AACA,SAAS,iEAAU;AACnB,YAAY,+DAAQ,iCAAiC,uEAAgB;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,gYAAwC;AAC9D;AACA;;AAEA;AACA,qBAAqB,qEAAc;AACnC;AACA;AACA,0CAA0C,+DAAQ;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,kYAAsC;AAC5D;AACA;;AAEA;AACA,qBAAqB,sEAAe;AACpC;AACA;AACA,2CAA2C,gEAAS;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,qYAAuC;AAC7D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iEAAU;AAChB;AACA;AACA;AACA,WAAW,+DAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,2PAAwC;AAC9D;AACA;AACA,YAAY,yCAAyC,QAAQ,2OAAgC;AAC7F,SAAS,+DAAQ;AACjB,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,iEAAU;AAChB;AACA;AACA;AACA,WAAW,+DAAQ;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,iQAA0C;AAChE;AACA;AACA,YAAY,2CAA2C,QAAQ,2OAAgC;AAC/F,oBAAoB,+DAAQ;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,mEAAgB;AACvC;AACA;AACA;AACA;AACA;AACA,uCAAuC,OAAO,gBAAgB,WAAW,kCAAkC,gBAAgB;AAC3H;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN,MAAM,qEAAc;AACpB,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,gBAAgB,gEAAS;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAQ;AAClB;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,WAAW,8DAAO;AAClB,cAAc,SAAS;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,2DAAI;AACV;AACA;AACA;AACA,gDAAgD,qBAAqB,iBAAiB,6CAA6C;AACnI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,gBAAgB;AAChB,MAAM;AACN;AACA,6BAA6B,2DAAQ,wBAAwB,SAAS;AACtE;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,4FAA4F,QAAQ;AACpG;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,aAAa,sEAAe;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,sEAAe;AACnC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wFAAwF,mEAAgB;AACxG;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA,0DAA0D,+BAA+B;AACzF;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,YAAY,OAAO,iBAAiB,UAAU;AAC9C;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO,aAAa,WAAW;AACvE;AACA;AACA,QAAQ,2DAAI;AACZ;AACA,MAAM;AACN;AACA,YAAY,2DAAI;AAChB,OAAO;AACP;AACA;AACA;AACA,YAAY,+BAA+B;AAC3C;AACA,SAAS,2DAAI;AACb;AACA,0BAA0B,2DAAI;AAC9B;AACA,uBAAuB,2DAAI;AAC3B,2CAA2C,2DAAI;AAC/C;AACA,MAAM;AACN;AACA;AACA,gBAAgB,oEAAa;AAC7B;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO,iBAAiB,UAAU;AAC9C;AACA,8DAA8D,SAAS;AACvE;AACA;AACA;AACA;AACA,UAAU;AACV;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA,uBAAuB,2DAAI;AAC3B,2CAA2C,2DAAI;AAC/C;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAsF;AAClG;AACA,QAAQ,2DAAI;AACZ,qBAAqB,2DAAI;AACzB,yCAAyC,2DAAI;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,2DAAI;AACpC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qBAAqB,2DAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA,YAAY,wBAAwB,2BAA2B,4DAAS,KAAK,yDAAM,IAAI,uEAAgB;AACvG;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAI,kDAAkD,CAAqB;AAC/F;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,cAAc,gBAAgB;AAC9B,WAAW,2DAAI;AACf;AACA,UAAU,KAAI,mDAAmD,CAAqB;AACtF;AACA;AACA;AACA;AACA,MAAM,iEAAU;AAChB;AACA,8BAA8B,2OAAgC;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,2DAAI;AAC/B;AACA;AACA,kBAAkB,2DAAI;AACtB,uBAAuB,2DAAI;AAC3B,SAAS;AACT;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,YAAY,sBAAsB;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,qBAAqB,2DAAI;AACzB,QAAQ,kEAAW;AACnB;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,MAAM;AACN;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAa;AAC7B,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oEAAa;AAC7B,OAAO;AACP;AACA;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA,YAAY,6BAA6B;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sFAAsF;AAClG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAiD,MAAM,8DAA8D,gBAAgB;AACrI;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE,OAAO;AAC3E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA,IAAI,gEAAS;AACb;AACA;AACA,YAAY,qCAAqC;AACjD,gBAAgB,6DAAU;AAC1B,cAAc,6DAAU;AACxB,eAAe,6DAAU;AACzB;AACA;AACA;AACA;AACA;AACA,IAAI,8DAAO;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kCAAkC,2DAAQ;AAC1C,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA;AACA,QAAQ,mEAAgB;AACxB;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,aAAa;AACzB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,YAAY;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC,6DAAM;AAC1C,cAAc,YAAY,iBAAiB,0BAA0B;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6DAAU;AAC5B;AACA;AACA,cAAc,2DAAQ,aAAa,UAAU,uBAAuB;AACpE;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,sCAAsC;AAClD;AACA;AACA;AACA;AACA,IAAI,sEAAe;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD,+BAA+B;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,kEAAe;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb,WAAW;AACX,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA;AACA,YAAY,UAAU,iBAAiB,UAAU;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,0CAA0C,iBAAiB,cAAc;AACrF;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,YAAY;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,6DAAU;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6DAAU;AAC1B;AACA;AACA,4BAA4B,gEAAa;AACzC;AACA,gBAAgB,gEAAa;AAC7B,gBAAgB,gEAAa;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,OAAO;AAC/C;AACA;AACA;AACA,YAAY,yBAAyB;AACrC;AACA;AACA;AACA,kBAAkB,6DAAU;AAC5B,gBAAgB,6DAAU;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iDAAiD;AAC7D;AACA;AACA;AACA,wBAAwB,uEAAgB;AACxC;AACA;AACA;AACA,YAAY,gEAAgE;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,wEAAwE,iBAAiB,+CAA+C,iCAAiC,uEAAgB,yKAAyK,uEAAgB;AAC9X;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,gBAAgB;AACpC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,+CAA+C,gBAAgB;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAI;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,YAAY,qBAAqB;AACjC;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU;AACtB;AACA;AACA,gDAAgD,gBAAgB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA,8CAA8C,gBAAgB;AAC9D;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,6DAA6D;AACvE;AACA;AACA;AACA;AACA,YAAY,kEAAe;AAC3B;AACA;AACA;AACA,6CAA6C,gBAAgB;AAC7D;AACA;AACA;AACA,gBAAgB,8CAA8C;AAC9D;AACA,KAAK;AACL;AACA;AACA,YAAY,8BAA8B;AAC1C;AACA,2BAA2B,0EAAmB;AAC9C;AACA;AACA;AACA;AACA,mBAAmB,4DAAS;AAC5B;AACA;AACA;AACA,YAAY,uCAAuC;AACnD;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,YAAY,UAAU,iBAAiB,2BAA2B;AAClE;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU,iBAAiB,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU,iBAAiB,yBAAyB;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,uEAAgB;AAChC;AACA,cAAc,mCAAmC;AACjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,MAAM;AACN;AACA;AACA,YAAY,oEAAoE;AAChF;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,uEAAgB;AACjC;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA,gDAAgD,+BAA+B;AAC/E;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,YAAY,cAAc;AAC1B;AACA;AACA;AACA;AACA;AACA,gDAAgD,gBAAgB;AAChE,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA,YAAY,UAAU,iBAAiB,mCAAmC;AAC1E;AACA;AACA,+BAA+B,gBAAgB;AAC/C;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,6DAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,4CAA4C;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA;AACA,YAAY,QAAQ;AACpB,oCAAoC,iBAAiB;AACrD;AACA;AACA;AACA;AACA,wCAAwC,kBAAkB;AAC1D;AACA;AACA;AACA,mCAAmC,cAAc;AACjD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,qCAAqC,kBAAkB;AACvD;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,2CAA2C,gBAAgB;AAC3D;AACA;AACA,YAAY,gBAAgB;AAC5B;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,cAAc;AAC1B;AACA;AACA,KAAK;AACL;AACA;AACA,mCAAmC,4BAA4B;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC,gCAAgC;AACxE;AACA;;AAEA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iCAAiC;AAC7C;AACA;AACA;AACA,+BAA+B,eAAe;AAC9C,KAAK;AACL;AACA;AACA,YAAY,kBAAkB;AAC9B;AACA;AACA;AACA,wBAAwB,2DAAQ,2BAA2B,iBAAiB;AAC5E;AACA;AACA,8CAA8C,SAAS;AACvD;AACA;AACA,+CAA+C,SAAS;AACxD;AACA;AACA;AACA;AACA;AACA,kBAAkB,+DAAQ;AAC1B;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,6BAA6B,6CAA6C,IAAI;AAC9E;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,oBAAoB;AACpC;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,4CAA4C;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,4DAAK;AACd;;AAEA,yBAAyB,iEAAc;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kEAAkE,iEAAc;AAChF,cAAc,uBAAuB;AACrC;AACA;AACA;AACA;AACA,iFAAiF,+DAAQ;AACzF;AACA,aAAa,oBAAoB,KAAK,gBAAgB,KAAK,kBAAkB,EAAE,8BAA8B;AAC7G,uBAAuB,uBAAuB,cAAc,sBAAsB,oBAAoB,gBAAgB;AACtH,kBAAkB,+BAA+B,kBAAkB,gBAAgB;AACnF,sBAAsB,iBAAiB,kBAAkB;AACzD;AACA;AACA,4CAA4C,mCAAmC;AAC/E;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,gEAAS;AACb;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM,4BAA4B,kEAAW;AAC7C;AACA,MAAM;AACN;AACA;AACA;AACA;;AAEA,0BAA0B,4DAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAM;AACvB,sBAAsB,6DAAM;AAC5B;AACA;AACA;AACA;AACA;AACA,MAAM,6DAAM;AACZ;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,kEAAe;AACtC;AACA;AACA;AACA,IAAI,qEAAc,CAAC,gEAAY;AAC/B;AACA,QAAQ,0EAAsB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA,IAAI,0EAAmB;AACvB,IAAI,0EAAmB;AACvB,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,kEAAW;AACf;AACA;AACA,QAAQ,4DAAS,EAAE,mEAAY;AAC/B;AACA;AACA;AACA,sCAAsC,6EAAsB;AAC5D;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,IAAI,gEAAS;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2BAA2B,uCAAuC,uCAAuC,yEAAkB,iDAAiD,sBAAsB,EAAE,KAAK;AACzM,IAAI,mEAAY;AAChB;AACA;AACA,SAAS,UAAU,gCAAgC,aAAa;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,0BAA0B,yEAAkB;AAC5C,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA,gBAAgB,4BAA4B;AAC5C;AACA,OAAO;AACP;AACA,gBAAgB,QAAQ;AACxB;AACA,OAAO;AACP;AACA,gBAAgB,gBAAgB;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kDAAkD,uEAAgB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,+DAAQ;AACZ,IAAI,+DAAQ;AACZ;AACA;AACA;AACA,IAAI,mEAAY;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,2DAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,WAAW,2DAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,2DAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,yDAAyD;AACvE,mBAAmB,2DAAI;AACvB,MAAM,2DAAI;AACV;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,WAAW,2DAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,kEAAW;AACrC;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,2DAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,wDAAwD,+DAAQ;AAChE;AACA,cAAc,SAAS,0BAA0B,+DAAQ,uDAAuD,+DAAQ;AACxH,MAAM,6DAAM;AACZ;AACA;AACA;AACA,IAAI,gEAAS;AACb;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,6BAA6B,iBAAiB,SAAS;AACnE,wBAAwB,QAAQ,GAAG,gBAAgB,GAAG,cAAc;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,2DAAI;AACJ,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;AACN,6DAAM;;AAEN;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,+DAAQ;AAC5B;AACA;AACA;AACA,KAAK;AACL,YAAY,SAAS;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,SAAS;AACrB,sDAAsD,2DAAI;AAC1D,kDAAkD,2DAAI;AACtD;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,WAAW;AAC5B;;AAEA;;AAEA,oBAAoB,QAAQ,WAAW,uBAAuB;;AAE9D;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAc,cAAc,wBAAwB,4EAAqB;AACzE;AACA;AACA,sBAAsB,+DAAQ;AAC9B;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA,+CAA+C,2DAAI;AACnD,QAAQ,2DAAI;AACZ;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA,IAAI,2DAAI;AACR;AACA;AACA,sBAAsB,mBAAmB,uCAAuC,2DAAQ,qBAAqB,UAAU,WAAW,gCAAgC,oDAAoD;AACtN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAI;AACd;AACA,kBAAkB,2DAAI;AACtB,uBAAuB,2DAAI;AAC3B,SAAS;AACT,QAAQ;AACR;AACA;AACA;AACA;AACA,2BAA2B,2DAAQ;AACnC,oBAAoB;AACpB,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,sBAAsB,2DAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc,2DAAI;AAClB;AACA;AACA;AACA;AACA;AACA,qBAAqB,2DAAI;AACzB;AACA,MAAM,6DAAM;AACZ;AACA;AACA;AACA,IAAI,2DAAI;AACR;AACA;AACA;AACA,kGAAkG,2DAAI,oDAAoD,2DAAI;AAC9J;AACA;AACA;AACA;AACA;AACA,UAAU,+DAAQ;AAClB,gCAAgC,qEAAc;AAC9C;AACA,yBAAyB,4EAAqB;AAC9C;AACA,WAAW;AACX;AACA,WAAW,QAAQ,uDAAI;AACvB;AACA,QAAQ,SAAS,gEAAS;AAC1B;AACA,uBAAuB,4EAAqB;AAC5C;AACA,SAAS;AACT;AACA,SAAS,QAAQ,uDAAI;AACrB,QAAQ;AACR;AACA;AACA,MAAM,2DAAI;AACV,wBAAwB,2DAAI;AAC5B;AACA;AACA,0MAA0M,gBAAgB;AAC1N;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA,MAAM,+DAAQ,gBAAgB,iEAAU;AACxC,MAAM;AACN;AACA,yEAAyE,WAAW;AACpF;AACA;AACA;AACA;AACA,qCAAqC,wCAAwC;AAC7E;AACA,uDAAuD,2DAAQ,oBAAoB,gBAAgB;AACnG;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,8DAAO;AACjB,QAAQ,+DAAQ;AAChB,eAAe;AACf,MAAM;AACN,eAAe;AACf;AACA,GAAG;AACH;AACA;AACA,MAAM,+DAAQ;AACd;AACA,IAAI,SAAS,+DAAQ;AACrB;AACA,IAAI,kBAAkB,+DAAQ,GAAG,eAAe;AAChD;AACA,IAAI,kBAAkB,gEAAS,GAAG,eAAe;AACjD;AACA,IAAI,UAAU,+DAAQ;AACtB;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,4DAAS;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,4DAAS;AACrC;AACA;AACA;AACA,qBAAqB,wDAAK;AAC1B;AACA,GAAG;AACH;AACA;AACA,gBAAgB,6DAAM;AACtB,eAAe,6DAAM;AACrB;AACA;AACA,kBAAkB,uEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,6EAAsB;AAC5D;AACA;AACA,4BAA4B,mCAAmC;AAC/D;AACA;AACA,IAAI,gEAAS;AACb;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,gEAAS;AACb;AACA,KAAK;AACL;AACA;AACA;AACA,2CAA2C,YAAY;AACvD,gEAAgE,2DAAI;AACpE;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,2DAAI;AACd;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,iBAAiB;AAC7B;AACA;AACA;AACA;AACA,MAAM,+DAAQ;AACd,MAAM,+DAAQ;AACd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,KAAK;AACrD,cAAc,+DAAQ;AACtB;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4DAAS;AAChC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,IAAI,2DAAI;AACR;AACA;AACA;AACA,6DAAM;;AAEwnB;;;;;;;;;;;;;;;ACjgK9nB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEsB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACbmR;AACjO;AACgB;AACxD;AAC0C;AACZ;AACS;AACT;AACb;AACQ;;AAEzD,6BAA6B,oEAAa;AAC1C;AACA,SAAS,iEAAU;AACnB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,4BAA4B;AAC/C,gBAAgB,4BAA4B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,4BAA4B,4DAAS;AACrC;AACA;AACA,UAAU,+DAAQ;AAClB;AACA;AACA,GAAG;AACH,eAAe,+DAAQ;AACvB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,IAAI,qEAAc;AAClB;AACA;AACA;AACA,gCAAgC,6DAAM;AACtC,qCAAqC,6DAAM;AAC3C,kBAAkB,6DAAM;AACxB,KAAK;AACL;AACA;AACA,IAAI,uEAAgB;AACpB;AACA;AACA,iCAAiC,gEAAS,kBAAkB,+DAAQ;AACpE;AACA;AACA;AACA,2DAAI;AACJ,2DAAI;;AAEJ;AACA,EAAE,6DAAM;AACR,YAAY,SAAS,EAAE,sEAAe;AACtC,UAAU,mEAAY;AACtB;AACA,GAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA,SAAS,8DAAO;AAChB,YAAY,yCAAyC;AACrD;AACA,WAAW,8CAAI,kCAAkC,8DAAO,eAAe;AACvE,GAAG;AACH;;AAEA;AACA,SAAS,8CAAI;AACb,WAAW,GAAG,KAAK;AACnB,iBAAiB,gBAAgB,KAAK,OAAO,cAAc,QAAQ,OAAO;AAC1E;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,8DAAO;AAChB;;AAEA,gCAAgC,SAAS;AACzC,UAAU,eAAe,+BAA+B,sBAAsB,EAAE,oEAAa,aAAa,8DAAO;AACjH,mEAAmE,yEAAkB;AACrF,cAAc,aAAa,EAAE,UAAU;AACvC,GAAG;AACH,SAAS,8CAAI;AACb;AACA;AACA,iFAAiF,OAAO;AACxF,YAAY;AACZ;AACA;AACA,qEAAqE,QAAQ;AAC7E,iDAAiD,aAAa;AAC9D;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C,UAAU,eAAe,+BAA+B,sBAAsB,EAAE,oEAAa,aAAa,8DAAO;AACjH,0EAA0E,yEAAkB;AAC5F,cAAc,gBAAgB,EAAE,UAAU;AAC1C,GAAG;AACH,SAAS,8CAAI;AACb;AACA;AACA,yFAAyF,OAAO;AAChG,YAAY;AACZ;AACA;AACA,qEAAqE,QAAQ;AAC7E,qDAAqD,gBAAgB;AACrE;AACA;AACA;AACA;AACA,6BAA6B,SAAS;AACtC,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,YAAY;AACZ;AACA;AACA,qEAAqE,QAAQ;AAC7E,8CAA8C,UAAU;AACxD,+CAA+C,WAAW;AAC1D;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,uDAAI;AACnB,CAAC;AACD,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,uBAAuB;AACvB,YAAY,+DAAG;AACf;AACA,YAAY;AACZ;AACA;AACA,qEAAqE,QAAQ;AAC7E,8CAA8C,YAAY;AAC1D,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA,gCAAgC,SAAS;AACzC,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,YAAY;AACZ;AACA;AACA,qEAAqE,QAAQ;AAC7E,+CAA+C,WAAW;AAC1D,gDAAgD,UAAU;AAC1D;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,YAAY;AACZ;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D,kDAAkD,UAAU;AAC5D;AACA;AACA;AACA;AACA,mCAAmC,SAAS;AAC5C,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA,YAAY;AACZ;AACA;AACA,qEAAqE,QAAQ;AAC7E,kDAAkD,WAAW;AAC7D,iDAAiD,UAAU;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,UAAU,yBAAyB;AACnC,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,oBAAoB,8DAAO;AAC3B,uBAAuB;AACvB;AACA,YAAY;AACZ;AACA;AACA,qEAAqE,QAAQ;AAC7E,UAAU;AACV;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,+BAA+B,OAAO,EAAE,oEAAa;AAC9E,kBAAkB,8CAAI;AACtB,gEAAgE,OAAO;AACvE,+CAA+C,UAAU;AACzD;AACA;AACA;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,yBAAyB;AACrC,QAAQ,4DAAK;AACb,YAAY,gBAAgB,EAAE,oEAAa,4BAA4B,sEAAe;AACtF;AACA;AACA;AACA,KAAK;AACL,kBAAkB,8CAAI;AACtB;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,uBAAuB,wBAAwB,UAAU;AACzD,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA,SAAS,8CAAI;AACb;;AAEA;AACA,SAAS,8CAAI;AACb,oCAAoC,8DAAO,aAAa;AACxD,QAAQ;AACR;AACA;AACA;AACA;AACA,aAAa,+DAAQ;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,EAAE,6DAAM;AACR;AACA,YAAY,WAAW,EAAE,oEAAa;AACtC,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,IAAI,mEAAY;AAChB,GAAG;AACH,UAAU,cAAc;AACxB,EAAE,uEAAgB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD,UAAU,aAAa,EAAE,sEAAe,MAAM,uCAAuC,EAAE,oEAAa;AACpG;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,yCAAyC,+DAAQ;AACrD,uFAAuF,6DAAM;AAC7F,IAAI,2EAAoB;AACxB;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB,+DAAQ;AAC7B,sBAAsB,6DAAM,0BAA0B,6DAAM;AAC5D,eAAe,+DAAQ;AACvB;AACA,eAAe,6DAAM;AACrB;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,8CAAI;AACpB;AACA;AACA,kBAAkB,8DAAO;AACzB,eAAe,8DAAO;AACtB;AACA,QAAQ,8DAAO;AACf;AACA,WAAW,8CAAI;AACf;AACA;AACA,0BAA0B,8DAAO;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,8CAAI;AACb,2DAA2D,QAAQ,SAAS,QAAQ;AACpF;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA,cAAc;AACd;AACA;AACA;AACA;AACA,sBAAsB,iEAAU,YAAY,8DAAO;AACnD;AACA,YAAY;AACZ;AACA;AACA,QAAQ;AACR;AACA;AACA;;AAEA;AACA,UAAU,QAAQ;AAClB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,6DAAM;AAClB,GAAG;AACH;AACA;AACA;AACA;AACA,qDAAqD,uEAAgB,OAAO;AAC5E,QAAQ,+DAAQ;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAU,SAAS,EAAE,sEAAe;AACpC;AACA,EAAE,gEAAS;AACX;AACA,IAAI,6DAAM;AACV,yBAAyB,6DAAM;AAC/B,yGAAyG,uEAAgB,OAAO,8BAA8B,uEAAgB,OAAO;AACrL,QAAQ,6DAAM;AACd;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA8B,kCAAkC;AAChE;AACA,WAAW,8CAAI;AACf;AACA,6CAA6C,SAAS;AACtD;AACA;AACA;AACA,iCAAiC,YAAY;AAC7C,SAAS,8CAAI;AACb,qEAAqE,GAAG;AACxE;AACA,qBAAqB,GAAG,GAAG,MAAM;AACjC,UAAU,QAAQ,8CAAI,uCAAuC,MAAM;AACnE;AACA,2CAA2C,SAAS;AACpD;AACA;AACA;AACA,2BAA2B,iBAAiB;AAC5C,SAAS,8CAAI;AACb;AACA,yCAAyC,MAAM;AAC/C,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,SAAS,8CAAI;AACb;AACA,QAAQ;AACR,QAAQ;AACR,0CAA0C,8DAAO,QAAQ;AACzD,0DAA0D,OAAO,8DAAO,eAAe;AACvF,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,YAAY,gCAAgC;AAC5C,WAAW,8CAAI;AACf,6CAA6C,OAAO;AACpD,UAAU;AACV,UAAU,aAAa,8CAAI;AAC3B;AACA,kBAAkB,+DAAQ,sBAAsB,8DAAO;AACvD;AACA;AACA,UAAU,iEAAU;AACpB;AACA;AACA;AACA,SAAS,8CAAI;AACb;AACA;AACA,cAAc,+DAAQ,0BAA0B,8DAAO;AACvD,gBAAgB;AAChB;AACA,QAAQ,8DAAO,uCAAuC,8DAAO;AAC7D;AACA;AACA;AACA;AACA,SAAS,8DAAO,sCAAsC,0CAA0C,4CAA4C,8BAA8B;AAC1K;;AAEA;AACA,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAI;AACb;AACA,cAAc,qCAAqC,yBAAyB;AAC5E,iBAAiB,8DAAO;AACxB,iBAAiB,8DAAO;AACxB;AACA,QAAQ,WAAW,8CAAI;AACvB;AACA,gBAAgB;AAChB,YAAY,8CAAI,QAAQ,MAAM;AAC9B,YAAY,8CAAI,QAAQ,MAAM;AAC9B;AACA;AACA,gDAAgD,QAAQ;AACxD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,cAAc,EAAE,oEAAa,MAAM,eAAe;AAC9D;AACA,WAAW,8CAAI;AACf;AACA,UAAU;AACV;AACA,KAAK;AACL;AACA,YAAY;AACZ;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb,2DAA2D,YAAY;AACvE,0CAA0C,8DAAO,SAAS;AAC1D;AACA;AACA;AACA,8BAA8B,qBAAqB;AACnD,UAAU,SAAS,EAAE,sEAAe,MAAM,eAAe;AACzD;AACA,IAAI,2DAAI;AACR;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa,8DAAO;AACpB,gBAAgB,8CAAI;AACpB;AACA;AACA;AACA,mBAAmB,8DAAO;AAC1B,mBAAmB;AACnB;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,mCAAmC;AAC/C;AACA,aAAa,8DAAO;AACpB,aAAa,8DAAO;AACpB;AACA;AACA;AACA;AACA,gBAAgB,8CAAI;AACpB;AACA;AACA,gBAAgB;AAChB,gBAAgB;AAChB,iBAAiB;AACjB,qBAAqB;AACrB,mBAAmB,8DAAO;AAC1B,uBAAuB,8DAAO;AAC9B,0BAA0B;AAC1B,+BAA+B;AAC/B;AACA,YAAY,qBAAqB,EAAE;AACnC;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,8BAA8B,+DAAQ;AACtC;AACA,SAAS,8CAAI;AACb,wBAAwB,OAAO,uEAAgB,OAAO,gBAAgB;AACtE,QAAQ,oBAAoB,4BAA4B;AACxD;AACA,UAAU;AACV;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,UAAU,eAAe,2GAA2G,6DAAM,8CAA8C,6DAAM,wBAAwB,8DAAO,CAAC,gEAAS;AACvO,2BAA2B,2DAAI;AAC/B;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,sEAAe;AACvB;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,mBAAmB;AACnB,qBAAqB;AACrB,oBAAoB,8DAAO;AAC3B,mBAAmB;AACnB,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;;AAEA;AACA,SAAS,8DAAO;AAChB,YAAY,eAAe;AAC3B,WAAW,8CAAI;AACf;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,yCAAyC;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,oEAAoE,+BAA+B,WAAW,EAAE,oEAAa,gBAAgB,+DAAQ;AACjK;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA;AACA,SAAS,8DAAO;AAChB,YAAY,4BAA4B,+BAA+B,+BAA+B,EAAE,oEAAa,gBAAgB,+DAAQ;AAC7I;AACA;AACA,KAAK;AACL;AACA,WAAW,8CAAI;AACf;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA,YAAY;AACZ;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,eAAe,+BAA+B,cAAc,EAAE,oEAAa,+DAA+D,+DAAQ;AAC9J;AACA;AACA,gBAAgB,8CAAI;AACpB;AACA,YAAY;AACZ;AACA,OAAO;AACP;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,4BAA4B,+BAA+B,kBAAkB,EAAE,oEAAa,gBAAgB,+DAAQ;AAChI;AACA,YAAY,YAAY,EAAE,oEAAa;AACvC;AACA;AACA,aAAa,8DAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA,mBAAmB;AACnB,YAAY,8DAAO;AACnB,YAAY,8DAAO;AACnB,aAAa,8DAAO;AACpB,iBAAiB,8DAAO;AACxB;AACA,QAAQ,qBAAqB,EAAE;AAC/B;AACA;AACA;AACA;AACA,UAAU,aAAa;AACvB,SAAS,8DAAO;AAChB;AACA;AACA,UAAU,aAAa;AACvB,SAAS,8DAAO;AAChB;AACA;AACA,UAAU,aAAa;AACvB,SAAS,8DAAO;AAChB;;AAEA;AACA,SAAS,8DAAO;AAChB,YAAY,eAAe,+BAA+B,cAAc,EAAE,oEAAa;AACvF;AACA,WAAW,8CAAI;AACf;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA,SAAS,8DAAO;AAChB,YAAY,eAAe;AAC3B,WAAW,8CAAI;AACf;AACA,UAAU;AACV;AACA;AACA,KAAK;AACL;AACA,YAAY;AACZ;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,SAAS,EAAE,sEAAe,MAAM,eAAe;AACzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,eAAe,+BAA+B,mCAAmC,EAAE,oEAAa;AAC5G;AACA;AACA;AACA,aAAa,8DAAO;AACpB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,UAAU,gBAAgB;AAC1B,SAAS,8DAAO;AAChB;AACA;AACA,UAAU,gBAAgB;AAC1B,SAAS,8DAAO;AAChB;AACA;AACA,UAAU,gBAAgB;AAC1B,SAAS,8DAAO;AAChB;AACA;AACA,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA,mBAAmB;AACnB,YAAY,8DAAO;AACnB,YAAY,8DAAO;AACnB,aAAa,8DAAO;AACpB,iBAAiB,8DAAO;AACxB;AACA,QAAQ,qBAAqB,EAAE;AAC/B;AACA;AACA;AACA;AACA,UAAU,oBAAoB,EAAE,sEAAe,MAAM,oDAAoD,EAAE,oEAAa,MAAM,eAAe,yDAAyD,+DAAQ;AAC9M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,mCAAmC,+BAA+B,oCAAoC,EAAE,oEAAa,gBAAgB,+DAAQ,wEAAwE,+DAAQ,OAAO,yEAAkB;AAClQ;AACA;AACA;AACA,aAAa,8DAAO;AACpB,iJAAiJ,4BAA4B;AAC7K,2BAA2B,OAAO,GAAG,mBAAmB,YAAY,QAAQ;AAC5E,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL,GAAG;AACH;AACA;AACA,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb,6EAA6E,OAAO;AACpF,QAAQ,qBAAqB,EAAE;AAC/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD,SAAS,8DAAO;AAChB,YAAY,WAAW,EAAE,oEAAa;AACtC;AACA;AACA;AACA;AACA;AACA,MAAM,0CAA0C,+DAAQ;AACxD,wBAAwB,6DAAM,0BAA0B,6DAAM;AAC9D,iBAAiB,+DAAQ;AACzB;AACA,iBAAiB,6DAAM;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAI;AACtB;AACA;AACA,oBAAoB,8DAAO;AAC3B,iBAAiB,8DAAO;AACxB;AACA,UAAU,8DAAO;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,8CAAI;AACf,6DAA6D,QAAQ,SAAS,QAAQ;AACtF;AACA;AACA;AACA;AACA,2BAA2B;AAC3B;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,wBAAwB,iEAAU,YAAY,8DAAO;AACrD;AACA,cAAc;AACd;AACA;AACA,UAAU;AACV;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,CAAC;AACD,SAAS,8DAAO;AAChB,YAAY,+BAA+B,EAAE,oEAAa;AAC1D;AACA;AACA,iCAAiC,SAAS;AAC1C;AACA,qBAAqB,6DAAM,0BAA0B,gEAAS;AAC9D,WAAW,8CAAI;AACf,6CAA6C,8DAAO,iBAAiB,EAAE,+DAAG,eAAe;AACzF,UAAU,oBAAoB,SAAS;AACvC,wCAAwC,sBAAsB,aAAa,EAAE;AAC7E;AACA;AACA,GAAG;AACH;AACA,+BAA+B,cAAc,IAAI;AACjD,UAAU,eAAe;AACzB,SAAS,8CAAI;AACb;AACA;AACA,mBAAmB;AACnB,oBAAoB,4EAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,6DAAM,mBAAmB,6DAAM;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA,IAAI,iFAAiF,8DAAO,2CAA2C,8DAAO,2DAA2D,8DAAO;AAChN,EAAE,wEAAiB;AACnB;AACA;AACA,GAAG;AACH,SAAS,8CAAI;AACb;AACA;AACA,mBAAmB;AACnB,iBAAiB,8DAAO;AACxB,kBAAkB;AAClB,0BAA0B,8DAAO;AACjC,QAAQ,+DAAG;AACX;AACA,qEAAqE,oBAAoB;AACzF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,SAAS,8CAAI;AACb;AACA,QAAQ,8DAAO;AACf,YAAY,WAAW,EAAE,oEAAa;AACtC;AACA;AACA,MAAM,8CAAI;AACV,MAAM,8CAAI;AACV,MAAM,8CAAI;AACV;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,iBAAiB,EAAE,oEAAa;AAC5C,uDAAuD,8CAAI;AAC3D,GAAG;AACH;AACA;AACA,SAAS,8DAAO;AAChB,YAAY,OAAO,EAAE,oEAAa;AAClC;AACA,GAAG;AACH;;AAEA;AACA,SAAS,8DAAO;AAChB,YAAY,aAAa,EAAE,sEAAe,MAAM,iBAAiB,EAAE,oEAAa,mBAAmB,6DAAM;AACzG,IAAI,2EAAoB;AACxB,+EAA+E,8CAAI;AACnF,GAAG;AACH;AACA;AACA,SAAS,8CAAI;AACb;;AAEA,uCAAuC,oEAAiB;AACxD;AACA,yBAAyB,2OAAgC;AACzD;AACA,wBAAwB,2DAAI,GAAG,wCAAwC;AACvE;AACA;AACA;AACA;;AAEqf;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC57CpZ;AACiP;AACxN;AACjE;;AAEzD,oCAAoC,qEAAc;AAClD;AACA;AACA,oCAAoC,2DAAI,cAAc,4DAAS;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B;AACA;AACA;AACA,IAAI,6DAAM;AACV,MAAM,mEAAY;AAClB,MAAM,mEAAY;AAClB,KAAK;AACL;AACA;AACA,WAAW,2EAAoB;AAC/B;AACA;;AAEA,+BAA+B,2DAAI,cAAc,uDAAI;AACrD;AACA;AACA,IAAI,6DAAM;AACV;AACA,KAAK;AACL;AACA;;AAEA,wCAAwC,2DAAI,cAAc,gEAAa;AACvE;AACA;;AAEA,wCAAwC,2DAAI,cAAc,gEAAa;AACvE;AACA;;AAEA,2CAA2C,2DAAI,cAAc,mEAAgB;AAC7E;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;;AAEA,oCAAoC,2DAAI,cAAc,4DAAS;AAC/D;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;;AAEA;AACA,EAAE,kFAA2B;AAC7B;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA;AACA;AACA,MAAM,oEAAa;AACnB,gBAAgB,eAAe;AAC/B;AACA;AACA,cAAc,+DAAQ;AACtB;AACA,YAAY;AACZ,YAAY,6DAAM;AAClB;AACA,aAAa;AACb;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL,GAAG;AACH;;AAEA,0CAA0C,2DAAI,cAAc,kEAAe;AAC3E;AACA;AACA;AACA;AACA;;AAEA,6CAA6C,2DAAI,cAAc,qEAAkB;AACjF;AACA;AACA;AACA;AACA;;AAEA,+BAA+B,2DAAI,cAAc,uDAAI;AACrD;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;;AAEA,mCAAmC,2DAAI,cAAc,2DAAQ;AAC7D;AACA;;AAEA,oCAAoC,2DAAI,cAAc,4DAAS;AAC/D;AACA;;AAEA,0CAA0C,2DAAI,cAAc,kEAAe;AAC3E;AACA;AACA;AACA;AACA;;AAEA,4CAA4C,2DAAI,cAAc,oEAAiB;AAC/E;AACA;AACA;AACA;AACA;AACA,QAAQ,6DAAM;AACd;AACA,SAAS;AACT;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sEAAe;AACjC,mBAAmB,+DAAQ,CAAC,yDAAM;AAClC;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA;AACA,YAAY,0BAA0B;AACtC;AACA;AACA;;AAEA,sCAAsC,2DAAI,cAAc,8DAAW;AACnE;AACA;AACA;AACA,iBAAiB,0DAAO;AACxB;AACA;AACA;AACA,IAAI,6DAAM;AACV;AACA,KAAK;AACL;AACA;;AAEA,qCAAqC,2DAAI,cAAc,6DAAU;AACjE;AACA;;AAEA,wCAAwC,2DAAI,cAAc,gEAAa;AACvE;AACA;;AAEA,uCAAuC,2DAAI,cAAc,+DAAY;AACrE;AACA;;AAE0mB;;;;;;;;;;;;;;;;;;;;;;;;ACvMlf;AACvE;AACa;AACA;AACoB;AACzB;;AAEzD,8BAA8B,uEAAc;AAC5C;AACA;AACA;AACA;AACA;AACA,iCAAiC,iEAAQ,4BAA4B,iEAAQ;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C,2DAAI,kBAAkB,6CAAO;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,6DAAM;AACvB;AACA;AACA,0BAA0B,4EAAS;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,cAAc,uCAAuC,iBAAiB;AACtE,uCAAuC,QAAQ;AAC/C,cAAc,OAAO;AACrB;AACA;AACA;;AAEA;;AAEA,EAAE,2BAA2B;AAC7B;AACA,UAAU;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,sEAAS,kBAAkB,+DAAQ;AAC5C;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6DAA6D,gCAAgC;AAC7F,IAAI,gEAAS;AACb,IAAI,gEAAS;AACb;AACA;AACA;AACA;AACA;AACA,QAAQ,gEAAS;AACjB;AACA;AACA,MAAM;AACN,MAAM,gDAAM;AACZ,MAAM,gDAAM;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8DAA8D,iBAAiB;AAC/E,IAAI,gEAAS;AACb;AACA,gBAAgB,6EAAsB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gBAAgB,0DAA0D;AAC1E,SAAS,8CAAI;AACb,aAAa,2BAA2B,OAAO,QAAQ;AACvD,eAAe,QAAQ;AACvB;AACA;AACA;AACA;AACA,gBAAgB,4EAAS;AACzB;AACA,MAAM,CAAC,+DAAQ,2BAA2B,4EAAS;AACnD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0BAA0B,SAAS;AACnC;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,iBAAiB,aAAa;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,YAAY,SAAS,EAAE,sEAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,cAAc,gEAAS;AACvB;AACA;;AAEyD;;;;;;;;;;;;;;;;;;;;;;;;;;AC/NzB;AACmH;AACxC;AACvC;AAC8B;AACnC;AACC;AACI;AACzB;AACA;AACN;AACM;;AAE3C,oCAAoC,2EAAiB;AACrD;AACA,yBAAyB,sPAA2C;AACpE;AACA,wBAAwB,kEAAI;AAC5B;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB,6EAAe,MAAM,OAAO,kBAAkB,UAAU,iCAAiC,sEAAQ;AACjH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAe,MAAM,eAAe,EAAE,kFAAoB,MAAM,QAAQ,yBAAyB,qEAAO,UAAU,2BAA2B,IAAI,QAAQ;AACzK,SAAS,8CAAI;AACb;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,WAAW,EAAE,kFAAoB;AAC3C,SAAS,qEAAO;AAChB;AACA;AACA,UAAU,0BAA0B,EAAE,kFAAoB;AAC1D,SAAS,8CAAI;AACb;AACA,aAAa,qEAAO;AACpB;AACA,aAAa,qEAAO;AACpB;AACA;AACA;AACA;AACA,gBAAgB,6EAAe,MAAM,SAAS,yBAAyB,qEAAO,iCAAiC,SAAS,GAAG;AAC3H,SAAS,8CAAI,mCAAmC,OAAO;AACvD;AACA;AACA,0FAA0F,WAAW,EAAE,kFAAoB,gBAAgB,qEAAO;AAClJ;AACA;AACA,SAAS,8CAAI,+BAA+B,UAAU;AACtD;AACA;AACA,UAAU,WAAW,EAAE,kFAAoB,gBAAgB,qEAAO;AAClE,SAAS,8CAAI,+BAA+B,UAAU;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA,oCAAoC,+BAA+B;AACnE;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,aAAa;AAChE,uDAAuD,YAAY;AACnE;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA;AACA,mDAAmD,YAAY;AAC/D,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,mDAAmD,UAAU;AAC7D,uDAAuD,WAAW;AAClE;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA;AACA,mDAAmD,WAAW;AAC9D,uDAAuD,UAAU;AACjE;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB,MAAM,SAAS,EAAE,6EAAe;AAC/E;AACA,QAAQ,6EAAe,YAAY,6EAAe;AAClD;AACA;AACA,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,mBAAmB;AACnB,iBAAiB;AACjB;AACA;AACA,oCAAoC,aAAa;AACjD;AACA;AACA;AACA;AACA,UAAU,yBAAyB,EAAE,kFAAoB,aAAa,qEAAO,UAAU,8BAA8B,EAAE,WAAW,gBAAgB,qEAAO;AACzJ,SAAS,8CAAI;AACb;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA,UAAU,yBAAyB,EAAE,kFAAoB,aAAa,qEAAO,UAAU,+BAA+B,EAAE,WAAW,gBAAgB,qEAAO;AAC1J,SAAS,8CAAI;AACb;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA,oCAAoC,OAAO;AAC3C;AACA;AACA;AACA;AACA,cAAc,6EAAe,MAAM,qBAAqB,kBAAkB,2DAA2D,EAAE,kFAAoB,4DAA4D,oEAAM,uBAAuB,qEAAO;AAC3P;AACA,oBAAoB,8CAAI,8CAA8C,8EAAU,eAAe;AAC/F,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC,qEAAO;AAChD,kBAAkB,8CAAI;AACtB;AACA,cAAc;AACd;AACA;AACA,YAAY,8CAAI;AAChB,0EAA0E,SAAS;AACnF,2CAA2C,KAAK;AAChD;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,8CAAI;AACtB;AACA;AACA,wBAAwB;AACxB,wBAAwB;AACxB,kBAAkB,SAAS,4BAA4B,EAAE;AACzD;AACA;AACA;AACA;AACA,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,qEAAO;AAC5B,uBAAuB;AACvB,mCAAmC;AACnC;AACA;AACA;AACA;AACA,YAAY,qEAAO,UAAU,EAAE,qEAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qEAAO;AAChB;AACA,WAAW,8CAAI;AACf;AACA,UAAU;AACV;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb,8EAA8E,YAAY;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6EAAe,MAAM,wDAAwD,EAAE,kFAAoB,aAAa,oEAAM,CAAC,kEAAI;AAC3I;AACA,8CAA8C,6EAAe,YAAY,6EAAe;AACxF;AACA;AACA;AACA;AACA;AACA,WAAW,qEAAO;AAClB;AACA,SAAS,qEAAO;AAChB,YAAY,aAAa,8HAA8H,qEAAO;AAC9J,mEAAmE,8CAAI;AACvE;AACA;AACA;AACA;AACA,oDAAoD,UAAU;AAC9D;AACA,YAAY,8CAAI;AAChB;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB,yBAAyB;AACzB,yBAAyB;AACzB,uBAAuB;AACvB;AACA,YAAY;AACZ;AACA,GAAG;AACH;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA,SAAS,qEAAO;AAChB,kBAAkB,6EAAe,MAAM,yBAAyB,EAAE,kFAAoB,MAAM,gBAAgB,gEAAgE,6EAAe;AAC3L;AACA;AACA;AACA,KAAK;AACL,kBAAkB,8CAAI;AACtB;AACA;AACA,mBAAmB,wBAAwB,UAAU;AACrD,uBAAuB;AACvB;AACA;AACA;AACA,0CAA0C,cAAc;AACxD;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,qEAAO;AAChB,YAAY,iCAAiC,EAAE,kFAAoB;AACnE;AACA,sBAAsB,8CAAI;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,8CAAI;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,gBAAgB,6EAAe,gBAAgB,oEAAM,qBAAqB,qEAAO,OAAO,8EAAU;AAClG,EAAE,oEAAM;AACR;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,yEAAW;AACtB,GAAG;AACH,SAAS,8CAAI;AACb;AACA,oCAAoC,SAAS;AAC7C;AACA;AACA;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA,wCAAwC,cAAc;AACtD;AACA;AACA,sBAAsB,0DAA0D;AAChF;AACA;AACA;AACA;AACA;AACA,gBAAgB,iBAAiB;AACjC,eAAe,oEAAM;AACrB,SAAS,8CAAI;AACb,wBAAwB,QAAQ,SAAS,QAAQ;AACjD,QAAQ,aAAa,aAAa;AAClC,0BAA0B,SAAS;AACnC;AACA;AACA;AACA,sBAAsB,aAAa;AACnC,UAAU,eAAe,EAAE,kFAAoB,aAAa,qEAAO,uCAAuC,4BAA4B;AACtI;AACA;AACA,WAAW,qEAAO,gBAAgB,8CAAI,+BAA+B,MAAM;AAC3E;AACA,SAAS,8CAAI;AACb,+BAA+B,QAAQ;AACvC,oDAAoD,YAAY;AAChE,UAAU;AACV;AACA;AACA,QAAQ;AACR;AACA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb,2CAA2C,+BAA+B;AAC1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,6CAA6C;AAC7D;AACA;AACA,UAAU,sBAAsB,EAAE,kFAAoB;AACtD,SAAS,8CAAI;AACb,sCAAsC,OAAO,eAAe,8BAA8B;AAC1F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mDAAmD;AACnE;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb,4CAA4C,gCAAgC;AAC5E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,iDAAiD;AACjE;AACA;AACA,UAAU,eAAe,EAAE,kFAAoB;AAC/C,SAAS,8CAAI;AACb,4CAA4C,4BAA4B;AACxE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qEAAO;AAChB;AACA;AACA,SAAS,qEAAO;AAChB;;AAEA,qCAAqC,kEAAI,CAAC,qEAAU,EAAE,oEAAU;AAChE;AACA;AACA;AACA;AACA,kBAAkB,6EAAe;AACjC;AACA;AACA;AACA,IAAI,uEAAS;AACb,IAAI,kFAAoB;AACxB,IAAI,oEAAM;AACV;AACA,YAAY,qEAAW;AACvB,QAAQ;AACR;AACA;AACA,KAAK;AACL;AACA;AACA,WAAW,qEAAO;AAClB;AACA;AACA,YAAY,WAAW;AACvB;AACA;AACA;;AAEkC;;;;;;;;;;;;;;;;;;;;;;;;;;AC1jBiE;AACwV;AACxW;AACuB;AACjC;AACV;AAC/B;AACiB;AACN;AACA;AACA;AACA;AACA;AACjB;AACiB;AACN;;AAErC,4DAA4D,sEAAa;AACzE;AACA;AACA,aAAa,UAAU;AACvB,kBAAkB,OAAO;AACzB;AACA;;AAEA;AACA;AACA,IAAI,6EAAgB;AACpB,IAAI,4EAAe;AACnB,IAAI,8CAAI;AACR;AACA;AACA,YAAY;AACZ,MAAM,8EAAiB,GAAG,sCAAsC;AAChE,MAAM,8EAAiB,GAAG,gBAAgB;AAC1C,MAAM,8EAAiB,GAAG,gBAAgB;AAC1C;AACA,MAAM,8EAAiB;AACvB,MAAM,8EAAiB;AACvB,MAAM,+EAAkB,GAAG,yCAAyC;AACpE,MAAM,iFAAoB,GAAG,gBAAgB;AAC7C,MAAM,kFAAqB;AAC3B,MAAM,iFAAoB,GAAG,gBAAgB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qEAAO;AAChB,eAAe,oEAAM,+BAA+B,oEAAM,iBAAiB,6EAAe,MAAM,qCAAqC,EAAE,2EAAa,MAAM,eAAe,EAAE,oFAAuB,0BAA0B,iFAAmB;AAC/O;AACA;AACA,gBAAgB,iEAAI,qBAAqB,IAAI,QAAQ;AACrD;AACA,IAAI,oEAAM;AACV;AACA,iCAAiC,qBAAqB;AACtD;AACA,KAAK;AACL;AACA;AACA,YAAY,yEAAW;AACvB;AACA;AACA;AACA,aAAa,8CAAI;AACjB;AACA,YAAY,qEAAO,SAAS,EAAE,qEAAO,wBAAwB,gFAAmB;AAChF;AACA;AACA;AACA,IAAI,+EAAiB;AACrB,qBAAqB,8CAAI;AACzB,0CAA0C,qEAAO,UAAU,EAAE,+DAAG,WAAW;AAC3E,cAAc;AACd;AACA,MAAM,qEAAO;AACb;AACA;AACA,YAAY,kFAAqB;AACjC,GAAG;AACH;AACA;AACA;AACA;AACA,IAAI,gFAAmB,GAAG,yCAAyC;AACnE,IAAI,gFAAmB,GAAG,6CAA6C;AACvE;AACA;;AAEA,sCAAsC,kEAAI,CAAC,qEAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,oEAAM;AACrB;AACA;AACA,kBAAkB,6EAAe;AACjC;AACA;AACA;AACA;AACA,IAAI,0EAAa;AACjB;AACA;AACA;AACA,WAAW,qEAAO;AAClB;AACA;AACA;AACA;AACA;AACA,YAAY,aAAa,EAAE,oFAAuB;AAClD,IAAI,oEAAM;AACV;AACA,wBAAwB,gFAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,2DAA2D,qEAAW,cAAc,iFAAwB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,UAAU;AACtB,IAAI,oEAAM;AACV;AACA,MAAM,oEAAM;AACZ,KAAK;AACL;AACA;AACA;AACA,MAAM,yEAAW,2DAA2D,eAAe;AAC3F;AACA;AACA,IAAI,yEAAW;AACf,IAAI,yEAAW;AACf;AACA;AACA,YAAY,SAAS,4BAA4B,2EAAa;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvKkE;AACwX;AAC1Y;AACV;AACV;AAC/B;AACqB;AACU;AACpB;AACA;AACA;AACP;AACO;AACA;AACA;AACN;AACX;;AAE1B,iCAAiC,sEAAa;AAC9C;AACA;AACA,aAAa,UAAU;AACvB,kBAAkB,eAAe;AACjC;AACA;;AAEA;AACA,SAAS,qEAAO;AAChB,kBAAkB,6EAAe,MAAM,sDAAsD,EAAE,oFAAuB,gBAAgB,sEAAQ;AAC9I;AACA;AACA;AACA,oBAAoB,oEAAM,WAAW,qBAAqB;AAC1D,IAAI,oEAAM;AACV;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL,4BAA4B,sEAAQ;AACpC;AACA,mCAAmC,8EAAgB;AACnD,KAAK;AACL,uBAAuB,sEAAQ,uBAAuB,4BAA4B,YAAY,sEAAQ,uBAAuB,sEAAQ;AACrI;AACA,oBAAoB,yEAAU;AAC9B,KAAK;AACL;AACA;AACA;AACA,aAAa,8CAAI;AACjB;AACA,qCAAqC,MAAM;AAC3C;AACA;AACA;AACA,WAAW,8CAAI;AACf,mBAAmB,qEAAO,cAAc,cAAc,qEAAO,kBAAkB;AAC/E;AACA,qCAAqC,qEAAO,QAAQ;AACpD;AACA,UAAU,qEAAO,OAAO,mEAAK;AAC7B;AACA;AACA,GAAG;AACH;AACA;AACA,UAAU,SAAS,EAAE,6EAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,gCAAgC;AAC5C;AACA;AACA,UAAU,SAAS,EAAE,6EAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,uCAAuC;AAC7D;AACA,uBAAuB,6CAA6C;AACpE;AACA,6CAA6C,kCAAkC;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAI,6EAAgB;AACpB;AACA;AACA;AACA,IAAI,4EAAe;AACnB,IAAI,8CAAI;AACR,IAAI,8CAAI;AACR;AACA,UAAU;AACV;AACA,MAAM,kFAAqB;AAC3B,MAAM,8CAAI;AACV,MAAM,kFAAqB;AAC3B,MAAM,8CAAI;AACV;AACA,gBAAgB,8EAAiB;AACjC;AACA;AACA,MAAM,8CAAI;AACV;AACA,gBAAgB;AAChB,QAAQ,8EAAiB,GAAG,sBAAsB;AAClD,QAAQ,+EAAkB,GAAG,2CAA2C;AACxE,QAAQ,4EAAe;AACvB,QAAQ,yEAAY;AACpB,QAAQ,iFAAoB,GAAG,gBAAgB;AAC/C;AACA,QAAQ,iFAAoB,GAAG,gBAAgB;AAC/C,QAAQ,oFAAuB,GAAG,gBAAgB;AAClD,QAAQ,kFAAqB;AAC7B,QAAQ,6EAAgB;AACxB,QAAQ,oFAAuB,GAAG,oBAAoB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,qEAAO;AAChB,YAAY,YAAY,EAAE,oFAAuB;AACjD;AACA,GAAG;AACH;AACA;AACA,SAAS,8CAAI;AACb;AACA,QAAQ,qEAAO;AACf,YAAY,YAAY,EAAE,oFAAuB;AACjD,oCAAoC,kFAAqB;AACzD,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,IAAI,6EAAgB;AACpB;AACA;AACA,IAAI,4EAAe;AACnB;AACA,IAAI,8CAAI;AACR,IAAI,8CAAI;AACR;AACA;AACA,YAAY;AACZ,MAAM,iFAAoB,GAAG,sBAAsB;AACnD,MAAM,oFAAuB,GAAG,yBAAyB;AACzD,MAAM,kFAAqB;AAC3B,MAAM,iFAAoB,GAAG,mBAAmB;AAChD,MAAM,kFAAqB;AAC3B;AACA,MAAM,+EAAkB,GAAG,gDAAgD;AAC3E;AACA;;AAEA,UAAU,kFAAqB;;AAE/B,qFAAqF;AACrF,YAAY;AACZ,MAAM,kFAAqB;AAC3B,MAAM,8EAAiB,GAAG,gBAAgB;AAC1C,MAAM,kFAAqB;AAC3B;AACA;;AAEA,UAAU,kFAAqB;;AAE/B;AACA,YAAY,CAAC,4EAAe,IAAI,yEAAY,IAAI,oFAAuB,GAAG,oBAAoB;AAC9F;;AAEA;AACA,YAAY,8EAAiB;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS,8CAAI;AACb;AACA,QAAQ,8BAA8B,8EAAiB,GAAG,gBAAgB;AAC1E;AACA;AACA;AACA;AACA,SAAS,qEAAO;AAChB,YAAY,WAAW,EAAE,2EAAa;AACtC;AACA,WAAW,8CAAI;AACf;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,SAAS,8CAAI;AACb;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,+BAA+B,EAAE,oFAAuB,mFAAmF,sEAAQ,UAAU,SAAS,EAAE,yCAAyC,iBAAiB,sEAAQ,UAAU,SAAS;AACvQ;AACA,IAAI,gFAAmB,GAAG,wDAAwD;AAClF,IAAI,gFAAmB,GAAG,wDAAwD;AAClF;AACA;AACA;AACA,SAAS,qEAAO;AAChB,YAAY,aAAa,EAAE,oFAAuB;AAClD;AACA,WAAW,8CAAI;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA,sCAAsC,kEAAI,CAAC,qEAAU;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,6EAAe;AACjC;AACA;AACA;AACA,IAAI,0EAAa;AACjB;AACA;AACA;AACA,WAAW,qEAAO;AAClB;AACA;AACA,YAAY,aAAa,EAAE,oFAAuB;AAClD,IAAI,oEAAM;AACV;AACA,wBAAwB,gFAAmB;AAC3C;AACA;AACA;AACA;AACA;AACA,2DAA2D,qEAAW,cAAc,iFAAwB;AAC5G;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,YAAY,OAAO,wBAAwB,sCAAsC;AACjF;AACA;AACA;;AAEmC;;;;;;;;;;;;;;;;;;;;;;;AC5TkC;AACU;AACA;AACX;AAC5B;AACA;AACA;AACd;AACR;AACsB;AACG;AACA;AACN;AACG;AACA;AACJ;AACI;AACA;AACA;AACF;AACE;AACI;;AAE5C,iFAAmB,CAAC,wFAAuB;AAC3C,iFAAmB,CAAC,wFAAuB;AAC3C,iFAAmB,CAAC,8EAAsB;;;;;;;;;;;;;;;;;ACzB2B;AACgnB;AAC9D;AACnjB;AAC5B;AACA;AACA;AACd;AACc;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACtB;AACsB;AACA;;AAExC,iFAAmB,CAAC,4EAAkB;AACtC,iFAAmB,CAAC,8EAAoB;AACxC,iFAAmB,CAAC,mFAAyB;AAC7C,iFAAmB,CAAC,4EAAkB;AACtC,iFAAmB,CAAC,+EAAqB;AACzC,iFAAmB,CAAC,6EAAmB;AACvC,iFAAmB,CAAC,oFAA0B;AAC9C,iFAAmB,CAAC,oFAA0B;AAC9C,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,mFAAyB;AAC7C,iFAAmB,CAAC,sFAA4B;AAChD,iFAAmB,CAAC,+EAAqB;AACzC,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,mFAAyB;AAC7C,iFAAmB,CAAC,sFAA4B;AAChD,iFAAmB,CAAC,kFAAwB;AAC5C,iFAAmB,CAAC,4EAAkB;AACtC,iFAAmB,CAAC,qFAA2B;AAC/C,iFAAmB,CAAC,kFAAwB;AAC5C,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,iFAAuB;AAC3C,iFAAmB,CAAC,mFAAyB;AAC7C,iFAAmB,CAAC,oFAA0B;AAC9C,iFAAmB,CAAC,iFAAuB;AAC3C,iFAAmB,CAAC,mFAAyB;AAC7C,iFAAmB,CAAC,iFAAuB;AAC3C,iFAAmB,CAAC,qFAA2B;AAC/C,iFAAmB,CAAC,iFAAuB;AAC3C,iFAAmB,CAAC,0EAAgB;AACpC,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,+EAAqB;AACzC,iFAAmB,CAAC,8EAAoB;AACxC,iFAAmB,CAAC,qFAA2B;AAC/C,iFAAmB,CAAC,wFAA8B;AAClD,iFAAmB,CAAC,qFAA2B;AAC/C,iFAAmB,CAAC,yFAA+B;AACnD,iFAAmB,CAAC,uFAA6B;AACjD,iFAAmB,CAAC,wFAA8B;AAClD,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,2EAAiB;AACrC,iFAAmB,CAAC,6EAAmB;AACvC,iFAAmB,CAAC,+EAAqB;AACzC,iFAAmB,CAAC,8EAAoB;AACxC,iFAAmB,CAAC,gFAAsB;AAC1C,iFAAmB,CAAC,0EAAgB;AACpC,iFAAmB,CAAC,2EAAiB;AACrC,iFAAmB,CAAC,kFAAwB;AAC5C,iFAAmB,CAAC,6EAAmB;;;;;;;;;;;;;;ACtE8B;AACqB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACd;AACc;AACA;;AAExC,iFAAmB,CAAC,4EAAkB;AACtC,iFAAmB,CAAC,8EAAoB;;;;;;;UClBxC;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;UAEA;UACA;;;;;WCzBA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,EAAE;WACF;;;;;WCRA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA;;;;;WCJA;WACA;WACA;WACA;WACA,GAAG;WACH;WACA;WACA,CAAC;;;;;WCPD;;;;;WCAA;WACA;WACA;WACA;WACA,uBAAuB,4BAA4B;WACnD;WACA;WACA;WACA,iBAAiB,oBAAoB;WACrC;WACA,mGAAmG,YAAY;WAC/G;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,mEAAmE,iCAAiC;WACpG;WACA;WACA;WACA;;;;;WCzCA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;WCNA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;;;;WClBA;;WAEA;WACA;WACA;WACA;WACA;WACA;;WAEA;WACA;WACA;WACA,iCAAiC;;WAEjC;WACA;WACA;WACA,KAAK;WACL,eAAe;WACf;WACA;WACA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;;WAEA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA;WACA,MAAM,qBAAqB;WAC3B;WACA;WACA;WACA;WACA;WACA;;WAEA;;WAEA;WACA;WACA;;;;;;;;;;;;;;ACvFA;AACuB;AAE2B;AACQ;;AAE1D;AACyB;AACA;AACQ;AACL;;AAE5B;AACAC,QAAQ,CAACC,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;EAClD;EACA,IAAI,CAACF,0DAAe,CAAC,CAAC,EAAE;IACtBI,OAAO,CAACC,KAAK,CAAC,2CAA2C,CAAC;IAC1D;EACF;;EAEA;EACA,MAAMC,OAAO,GAAGL,QAAQ,CAACM,gBAAgB,CAAC,cAAc,CAAC;EAEzD,IAAI,CAACD,OAAO,CAACE,MAAM,EAAE;IACnBJ,OAAO,CAACC,KAAK,CAAC,iCAAiC,CAAC;IAChD;EACF;;EAEA;;EAKAC,OAAO,CAACG,OAAO,CAAEC,MAAM,IAAK;IAC1B;IACAA,MAAM,CAACR,gBAAgB,CAAC,iBAAiB,EAAE,MAAOS,KAAkB,IAAK;MACvE,MAAMC,QAAQ,GAAGD,KAAK,CAACE,MAA4B;;MAEnD;MACA,IAAID,QAAQ,EAAEE,IAAI,KAAK,KAAK,EAAE;QAC5B;QACAF,QAAQ,CAACG,OAAO,GAAGf,8CAAG,CAAC,CAAC;;QAExB;QACA,MAAMgB,YAAY,GAAGN,MAAM,CAACO,aAAa,CAAC,OAAO,CAAC;QAClD,IAAID,YAAY,EAAE;UAChB;UACA,MAAME,GAAG,GAAG,IAAIlB,8CAAG,CAAC,CAAC;UACrBkB,GAAG,CAACC,WAAW,CAACH,YAAY,CAAC;;UAE7B;UACAE,GAAG,CAACE,EAAE,CAACpB,qDAAU,CAACsB,cAAc,EAAE,MAAM;YACtC;YACA,MAAMC,QAAQ,GAAGP,YAAY,CAACQ,YAAY,CAAC,KAAK,CAAC;YACjD,IAAID,QAAQ,EAAE;cACZL,GAAG,CAACO,UAAU,CAACF,QAAQ,CAAC;;cAExB;cACAL,GAAG,CAACE,EAAE,CAACpB,qDAAU,CAAC0B,eAAe,EAAE,MAAM;gBACvC;gBACAV,YAAY,CAACW,IAAI,CAAC,CAAC;cACrB,CAAC,CAAC;YACJ,CAAC,MAAM;cACLvB,OAAO,CAACC,KAAK,CAAC,wBAAwB,CAAC;YACzC;UACF,CAAC,CAAC;;UAEF;UACAa,GAAG,CAACE,EAAE,CAACpB,qDAAU,CAAC4B,KAAK,EAAE,CAACjB,KAAK,EAAEkB,IAAI,KAAK;YACxCzB,OAAO,CAACC,KAAK,CAAC,eAAe,EAAEwB,IAAI,CAAC;UACtC,CAAC,CAAC;QACJ,CAAC,MAAM;UACLzB,OAAO,CAACC,KAAK,CAAC,yCAAyC,CAAC;QAC1D;MACF;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ,CAAC,CAAC,C","sources":["webpack://rrze-video/./src/front/styles.scss","webpack://rrze-video/./node_modules/@floating-ui/core/dist/floating-ui.core.mjs","webpack://rrze-video/./node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs","webpack://rrze-video/./node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs","webpack://rrze-video/./node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs","webpack://rrze-video/./node_modules/hls.js/dist/hls.mjs","webpack://rrze-video/./node_modules/lit-html/development/async-directive.js","webpack://rrze-video/./node_modules/lit-html/development/directive-helpers.js","webpack://rrze-video/./node_modules/lit-html/development/directive.js","webpack://rrze-video/./node_modules/lit-html/development/directives/if-defined.js","webpack://rrze-video/./node_modules/lit-html/development/directives/keyed.js","webpack://rrze-video/./node_modules/lit-html/development/directives/ref.js","webpack://rrze-video/./node_modules/lit-html/development/directives/unsafe-html.js","webpack://rrze-video/./node_modules/lit-html/development/directives/unsafe-svg.js","webpack://rrze-video/./node_modules/lit-html/development/lit-html.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-3JWzcpEe.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-9MhB-Ya7.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-B5ElR9su.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-BOTZD4tC.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-BgIVvpNy.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-Bpr4fI4n.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-BrQmGphD.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-C1THCRTj.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-CGUlKgT8.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-CK0M3MJg.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-CUYciP40.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-CWb-Pl1C.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-CrZuJYaH.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-CuDKkHai.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-CwTj4H1w.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-DB2Hlarx.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-DUJY8d_d.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-DVpy0IqK.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-DbBJlz7I.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-DghpoXbA.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-Dihypf8P.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-Dn9nMoEW.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-Dv_LIPFu.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-Tte9uVV_.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-U09LnPQC.js","webpack://rrze-video/./node_modules/vidstack/dev/chunks/vidstack-mJNGvZNe.js","webpack://rrze-video/./node_modules/vidstack/dev/define/templates/plyr-layout.js","webpack://rrze-video/./node_modules/vidstack/dev/define/templates/vidstack-audio-layout.js","webpack://rrze-video/./node_modules/vidstack/dev/define/templates/vidstack-video-layout.js","webpack://rrze-video/./node_modules/vidstack/dev/define/vidstack-player-layouts.js","webpack://rrze-video/./node_modules/vidstack/dev/define/vidstack-player-ui.js","webpack://rrze-video/./node_modules/vidstack/dev/define/vidstack-player.js","webpack://rrze-video/webpack/bootstrap","webpack://rrze-video/webpack/runtime/define property getters","webpack://rrze-video/webpack/runtime/ensure chunk","webpack://rrze-video/webpack/runtime/get javascript chunk filename","webpack://rrze-video/webpack/runtime/get mini-css chunk filename","webpack://rrze-video/webpack/runtime/global","webpack://rrze-video/webpack/runtime/hasOwnProperty shorthand","webpack://rrze-video/webpack/runtime/load script","webpack://rrze-video/webpack/runtime/make namespace object","webpack://rrze-video/webpack/runtime/publicPath","webpack://rrze-video/webpack/runtime/jsonp chunk loading","webpack://rrze-video/./src/front/index.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin\nexport {};","import { getSideAxis, getAlignmentAxis, getAxisLength, getSide, getAlignment, evaluate, getPaddingObject, rectToClientRect, min, clamp, placements, getAlignmentSides, getOppositeAlignmentPlacement, getOppositePlacement, getExpandedPlacements, getOppositeAxisPlacements, sides, max, getOppositeAxis } from '@floating-ui/utils';\nexport { rectToClientRect } from '@floating-ui/utils';\n\nfunction computeCoordsFromPlacement(_ref, placement, rtl) {\n  let {\n    reference,\n    floating\n  } = _ref;\n  const sideAxis = getSideAxis(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const alignLength = getAxisLength(alignmentAxis);\n  const side = getSide(placement);\n  const isVertical = sideAxis === 'y';\n  const commonX = reference.x + reference.width / 2 - floating.width / 2;\n  const commonY = reference.y + reference.height / 2 - floating.height / 2;\n  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;\n  let coords;\n  switch (side) {\n    case 'top':\n      coords = {\n        x: commonX,\n        y: reference.y - floating.height\n      };\n      break;\n    case 'bottom':\n      coords = {\n        x: commonX,\n        y: reference.y + reference.height\n      };\n      break;\n    case 'right':\n      coords = {\n        x: reference.x + reference.width,\n        y: commonY\n      };\n      break;\n    case 'left':\n      coords = {\n        x: reference.x - floating.width,\n        y: commonY\n      };\n      break;\n    default:\n      coords = {\n        x: reference.x,\n        y: reference.y\n      };\n  }\n  switch (getAlignment(placement)) {\n    case 'start':\n      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n    case 'end':\n      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);\n      break;\n  }\n  return coords;\n}\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n *\n * This export does not have any `platform` interface logic. You will need to\n * write one for the platform you are using Floating UI with.\n */\nconst computePosition = async (reference, floating, config) => {\n  const {\n    placement = 'bottom',\n    strategy = 'absolute',\n    middleware = [],\n    platform\n  } = config;\n  const validMiddleware = middleware.filter(Boolean);\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));\n  let rects = await platform.getElementRects({\n    reference,\n    floating,\n    strategy\n  });\n  let {\n    x,\n    y\n  } = computeCoordsFromPlacement(rects, placement, rtl);\n  let statefulPlacement = placement;\n  let middlewareData = {};\n  let resetCount = 0;\n  for (let i = 0; i < validMiddleware.length; i++) {\n    const {\n      name,\n      fn\n    } = validMiddleware[i];\n    const {\n      x: nextX,\n      y: nextY,\n      data,\n      reset\n    } = await fn({\n      x,\n      y,\n      initialPlacement: placement,\n      placement: statefulPlacement,\n      strategy,\n      middlewareData,\n      rects,\n      platform,\n      elements: {\n        reference,\n        floating\n      }\n    });\n    x = nextX != null ? nextX : x;\n    y = nextY != null ? nextY : y;\n    middlewareData = {\n      ...middlewareData,\n      [name]: {\n        ...middlewareData[name],\n        ...data\n      }\n    };\n    if (reset && resetCount <= 50) {\n      resetCount++;\n      if (typeof reset === 'object') {\n        if (reset.placement) {\n          statefulPlacement = reset.placement;\n        }\n        if (reset.rects) {\n          rects = reset.rects === true ? await platform.getElementRects({\n            reference,\n            floating,\n            strategy\n          }) : reset.rects;\n        }\n        ({\n          x,\n          y\n        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));\n      }\n      i = -1;\n    }\n  }\n  return {\n    x,\n    y,\n    placement: statefulPlacement,\n    strategy,\n    middlewareData\n  };\n};\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nasync function detectOverflow(state, options) {\n  var _await$platform$isEle;\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    x,\n    y,\n    platform,\n    rects,\n    elements,\n    strategy\n  } = state;\n  const {\n    boundary = 'clippingAncestors',\n    rootBoundary = 'viewport',\n    elementContext = 'floating',\n    altBoundary = false,\n    padding = 0\n  } = evaluate(options, state);\n  const paddingObject = getPaddingObject(padding);\n  const altContext = elementContext === 'floating' ? 'reference' : 'floating';\n  const element = elements[altBoundary ? altContext : elementContext];\n  const clippingClientRect = rectToClientRect(await platform.getClippingRect({\n    element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || (await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating))),\n    boundary,\n    rootBoundary,\n    strategy\n  }));\n  const rect = elementContext === 'floating' ? {\n    x,\n    y,\n    width: rects.floating.width,\n    height: rects.floating.height\n  } : rects.reference;\n  const offsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating));\n  const offsetScale = (await (platform.isElement == null ? void 0 : platform.isElement(offsetParent))) ? (await (platform.getScale == null ? void 0 : platform.getScale(offsetParent))) || {\n    x: 1,\n    y: 1\n  } : {\n    x: 1,\n    y: 1\n  };\n  const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  }) : rect);\n  return {\n    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,\n    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,\n    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,\n    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x\n  };\n}\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = options => ({\n  name: 'arrow',\n  options,\n  async fn(state) {\n    const {\n      x,\n      y,\n      placement,\n      rects,\n      platform,\n      elements,\n      middlewareData\n    } = state;\n    // Since `element` is required, we don't Partial<> the type.\n    const {\n      element,\n      padding = 0\n    } = evaluate(options, state) || {};\n    if (element == null) {\n      return {};\n    }\n    const paddingObject = getPaddingObject(padding);\n    const coords = {\n      x,\n      y\n    };\n    const axis = getAlignmentAxis(placement);\n    const length = getAxisLength(axis);\n    const arrowDimensions = await platform.getDimensions(element);\n    const isYAxis = axis === 'y';\n    const minProp = isYAxis ? 'top' : 'left';\n    const maxProp = isYAxis ? 'bottom' : 'right';\n    const clientProp = isYAxis ? 'clientHeight' : 'clientWidth';\n    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];\n    const startDiff = coords[axis] - rects.reference[axis];\n    const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));\n    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;\n\n    // DOM platform can return `window` as the `offsetParent`.\n    if (!clientSize || !(await (platform.isElement == null ? void 0 : platform.isElement(arrowOffsetParent)))) {\n      clientSize = elements.floating[clientProp] || rects.floating[length];\n    }\n    const centerToReference = endDiff / 2 - startDiff / 2;\n\n    // If the padding is large enough that it causes the arrow to no longer be\n    // centered, modify the padding so that it is centered.\n    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;\n    const minPadding = min(paddingObject[minProp], largestPossiblePadding);\n    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);\n\n    // Make sure the arrow doesn't overflow the floating element if the center\n    // point is outside the floating element's bounds.\n    const min$1 = minPadding;\n    const max = clientSize - arrowDimensions[length] - maxPadding;\n    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;\n    const offset = clamp(min$1, center, max);\n\n    // If the reference is small enough that the arrow's padding causes it to\n    // to point to nothing for an aligned placement, adjust the offset of the\n    // floating element itself. To ensure `shift()` continues to take action,\n    // a single reset is performed when this is true.\n    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;\n    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max : 0;\n    return {\n      [axis]: coords[axis] + alignmentOffset,\n      data: {\n        [axis]: offset,\n        centerOffset: center - offset - alignmentOffset,\n        ...(shouldAddOffset && {\n          alignmentOffset\n        })\n      },\n      reset: shouldAddOffset\n    };\n  }\n});\n\nfunction getPlacementList(alignment, autoAlignment, allowedPlacements) {\n  const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter(placement => getAlignment(placement) === alignment), ...allowedPlacements.filter(placement => getAlignment(placement) !== alignment)] : allowedPlacements.filter(placement => getSide(placement) === placement);\n  return allowedPlacementsSortedByAlignment.filter(placement => {\n    if (alignment) {\n      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);\n    }\n    return true;\n  });\n}\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'autoPlacement',\n    options,\n    async fn(state) {\n      var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE;\n      const {\n        rects,\n        middlewareData,\n        placement,\n        platform,\n        elements\n      } = state;\n      const {\n        crossAxis = false,\n        alignment,\n        allowedPlacements = placements,\n        autoAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const placements$1 = alignment !== undefined || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;\n      const currentPlacement = placements$1[currentIndex];\n      if (currentPlacement == null) {\n        return {};\n      }\n      const alignmentSides = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));\n\n      // Make `computeCoords` start from the right place.\n      if (placement !== currentPlacement) {\n        return {\n          reset: {\n            placement: placements$1[0]\n          }\n        };\n      }\n      const currentOverflows = [overflow[getSide(currentPlacement)], overflow[alignmentSides[0]], overflow[alignmentSides[1]]];\n      const allOverflows = [...(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []), {\n        placement: currentPlacement,\n        overflows: currentOverflows\n      }];\n      const nextPlacement = placements$1[currentIndex + 1];\n\n      // There are more placements to check.\n      if (nextPlacement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: nextPlacement\n          }\n        };\n      }\n      const placementsSortedByMostSpace = allOverflows.map(d => {\n        const alignment = getAlignment(d.placement);\n        return [d.placement, alignment && crossAxis ?\n        // Check along the mainAxis and main crossAxis side.\n        d.overflows.slice(0, 2).reduce((acc, v) => acc + v, 0) :\n        // Check only the mainAxis.\n        d.overflows[0], d.overflows];\n      }).sort((a, b) => a[1] - b[1]);\n      const placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(d => d[2].slice(0,\n      // Aligned placements should not check their opposite crossAxis\n      // side.\n      getAlignment(d[0]) ? 2 : 3).every(v => v <= 0));\n      const resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];\n      if (resetPlacement !== placement) {\n        return {\n          data: {\n            index: currentIndex + 1,\n            overflows: allOverflows\n          },\n          reset: {\n            placement: resetPlacement\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'flip',\n    options,\n    async fn(state) {\n      var _middlewareData$arrow, _middlewareData$flip;\n      const {\n        placement,\n        middlewareData,\n        rects,\n        initialPlacement,\n        platform,\n        elements\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true,\n        fallbackPlacements: specifiedFallbackPlacements,\n        fallbackStrategy = 'bestFit',\n        fallbackAxisSideDirection = 'none',\n        flipAlignment = true,\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n\n      // If a reset by the arrow was caused due to an alignment offset being\n      // added, we should skip any logic now since `flip()` has already done its\n      // work.\n      // https://github.com/floating-ui/floating-ui/issues/2549#issuecomment-1719601643\n      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      const side = getSide(placement);\n      const initialSideAxis = getSideAxis(initialPlacement);\n      const isBasePlacement = getSide(initialPlacement) === initialPlacement;\n      const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));\n      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== 'none';\n      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {\n        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));\n      }\n      const placements = [initialPlacement, ...fallbackPlacements];\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const overflows = [];\n      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];\n      if (checkMainAxis) {\n        overflows.push(overflow[side]);\n      }\n      if (checkCrossAxis) {\n        const sides = getAlignmentSides(placement, rects, rtl);\n        overflows.push(overflow[sides[0]], overflow[sides[1]]);\n      }\n      overflowsData = [...overflowsData, {\n        placement,\n        overflows\n      }];\n\n      // One or more sides is overflowing.\n      if (!overflows.every(side => side <= 0)) {\n        var _middlewareData$flip2, _overflowsData$filter;\n        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;\n        const nextPlacement = placements[nextIndex];\n        if (nextPlacement) {\n          // Try next placement and re-run the lifecycle.\n          return {\n            data: {\n              index: nextIndex,\n              overflows: overflowsData\n            },\n            reset: {\n              placement: nextPlacement\n            }\n          };\n        }\n\n        // First, find the candidates that fit on the mainAxis side of overflow,\n        // then find the placement that fits the best on the main crossAxis side.\n        let resetPlacement = (_overflowsData$filter = overflowsData.filter(d => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;\n\n        // Otherwise fallback.\n        if (!resetPlacement) {\n          switch (fallbackStrategy) {\n            case 'bestFit':\n              {\n                var _overflowsData$filter2;\n                const placement = (_overflowsData$filter2 = overflowsData.filter(d => {\n                  if (hasFallbackAxisSideDirection) {\n                    const currentSideAxis = getSideAxis(d.placement);\n                    return currentSideAxis === initialSideAxis ||\n                    // Create a bias to the `y` side axis due to horizontal\n                    // reading directions favoring greater width.\n                    currentSideAxis === 'y';\n                  }\n                  return true;\n                }).map(d => [d.placement, d.overflows.filter(overflow => overflow > 0).reduce((acc, overflow) => acc + overflow, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$filter2[0];\n                if (placement) {\n                  resetPlacement = placement;\n                }\n                break;\n              }\n            case 'initialPlacement':\n              resetPlacement = initialPlacement;\n              break;\n          }\n        }\n        if (placement !== resetPlacement) {\n          return {\n            reset: {\n              placement: resetPlacement\n            }\n          };\n        }\n      }\n      return {};\n    }\n  };\n};\n\nfunction getSideOffsets(overflow, rect) {\n  return {\n    top: overflow.top - rect.height,\n    right: overflow.right - rect.width,\n    bottom: overflow.bottom - rect.height,\n    left: overflow.left - rect.width\n  };\n}\nfunction isAnySideFullyClipped(overflow) {\n  return sides.some(side => overflow[side] >= 0);\n}\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'hide',\n    options,\n    async fn(state) {\n      const {\n        rects\n      } = state;\n      const {\n        strategy = 'referenceHidden',\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      switch (strategy) {\n        case 'referenceHidden':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              elementContext: 'reference'\n            });\n            const offsets = getSideOffsets(overflow, rects.reference);\n            return {\n              data: {\n                referenceHiddenOffsets: offsets,\n                referenceHidden: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        case 'escaped':\n          {\n            const overflow = await detectOverflow(state, {\n              ...detectOverflowOptions,\n              altBoundary: true\n            });\n            const offsets = getSideOffsets(overflow, rects.floating);\n            return {\n              data: {\n                escapedOffsets: offsets,\n                escaped: isAnySideFullyClipped(offsets)\n              }\n            };\n          }\n        default:\n          {\n            return {};\n          }\n      }\n    }\n  };\n};\n\nfunction getBoundingRect(rects) {\n  const minX = min(...rects.map(rect => rect.left));\n  const minY = min(...rects.map(rect => rect.top));\n  const maxX = max(...rects.map(rect => rect.right));\n  const maxY = max(...rects.map(rect => rect.bottom));\n  return {\n    x: minX,\n    y: minY,\n    width: maxX - minX,\n    height: maxY - minY\n  };\n}\nfunction getRectsByLine(rects) {\n  const sortedRects = rects.slice().sort((a, b) => a.y - b.y);\n  const groups = [];\n  let prevRect = null;\n  for (let i = 0; i < sortedRects.length; i++) {\n    const rect = sortedRects[i];\n    if (!prevRect || rect.y - prevRect.y > prevRect.height / 2) {\n      groups.push([rect]);\n    } else {\n      groups[groups.length - 1].push(rect);\n    }\n    prevRect = rect;\n  }\n  return groups.map(rect => rectToClientRect(getBoundingRect(rect)));\n}\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'inline',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        elements,\n        rects,\n        platform,\n        strategy\n      } = state;\n      // A MouseEvent's client{X,Y} coords can be up to 2 pixels off a\n      // ClientRect's bounds, despite the event listener being triggered. A\n      // padding of 2 seems to handle this issue.\n      const {\n        padding = 2,\n        x,\n        y\n      } = evaluate(options, state);\n      const nativeClientRects = Array.from((await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) || []);\n      const clientRects = getRectsByLine(nativeClientRects);\n      const fallback = rectToClientRect(getBoundingRect(nativeClientRects));\n      const paddingObject = getPaddingObject(padding);\n      function getBoundingClientRect() {\n        // There are two rects and they are disjoined.\n        if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {\n          // Find the first rect in which the point is fully inside.\n          return clientRects.find(rect => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom) || fallback;\n        }\n\n        // There are 2 or more connected rects.\n        if (clientRects.length >= 2) {\n          if (getSideAxis(placement) === 'y') {\n            const firstRect = clientRects[0];\n            const lastRect = clientRects[clientRects.length - 1];\n            const isTop = getSide(placement) === 'top';\n            const top = firstRect.top;\n            const bottom = lastRect.bottom;\n            const left = isTop ? firstRect.left : lastRect.left;\n            const right = isTop ? firstRect.right : lastRect.right;\n            const width = right - left;\n            const height = bottom - top;\n            return {\n              top,\n              bottom,\n              left,\n              right,\n              width,\n              height,\n              x: left,\n              y: top\n            };\n          }\n          const isLeftSide = getSide(placement) === 'left';\n          const maxRight = max(...clientRects.map(rect => rect.right));\n          const minLeft = min(...clientRects.map(rect => rect.left));\n          const measureRects = clientRects.filter(rect => isLeftSide ? rect.left === minLeft : rect.right === maxRight);\n          const top = measureRects[0].top;\n          const bottom = measureRects[measureRects.length - 1].bottom;\n          const left = minLeft;\n          const right = maxRight;\n          const width = right - left;\n          const height = bottom - top;\n          return {\n            top,\n            bottom,\n            left,\n            right,\n            width,\n            height,\n            x: left,\n            y: top\n          };\n        }\n        return fallback;\n      }\n      const resetRects = await platform.getElementRects({\n        reference: {\n          getBoundingClientRect\n        },\n        floating: elements.floating,\n        strategy\n      });\n      if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {\n        return {\n          reset: {\n            rects: resetRects\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\n// For type backwards-compatibility, the `OffsetOptions` type was also\n// Derivable.\n\nasync function convertValueToCoords(state, options) {\n  const {\n    placement,\n    platform,\n    elements\n  } = state;\n  const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));\n  const side = getSide(placement);\n  const alignment = getAlignment(placement);\n  const isVertical = getSideAxis(placement) === 'y';\n  const mainAxisMulti = ['left', 'top'].includes(side) ? -1 : 1;\n  const crossAxisMulti = rtl && isVertical ? -1 : 1;\n  const rawValue = evaluate(options, state);\n\n  // eslint-disable-next-line prefer-const\n  let {\n    mainAxis,\n    crossAxis,\n    alignmentAxis\n  } = typeof rawValue === 'number' ? {\n    mainAxis: rawValue,\n    crossAxis: 0,\n    alignmentAxis: null\n  } : {\n    mainAxis: 0,\n    crossAxis: 0,\n    alignmentAxis: null,\n    ...rawValue\n  };\n  if (alignment && typeof alignmentAxis === 'number') {\n    crossAxis = alignment === 'end' ? alignmentAxis * -1 : alignmentAxis;\n  }\n  return isVertical ? {\n    x: crossAxis * crossAxisMulti,\n    y: mainAxis * mainAxisMulti\n  } : {\n    x: mainAxis * mainAxisMulti,\n    y: crossAxis * crossAxisMulti\n  };\n}\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = function (options) {\n  if (options === void 0) {\n    options = 0;\n  }\n  return {\n    name: 'offset',\n    options,\n    async fn(state) {\n      var _middlewareData$offse, _middlewareData$arrow;\n      const {\n        x,\n        y,\n        placement,\n        middlewareData\n      } = state;\n      const diffCoords = await convertValueToCoords(state, options);\n\n      // If the placement is the same and the arrow caused an alignment offset\n      // then we don't need to change the positioning coordinates.\n      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {\n        return {};\n      }\n      return {\n        x: x + diffCoords.x,\n        y: y + diffCoords.y,\n        data: {\n          ...diffCoords,\n          placement\n        }\n      };\n    }\n  };\n};\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'shift',\n    options,\n    async fn(state) {\n      const {\n        x,\n        y,\n        placement\n      } = state;\n      const {\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = false,\n        limiter = {\n          fn: _ref => {\n            let {\n              x,\n              y\n            } = _ref;\n            return {\n              x,\n              y\n            };\n          }\n        },\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const crossAxis = getSideAxis(getSide(placement));\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      if (checkMainAxis) {\n        const minSide = mainAxis === 'y' ? 'top' : 'left';\n        const maxSide = mainAxis === 'y' ? 'bottom' : 'right';\n        const min = mainAxisCoord + overflow[minSide];\n        const max = mainAxisCoord - overflow[maxSide];\n        mainAxisCoord = clamp(min, mainAxisCoord, max);\n      }\n      if (checkCrossAxis) {\n        const minSide = crossAxis === 'y' ? 'top' : 'left';\n        const maxSide = crossAxis === 'y' ? 'bottom' : 'right';\n        const min = crossAxisCoord + overflow[minSide];\n        const max = crossAxisCoord - overflow[maxSide];\n        crossAxisCoord = clamp(min, crossAxisCoord, max);\n      }\n      const limitedCoords = limiter.fn({\n        ...state,\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      });\n      return {\n        ...limitedCoords,\n        data: {\n          x: limitedCoords.x - x,\n          y: limitedCoords.y - y\n        }\n      };\n    }\n  };\n};\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    options,\n    fn(state) {\n      const {\n        x,\n        y,\n        placement,\n        rects,\n        middlewareData\n      } = state;\n      const {\n        offset = 0,\n        mainAxis: checkMainAxis = true,\n        crossAxis: checkCrossAxis = true\n      } = evaluate(options, state);\n      const coords = {\n        x,\n        y\n      };\n      const crossAxis = getSideAxis(placement);\n      const mainAxis = getOppositeAxis(crossAxis);\n      let mainAxisCoord = coords[mainAxis];\n      let crossAxisCoord = coords[crossAxis];\n      const rawOffset = evaluate(offset, state);\n      const computedOffset = typeof rawOffset === 'number' ? {\n        mainAxis: rawOffset,\n        crossAxis: 0\n      } : {\n        mainAxis: 0,\n        crossAxis: 0,\n        ...rawOffset\n      };\n      if (checkMainAxis) {\n        const len = mainAxis === 'y' ? 'height' : 'width';\n        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;\n        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;\n        if (mainAxisCoord < limitMin) {\n          mainAxisCoord = limitMin;\n        } else if (mainAxisCoord > limitMax) {\n          mainAxisCoord = limitMax;\n        }\n      }\n      if (checkCrossAxis) {\n        var _middlewareData$offse, _middlewareData$offse2;\n        const len = mainAxis === 'y' ? 'width' : 'height';\n        const isOriginSide = ['top', 'left'].includes(getSide(placement));\n        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);\n        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);\n        if (crossAxisCoord < limitMin) {\n          crossAxisCoord = limitMin;\n        } else if (crossAxisCoord > limitMax) {\n          crossAxisCoord = limitMax;\n        }\n      }\n      return {\n        [mainAxis]: mainAxisCoord,\n        [crossAxis]: crossAxisCoord\n      };\n    }\n  };\n};\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = function (options) {\n  if (options === void 0) {\n    options = {};\n  }\n  return {\n    name: 'size',\n    options,\n    async fn(state) {\n      const {\n        placement,\n        rects,\n        platform,\n        elements\n      } = state;\n      const {\n        apply = () => {},\n        ...detectOverflowOptions\n      } = evaluate(options, state);\n      const overflow = await detectOverflow(state, detectOverflowOptions);\n      const side = getSide(placement);\n      const alignment = getAlignment(placement);\n      const isYAxis = getSideAxis(placement) === 'y';\n      const {\n        width,\n        height\n      } = rects.floating;\n      let heightSide;\n      let widthSide;\n      if (side === 'top' || side === 'bottom') {\n        heightSide = side;\n        widthSide = alignment === ((await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating))) ? 'start' : 'end') ? 'left' : 'right';\n      } else {\n        widthSide = side;\n        heightSide = alignment === 'end' ? 'top' : 'bottom';\n      }\n      const maximumClippingHeight = height - overflow.top - overflow.bottom;\n      const maximumClippingWidth = width - overflow.left - overflow.right;\n      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);\n      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);\n      const noShift = !state.middlewareData.shift;\n      let availableHeight = overflowAvailableHeight;\n      let availableWidth = overflowAvailableWidth;\n      if (isYAxis) {\n        availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;\n      } else {\n        availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;\n      }\n      if (noShift && !alignment) {\n        const xMin = max(overflow.left, 0);\n        const xMax = max(overflow.right, 0);\n        const yMin = max(overflow.top, 0);\n        const yMax = max(overflow.bottom, 0);\n        if (isYAxis) {\n          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));\n        } else {\n          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));\n        }\n      }\n      await apply({\n        ...state,\n        availableWidth,\n        availableHeight\n      });\n      const nextDimensions = await platform.getDimensions(elements.floating);\n      if (width !== nextDimensions.width || height !== nextDimensions.height) {\n        return {\n          reset: {\n            rects: true\n          }\n        };\n      }\n      return {};\n    }\n  };\n};\n\nexport { arrow, autoPlacement, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, shift, size };\n","import { rectToClientRect, detectOverflow as detectOverflow$1, offset as offset$1, autoPlacement as autoPlacement$1, shift as shift$1, flip as flip$1, size as size$1, hide as hide$1, arrow as arrow$1, inline as inline$1, limitShift as limitShift$1, computePosition as computePosition$1 } from '@floating-ui/core';\nimport { round, createCoords, max, min, floor } from '@floating-ui/utils';\nimport { getComputedStyle, isHTMLElement, isElement, getWindow, isWebKit, getFrameElement, getDocumentElement, isTopLayer, getNodeName, isOverflowElement, getNodeScroll, getOverflowAncestors, getParentNode, isLastTraversableNode, isContainingBlock, isTableElement, getContainingBlock } from '@floating-ui/utils/dom';\nexport { getOverflowAncestors } from '@floating-ui/utils/dom';\n\nfunction getCssDimensions(element) {\n  const css = getComputedStyle(element);\n  // In testing environments, the `width` and `height` properties are empty\n  // strings for SVG elements, returning NaN. Fallback to `0` in this case.\n  let width = parseFloat(css.width) || 0;\n  let height = parseFloat(css.height) || 0;\n  const hasOffset = isHTMLElement(element);\n  const offsetWidth = hasOffset ? element.offsetWidth : width;\n  const offsetHeight = hasOffset ? element.offsetHeight : height;\n  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;\n  if (shouldFallback) {\n    width = offsetWidth;\n    height = offsetHeight;\n  }\n  return {\n    width,\n    height,\n    $: shouldFallback\n  };\n}\n\nfunction unwrapElement(element) {\n  return !isElement(element) ? element.contextElement : element;\n}\n\nfunction getScale(element) {\n  const domElement = unwrapElement(element);\n  if (!isHTMLElement(domElement)) {\n    return createCoords(1);\n  }\n  const rect = domElement.getBoundingClientRect();\n  const {\n    width,\n    height,\n    $\n  } = getCssDimensions(domElement);\n  let x = ($ ? round(rect.width) : rect.width) / width;\n  let y = ($ ? round(rect.height) : rect.height) / height;\n\n  // 0, NaN, or Infinity should always fallback to 1.\n\n  if (!x || !Number.isFinite(x)) {\n    x = 1;\n  }\n  if (!y || !Number.isFinite(y)) {\n    y = 1;\n  }\n  return {\n    x,\n    y\n  };\n}\n\nconst noOffsets = /*#__PURE__*/createCoords(0);\nfunction getVisualOffsets(element) {\n  const win = getWindow(element);\n  if (!isWebKit() || !win.visualViewport) {\n    return noOffsets;\n  }\n  return {\n    x: win.visualViewport.offsetLeft,\n    y: win.visualViewport.offsetTop\n  };\n}\nfunction shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {\n  if (isFixed === void 0) {\n    isFixed = false;\n  }\n  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {\n    return false;\n  }\n  return isFixed;\n}\n\nfunction getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {\n  if (includeScale === void 0) {\n    includeScale = false;\n  }\n  if (isFixedStrategy === void 0) {\n    isFixedStrategy = false;\n  }\n  const clientRect = element.getBoundingClientRect();\n  const domElement = unwrapElement(element);\n  let scale = createCoords(1);\n  if (includeScale) {\n    if (offsetParent) {\n      if (isElement(offsetParent)) {\n        scale = getScale(offsetParent);\n      }\n    } else {\n      scale = getScale(element);\n    }\n  }\n  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);\n  let x = (clientRect.left + visualOffsets.x) / scale.x;\n  let y = (clientRect.top + visualOffsets.y) / scale.y;\n  let width = clientRect.width / scale.x;\n  let height = clientRect.height / scale.y;\n  if (domElement) {\n    const win = getWindow(domElement);\n    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;\n    let currentWin = win;\n    let currentIFrame = getFrameElement(currentWin);\n    while (currentIFrame && offsetParent && offsetWin !== currentWin) {\n      const iframeScale = getScale(currentIFrame);\n      const iframeRect = currentIFrame.getBoundingClientRect();\n      const css = getComputedStyle(currentIFrame);\n      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;\n      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;\n      x *= iframeScale.x;\n      y *= iframeScale.y;\n      width *= iframeScale.x;\n      height *= iframeScale.y;\n      x += left;\n      y += top;\n      currentWin = getWindow(currentIFrame);\n      currentIFrame = getFrameElement(currentWin);\n    }\n  }\n  return rectToClientRect({\n    width,\n    height,\n    x,\n    y\n  });\n}\n\nfunction convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {\n  let {\n    elements,\n    rect,\n    offsetParent,\n    strategy\n  } = _ref;\n  const isFixed = strategy === 'fixed';\n  const documentElement = getDocumentElement(offsetParent);\n  const topLayer = elements ? isTopLayer(elements.floating) : false;\n  if (offsetParent === documentElement || topLayer && isFixed) {\n    return rect;\n  }\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  let scale = createCoords(1);\n  const offsets = createCoords(0);\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isHTMLElement(offsetParent)) {\n      const offsetRect = getBoundingClientRect(offsetParent);\n      scale = getScale(offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    }\n  }\n  return {\n    width: rect.width * scale.x,\n    height: rect.height * scale.y,\n    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,\n    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y\n  };\n}\n\nfunction getClientRects(element) {\n  return Array.from(element.getClientRects());\n}\n\nfunction getWindowScrollBarX(element) {\n  // If <html> has a CSS width greater than the viewport, then this will be\n  // incorrect for RTL.\n  return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;\n}\n\n// Gets the entire size of the scrollable document area, even extending outside\n// of the `<html>` and `<body>` rect bounds if horizontally scrollable.\nfunction getDocumentRect(element) {\n  const html = getDocumentElement(element);\n  const scroll = getNodeScroll(element);\n  const body = element.ownerDocument.body;\n  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);\n  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);\n  let x = -scroll.scrollLeft + getWindowScrollBarX(element);\n  const y = -scroll.scrollTop;\n  if (getComputedStyle(body).direction === 'rtl') {\n    x += max(html.clientWidth, body.clientWidth) - width;\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\nfunction getViewportRect(element, strategy) {\n  const win = getWindow(element);\n  const html = getDocumentElement(element);\n  const visualViewport = win.visualViewport;\n  let width = html.clientWidth;\n  let height = html.clientHeight;\n  let x = 0;\n  let y = 0;\n  if (visualViewport) {\n    width = visualViewport.width;\n    height = visualViewport.height;\n    const visualViewportBased = isWebKit();\n    if (!visualViewportBased || visualViewportBased && strategy === 'fixed') {\n      x = visualViewport.offsetLeft;\n      y = visualViewport.offsetTop;\n    }\n  }\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\n\n// Returns the inner client rect, subtracting scrollbars if present.\nfunction getInnerBoundingClientRect(element, strategy) {\n  const clientRect = getBoundingClientRect(element, true, strategy === 'fixed');\n  const top = clientRect.top + element.clientTop;\n  const left = clientRect.left + element.clientLeft;\n  const scale = isHTMLElement(element) ? getScale(element) : createCoords(1);\n  const width = element.clientWidth * scale.x;\n  const height = element.clientHeight * scale.y;\n  const x = left * scale.x;\n  const y = top * scale.y;\n  return {\n    width,\n    height,\n    x,\n    y\n  };\n}\nfunction getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {\n  let rect;\n  if (clippingAncestor === 'viewport') {\n    rect = getViewportRect(element, strategy);\n  } else if (clippingAncestor === 'document') {\n    rect = getDocumentRect(getDocumentElement(element));\n  } else if (isElement(clippingAncestor)) {\n    rect = getInnerBoundingClientRect(clippingAncestor, strategy);\n  } else {\n    const visualOffsets = getVisualOffsets(element);\n    rect = {\n      ...clippingAncestor,\n      x: clippingAncestor.x - visualOffsets.x,\n      y: clippingAncestor.y - visualOffsets.y\n    };\n  }\n  return rectToClientRect(rect);\n}\nfunction hasFixedPositionAncestor(element, stopNode) {\n  const parentNode = getParentNode(element);\n  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {\n    return false;\n  }\n  return getComputedStyle(parentNode).position === 'fixed' || hasFixedPositionAncestor(parentNode, stopNode);\n}\n\n// A \"clipping ancestor\" is an `overflow` element with the characteristic of\n// clipping (or hiding) child elements. This returns all clipping ancestors\n// of the given element up the tree.\nfunction getClippingElementAncestors(element, cache) {\n  const cachedResult = cache.get(element);\n  if (cachedResult) {\n    return cachedResult;\n  }\n  let result = getOverflowAncestors(element, [], false).filter(el => isElement(el) && getNodeName(el) !== 'body');\n  let currentContainingBlockComputedStyle = null;\n  const elementIsFixed = getComputedStyle(element).position === 'fixed';\n  let currentNode = elementIsFixed ? getParentNode(element) : element;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    const computedStyle = getComputedStyle(currentNode);\n    const currentNodeIsContaining = isContainingBlock(currentNode);\n    if (!currentNodeIsContaining && computedStyle.position === 'fixed') {\n      currentContainingBlockComputedStyle = null;\n    }\n    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === 'static' && !!currentContainingBlockComputedStyle && ['absolute', 'fixed'].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);\n    if (shouldDropCurrentNode) {\n      // Drop non-containing blocks.\n      result = result.filter(ancestor => ancestor !== currentNode);\n    } else {\n      // Record last containing block for next iteration.\n      currentContainingBlockComputedStyle = computedStyle;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  cache.set(element, result);\n  return result;\n}\n\n// Gets the maximum area that the element is visible in due to any number of\n// clipping ancestors.\nfunction getClippingRect(_ref) {\n  let {\n    element,\n    boundary,\n    rootBoundary,\n    strategy\n  } = _ref;\n  const elementClippingAncestors = boundary === 'clippingAncestors' ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);\n  const clippingAncestors = [...elementClippingAncestors, rootBoundary];\n  const firstClippingAncestor = clippingAncestors[0];\n  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {\n    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);\n    accRect.top = max(rect.top, accRect.top);\n    accRect.right = min(rect.right, accRect.right);\n    accRect.bottom = min(rect.bottom, accRect.bottom);\n    accRect.left = max(rect.left, accRect.left);\n    return accRect;\n  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));\n  return {\n    width: clippingRect.right - clippingRect.left,\n    height: clippingRect.bottom - clippingRect.top,\n    x: clippingRect.left,\n    y: clippingRect.top\n  };\n}\n\nfunction getDimensions(element) {\n  const {\n    width,\n    height\n  } = getCssDimensions(element);\n  return {\n    width,\n    height\n  };\n}\n\nfunction getRectRelativeToOffsetParent(element, offsetParent, strategy) {\n  const isOffsetParentAnElement = isHTMLElement(offsetParent);\n  const documentElement = getDocumentElement(offsetParent);\n  const isFixed = strategy === 'fixed';\n  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);\n  let scroll = {\n    scrollLeft: 0,\n    scrollTop: 0\n  };\n  const offsets = createCoords(0);\n  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n    if (getNodeName(offsetParent) !== 'body' || isOverflowElement(documentElement)) {\n      scroll = getNodeScroll(offsetParent);\n    }\n    if (isOffsetParentAnElement) {\n      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);\n      offsets.x = offsetRect.x + offsetParent.clientLeft;\n      offsets.y = offsetRect.y + offsetParent.clientTop;\n    } else if (documentElement) {\n      offsets.x = getWindowScrollBarX(documentElement);\n    }\n  }\n  const x = rect.left + scroll.scrollLeft - offsets.x;\n  const y = rect.top + scroll.scrollTop - offsets.y;\n  return {\n    x,\n    y,\n    width: rect.width,\n    height: rect.height\n  };\n}\n\nfunction isStaticPositioned(element) {\n  return getComputedStyle(element).position === 'static';\n}\n\nfunction getTrueOffsetParent(element, polyfill) {\n  if (!isHTMLElement(element) || getComputedStyle(element).position === 'fixed') {\n    return null;\n  }\n  if (polyfill) {\n    return polyfill(element);\n  }\n  return element.offsetParent;\n}\n\n// Gets the closest ancestor positioned element. Handles some edge cases,\n// such as table ancestors and cross browser bugs.\nfunction getOffsetParent(element, polyfill) {\n  const win = getWindow(element);\n  if (isTopLayer(element)) {\n    return win;\n  }\n  if (!isHTMLElement(element)) {\n    let svgOffsetParent = getParentNode(element);\n    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {\n      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {\n        return svgOffsetParent;\n      }\n      svgOffsetParent = getParentNode(svgOffsetParent);\n    }\n    return win;\n  }\n  let offsetParent = getTrueOffsetParent(element, polyfill);\n  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {\n    offsetParent = getTrueOffsetParent(offsetParent, polyfill);\n  }\n  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {\n    return win;\n  }\n  return offsetParent || getContainingBlock(element) || win;\n}\n\nconst getElementRects = async function (data) {\n  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;\n  const getDimensionsFn = this.getDimensions;\n  const floatingDimensions = await getDimensionsFn(data.floating);\n  return {\n    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),\n    floating: {\n      x: 0,\n      y: 0,\n      width: floatingDimensions.width,\n      height: floatingDimensions.height\n    }\n  };\n};\n\nfunction isRTL(element) {\n  return getComputedStyle(element).direction === 'rtl';\n}\n\nconst platform = {\n  convertOffsetParentRelativeRectToViewportRelativeRect,\n  getDocumentElement,\n  getClippingRect,\n  getOffsetParent,\n  getElementRects,\n  getClientRects,\n  getDimensions,\n  getScale,\n  isElement,\n  isRTL\n};\n\n// https://samthor.au/2021/observing-dom/\nfunction observeMove(element, onMove) {\n  let io = null;\n  let timeoutId;\n  const root = getDocumentElement(element);\n  function cleanup() {\n    var _io;\n    clearTimeout(timeoutId);\n    (_io = io) == null || _io.disconnect();\n    io = null;\n  }\n  function refresh(skip, threshold) {\n    if (skip === void 0) {\n      skip = false;\n    }\n    if (threshold === void 0) {\n      threshold = 1;\n    }\n    cleanup();\n    const {\n      left,\n      top,\n      width,\n      height\n    } = element.getBoundingClientRect();\n    if (!skip) {\n      onMove();\n    }\n    if (!width || !height) {\n      return;\n    }\n    const insetTop = floor(top);\n    const insetRight = floor(root.clientWidth - (left + width));\n    const insetBottom = floor(root.clientHeight - (top + height));\n    const insetLeft = floor(left);\n    const rootMargin = -insetTop + \"px \" + -insetRight + \"px \" + -insetBottom + \"px \" + -insetLeft + \"px\";\n    const options = {\n      rootMargin,\n      threshold: max(0, min(1, threshold)) || 1\n    };\n    let isFirstUpdate = true;\n    function handleObserve(entries) {\n      const ratio = entries[0].intersectionRatio;\n      if (ratio !== threshold) {\n        if (!isFirstUpdate) {\n          return refresh();\n        }\n        if (!ratio) {\n          // If the reference is clipped, the ratio is 0. Throttle the refresh\n          // to prevent an infinite loop of updates.\n          timeoutId = setTimeout(() => {\n            refresh(false, 1e-7);\n          }, 1000);\n        } else {\n          refresh(false, ratio);\n        }\n      }\n      isFirstUpdate = false;\n    }\n\n    // Older browsers don't support a `document` as the root and will throw an\n    // error.\n    try {\n      io = new IntersectionObserver(handleObserve, {\n        ...options,\n        // Handle <iframe>s\n        root: root.ownerDocument\n      });\n    } catch (e) {\n      io = new IntersectionObserver(handleObserve, options);\n    }\n    io.observe(element);\n  }\n  refresh(true);\n  return cleanup;\n}\n\n/**\n * Automatically updates the position of the floating element when necessary.\n * Should only be called when the floating element is mounted on the DOM or\n * visible on the screen.\n * @returns cleanup function that should be invoked when the floating element is\n * removed from the DOM or hidden from the screen.\n * @see https://floating-ui.com/docs/autoUpdate\n */\nfunction autoUpdate(reference, floating, update, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  const {\n    ancestorScroll = true,\n    ancestorResize = true,\n    elementResize = typeof ResizeObserver === 'function',\n    layoutShift = typeof IntersectionObserver === 'function',\n    animationFrame = false\n  } = options;\n  const referenceEl = unwrapElement(reference);\n  const ancestors = ancestorScroll || ancestorResize ? [...(referenceEl ? getOverflowAncestors(referenceEl) : []), ...getOverflowAncestors(floating)] : [];\n  ancestors.forEach(ancestor => {\n    ancestorScroll && ancestor.addEventListener('scroll', update, {\n      passive: true\n    });\n    ancestorResize && ancestor.addEventListener('resize', update);\n  });\n  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;\n  let reobserveFrame = -1;\n  let resizeObserver = null;\n  if (elementResize) {\n    resizeObserver = new ResizeObserver(_ref => {\n      let [firstEntry] = _ref;\n      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {\n        // Prevent update loops when using the `size` middleware.\n        // https://github.com/floating-ui/floating-ui/issues/1740\n        resizeObserver.unobserve(floating);\n        cancelAnimationFrame(reobserveFrame);\n        reobserveFrame = requestAnimationFrame(() => {\n          var _resizeObserver;\n          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);\n        });\n      }\n      update();\n    });\n    if (referenceEl && !animationFrame) {\n      resizeObserver.observe(referenceEl);\n    }\n    resizeObserver.observe(floating);\n  }\n  let frameId;\n  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;\n  if (animationFrame) {\n    frameLoop();\n  }\n  function frameLoop() {\n    const nextRefRect = getBoundingClientRect(reference);\n    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {\n      update();\n    }\n    prevRefRect = nextRefRect;\n    frameId = requestAnimationFrame(frameLoop);\n  }\n  update();\n  return () => {\n    var _resizeObserver2;\n    ancestors.forEach(ancestor => {\n      ancestorScroll && ancestor.removeEventListener('scroll', update);\n      ancestorResize && ancestor.removeEventListener('resize', update);\n    });\n    cleanupIo == null || cleanupIo();\n    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();\n    resizeObserver = null;\n    if (animationFrame) {\n      cancelAnimationFrame(frameId);\n    }\n  };\n}\n\n/**\n * Resolves with an object of overflow side offsets that determine how much the\n * element is overflowing a given clipping boundary on each side.\n * - positive = overflowing the boundary by that number of pixels\n * - negative = how many pixels left before it will overflow\n * - 0 = lies flush with the boundary\n * @see https://floating-ui.com/docs/detectOverflow\n */\nconst detectOverflow = detectOverflow$1;\n\n/**\n * Modifies the placement by translating the floating element along the\n * specified axes.\n * A number (shorthand for `mainAxis` or distance), or an axes configuration\n * object may be passed.\n * @see https://floating-ui.com/docs/offset\n */\nconst offset = offset$1;\n\n/**\n * Optimizes the visibility of the floating element by choosing the placement\n * that has the most space available automatically, without needing to specify a\n * preferred placement. Alternative to `flip`.\n * @see https://floating-ui.com/docs/autoPlacement\n */\nconst autoPlacement = autoPlacement$1;\n\n/**\n * Optimizes the visibility of the floating element by shifting it in order to\n * keep it in view when it will overflow the clipping boundary.\n * @see https://floating-ui.com/docs/shift\n */\nconst shift = shift$1;\n\n/**\n * Optimizes the visibility of the floating element by flipping the `placement`\n * in order to keep it in view when the preferred placement(s) will overflow the\n * clipping boundary. Alternative to `autoPlacement`.\n * @see https://floating-ui.com/docs/flip\n */\nconst flip = flip$1;\n\n/**\n * Provides data that allows you to change the size of the floating element \n * for instance, prevent it from overflowing the clipping boundary or match the\n * width of the reference element.\n * @see https://floating-ui.com/docs/size\n */\nconst size = size$1;\n\n/**\n * Provides data to hide the floating element in applicable situations, such as\n * when it is not in the same clipping context as the reference element.\n * @see https://floating-ui.com/docs/hide\n */\nconst hide = hide$1;\n\n/**\n * Provides data to position an inner element of the floating element so that it\n * appears centered to the reference element.\n * @see https://floating-ui.com/docs/arrow\n */\nconst arrow = arrow$1;\n\n/**\n * Provides improved positioning for inline reference elements that can span\n * over multiple lines, such as hyperlinks or range selections.\n * @see https://floating-ui.com/docs/inline\n */\nconst inline = inline$1;\n\n/**\n * Built-in `limiter` that will stop `shift()` at a certain point.\n */\nconst limitShift = limitShift$1;\n\n/**\n * Computes the `x` and `y` coordinates that will place the floating element\n * next to a given reference element.\n */\nconst computePosition = (reference, floating, options) => {\n  // This caches the expensive `getClippingElementAncestors` function so that\n  // multiple lifecycle resets re-use the same result. It only lives for a\n  // single call. If other functions become expensive, we can add them as well.\n  const cache = new Map();\n  const mergedOptions = {\n    platform,\n    ...options\n  };\n  const platformWithCache = {\n    ...mergedOptions.platform,\n    _c: cache\n  };\n  return computePosition$1(reference, floating, {\n    ...mergedOptions,\n    platform: platformWithCache\n  });\n};\n\nexport { arrow, autoPlacement, autoUpdate, computePosition, detectOverflow, flip, hide, inline, limitShift, offset, platform, shift, size };\n","function getNodeName(node) {\n  if (isNode(node)) {\n    return (node.nodeName || '').toLowerCase();\n  }\n  // Mocked nodes in testing environments may not be instances of Node. By\n  // returning `#document` an infinite loop won't occur.\n  // https://github.com/floating-ui/floating-ui/issues/2317\n  return '#document';\n}\nfunction getWindow(node) {\n  var _node$ownerDocument;\n  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;\n}\nfunction getDocumentElement(node) {\n  var _ref;\n  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;\n}\nfunction isNode(value) {\n  return value instanceof Node || value instanceof getWindow(value).Node;\n}\nfunction isElement(value) {\n  return value instanceof Element || value instanceof getWindow(value).Element;\n}\nfunction isHTMLElement(value) {\n  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;\n}\nfunction isShadowRoot(value) {\n  // Browsers without `ShadowRoot` support.\n  if (typeof ShadowRoot === 'undefined') {\n    return false;\n  }\n  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;\n}\nfunction isOverflowElement(element) {\n  const {\n    overflow,\n    overflowX,\n    overflowY,\n    display\n  } = getComputedStyle(element);\n  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !['inline', 'contents'].includes(display);\n}\nfunction isTableElement(element) {\n  return ['table', 'td', 'th'].includes(getNodeName(element));\n}\nfunction isTopLayer(element) {\n  return [':popover-open', ':modal'].some(selector => {\n    try {\n      return element.matches(selector);\n    } catch (e) {\n      return false;\n    }\n  });\n}\nfunction isContainingBlock(elementOrCss) {\n  const webkit = isWebKit();\n  const css = isElement(elementOrCss) ? getComputedStyle(elementOrCss) : elementOrCss;\n\n  // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n  return css.transform !== 'none' || css.perspective !== 'none' || (css.containerType ? css.containerType !== 'normal' : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== 'none' : false) || !webkit && (css.filter ? css.filter !== 'none' : false) || ['transform', 'perspective', 'filter'].some(value => (css.willChange || '').includes(value)) || ['paint', 'layout', 'strict', 'content'].some(value => (css.contain || '').includes(value));\n}\nfunction getContainingBlock(element) {\n  let currentNode = getParentNode(element);\n  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {\n    if (isContainingBlock(currentNode)) {\n      return currentNode;\n    } else if (isTopLayer(currentNode)) {\n      return null;\n    }\n    currentNode = getParentNode(currentNode);\n  }\n  return null;\n}\nfunction isWebKit() {\n  if (typeof CSS === 'undefined' || !CSS.supports) return false;\n  return CSS.supports('-webkit-backdrop-filter', 'none');\n}\nfunction isLastTraversableNode(node) {\n  return ['html', 'body', '#document'].includes(getNodeName(node));\n}\nfunction getComputedStyle(element) {\n  return getWindow(element).getComputedStyle(element);\n}\nfunction getNodeScroll(element) {\n  if (isElement(element)) {\n    return {\n      scrollLeft: element.scrollLeft,\n      scrollTop: element.scrollTop\n    };\n  }\n  return {\n    scrollLeft: element.scrollX,\n    scrollTop: element.scrollY\n  };\n}\nfunction getParentNode(node) {\n  if (getNodeName(node) === 'html') {\n    return node;\n  }\n  const result =\n  // Step into the shadow DOM of the parent of a slotted node.\n  node.assignedSlot ||\n  // DOM Element detected.\n  node.parentNode ||\n  // ShadowRoot detected.\n  isShadowRoot(node) && node.host ||\n  // Fallback.\n  getDocumentElement(node);\n  return isShadowRoot(result) ? result.host : result;\n}\nfunction getNearestOverflowAncestor(node) {\n  const parentNode = getParentNode(node);\n  if (isLastTraversableNode(parentNode)) {\n    return node.ownerDocument ? node.ownerDocument.body : node.body;\n  }\n  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {\n    return parentNode;\n  }\n  return getNearestOverflowAncestor(parentNode);\n}\nfunction getOverflowAncestors(node, list, traverseIframes) {\n  var _node$ownerDocument2;\n  if (list === void 0) {\n    list = [];\n  }\n  if (traverseIframes === void 0) {\n    traverseIframes = true;\n  }\n  const scrollableAncestor = getNearestOverflowAncestor(node);\n  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);\n  const win = getWindow(scrollableAncestor);\n  if (isBody) {\n    const frameElement = getFrameElement(win);\n    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);\n  }\n  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));\n}\nfunction getFrameElement(win) {\n  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;\n}\n\nexport { getComputedStyle, getContainingBlock, getDocumentElement, getFrameElement, getNearestOverflowAncestor, getNodeName, getNodeScroll, getOverflowAncestors, getParentNode, getWindow, isContainingBlock, isElement, isHTMLElement, isLastTraversableNode, isNode, isOverflowElement, isShadowRoot, isTableElement, isTopLayer, isWebKit };\n","/**\n * Custom positioning reference element.\n * @see https://floating-ui.com/docs/virtual-elements\n */\n\nconst sides = ['top', 'right', 'bottom', 'left'];\nconst alignments = ['start', 'end'];\nconst placements = /*#__PURE__*/sides.reduce((acc, side) => acc.concat(side, side + \"-\" + alignments[0], side + \"-\" + alignments[1]), []);\nconst min = Math.min;\nconst max = Math.max;\nconst round = Math.round;\nconst floor = Math.floor;\nconst createCoords = v => ({\n  x: v,\n  y: v\n});\nconst oppositeSideMap = {\n  left: 'right',\n  right: 'left',\n  bottom: 'top',\n  top: 'bottom'\n};\nconst oppositeAlignmentMap = {\n  start: 'end',\n  end: 'start'\n};\nfunction clamp(start, value, end) {\n  return max(start, min(value, end));\n}\nfunction evaluate(value, param) {\n  return typeof value === 'function' ? value(param) : value;\n}\nfunction getSide(placement) {\n  return placement.split('-')[0];\n}\nfunction getAlignment(placement) {\n  return placement.split('-')[1];\n}\nfunction getOppositeAxis(axis) {\n  return axis === 'x' ? 'y' : 'x';\n}\nfunction getAxisLength(axis) {\n  return axis === 'y' ? 'height' : 'width';\n}\nfunction getSideAxis(placement) {\n  return ['top', 'bottom'].includes(getSide(placement)) ? 'y' : 'x';\n}\nfunction getAlignmentAxis(placement) {\n  return getOppositeAxis(getSideAxis(placement));\n}\nfunction getAlignmentSides(placement, rects, rtl) {\n  if (rtl === void 0) {\n    rtl = false;\n  }\n  const alignment = getAlignment(placement);\n  const alignmentAxis = getAlignmentAxis(placement);\n  const length = getAxisLength(alignmentAxis);\n  let mainAlignmentSide = alignmentAxis === 'x' ? alignment === (rtl ? 'end' : 'start') ? 'right' : 'left' : alignment === 'start' ? 'bottom' : 'top';\n  if (rects.reference[length] > rects.floating[length]) {\n    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);\n  }\n  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];\n}\nfunction getExpandedPlacements(placement) {\n  const oppositePlacement = getOppositePlacement(placement);\n  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];\n}\nfunction getOppositeAlignmentPlacement(placement) {\n  return placement.replace(/start|end/g, alignment => oppositeAlignmentMap[alignment]);\n}\nfunction getSideList(side, isStart, rtl) {\n  const lr = ['left', 'right'];\n  const rl = ['right', 'left'];\n  const tb = ['top', 'bottom'];\n  const bt = ['bottom', 'top'];\n  switch (side) {\n    case 'top':\n    case 'bottom':\n      if (rtl) return isStart ? rl : lr;\n      return isStart ? lr : rl;\n    case 'left':\n    case 'right':\n      return isStart ? tb : bt;\n    default:\n      return [];\n  }\n}\nfunction getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {\n  const alignment = getAlignment(placement);\n  let list = getSideList(getSide(placement), direction === 'start', rtl);\n  if (alignment) {\n    list = list.map(side => side + \"-\" + alignment);\n    if (flipAlignment) {\n      list = list.concat(list.map(getOppositeAlignmentPlacement));\n    }\n  }\n  return list;\n}\nfunction getOppositePlacement(placement) {\n  return placement.replace(/left|right|bottom|top/g, side => oppositeSideMap[side]);\n}\nfunction expandPaddingObject(padding) {\n  return {\n    top: 0,\n    right: 0,\n    bottom: 0,\n    left: 0,\n    ...padding\n  };\n}\nfunction getPaddingObject(padding) {\n  return typeof padding !== 'number' ? expandPaddingObject(padding) : {\n    top: padding,\n    right: padding,\n    bottom: padding,\n    left: padding\n  };\n}\nfunction rectToClientRect(rect) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  return {\n    width,\n    height,\n    top: y,\n    left: x,\n    right: x + width,\n    bottom: y + height,\n    x,\n    y\n  };\n}\n\nexport { alignments, clamp, createCoords, evaluate, expandPaddingObject, floor, getAlignment, getAlignmentAxis, getAlignmentSides, getAxisLength, getExpandedPlacements, getOppositeAlignmentPlacement, getOppositeAxis, getOppositeAxisPlacements, getOppositePlacement, getPaddingObject, getSide, getSideAxis, max, min, placements, rectToClientRect, round, sides };\n","function getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar urlToolkit = {exports: {}};\n\n(function (module, exports) {\n\t// see https://tools.ietf.org/html/rfc1808\n\n\t(function (root) {\n\t  var URL_REGEX =\n\t    /^(?=((?:[a-zA-Z0-9+\\-.]+:)?))\\1(?=((?:\\/\\/[^\\/?#]*)?))\\2(?=((?:(?:[^?#\\/]*\\/)*[^;?#\\/]*)?))\\3((?:;[^?#]*)?)(\\?[^#]*)?(#[^]*)?$/;\n\t  var FIRST_SEGMENT_REGEX = /^(?=([^\\/?#]*))\\1([^]*)$/;\n\t  var SLASH_DOT_REGEX = /(?:\\/|^)\\.(?=\\/)/g;\n\t  var SLASH_DOT_DOT_REGEX = /(?:\\/|^)\\.\\.\\/(?!\\.\\.\\/)[^\\/]*(?=\\/)/g;\n\n\t  var URLToolkit = {\n\t    // If opts.alwaysNormalize is true then the path will always be normalized even when it starts with / or //\n\t    // E.g\n\t    // With opts.alwaysNormalize = false (default, spec compliant)\n\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/f/../g\n\t    // With opts.alwaysNormalize = true (not spec compliant)\n\t    // http://a.com/b/cd + /e/f/../g => http://a.com/e/g\n\t    buildAbsoluteURL: function (baseURL, relativeURL, opts) {\n\t      opts = opts || {};\n\t      // remove any remaining space and CRLF\n\t      baseURL = baseURL.trim();\n\t      relativeURL = relativeURL.trim();\n\t      if (!relativeURL) {\n\t        // 2a) If the embedded URL is entirely empty, it inherits the\n\t        // entire base URL (i.e., is set equal to the base URL)\n\t        // and we are done.\n\t        if (!opts.alwaysNormalize) {\n\t          return baseURL;\n\t        }\n\t        var basePartsForNormalise = URLToolkit.parseURL(baseURL);\n\t        if (!basePartsForNormalise) {\n\t          throw new Error('Error trying to parse base URL.');\n\t        }\n\t        basePartsForNormalise.path = URLToolkit.normalizePath(\n\t          basePartsForNormalise.path\n\t        );\n\t        return URLToolkit.buildURLFromParts(basePartsForNormalise);\n\t      }\n\t      var relativeParts = URLToolkit.parseURL(relativeURL);\n\t      if (!relativeParts) {\n\t        throw new Error('Error trying to parse relative URL.');\n\t      }\n\t      if (relativeParts.scheme) {\n\t        // 2b) If the embedded URL starts with a scheme name, it is\n\t        // interpreted as an absolute URL and we are done.\n\t        if (!opts.alwaysNormalize) {\n\t          return relativeURL;\n\t        }\n\t        relativeParts.path = URLToolkit.normalizePath(relativeParts.path);\n\t        return URLToolkit.buildURLFromParts(relativeParts);\n\t      }\n\t      var baseParts = URLToolkit.parseURL(baseURL);\n\t      if (!baseParts) {\n\t        throw new Error('Error trying to parse base URL.');\n\t      }\n\t      if (!baseParts.netLoc && baseParts.path && baseParts.path[0] !== '/') {\n\t        // If netLoc missing and path doesn't start with '/', assume everthing before the first '/' is the netLoc\n\t        // This causes 'example.com/a' to be handled as '//example.com/a' instead of '/example.com/a'\n\t        var pathParts = FIRST_SEGMENT_REGEX.exec(baseParts.path);\n\t        baseParts.netLoc = pathParts[1];\n\t        baseParts.path = pathParts[2];\n\t      }\n\t      if (baseParts.netLoc && !baseParts.path) {\n\t        baseParts.path = '/';\n\t      }\n\t      var builtParts = {\n\t        // 2c) Otherwise, the embedded URL inherits the scheme of\n\t        // the base URL.\n\t        scheme: baseParts.scheme,\n\t        netLoc: relativeParts.netLoc,\n\t        path: null,\n\t        params: relativeParts.params,\n\t        query: relativeParts.query,\n\t        fragment: relativeParts.fragment,\n\t      };\n\t      if (!relativeParts.netLoc) {\n\t        // 3) If the embedded URL's <net_loc> is non-empty, we skip to\n\t        // Step 7.  Otherwise, the embedded URL inherits the <net_loc>\n\t        // (if any) of the base URL.\n\t        builtParts.netLoc = baseParts.netLoc;\n\t        // 4) If the embedded URL path is preceded by a slash \"/\", the\n\t        // path is not relative and we skip to Step 7.\n\t        if (relativeParts.path[0] !== '/') {\n\t          if (!relativeParts.path) {\n\t            // 5) If the embedded URL path is empty (and not preceded by a\n\t            // slash), then the embedded URL inherits the base URL path\n\t            builtParts.path = baseParts.path;\n\t            // 5a) if the embedded URL's <params> is non-empty, we skip to\n\t            // step 7; otherwise, it inherits the <params> of the base\n\t            // URL (if any) and\n\t            if (!relativeParts.params) {\n\t              builtParts.params = baseParts.params;\n\t              // 5b) if the embedded URL's <query> is non-empty, we skip to\n\t              // step 7; otherwise, it inherits the <query> of the base\n\t              // URL (if any) and we skip to step 7.\n\t              if (!relativeParts.query) {\n\t                builtParts.query = baseParts.query;\n\t              }\n\t            }\n\t          } else {\n\t            // 6) The last segment of the base URL's path (anything\n\t            // following the rightmost slash \"/\", or the entire path if no\n\t            // slash is present) is removed and the embedded URL's path is\n\t            // appended in its place.\n\t            var baseURLPath = baseParts.path;\n\t            var newPath =\n\t              baseURLPath.substring(0, baseURLPath.lastIndexOf('/') + 1) +\n\t              relativeParts.path;\n\t            builtParts.path = URLToolkit.normalizePath(newPath);\n\t          }\n\t        }\n\t      }\n\t      if (builtParts.path === null) {\n\t        builtParts.path = opts.alwaysNormalize\n\t          ? URLToolkit.normalizePath(relativeParts.path)\n\t          : relativeParts.path;\n\t      }\n\t      return URLToolkit.buildURLFromParts(builtParts);\n\t    },\n\t    parseURL: function (url) {\n\t      var parts = URL_REGEX.exec(url);\n\t      if (!parts) {\n\t        return null;\n\t      }\n\t      return {\n\t        scheme: parts[1] || '',\n\t        netLoc: parts[2] || '',\n\t        path: parts[3] || '',\n\t        params: parts[4] || '',\n\t        query: parts[5] || '',\n\t        fragment: parts[6] || '',\n\t      };\n\t    },\n\t    normalizePath: function (path) {\n\t      // The following operations are\n\t      // then applied, in order, to the new path:\n\t      // 6a) All occurrences of \"./\", where \".\" is a complete path\n\t      // segment, are removed.\n\t      // 6b) If the path ends with \".\" as a complete path segment,\n\t      // that \".\" is removed.\n\t      path = path.split('').reverse().join('').replace(SLASH_DOT_REGEX, '');\n\t      // 6c) All occurrences of \"<segment>/../\", where <segment> is a\n\t      // complete path segment not equal to \"..\", are removed.\n\t      // Removal of these path segments is performed iteratively,\n\t      // removing the leftmost matching pattern on each iteration,\n\t      // until no matching pattern remains.\n\t      // 6d) If the path ends with \"<segment>/..\", where <segment> is a\n\t      // complete path segment not equal to \"..\", that\n\t      // \"<segment>/..\" is removed.\n\t      while (\n\t        path.length !== (path = path.replace(SLASH_DOT_DOT_REGEX, '')).length\n\t      ) {}\n\t      return path.split('').reverse().join('');\n\t    },\n\t    buildURLFromParts: function (parts) {\n\t      return (\n\t        parts.scheme +\n\t        parts.netLoc +\n\t        parts.path +\n\t        parts.params +\n\t        parts.query +\n\t        parts.fragment\n\t      );\n\t    },\n\t  };\n\n\t  module.exports = URLToolkit;\n\t})(); \n} (urlToolkit));\n\nvar urlToolkitExports = urlToolkit.exports;\n\nfunction ownKeys(e, r) {\n  var t = Object.keys(e);\n  if (Object.getOwnPropertySymbols) {\n    var o = Object.getOwnPropertySymbols(e);\n    r && (o = o.filter(function (r) {\n      return Object.getOwnPropertyDescriptor(e, r).enumerable;\n    })), t.push.apply(t, o);\n  }\n  return t;\n}\nfunction _objectSpread2(e) {\n  for (var r = 1; r < arguments.length; r++) {\n    var t = null != arguments[r] ? arguments[r] : {};\n    r % 2 ? ownKeys(Object(t), !0).forEach(function (r) {\n      _defineProperty(e, r, t[r]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {\n      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));\n    });\n  }\n  return e;\n}\nfunction _toPrimitive(t, r) {\n  if (\"object\" != typeof t || !t) return t;\n  var e = t[Symbol.toPrimitive];\n  if (void 0 !== e) {\n    var i = e.call(t, r || \"default\");\n    if (\"object\" != typeof i) return i;\n    throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n  }\n  return (\"string\" === r ? String : Number)(t);\n}\nfunction _toPropertyKey(t) {\n  var i = _toPrimitive(t, \"string\");\n  return \"symbol\" == typeof i ? i : String(i);\n}\nfunction _defineProperty(obj, key, value) {\n  key = _toPropertyKey(key);\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _extends() {\n  _extends = Object.assign ? Object.assign.bind() : function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (Object.prototype.hasOwnProperty.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  };\n  return _extends.apply(this, arguments);\n}\n\n// https://caniuse.com/mdn-javascript_builtins_number_isfinite\nconst isFiniteNumber = Number.isFinite || function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\n// https://caniuse.com/mdn-javascript_builtins_number_issafeinteger\nconst isSafeInteger = Number.isSafeInteger || function (value) {\n  return typeof value === 'number' && Math.abs(value) <= MAX_SAFE_INTEGER;\n};\nconst MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;\n\nlet Events = /*#__PURE__*/function (Events) {\n  Events[\"MEDIA_ATTACHING\"] = \"hlsMediaAttaching\";\n  Events[\"MEDIA_ATTACHED\"] = \"hlsMediaAttached\";\n  Events[\"MEDIA_DETACHING\"] = \"hlsMediaDetaching\";\n  Events[\"MEDIA_DETACHED\"] = \"hlsMediaDetached\";\n  Events[\"BUFFER_RESET\"] = \"hlsBufferReset\";\n  Events[\"BUFFER_CODECS\"] = \"hlsBufferCodecs\";\n  Events[\"BUFFER_CREATED\"] = \"hlsBufferCreated\";\n  Events[\"BUFFER_APPENDING\"] = \"hlsBufferAppending\";\n  Events[\"BUFFER_APPENDED\"] = \"hlsBufferAppended\";\n  Events[\"BUFFER_EOS\"] = \"hlsBufferEos\";\n  Events[\"BUFFER_FLUSHING\"] = \"hlsBufferFlushing\";\n  Events[\"BUFFER_FLUSHED\"] = \"hlsBufferFlushed\";\n  Events[\"MANIFEST_LOADING\"] = \"hlsManifestLoading\";\n  Events[\"MANIFEST_LOADED\"] = \"hlsManifestLoaded\";\n  Events[\"MANIFEST_PARSED\"] = \"hlsManifestParsed\";\n  Events[\"LEVEL_SWITCHING\"] = \"hlsLevelSwitching\";\n  Events[\"LEVEL_SWITCHED\"] = \"hlsLevelSwitched\";\n  Events[\"LEVEL_LOADING\"] = \"hlsLevelLoading\";\n  Events[\"LEVEL_LOADED\"] = \"hlsLevelLoaded\";\n  Events[\"LEVEL_UPDATED\"] = \"hlsLevelUpdated\";\n  Events[\"LEVEL_PTS_UPDATED\"] = \"hlsLevelPtsUpdated\";\n  Events[\"LEVELS_UPDATED\"] = \"hlsLevelsUpdated\";\n  Events[\"AUDIO_TRACKS_UPDATED\"] = \"hlsAudioTracksUpdated\";\n  Events[\"AUDIO_TRACK_SWITCHING\"] = \"hlsAudioTrackSwitching\";\n  Events[\"AUDIO_TRACK_SWITCHED\"] = \"hlsAudioTrackSwitched\";\n  Events[\"AUDIO_TRACK_LOADING\"] = \"hlsAudioTrackLoading\";\n  Events[\"AUDIO_TRACK_LOADED\"] = \"hlsAudioTrackLoaded\";\n  Events[\"SUBTITLE_TRACKS_UPDATED\"] = \"hlsSubtitleTracksUpdated\";\n  Events[\"SUBTITLE_TRACKS_CLEARED\"] = \"hlsSubtitleTracksCleared\";\n  Events[\"SUBTITLE_TRACK_SWITCH\"] = \"hlsSubtitleTrackSwitch\";\n  Events[\"SUBTITLE_TRACK_LOADING\"] = \"hlsSubtitleTrackLoading\";\n  Events[\"SUBTITLE_TRACK_LOADED\"] = \"hlsSubtitleTrackLoaded\";\n  Events[\"SUBTITLE_FRAG_PROCESSED\"] = \"hlsSubtitleFragProcessed\";\n  Events[\"CUES_PARSED\"] = \"hlsCuesParsed\";\n  Events[\"NON_NATIVE_TEXT_TRACKS_FOUND\"] = \"hlsNonNativeTextTracksFound\";\n  Events[\"INIT_PTS_FOUND\"] = \"hlsInitPtsFound\";\n  Events[\"FRAG_LOADING\"] = \"hlsFragLoading\";\n  Events[\"FRAG_LOAD_EMERGENCY_ABORTED\"] = \"hlsFragLoadEmergencyAborted\";\n  Events[\"FRAG_LOADED\"] = \"hlsFragLoaded\";\n  Events[\"FRAG_DECRYPTED\"] = \"hlsFragDecrypted\";\n  Events[\"FRAG_PARSING_INIT_SEGMENT\"] = \"hlsFragParsingInitSegment\";\n  Events[\"FRAG_PARSING_USERDATA\"] = \"hlsFragParsingUserdata\";\n  Events[\"FRAG_PARSING_METADATA\"] = \"hlsFragParsingMetadata\";\n  Events[\"FRAG_PARSED\"] = \"hlsFragParsed\";\n  Events[\"FRAG_BUFFERED\"] = \"hlsFragBuffered\";\n  Events[\"FRAG_CHANGED\"] = \"hlsFragChanged\";\n  Events[\"FPS_DROP\"] = \"hlsFpsDrop\";\n  Events[\"FPS_DROP_LEVEL_CAPPING\"] = \"hlsFpsDropLevelCapping\";\n  Events[\"MAX_AUTO_LEVEL_UPDATED\"] = \"hlsMaxAutoLevelUpdated\";\n  Events[\"ERROR\"] = \"hlsError\";\n  Events[\"DESTROYING\"] = \"hlsDestroying\";\n  Events[\"KEY_LOADING\"] = \"hlsKeyLoading\";\n  Events[\"KEY_LOADED\"] = \"hlsKeyLoaded\";\n  Events[\"LIVE_BACK_BUFFER_REACHED\"] = \"hlsLiveBackBufferReached\";\n  Events[\"BACK_BUFFER_REACHED\"] = \"hlsBackBufferReached\";\n  Events[\"STEERING_MANIFEST_LOADED\"] = \"hlsSteeringManifestLoaded\";\n  return Events;\n}({});\n\n/**\n * Defines each Event type and payload by Event name. Used in {@link hls.js#HlsEventEmitter} to strongly type the event listener API.\n */\n\nlet ErrorTypes = /*#__PURE__*/function (ErrorTypes) {\n  ErrorTypes[\"NETWORK_ERROR\"] = \"networkError\";\n  ErrorTypes[\"MEDIA_ERROR\"] = \"mediaError\";\n  ErrorTypes[\"KEY_SYSTEM_ERROR\"] = \"keySystemError\";\n  ErrorTypes[\"MUX_ERROR\"] = \"muxError\";\n  ErrorTypes[\"OTHER_ERROR\"] = \"otherError\";\n  return ErrorTypes;\n}({});\nlet ErrorDetails = /*#__PURE__*/function (ErrorDetails) {\n  ErrorDetails[\"KEY_SYSTEM_NO_KEYS\"] = \"keySystemNoKeys\";\n  ErrorDetails[\"KEY_SYSTEM_NO_ACCESS\"] = \"keySystemNoAccess\";\n  ErrorDetails[\"KEY_SYSTEM_NO_SESSION\"] = \"keySystemNoSession\";\n  ErrorDetails[\"KEY_SYSTEM_NO_CONFIGURED_LICENSE\"] = \"keySystemNoConfiguredLicense\";\n  ErrorDetails[\"KEY_SYSTEM_LICENSE_REQUEST_FAILED\"] = \"keySystemLicenseRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED\"] = \"keySystemServerCertificateRequestFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED\"] = \"keySystemServerCertificateUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_SESSION_UPDATE_FAILED\"] = \"keySystemSessionUpdateFailed\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED\"] = \"keySystemStatusOutputRestricted\";\n  ErrorDetails[\"KEY_SYSTEM_STATUS_INTERNAL_ERROR\"] = \"keySystemStatusInternalError\";\n  ErrorDetails[\"MANIFEST_LOAD_ERROR\"] = \"manifestLoadError\";\n  ErrorDetails[\"MANIFEST_LOAD_TIMEOUT\"] = \"manifestLoadTimeOut\";\n  ErrorDetails[\"MANIFEST_PARSING_ERROR\"] = \"manifestParsingError\";\n  ErrorDetails[\"MANIFEST_INCOMPATIBLE_CODECS_ERROR\"] = \"manifestIncompatibleCodecsError\";\n  ErrorDetails[\"LEVEL_EMPTY_ERROR\"] = \"levelEmptyError\";\n  ErrorDetails[\"LEVEL_LOAD_ERROR\"] = \"levelLoadError\";\n  ErrorDetails[\"LEVEL_LOAD_TIMEOUT\"] = \"levelLoadTimeOut\";\n  ErrorDetails[\"LEVEL_PARSING_ERROR\"] = \"levelParsingError\";\n  ErrorDetails[\"LEVEL_SWITCH_ERROR\"] = \"levelSwitchError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_ERROR\"] = \"audioTrackLoadError\";\n  ErrorDetails[\"AUDIO_TRACK_LOAD_TIMEOUT\"] = \"audioTrackLoadTimeOut\";\n  ErrorDetails[\"SUBTITLE_LOAD_ERROR\"] = \"subtitleTrackLoadError\";\n  ErrorDetails[\"SUBTITLE_TRACK_LOAD_TIMEOUT\"] = \"subtitleTrackLoadTimeOut\";\n  ErrorDetails[\"FRAG_LOAD_ERROR\"] = \"fragLoadError\";\n  ErrorDetails[\"FRAG_LOAD_TIMEOUT\"] = \"fragLoadTimeOut\";\n  ErrorDetails[\"FRAG_DECRYPT_ERROR\"] = \"fragDecryptError\";\n  ErrorDetails[\"FRAG_PARSING_ERROR\"] = \"fragParsingError\";\n  ErrorDetails[\"FRAG_GAP\"] = \"fragGap\";\n  ErrorDetails[\"REMUX_ALLOC_ERROR\"] = \"remuxAllocError\";\n  ErrorDetails[\"KEY_LOAD_ERROR\"] = \"keyLoadError\";\n  ErrorDetails[\"KEY_LOAD_TIMEOUT\"] = \"keyLoadTimeOut\";\n  ErrorDetails[\"BUFFER_ADD_CODEC_ERROR\"] = \"bufferAddCodecError\";\n  ErrorDetails[\"BUFFER_INCOMPATIBLE_CODECS_ERROR\"] = \"bufferIncompatibleCodecsError\";\n  ErrorDetails[\"BUFFER_APPEND_ERROR\"] = \"bufferAppendError\";\n  ErrorDetails[\"BUFFER_APPENDING_ERROR\"] = \"bufferAppendingError\";\n  ErrorDetails[\"BUFFER_STALLED_ERROR\"] = \"bufferStalledError\";\n  ErrorDetails[\"BUFFER_FULL_ERROR\"] = \"bufferFullError\";\n  ErrorDetails[\"BUFFER_SEEK_OVER_HOLE\"] = \"bufferSeekOverHole\";\n  ErrorDetails[\"BUFFER_NUDGE_ON_STALL\"] = \"bufferNudgeOnStall\";\n  ErrorDetails[\"INTERNAL_EXCEPTION\"] = \"internalException\";\n  ErrorDetails[\"INTERNAL_ABORTED\"] = \"aborted\";\n  ErrorDetails[\"UNKNOWN\"] = \"unknown\";\n  return ErrorDetails;\n}({});\n\nconst noop = function noop() {};\nconst fakeLogger = {\n  trace: noop,\n  debug: noop,\n  log: noop,\n  warn: noop,\n  info: noop,\n  error: noop\n};\nlet exportedLogger = fakeLogger;\n\n// let lastCallTime;\n// function formatMsgWithTimeInfo(type, msg) {\n//   const now = Date.now();\n//   const diff = lastCallTime ? '+' + (now - lastCallTime) : '0';\n//   lastCallTime = now;\n//   msg = (new Date(now)).toISOString() + ' | [' +  type + '] > ' + msg + ' ( ' + diff + ' ms )';\n//   return msg;\n// }\n\nfunction consolePrintFn(type) {\n  const func = self.console[type];\n  if (func) {\n    return func.bind(self.console, `[${type}] >`);\n  }\n  return noop;\n}\nfunction exportLoggerFunctions(debugConfig, ...functions) {\n  functions.forEach(function (type) {\n    exportedLogger[type] = debugConfig[type] ? debugConfig[type].bind(debugConfig) : consolePrintFn(type);\n  });\n}\nfunction enableLogs(debugConfig, id) {\n  // check that console is available\n  if (typeof console === 'object' && debugConfig === true || typeof debugConfig === 'object') {\n    exportLoggerFunctions(debugConfig,\n    // Remove out from list here to hard-disable a log-level\n    // 'trace',\n    'debug', 'log', 'info', 'warn', 'error');\n    // Some browsers don't allow to use bind on console object anyway\n    // fallback to default if needed\n    try {\n      exportedLogger.log(`Debug logs enabled for \"${id}\" in hls.js version ${\"1.5.15\"}`);\n    } catch (e) {\n      exportedLogger = fakeLogger;\n    }\n  } else {\n    exportedLogger = fakeLogger;\n  }\n}\nconst logger = exportedLogger;\n\nconst DECIMAL_RESOLUTION_REGEX = /^(\\d+)x(\\d+)$/;\nconst ATTR_LIST_REGEX = /(.+?)=(\".*?\"|.*?)(?:,|$)/g;\n\n// adapted from https://github.com/kanongil/node-m3u8parse/blob/master/attrlist.js\nclass AttrList {\n  constructor(attrs) {\n    if (typeof attrs === 'string') {\n      attrs = AttrList.parseAttrList(attrs);\n    }\n    _extends(this, attrs);\n  }\n  get clientAttrs() {\n    return Object.keys(this).filter(attr => attr.substring(0, 2) === 'X-');\n  }\n  decimalInteger(attrName) {\n    const intValue = parseInt(this[attrName], 10);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  hexadecimalInteger(attrName) {\n    if (this[attrName]) {\n      let stringValue = (this[attrName] || '0x').slice(2);\n      stringValue = (stringValue.length & 1 ? '0' : '') + stringValue;\n      const value = new Uint8Array(stringValue.length / 2);\n      for (let i = 0; i < stringValue.length / 2; i++) {\n        value[i] = parseInt(stringValue.slice(i * 2, i * 2 + 2), 16);\n      }\n      return value;\n    } else {\n      return null;\n    }\n  }\n  hexadecimalIntegerAsNumber(attrName) {\n    const intValue = parseInt(this[attrName], 16);\n    if (intValue > Number.MAX_SAFE_INTEGER) {\n      return Infinity;\n    }\n    return intValue;\n  }\n  decimalFloatingPoint(attrName) {\n    return parseFloat(this[attrName]);\n  }\n  optionalFloat(attrName, defaultValue) {\n    const value = this[attrName];\n    return value ? parseFloat(value) : defaultValue;\n  }\n  enumeratedString(attrName) {\n    return this[attrName];\n  }\n  bool(attrName) {\n    return this[attrName] === 'YES';\n  }\n  decimalResolution(attrName) {\n    const res = DECIMAL_RESOLUTION_REGEX.exec(this[attrName]);\n    if (res === null) {\n      return undefined;\n    }\n    return {\n      width: parseInt(res[1], 10),\n      height: parseInt(res[2], 10)\n    };\n  }\n  static parseAttrList(input) {\n    let match;\n    const attrs = {};\n    const quote = '\"';\n    ATTR_LIST_REGEX.lastIndex = 0;\n    while ((match = ATTR_LIST_REGEX.exec(input)) !== null) {\n      let value = match[2];\n      if (value.indexOf(quote) === 0 && value.lastIndexOf(quote) === value.length - 1) {\n        value = value.slice(1, -1);\n      }\n      const name = match[1].trim();\n      attrs[name] = value;\n    }\n    return attrs;\n  }\n}\n\n// Avoid exporting const enum so that these values can be inlined\n\nfunction isDateRangeCueAttribute(attrName) {\n  return attrName !== \"ID\" && attrName !== \"CLASS\" && attrName !== \"START-DATE\" && attrName !== \"DURATION\" && attrName !== \"END-DATE\" && attrName !== \"END-ON-NEXT\";\n}\nfunction isSCTE35Attribute(attrName) {\n  return attrName === \"SCTE35-OUT\" || attrName === \"SCTE35-IN\";\n}\nclass DateRange {\n  constructor(dateRangeAttr, dateRangeWithSameId) {\n    this.attr = void 0;\n    this._startDate = void 0;\n    this._endDate = void 0;\n    this._badValueForSameId = void 0;\n    if (dateRangeWithSameId) {\n      const previousAttr = dateRangeWithSameId.attr;\n      for (const key in previousAttr) {\n        if (Object.prototype.hasOwnProperty.call(dateRangeAttr, key) && dateRangeAttr[key] !== previousAttr[key]) {\n          logger.warn(`DATERANGE tag attribute: \"${key}\" does not match for tags with ID: \"${dateRangeAttr.ID}\"`);\n          this._badValueForSameId = key;\n          break;\n        }\n      }\n      // Merge DateRange tags with the same ID\n      dateRangeAttr = _extends(new AttrList({}), previousAttr, dateRangeAttr);\n    }\n    this.attr = dateRangeAttr;\n    this._startDate = new Date(dateRangeAttr[\"START-DATE\"]);\n    if (\"END-DATE\" in this.attr) {\n      const endDate = new Date(this.attr[\"END-DATE\"]);\n      if (isFiniteNumber(endDate.getTime())) {\n        this._endDate = endDate;\n      }\n    }\n  }\n  get id() {\n    return this.attr.ID;\n  }\n  get class() {\n    return this.attr.CLASS;\n  }\n  get startDate() {\n    return this._startDate;\n  }\n  get endDate() {\n    if (this._endDate) {\n      return this._endDate;\n    }\n    const duration = this.duration;\n    if (duration !== null) {\n      return new Date(this._startDate.getTime() + duration * 1000);\n    }\n    return null;\n  }\n  get duration() {\n    if (\"DURATION\" in this.attr) {\n      const duration = this.attr.decimalFloatingPoint(\"DURATION\");\n      if (isFiniteNumber(duration)) {\n        return duration;\n      }\n    } else if (this._endDate) {\n      return (this._endDate.getTime() - this._startDate.getTime()) / 1000;\n    }\n    return null;\n  }\n  get plannedDuration() {\n    if (\"PLANNED-DURATION\" in this.attr) {\n      return this.attr.decimalFloatingPoint(\"PLANNED-DURATION\");\n    }\n    return null;\n  }\n  get endOnNext() {\n    return this.attr.bool(\"END-ON-NEXT\");\n  }\n  get isValid() {\n    return !!this.id && !this._badValueForSameId && isFiniteNumber(this.startDate.getTime()) && (this.duration === null || this.duration >= 0) && (!this.endOnNext || !!this.class);\n  }\n}\n\nclass LoadStats {\n  constructor() {\n    this.aborted = false;\n    this.loaded = 0;\n    this.retry = 0;\n    this.total = 0;\n    this.chunkCount = 0;\n    this.bwEstimate = 0;\n    this.loading = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n    this.parsing = {\n      start: 0,\n      end: 0\n    };\n    this.buffering = {\n      start: 0,\n      first: 0,\n      end: 0\n    };\n  }\n}\n\nvar ElementaryStreamTypes = {\n  AUDIO: \"audio\",\n  VIDEO: \"video\",\n  AUDIOVIDEO: \"audiovideo\"\n};\nclass BaseSegment {\n  constructor(baseurl) {\n    this._byteRange = null;\n    this._url = null;\n    // baseurl is the URL to the playlist\n    this.baseurl = void 0;\n    // relurl is the portion of the URL that comes from inside the playlist.\n    this.relurl = void 0;\n    // Holds the types of data this fragment supports\n    this.elementaryStreams = {\n      [ElementaryStreamTypes.AUDIO]: null,\n      [ElementaryStreamTypes.VIDEO]: null,\n      [ElementaryStreamTypes.AUDIOVIDEO]: null\n    };\n    this.baseurl = baseurl;\n  }\n\n  // setByteRange converts a EXT-X-BYTERANGE attribute into a two element array\n  setByteRange(value, previous) {\n    const params = value.split('@', 2);\n    let start;\n    if (params.length === 1) {\n      start = (previous == null ? void 0 : previous.byteRangeEndOffset) || 0;\n    } else {\n      start = parseInt(params[1]);\n    }\n    this._byteRange = [start, parseInt(params[0]) + start];\n  }\n  get byteRange() {\n    if (!this._byteRange) {\n      return [];\n    }\n    return this._byteRange;\n  }\n  get byteRangeStartOffset() {\n    return this.byteRange[0];\n  }\n  get byteRangeEndOffset() {\n    return this.byteRange[1];\n  }\n  get url() {\n    if (!this._url && this.baseurl && this.relurl) {\n      this._url = urlToolkitExports.buildAbsoluteURL(this.baseurl, this.relurl, {\n        alwaysNormalize: true\n      });\n    }\n    return this._url || '';\n  }\n  set url(value) {\n    this._url = value;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Segment. Found in {@link hls.js#LevelDetails.fragments}.\n */\nclass Fragment extends BaseSegment {\n  constructor(type, baseurl) {\n    super(baseurl);\n    this._decryptdata = null;\n    this.rawProgramDateTime = null;\n    this.programDateTime = null;\n    this.tagList = [];\n    // EXTINF has to be present for a m3u8 to be considered valid\n    this.duration = 0;\n    // sn notates the sequence number for a segment, and if set to a string can be 'initSegment'\n    this.sn = 0;\n    // levelkeys are the EXT-X-KEY tags that apply to this segment for decryption\n    // core difference from the private field _decryptdata is the lack of the initialized IV\n    // _decryptdata will set the IV for this segment based on the segment number in the fragment\n    this.levelkeys = void 0;\n    // A string representing the fragment type\n    this.type = void 0;\n    // A reference to the loader. Set while the fragment is loading, and removed afterwards. Used to abort fragment loading\n    this.loader = null;\n    // A reference to the key loader. Set while the key is loading, and removed afterwards. Used to abort key loading\n    this.keyLoader = null;\n    // The level/track index to which the fragment belongs\n    this.level = -1;\n    // The continuity counter of the fragment\n    this.cc = 0;\n    // The starting Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.startPTS = void 0;\n    // The ending Presentation Time Stamp (PTS) of the fragment. Set after transmux complete.\n    this.endPTS = void 0;\n    // The starting Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.startDTS = void 0;\n    // The ending Decode Time Stamp (DTS) of the fragment. Set after transmux complete.\n    this.endDTS = void 0;\n    // The start time of the fragment, as listed in the manifest. Updated after transmux complete.\n    this.start = 0;\n    // Set by `updateFragPTSDTS` in level-helper\n    this.deltaPTS = void 0;\n    // The maximum starting Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.maxStartPTS = void 0;\n    // The minimum ending Presentation Time Stamp (audio/video PTS) of the fragment. Set after transmux complete.\n    this.minEndPTS = void 0;\n    // Load/parse timing information\n    this.stats = new LoadStats();\n    // Init Segment bytes (unset for media segments)\n    this.data = void 0;\n    // A flag indicating whether the segment was downloaded in order to test bitrate, and was not buffered\n    this.bitrateTest = false;\n    // #EXTINF  segment title\n    this.title = null;\n    // The Media Initialization Section for this segment\n    this.initSegment = null;\n    // Fragment is the last fragment in the media playlist\n    this.endList = void 0;\n    // Fragment is marked by an EXT-X-GAP tag indicating that it does not contain media data and should not be loaded\n    this.gap = void 0;\n    // Deprecated\n    this.urlId = 0;\n    this.type = type;\n  }\n  get decryptdata() {\n    const {\n      levelkeys\n    } = this;\n    if (!levelkeys && !this._decryptdata) {\n      return null;\n    }\n    if (!this._decryptdata && this.levelkeys && !this.levelkeys.NONE) {\n      const key = this.levelkeys.identity;\n      if (key) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      } else {\n        const keyFormats = Object.keys(this.levelkeys);\n        if (keyFormats.length === 1) {\n          return this._decryptdata = this.levelkeys[keyFormats[0]].getDecryptData(this.sn);\n        }\n      }\n    }\n    return this._decryptdata;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get endProgramDateTime() {\n    if (this.programDateTime === null) {\n      return null;\n    }\n    if (!isFiniteNumber(this.programDateTime)) {\n      return null;\n    }\n    const duration = !isFiniteNumber(this.duration) ? 0 : this.duration;\n    return this.programDateTime + duration * 1000;\n  }\n  get encrypted() {\n    var _this$_decryptdata;\n    // At the m3u8-parser level we need to add support for manifest signalled keyformats\n    // when we want the fragment to start reporting that it is encrypted.\n    // Currently, keyFormat will only be set for identity keys\n    if ((_this$_decryptdata = this._decryptdata) != null && _this$_decryptdata.encrypted) {\n      return true;\n    } else if (this.levelkeys) {\n      const keyFormats = Object.keys(this.levelkeys);\n      const len = keyFormats.length;\n      if (len > 1 || len === 1 && this.levelkeys[keyFormats[0]].encrypted) {\n        return true;\n      }\n    }\n    return false;\n  }\n  setKeyFormat(keyFormat) {\n    if (this.levelkeys) {\n      const key = this.levelkeys[keyFormat];\n      if (key && !this._decryptdata) {\n        this._decryptdata = key.getDecryptData(this.sn);\n      }\n    }\n  }\n  abortRequests() {\n    var _this$loader, _this$keyLoader;\n    (_this$loader = this.loader) == null ? void 0 : _this$loader.abort();\n    (_this$keyLoader = this.keyLoader) == null ? void 0 : _this$keyLoader.abort();\n  }\n  setElementaryStreamInfo(type, startPTS, endPTS, startDTS, endDTS, partial = false) {\n    const {\n      elementaryStreams\n    } = this;\n    const info = elementaryStreams[type];\n    if (!info) {\n      elementaryStreams[type] = {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS,\n        partial\n      };\n      return;\n    }\n    info.startPTS = Math.min(info.startPTS, startPTS);\n    info.endPTS = Math.max(info.endPTS, endPTS);\n    info.startDTS = Math.min(info.startDTS, startDTS);\n    info.endDTS = Math.max(info.endDTS, endDTS);\n  }\n  clearElementaryStreamInfo() {\n    const {\n      elementaryStreams\n    } = this;\n    elementaryStreams[ElementaryStreamTypes.AUDIO] = null;\n    elementaryStreams[ElementaryStreamTypes.VIDEO] = null;\n    elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO] = null;\n  }\n}\n\n/**\n * Object representing parsed data from an HLS Partial Segment. Found in {@link hls.js#LevelDetails.partList}.\n */\nclass Part extends BaseSegment {\n  constructor(partAttrs, frag, baseurl, index, previous) {\n    super(baseurl);\n    this.fragOffset = 0;\n    this.duration = 0;\n    this.gap = false;\n    this.independent = false;\n    this.relurl = void 0;\n    this.fragment = void 0;\n    this.index = void 0;\n    this.stats = new LoadStats();\n    this.duration = partAttrs.decimalFloatingPoint('DURATION');\n    this.gap = partAttrs.bool('GAP');\n    this.independent = partAttrs.bool('INDEPENDENT');\n    this.relurl = partAttrs.enumeratedString('URI');\n    this.fragment = frag;\n    this.index = index;\n    const byteRange = partAttrs.enumeratedString('BYTERANGE');\n    if (byteRange) {\n      this.setByteRange(byteRange, previous);\n    }\n    if (previous) {\n      this.fragOffset = previous.fragOffset + previous.duration;\n    }\n  }\n  get start() {\n    return this.fragment.start + this.fragOffset;\n  }\n  get end() {\n    return this.start + this.duration;\n  }\n  get loaded() {\n    const {\n      elementaryStreams\n    } = this;\n    return !!(elementaryStreams.audio || elementaryStreams.video || elementaryStreams.audiovideo);\n  }\n}\n\nconst DEFAULT_TARGET_DURATION = 10;\n\n/**\n * Object representing parsed data from an HLS Media Playlist. Found in {@link hls.js#Level.details}.\n */\nclass LevelDetails {\n  constructor(baseUrl) {\n    this.PTSKnown = false;\n    this.alignedSliding = false;\n    this.averagetargetduration = void 0;\n    this.endCC = 0;\n    this.endSN = 0;\n    this.fragments = void 0;\n    this.fragmentHint = void 0;\n    this.partList = null;\n    this.dateRanges = void 0;\n    this.live = true;\n    this.ageHeader = 0;\n    this.advancedDateTime = void 0;\n    this.updated = true;\n    this.advanced = true;\n    this.availabilityDelay = void 0;\n    // Manifest reload synchronization\n    this.misses = 0;\n    this.startCC = 0;\n    this.startSN = 0;\n    this.startTimeOffset = null;\n    this.targetduration = 0;\n    this.totalduration = 0;\n    this.type = null;\n    this.url = void 0;\n    this.m3u8 = '';\n    this.version = null;\n    this.canBlockReload = false;\n    this.canSkipUntil = 0;\n    this.canSkipDateRanges = false;\n    this.skippedSegments = 0;\n    this.recentlyRemovedDateranges = void 0;\n    this.partHoldBack = 0;\n    this.holdBack = 0;\n    this.partTarget = 0;\n    this.preloadHint = void 0;\n    this.renditionReports = void 0;\n    this.tuneInGoal = 0;\n    this.deltaUpdateFailed = void 0;\n    this.driftStartTime = 0;\n    this.driftEndTime = 0;\n    this.driftStart = 0;\n    this.driftEnd = 0;\n    this.encryptedFragments = void 0;\n    this.playlistParsingError = null;\n    this.variableList = null;\n    this.hasVariableRefs = false;\n    this.fragments = [];\n    this.encryptedFragments = [];\n    this.dateRanges = {};\n    this.url = baseUrl;\n  }\n  reloaded(previous) {\n    if (!previous) {\n      this.advanced = true;\n      this.updated = true;\n      return;\n    }\n    const partSnDiff = this.lastPartSn - previous.lastPartSn;\n    const partIndexDiff = this.lastPartIndex - previous.lastPartIndex;\n    this.updated = this.endSN !== previous.endSN || !!partIndexDiff || !!partSnDiff || !this.live;\n    this.advanced = this.endSN > previous.endSN || partSnDiff > 0 || partSnDiff === 0 && partIndexDiff > 0;\n    if (this.updated || this.advanced) {\n      this.misses = Math.floor(previous.misses * 0.6);\n    } else {\n      this.misses = previous.misses + 1;\n    }\n    this.availabilityDelay = previous.availabilityDelay;\n  }\n  get hasProgramDateTime() {\n    if (this.fragments.length) {\n      return isFiniteNumber(this.fragments[this.fragments.length - 1].programDateTime);\n    }\n    return false;\n  }\n  get levelTargetDuration() {\n    return this.averagetargetduration || this.targetduration || DEFAULT_TARGET_DURATION;\n  }\n  get drift() {\n    const runTime = this.driftEndTime - this.driftStartTime;\n    if (runTime > 0) {\n      const runDuration = this.driftEnd - this.driftStart;\n      return runDuration * 1000 / runTime;\n    }\n    return 1;\n  }\n  get edge() {\n    return this.partEnd || this.fragmentEnd;\n  }\n  get partEnd() {\n    var _this$partList;\n    if ((_this$partList = this.partList) != null && _this$partList.length) {\n      return this.partList[this.partList.length - 1].end;\n    }\n    return this.fragmentEnd;\n  }\n  get fragmentEnd() {\n    var _this$fragments;\n    if ((_this$fragments = this.fragments) != null && _this$fragments.length) {\n      return this.fragments[this.fragments.length - 1].end;\n    }\n    return 0;\n  }\n  get age() {\n    if (this.advancedDateTime) {\n      return Math.max(Date.now() - this.advancedDateTime, 0) / 1000;\n    }\n    return 0;\n  }\n  get lastPartIndex() {\n    var _this$partList2;\n    if ((_this$partList2 = this.partList) != null && _this$partList2.length) {\n      return this.partList[this.partList.length - 1].index;\n    }\n    return -1;\n  }\n  get lastPartSn() {\n    var _this$partList3;\n    if ((_this$partList3 = this.partList) != null && _this$partList3.length) {\n      return this.partList[this.partList.length - 1].fragment.sn;\n    }\n    return this.endSN;\n  }\n}\n\nfunction base64Decode(base64encodedStr) {\n  return Uint8Array.from(atob(base64encodedStr), c => c.charCodeAt(0));\n}\n\nfunction getKeyIdBytes(str) {\n  const keyIdbytes = strToUtf8array(str).subarray(0, 16);\n  const paddedkeyIdbytes = new Uint8Array(16);\n  paddedkeyIdbytes.set(keyIdbytes, 16 - keyIdbytes.length);\n  return paddedkeyIdbytes;\n}\nfunction changeEndianness(keyId) {\n  const swap = function swap(array, from, to) {\n    const cur = array[from];\n    array[from] = array[to];\n    array[to] = cur;\n  };\n  swap(keyId, 0, 3);\n  swap(keyId, 1, 2);\n  swap(keyId, 4, 5);\n  swap(keyId, 6, 7);\n}\nfunction convertDataUriToArrayBytes(uri) {\n  // data:[<media type][;attribute=value][;base64],<data>\n  const colonsplit = uri.split(':');\n  let keydata = null;\n  if (colonsplit[0] === 'data' && colonsplit.length === 2) {\n    const semicolonsplit = colonsplit[1].split(';');\n    const commasplit = semicolonsplit[semicolonsplit.length - 1].split(',');\n    if (commasplit.length === 2) {\n      const isbase64 = commasplit[0] === 'base64';\n      const data = commasplit[1];\n      if (isbase64) {\n        semicolonsplit.splice(-1, 1); // remove from processing\n        keydata = base64Decode(data);\n      } else {\n        keydata = getKeyIdBytes(data);\n      }\n    }\n  }\n  return keydata;\n}\nfunction strToUtf8array(str) {\n  return Uint8Array.from(unescape(encodeURIComponent(str)), c => c.charCodeAt(0));\n}\n\n/** returns `undefined` is `self` is missing, e.g. in node */\nconst optionalSelf = typeof self !== 'undefined' ? self : undefined;\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Navigator/requestMediaKeySystemAccess\n */\nvar KeySystems = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.fps\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"com.widevine.alpha\"\n};\n\n// Playlist #EXT-X-KEY KEYFORMAT values\nvar KeySystemFormats = {\n  CLEARKEY: \"org.w3.clearkey\",\n  FAIRPLAY: \"com.apple.streamingkeydelivery\",\n  PLAYREADY: \"com.microsoft.playready\",\n  WIDEVINE: \"urn:uuid:edef8ba9-79d6-4ace-a3c8-27dcd51d21ed\"\n};\nfunction keySystemFormatToKeySystemDomain(format) {\n  switch (format) {\n    case KeySystemFormats.FAIRPLAY:\n      return KeySystems.FAIRPLAY;\n    case KeySystemFormats.PLAYREADY:\n      return KeySystems.PLAYREADY;\n    case KeySystemFormats.WIDEVINE:\n      return KeySystems.WIDEVINE;\n    case KeySystemFormats.CLEARKEY:\n      return KeySystems.CLEARKEY;\n  }\n}\n\n// System IDs for which we can extract a key ID from \"encrypted\" event PSSH\nvar KeySystemIds = {\n  CENC: \"1077efecc0b24d02ace33c1e52e2fb4b\",\n  CLEARKEY: \"e2719d58a985b3c9781ab030af78d30e\",\n  FAIRPLAY: \"94ce86fb07ff4f43adb893d2fa968ca2\",\n  PLAYREADY: \"9a04f07998404286ab92e65be0885f95\",\n  WIDEVINE: \"edef8ba979d64acea3c827dcd51d21ed\"\n};\nfunction keySystemIdToKeySystemDomain(systemId) {\n  if (systemId === KeySystemIds.WIDEVINE) {\n    return KeySystems.WIDEVINE;\n  } else if (systemId === KeySystemIds.PLAYREADY) {\n    return KeySystems.PLAYREADY;\n  } else if (systemId === KeySystemIds.CENC || systemId === KeySystemIds.CLEARKEY) {\n    return KeySystems.CLEARKEY;\n  }\n}\nfunction keySystemDomainToKeySystemFormat(keySystem) {\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      return KeySystemFormats.FAIRPLAY;\n    case KeySystems.PLAYREADY:\n      return KeySystemFormats.PLAYREADY;\n    case KeySystems.WIDEVINE:\n      return KeySystemFormats.WIDEVINE;\n    case KeySystems.CLEARKEY:\n      return KeySystemFormats.CLEARKEY;\n  }\n}\nfunction getKeySystemsForConfig(config) {\n  const {\n    drmSystems,\n    widevineLicenseUrl\n  } = config;\n  const keySystemsToAttempt = drmSystems ? [KeySystems.FAIRPLAY, KeySystems.WIDEVINE, KeySystems.PLAYREADY, KeySystems.CLEARKEY].filter(keySystem => !!drmSystems[keySystem]) : [];\n  if (!keySystemsToAttempt[KeySystems.WIDEVINE] && widevineLicenseUrl) {\n    keySystemsToAttempt.push(KeySystems.WIDEVINE);\n  }\n  return keySystemsToAttempt;\n}\nconst requestMediaKeySystemAccess = function (_optionalSelf$navigat) {\n  if (optionalSelf != null && (_optionalSelf$navigat = optionalSelf.navigator) != null && _optionalSelf$navigat.requestMediaKeySystemAccess) {\n    return self.navigator.requestMediaKeySystemAccess.bind(self.navigator);\n  } else {\n    return null;\n  }\n}();\n\n/**\n * @see https://developer.mozilla.org/en-US/docs/Web/API/MediaKeySystemConfiguration\n */\nfunction getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, drmSystemOptions) {\n  let initDataTypes;\n  switch (keySystem) {\n    case KeySystems.FAIRPLAY:\n      initDataTypes = ['cenc', 'sinf'];\n      break;\n    case KeySystems.WIDEVINE:\n    case KeySystems.PLAYREADY:\n      initDataTypes = ['cenc'];\n      break;\n    case KeySystems.CLEARKEY:\n      initDataTypes = ['cenc', 'keyids'];\n      break;\n    default:\n      throw new Error(`Unknown key-system: ${keySystem}`);\n  }\n  return createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions);\n}\nfunction createMediaKeySystemConfigurations(initDataTypes, audioCodecs, videoCodecs, drmSystemOptions) {\n  const baseConfig = {\n    initDataTypes: initDataTypes,\n    persistentState: drmSystemOptions.persistentState || 'optional',\n    distinctiveIdentifier: drmSystemOptions.distinctiveIdentifier || 'optional',\n    sessionTypes: drmSystemOptions.sessionTypes || [drmSystemOptions.sessionType || 'temporary'],\n    audioCapabilities: audioCodecs.map(codec => ({\n      contentType: `audio/mp4; codecs=\"${codec}\"`,\n      robustness: drmSystemOptions.audioRobustness || '',\n      encryptionScheme: drmSystemOptions.audioEncryptionScheme || null\n    })),\n    videoCapabilities: videoCodecs.map(codec => ({\n      contentType: `video/mp4; codecs=\"${codec}\"`,\n      robustness: drmSystemOptions.videoRobustness || '',\n      encryptionScheme: drmSystemOptions.videoEncryptionScheme || null\n    }))\n  };\n  return [baseConfig];\n}\n\nfunction sliceUint8(array, start, end) {\n  // @ts-expect-error This polyfills IE11 usage of Uint8Array slice.\n  // It always exists in the TypeScript definition so fails, but it fails at runtime on IE11.\n  return Uint8Array.prototype.slice ? array.slice(start, end) : new Uint8Array(Array.prototype.slice.call(array, start, end));\n}\n\n// breaking up those two types in order to clarify what is happening in the decoding path.\n\n/**\n * Returns true if an ID3 header can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isHeader$2 = (data, offset) => {\n  /*\n   * http://id3.org/id3v2.3.0\n   * [0]     = 'I'\n   * [1]     = 'D'\n   * [2]     = '3'\n   * [3,4]   = {Version}\n   * [5]     = {Flags}\n   * [6-9]   = {ID3 Size}\n   *\n   * An ID3v2 tag can be detected with the following pattern:\n   *  $49 44 33 yy yy xx zz zz zz zz\n   * Where yy is less than $FF, xx is the 'flags' byte and zz is less than $80\n   */\n  if (offset + 10 <= data.length) {\n    // look for 'ID3' identifier\n    if (data[offset] === 0x49 && data[offset + 1] === 0x44 && data[offset + 2] === 0x33) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns true if an ID3 footer can be found at offset in data\n * @param data - The data to search\n * @param offset - The offset at which to start searching\n */\nconst isFooter = (data, offset) => {\n  /*\n   * The footer is a copy of the header, but with a different identifier\n   */\n  if (offset + 10 <= data.length) {\n    // look for '3DI' identifier\n    if (data[offset] === 0x33 && data[offset + 1] === 0x44 && data[offset + 2] === 0x49) {\n      // check version is within range\n      if (data[offset + 3] < 0xff && data[offset + 4] < 0xff) {\n        // check size is within range\n        if (data[offset + 6] < 0x80 && data[offset + 7] < 0x80 && data[offset + 8] < 0x80 && data[offset + 9] < 0x80) {\n          return true;\n        }\n      }\n    }\n  }\n  return false;\n};\n\n/**\n * Returns any adjacent ID3 tags found in data starting at offset, as one block of data\n * @param data - The data to search in\n * @param offset - The offset at which to start searching\n * @returns the block of data containing any ID3 tags found\n * or *undefined* if no header is found at the starting offset\n */\nconst getID3Data = (data, offset) => {\n  const front = offset;\n  let length = 0;\n  while (isHeader$2(data, offset)) {\n    // ID3 header is 10 bytes\n    length += 10;\n    const size = readSize(data, offset + 6);\n    length += size;\n    if (isFooter(data, offset + 10)) {\n      // ID3 footer is 10 bytes\n      length += 10;\n    }\n    offset += length;\n  }\n  if (length > 0) {\n    return data.subarray(front, front + length);\n  }\n  return undefined;\n};\nconst readSize = (data, offset) => {\n  let size = 0;\n  size = (data[offset] & 0x7f) << 21;\n  size |= (data[offset + 1] & 0x7f) << 14;\n  size |= (data[offset + 2] & 0x7f) << 7;\n  size |= data[offset + 3] & 0x7f;\n  return size;\n};\nconst canParse$2 = (data, offset) => {\n  return isHeader$2(data, offset) && readSize(data, offset + 6) + 10 <= data.length - offset;\n};\n\n/**\n * Searches for the Elementary Stream timestamp found in the ID3 data chunk\n * @param data - Block of data containing one or more ID3 tags\n */\nconst getTimeStamp = data => {\n  const frames = getID3Frames(data);\n  for (let i = 0; i < frames.length; i++) {\n    const frame = frames[i];\n    if (isTimeStampFrame(frame)) {\n      return readTimeStamp(frame);\n    }\n  }\n  return undefined;\n};\n\n/**\n * Returns true if the ID3 frame is an Elementary Stream timestamp frame\n */\nconst isTimeStampFrame = frame => {\n  return frame && frame.key === 'PRIV' && frame.info === 'com.apple.streaming.transportStreamTimestamp';\n};\nconst getFrameData = data => {\n  /*\n  Frame ID       $xx xx xx xx (four characters)\n  Size           $xx xx xx xx\n  Flags          $xx xx\n  */\n  const type = String.fromCharCode(data[0], data[1], data[2], data[3]);\n  const size = readSize(data, 4);\n\n  // skip frame id, size, and flags\n  const offset = 10;\n  return {\n    type,\n    size,\n    data: data.subarray(offset, offset + size)\n  };\n};\n\n/**\n * Returns an array of ID3 frames found in all the ID3 tags in the id3Data\n * @param id3Data - The ID3 data containing one or more ID3 tags\n */\nconst getID3Frames = id3Data => {\n  let offset = 0;\n  const frames = [];\n  while (isHeader$2(id3Data, offset)) {\n    const size = readSize(id3Data, offset + 6);\n    // skip past ID3 header\n    offset += 10;\n    const end = offset + size;\n    // loop through frames in the ID3 tag\n    while (offset + 8 < end) {\n      const frameData = getFrameData(id3Data.subarray(offset));\n      const frame = decodeFrame(frameData);\n      if (frame) {\n        frames.push(frame);\n      }\n\n      // skip frame header and frame data\n      offset += frameData.size + 10;\n    }\n    if (isFooter(id3Data, offset)) {\n      offset += 10;\n    }\n  }\n  return frames;\n};\nconst decodeFrame = frame => {\n  if (frame.type === 'PRIV') {\n    return decodePrivFrame(frame);\n  } else if (frame.type[0] === 'W') {\n    return decodeURLFrame(frame);\n  }\n  return decodeTextFrame(frame);\n};\nconst decodePrivFrame = frame => {\n  /*\n  Format: <text string>\\0<binary data>\n  */\n  if (frame.size < 2) {\n    return undefined;\n  }\n  const owner = utf8ArrayToStr(frame.data, true);\n  const privateData = new Uint8Array(frame.data.subarray(owner.length + 1));\n  return {\n    key: frame.type,\n    info: owner,\n    data: privateData.buffer\n  };\n};\nconst decodeTextFrame = frame => {\n  if (frame.size < 2) {\n    return undefined;\n  }\n  if (frame.type === 'TXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{Value}\n    */\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0]   = {Text Encoding}\n  [1-?] = {Value}\n  */\n  const text = utf8ArrayToStr(frame.data.subarray(1));\n  return {\n    key: frame.type,\n    data: text\n  };\n};\nconst decodeURLFrame = frame => {\n  if (frame.type === 'WXXX') {\n    /*\n    Format:\n    [0]   = {Text Encoding}\n    [1-?] = {Description}\\0{URL}\n    */\n    if (frame.size < 2) {\n      return undefined;\n    }\n    let index = 1;\n    const description = utf8ArrayToStr(frame.data.subarray(index), true);\n    index += description.length + 1;\n    const value = utf8ArrayToStr(frame.data.subarray(index));\n    return {\n      key: frame.type,\n      info: description,\n      data: value\n    };\n  }\n  /*\n  Format:\n  [0-?] = {URL}\n  */\n  const url = utf8ArrayToStr(frame.data);\n  return {\n    key: frame.type,\n    data: url\n  };\n};\nconst readTimeStamp = timeStampFrame => {\n  if (timeStampFrame.data.byteLength === 8) {\n    const data = new Uint8Array(timeStampFrame.data);\n    // timestamp is 33 bit expressed as a big-endian eight-octet number,\n    // with the upper 31 bits set to zero.\n    const pts33Bit = data[3] & 0x1;\n    let timestamp = (data[4] << 23) + (data[5] << 15) + (data[6] << 7) + data[7];\n    timestamp /= 45;\n    if (pts33Bit) {\n      timestamp += 47721858.84;\n    } // 2^32 / 90\n\n    return Math.round(timestamp);\n  }\n  return undefined;\n};\n\n// http://stackoverflow.com/questions/8936984/uint8array-to-string-in-javascript/22373197\n// http://www.onicos.com/staff/iz/amuse/javascript/expert/utf.txt\n/* utf.js - UTF-8 <=> UTF-16 convertion\n *\n * Copyright (C) 1999 Masanao Izumo <iz@onicos.co.jp>\n * Version: 1.0\n * LastModified: Dec 25 1999\n * This library is free.  You can redistribute it and/or modify it.\n */\nconst utf8ArrayToStr = (array, exitOnNull = false) => {\n  const decoder = getTextDecoder();\n  if (decoder) {\n    const decoded = decoder.decode(array);\n    if (exitOnNull) {\n      // grab up to the first null\n      const idx = decoded.indexOf('\\0');\n      return idx !== -1 ? decoded.substring(0, idx) : decoded;\n    }\n\n    // remove any null characters\n    return decoded.replace(/\\0/g, '');\n  }\n  const len = array.length;\n  let c;\n  let char2;\n  let char3;\n  let out = '';\n  let i = 0;\n  while (i < len) {\n    c = array[i++];\n    if (c === 0x00 && exitOnNull) {\n      return out;\n    } else if (c === 0x00 || c === 0x03) {\n      // If the character is 3 (END_OF_TEXT) or 0 (NULL) then skip it\n      continue;\n    }\n    switch (c >> 4) {\n      case 0:\n      case 1:\n      case 2:\n      case 3:\n      case 4:\n      case 5:\n      case 6:\n      case 7:\n        // 0xxxxxxx\n        out += String.fromCharCode(c);\n        break;\n      case 12:\n      case 13:\n        // 110x xxxx   10xx xxxx\n        char2 = array[i++];\n        out += String.fromCharCode((c & 0x1f) << 6 | char2 & 0x3f);\n        break;\n      case 14:\n        // 1110 xxxx  10xx xxxx  10xx xxxx\n        char2 = array[i++];\n        char3 = array[i++];\n        out += String.fromCharCode((c & 0x0f) << 12 | (char2 & 0x3f) << 6 | (char3 & 0x3f) << 0);\n        break;\n    }\n  }\n  return out;\n};\nlet decoder;\nfunction getTextDecoder() {\n  // On Play Station 4, TextDecoder is defined but partially implemented.\n  // Manual decoding option is preferable\n  if (navigator.userAgent.includes('PlayStation 4')) {\n    return;\n  }\n  if (!decoder && typeof self.TextDecoder !== 'undefined') {\n    decoder = new self.TextDecoder('utf-8');\n  }\n  return decoder;\n}\n\n/**\n *  hex dump helper class\n */\n\nconst Hex = {\n  hexDump: function (array) {\n    let str = '';\n    for (let i = 0; i < array.length; i++) {\n      let h = array[i].toString(16);\n      if (h.length < 2) {\n        h = '0' + h;\n      }\n      str += h;\n    }\n    return str;\n  }\n};\n\nconst UINT32_MAX$1 = Math.pow(2, 32) - 1;\nconst push = [].push;\n\n// We are using fixed track IDs for driving the MP4 remuxer\n// instead of following the TS PIDs.\n// There is no reason not to do this and some browsers/SourceBuffer-demuxers\n// may not like if there are TrackID \"switches\"\n// See https://github.com/video-dev/hls.js/issues/1331\n// Here we are mapping our internal track types to constant MP4 track IDs\n// With MSE currently one can only have one track of each, and we are muxing\n// whatever video/audio rendition in them.\nconst RemuxerTrackIdConfig = {\n  video: 1,\n  audio: 2,\n  id3: 3,\n  text: 4\n};\nfunction bin2str(data) {\n  return String.fromCharCode.apply(null, data);\n}\nfunction readUint16(buffer, offset) {\n  const val = buffer[offset] << 8 | buffer[offset + 1];\n  return val < 0 ? 65536 + val : val;\n}\nfunction readUint32(buffer, offset) {\n  const val = readSint32(buffer, offset);\n  return val < 0 ? 4294967296 + val : val;\n}\nfunction readUint64(buffer, offset) {\n  let result = readUint32(buffer, offset);\n  result *= Math.pow(2, 32);\n  result += readUint32(buffer, offset + 4);\n  return result;\n}\nfunction readSint32(buffer, offset) {\n  return buffer[offset] << 24 | buffer[offset + 1] << 16 | buffer[offset + 2] << 8 | buffer[offset + 3];\n}\nfunction writeUint32(buffer, offset, value) {\n  buffer[offset] = value >> 24;\n  buffer[offset + 1] = value >> 16 & 0xff;\n  buffer[offset + 2] = value >> 8 & 0xff;\n  buffer[offset + 3] = value & 0xff;\n}\n\n// Find \"moof\" box\nfunction hasMoofData(data) {\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    if (size > 8 && data[i + 4] === 0x6d && data[i + 5] === 0x6f && data[i + 6] === 0x6f && data[i + 7] === 0x66) {\n      return true;\n    }\n    i = size > 1 ? i + size : end;\n  }\n  return false;\n}\n\n// Find the data for a box specified by its path\nfunction findBox(data, path) {\n  const results = [];\n  if (!path.length) {\n    // short-circuit the search for empty paths\n    return results;\n  }\n  const end = data.byteLength;\n  for (let i = 0; i < end;) {\n    const size = readUint32(data, i);\n    const type = bin2str(data.subarray(i + 4, i + 8));\n    const endbox = size > 1 ? i + size : end;\n    if (type === path[0]) {\n      if (path.length === 1) {\n        // this is the end of the path and we've found the box we were\n        // looking for\n        results.push(data.subarray(i + 8, endbox));\n      } else {\n        // recursively search for the next box along the path\n        const subresults = findBox(data.subarray(i + 8, endbox), path.slice(1));\n        if (subresults.length) {\n          push.apply(results, subresults);\n        }\n      }\n    }\n    i = endbox;\n  }\n\n  // we've finished searching all of data\n  return results;\n}\nfunction parseSegmentIndex(sidx) {\n  const references = [];\n  const version = sidx[0];\n\n  // set initial offset, we skip the reference ID (not needed)\n  let index = 8;\n  const timescale = readUint32(sidx, index);\n  index += 4;\n  let earliestPresentationTime = 0;\n  let firstOffset = 0;\n  if (version === 0) {\n    earliestPresentationTime = readUint32(sidx, index);\n    firstOffset = readUint32(sidx, index + 4);\n    index += 8;\n  } else {\n    earliestPresentationTime = readUint64(sidx, index);\n    firstOffset = readUint64(sidx, index + 8);\n    index += 16;\n  }\n\n  // skip reserved\n  index += 2;\n  let startByte = sidx.length + firstOffset;\n  const referencesCount = readUint16(sidx, index);\n  index += 2;\n  for (let i = 0; i < referencesCount; i++) {\n    let referenceIndex = index;\n    const referenceInfo = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    const referenceSize = referenceInfo & 0x7fffffff;\n    const referenceType = (referenceInfo & 0x80000000) >>> 31;\n    if (referenceType === 1) {\n      logger.warn('SIDX has hierarchical references (not supported)');\n      return null;\n    }\n    const subsegmentDuration = readUint32(sidx, referenceIndex);\n    referenceIndex += 4;\n    references.push({\n      referenceSize,\n      subsegmentDuration,\n      // unscaled\n      info: {\n        duration: subsegmentDuration / timescale,\n        start: startByte,\n        end: startByte + referenceSize - 1\n      }\n    });\n    startByte += referenceSize;\n\n    // Skipping 1 bit for |startsWithSap|, 3 bits for |sapType|, and 28 bits\n    // for |sapDelta|.\n    referenceIndex += 4;\n\n    // skip to next ref\n    index = referenceIndex;\n  }\n  return {\n    earliestPresentationTime,\n    timescale,\n    version,\n    referencesCount,\n    references\n  };\n}\n\n/**\n * Parses an MP4 initialization segment and extracts stream type and\n * timescale values for any declared tracks. Timescale values indicate the\n * number of clock ticks per second to assume for time-based values\n * elsewhere in the MP4.\n *\n * To determine the start time of an MP4, you need two pieces of\n * information: the timescale unit and the earliest base media decode\n * time. Multiple timescales can be specified within an MP4 but the\n * base media decode time is always expressed in the timescale from\n * the media header box for the track:\n * ```\n * moov > trak > mdia > mdhd.timescale\n * moov > trak > mdia > hdlr\n * ```\n * @param initSegment the bytes of the init segment\n * @returns a hash of track type to timescale values or null if\n * the init segment is malformed.\n */\n\nfunction parseInitSegment(initSegment) {\n  const result = [];\n  const traks = findBox(initSegment, ['moov', 'trak']);\n  for (let i = 0; i < traks.length; i++) {\n    const trak = traks[i];\n    const tkhd = findBox(trak, ['tkhd'])[0];\n    if (tkhd) {\n      let version = tkhd[0];\n      const trackId = readUint32(tkhd, version === 0 ? 12 : 20);\n      const mdhd = findBox(trak, ['mdia', 'mdhd'])[0];\n      if (mdhd) {\n        version = mdhd[0];\n        const timescale = readUint32(mdhd, version === 0 ? 12 : 20);\n        const hdlr = findBox(trak, ['mdia', 'hdlr'])[0];\n        if (hdlr) {\n          const hdlrType = bin2str(hdlr.subarray(8, 12));\n          const type = {\n            soun: ElementaryStreamTypes.AUDIO,\n            vide: ElementaryStreamTypes.VIDEO\n          }[hdlrType];\n          if (type) {\n            // Parse codec details\n            const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n            const stsdData = parseStsd(stsd);\n            result[trackId] = {\n              timescale,\n              type\n            };\n            result[type] = _objectSpread2({\n              timescale,\n              id: trackId\n            }, stsdData);\n          }\n        }\n      }\n    }\n  }\n  const trex = findBox(initSegment, ['moov', 'mvex', 'trex']);\n  trex.forEach(trex => {\n    const trackId = readUint32(trex, 4);\n    const track = result[trackId];\n    if (track) {\n      track.default = {\n        duration: readUint32(trex, 12),\n        flags: readUint32(trex, 20)\n      };\n    }\n  });\n  return result;\n}\nfunction parseStsd(stsd) {\n  const sampleEntries = stsd.subarray(8);\n  const sampleEntriesEnd = sampleEntries.subarray(8 + 78);\n  const fourCC = bin2str(sampleEntries.subarray(4, 8));\n  let codec = fourCC;\n  const encrypted = fourCC === 'enca' || fourCC === 'encv';\n  if (encrypted) {\n    const encBox = findBox(sampleEntries, [fourCC])[0];\n    const encBoxChildren = encBox.subarray(fourCC === 'enca' ? 28 : 78);\n    const sinfs = findBox(encBoxChildren, ['sinf']);\n    sinfs.forEach(sinf => {\n      const schm = findBox(sinf, ['schm'])[0];\n      if (schm) {\n        const scheme = bin2str(schm.subarray(4, 8));\n        if (scheme === 'cbcs' || scheme === 'cenc') {\n          const frma = findBox(sinf, ['frma'])[0];\n          if (frma) {\n            // for encrypted content codec fourCC will be in frma\n            codec = bin2str(frma);\n          }\n        }\n      }\n    });\n  }\n  switch (codec) {\n    case 'avc1':\n    case 'avc2':\n    case 'avc3':\n    case 'avc4':\n      {\n        // extract profile + compatibility + level out of avcC box\n        const avcCBox = findBox(sampleEntriesEnd, ['avcC'])[0];\n        codec += '.' + toHex(avcCBox[1]) + toHex(avcCBox[2]) + toHex(avcCBox[3]);\n        break;\n      }\n    case 'mp4a':\n      {\n        const codecBox = findBox(sampleEntries, [fourCC])[0];\n        const esdsBox = findBox(codecBox.subarray(28), ['esds'])[0];\n        if (esdsBox && esdsBox.length > 12) {\n          let i = 4;\n          // ES Descriptor tag\n          if (esdsBox[i++] !== 0x03) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          i += 2; // skip es_id;\n          const flags = esdsBox[i++];\n          if (flags & 0x80) {\n            i += 2; // skip dependency es_id\n          }\n          if (flags & 0x40) {\n            i += esdsBox[i++]; // skip URL\n          }\n          // Decoder config descriptor\n          if (esdsBox[i++] !== 0x04) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const objectType = esdsBox[i++];\n          if (objectType === 0x40) {\n            codec += '.' + toHex(objectType);\n          } else {\n            break;\n          }\n          i += 12;\n          // Decoder specific info\n          if (esdsBox[i++] !== 0x05) {\n            break;\n          }\n          i = skipBERInteger(esdsBox, i);\n          const firstByte = esdsBox[i++];\n          let audioObjectType = (firstByte & 0xf8) >> 3;\n          if (audioObjectType === 31) {\n            audioObjectType += 1 + ((firstByte & 0x7) << 3) + ((esdsBox[i] & 0xe0) >> 5);\n          }\n          codec += '.' + audioObjectType;\n        }\n        break;\n      }\n    case 'hvc1':\n    case 'hev1':\n      {\n        const hvcCBox = findBox(sampleEntriesEnd, ['hvcC'])[0];\n        const profileByte = hvcCBox[1];\n        const profileSpace = ['', 'A', 'B', 'C'][profileByte >> 6];\n        const generalProfileIdc = profileByte & 0x1f;\n        const profileCompat = readUint32(hvcCBox, 2);\n        const tierFlag = (profileByte & 0x20) >> 5 ? 'H' : 'L';\n        const levelIDC = hvcCBox[12];\n        const constraintIndicator = hvcCBox.subarray(6, 12);\n        codec += '.' + profileSpace + generalProfileIdc;\n        codec += '.' + profileCompat.toString(16).toUpperCase();\n        codec += '.' + tierFlag + levelIDC;\n        let constraintString = '';\n        for (let i = constraintIndicator.length; i--;) {\n          const byte = constraintIndicator[i];\n          if (byte || constraintString) {\n            const encodedByte = byte.toString(16).toUpperCase();\n            constraintString = '.' + encodedByte + constraintString;\n          }\n        }\n        codec += constraintString;\n        break;\n      }\n    case 'dvh1':\n    case 'dvhe':\n      {\n        const dvcCBox = findBox(sampleEntriesEnd, ['dvcC'])[0];\n        const profile = dvcCBox[2] >> 1 & 0x7f;\n        const level = dvcCBox[2] << 5 & 0x20 | dvcCBox[3] >> 3 & 0x1f;\n        codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level);\n        break;\n      }\n    case 'vp09':\n      {\n        const vpcCBox = findBox(sampleEntriesEnd, ['vpcC'])[0];\n        const profile = vpcCBox[4];\n        const level = vpcCBox[5];\n        const bitDepth = vpcCBox[6] >> 4 & 0x0f;\n        codec += '.' + addLeadingZero(profile) + '.' + addLeadingZero(level) + '.' + addLeadingZero(bitDepth);\n        break;\n      }\n    case 'av01':\n      {\n        const av1CBox = findBox(sampleEntriesEnd, ['av1C'])[0];\n        const profile = av1CBox[1] >>> 5;\n        const level = av1CBox[1] & 0x1f;\n        const tierFlag = av1CBox[2] >>> 7 ? 'H' : 'M';\n        const highBitDepth = (av1CBox[2] & 0x40) >> 6;\n        const twelveBit = (av1CBox[2] & 0x20) >> 5;\n        const bitDepth = profile === 2 && highBitDepth ? twelveBit ? 12 : 10 : highBitDepth ? 10 : 8;\n        const monochrome = (av1CBox[2] & 0x10) >> 4;\n        const chromaSubsamplingX = (av1CBox[2] & 0x08) >> 3;\n        const chromaSubsamplingY = (av1CBox[2] & 0x04) >> 2;\n        const chromaSamplePosition = av1CBox[2] & 0x03;\n        // TODO: parse color_description_present_flag\n        // default it to BT.709/limited range for now\n        // more info https://aomediacodec.github.io/av1-isobmff/#av1codecconfigurationbox-syntax\n        const colorPrimaries = 1;\n        const transferCharacteristics = 1;\n        const matrixCoefficients = 1;\n        const videoFullRangeFlag = 0;\n        codec += '.' + profile + '.' + addLeadingZero(level) + tierFlag + '.' + addLeadingZero(bitDepth) + '.' + monochrome + '.' + chromaSubsamplingX + chromaSubsamplingY + chromaSamplePosition + '.' + addLeadingZero(colorPrimaries) + '.' + addLeadingZero(transferCharacteristics) + '.' + addLeadingZero(matrixCoefficients) + '.' + videoFullRangeFlag;\n        break;\n      }\n  }\n  return {\n    codec,\n    encrypted\n  };\n}\nfunction skipBERInteger(bytes, i) {\n  const limit = i + 5;\n  while (bytes[i++] & 0x80 && i < limit) {}\n  return i;\n}\nfunction toHex(x) {\n  return ('0' + x.toString(16).toUpperCase()).slice(-2);\n}\nfunction addLeadingZero(num) {\n  return (num < 10 ? '0' : '') + num;\n}\nfunction patchEncyptionData(initSegment, decryptdata) {\n  if (!initSegment || !decryptdata) {\n    return initSegment;\n  }\n  const keyId = decryptdata.keyId;\n  if (keyId && decryptdata.isCommonEncryption) {\n    const traks = findBox(initSegment, ['moov', 'trak']);\n    traks.forEach(trak => {\n      const stsd = findBox(trak, ['mdia', 'minf', 'stbl', 'stsd'])[0];\n\n      // skip the sample entry count\n      const sampleEntries = stsd.subarray(8);\n      let encBoxes = findBox(sampleEntries, ['enca']);\n      const isAudio = encBoxes.length > 0;\n      if (!isAudio) {\n        encBoxes = findBox(sampleEntries, ['encv']);\n      }\n      encBoxes.forEach(enc => {\n        const encBoxChildren = isAudio ? enc.subarray(28) : enc.subarray(78);\n        const sinfBoxes = findBox(encBoxChildren, ['sinf']);\n        sinfBoxes.forEach(sinf => {\n          const tenc = parseSinf(sinf);\n          if (tenc) {\n            // Look for default key id (keyID offset is always 8 within the tenc box):\n            const tencKeyId = tenc.subarray(8, 24);\n            if (!tencKeyId.some(b => b !== 0)) {\n              logger.log(`[eme] Patching keyId in 'enc${isAudio ? 'a' : 'v'}>sinf>>tenc' box: ${Hex.hexDump(tencKeyId)} -> ${Hex.hexDump(keyId)}`);\n              tenc.set(keyId, 8);\n            }\n          }\n        });\n      });\n    });\n  }\n  return initSegment;\n}\nfunction parseSinf(sinf) {\n  const schm = findBox(sinf, ['schm'])[0];\n  if (schm) {\n    const scheme = bin2str(schm.subarray(4, 8));\n    if (scheme === 'cbcs' || scheme === 'cenc') {\n      return findBox(sinf, ['schi', 'tenc'])[0];\n    }\n  }\n  return null;\n}\n\n/**\n * Determine the base media decode start time, in seconds, for an MP4\n * fragment. If multiple fragments are specified, the earliest time is\n * returned.\n *\n * The base media decode time can be parsed from track fragment\n * metadata:\n * ```\n * moof > traf > tfdt.baseMediaDecodeTime\n * ```\n * It requires the timescale value from the mdhd to interpret.\n *\n * @param initData - a hash of track type to timescale values\n * @param fmp4 - the bytes of the mp4 fragment\n * @returns the earliest base media decode start time for the\n * fragment, in seconds\n */\nfunction getStartDTS(initData, fmp4) {\n  // we need info from two children of each track fragment box\n  return findBox(fmp4, ['moof', 'traf']).reduce((result, traf) => {\n    const tfdt = findBox(traf, ['tfdt'])[0];\n    const version = tfdt[0];\n    const start = findBox(traf, ['tfhd']).reduce((result, tfhd) => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (track) {\n        let baseTime = readUint32(tfdt, 4);\n        if (version === 1) {\n          // If value is too large, assume signed 64-bit. Negative track fragment decode times are invalid, but they exist in the wild.\n          // This prevents large values from being used for initPTS, which can cause playlist sync issues.\n          // https://github.com/video-dev/hls.js/issues/5303\n          if (baseTime === UINT32_MAX$1) {\n            logger.warn(`[mp4-demuxer]: Ignoring assumed invalid signed 64-bit track fragment decode time`);\n            return result;\n          }\n          baseTime *= UINT32_MAX$1 + 1;\n          baseTime += readUint32(tfdt, 8);\n        }\n        // assume a 90kHz clock if no timescale was specified\n        const scale = track.timescale || 90e3;\n        // convert base time to seconds\n        const startTime = baseTime / scale;\n        if (isFiniteNumber(startTime) && (result === null || startTime < result)) {\n          return startTime;\n        }\n      }\n      return result;\n    }, null);\n    if (start !== null && isFiniteNumber(start) && (result === null || start < result)) {\n      return start;\n    }\n    return result;\n  }, null);\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackFragmentHeaderBox\n           extends FullBox(tfhd, 0, tf_flags){\n     unsigned int(32)  track_ID;\n     // all the following are optional fields\n     unsigned int(64)  base_data_offset;\n     unsigned int(32)  sample_description_index;\n     unsigned int(32)  default_sample_duration;\n     unsigned int(32)  default_sample_size;\n     unsigned int(32)  default_sample_flags\n  }\n */\nfunction getDuration(data, initData) {\n  let rawDuration = 0;\n  let videoDuration = 0;\n  let audioDuration = 0;\n  const trafs = findBox(data, ['moof', 'traf']);\n  for (let i = 0; i < trafs.length; i++) {\n    const traf = trafs[i];\n    // There is only one tfhd & trun per traf\n    // This is true for CMAF style content, and we should perhaps check the ftyp\n    // and only look for a single trun then, but for ISOBMFF we should check\n    // for multiple track runs.\n    const tfhd = findBox(traf, ['tfhd'])[0];\n    // get the track id from the tfhd\n    const id = readUint32(tfhd, 4);\n    const track = initData[id];\n    if (!track) {\n      continue;\n    }\n    const trackDefault = track.default;\n    const tfhdFlags = readUint32(tfhd, 0) | (trackDefault == null ? void 0 : trackDefault.flags);\n    let sampleDuration = trackDefault == null ? void 0 : trackDefault.duration;\n    if (tfhdFlags & 0x000008) {\n      // 0x000008 indicates the presence of the default_sample_duration field\n      if (tfhdFlags & 0x000002) {\n        // 0x000002 indicates the presence of the sample_description_index field, which precedes default_sample_duration\n        // If present, the default_sample_duration exists at byte offset 12\n        sampleDuration = readUint32(tfhd, 12);\n      } else {\n        // Otherwise, the duration is at byte offset 8\n        sampleDuration = readUint32(tfhd, 8);\n      }\n    }\n    // assume a 90kHz clock if no timescale was specified\n    const timescale = track.timescale || 90e3;\n    const truns = findBox(traf, ['trun']);\n    for (let j = 0; j < truns.length; j++) {\n      rawDuration = computeRawDurationFromSamples(truns[j]);\n      if (!rawDuration && sampleDuration) {\n        const sampleCount = readUint32(truns[j], 4);\n        rawDuration = sampleDuration * sampleCount;\n      }\n      if (track.type === ElementaryStreamTypes.VIDEO) {\n        videoDuration += rawDuration / timescale;\n      } else if (track.type === ElementaryStreamTypes.AUDIO) {\n        audioDuration += rawDuration / timescale;\n      }\n    }\n  }\n  if (videoDuration === 0 && audioDuration === 0) {\n    // If duration samples are not available in the traf use sidx subsegment_duration\n    let sidxMinStart = Infinity;\n    let sidxMaxEnd = 0;\n    let sidxDuration = 0;\n    const sidxs = findBox(data, ['sidx']);\n    for (let i = 0; i < sidxs.length; i++) {\n      const sidx = parseSegmentIndex(sidxs[i]);\n      if (sidx != null && sidx.references) {\n        sidxMinStart = Math.min(sidxMinStart, sidx.earliestPresentationTime / sidx.timescale);\n        const subSegmentDuration = sidx.references.reduce((dur, ref) => dur + ref.info.duration || 0, 0);\n        sidxMaxEnd = Math.max(sidxMaxEnd, subSegmentDuration + sidx.earliestPresentationTime / sidx.timescale);\n        sidxDuration = sidxMaxEnd - sidxMinStart;\n      }\n    }\n    if (sidxDuration && isFiniteNumber(sidxDuration)) {\n      return sidxDuration;\n    }\n  }\n  if (videoDuration) {\n    return videoDuration;\n  }\n  return audioDuration;\n}\n\n/*\n  For Reference:\n  aligned(8) class TrackRunBox\n           extends FullBox(trun, version, tr_flags) {\n     unsigned int(32)  sample_count;\n     // the following are optional fields\n     signed int(32) data_offset;\n     unsigned int(32)  first_sample_flags;\n     // all fields in the following array are optional\n     {\n        unsigned int(32)  sample_duration;\n        unsigned int(32)  sample_size;\n        unsigned int(32)  sample_flags\n        if (version == 0)\n           { unsigned int(32)\n        else\n           { signed int(32)\n     }[ sample_count ]\n  }\n */\nfunction computeRawDurationFromSamples(trun) {\n  const flags = readUint32(trun, 0);\n  // Flags are at offset 0, non-optional sample_count is at offset 4. Therefore we start 8 bytes in.\n  // Each field is an int32, which is 4 bytes\n  let offset = 8;\n  // data-offset-present flag\n  if (flags & 0x000001) {\n    offset += 4;\n  }\n  // first-sample-flags-present flag\n  if (flags & 0x000004) {\n    offset += 4;\n  }\n  let duration = 0;\n  const sampleCount = readUint32(trun, 4);\n  for (let i = 0; i < sampleCount; i++) {\n    // sample-duration-present flag\n    if (flags & 0x000100) {\n      const sampleDuration = readUint32(trun, offset);\n      duration += sampleDuration;\n      offset += 4;\n    }\n    // sample-size-present flag\n    if (flags & 0x000200) {\n      offset += 4;\n    }\n    // sample-flags-present flag\n    if (flags & 0x000400) {\n      offset += 4;\n    }\n    // sample-composition-time-offsets-present flag\n    if (flags & 0x000800) {\n      offset += 4;\n    }\n  }\n  return duration;\n}\nfunction offsetStartDTS(initData, fmp4, timeOffset) {\n  findBox(fmp4, ['moof', 'traf']).forEach(traf => {\n    findBox(traf, ['tfhd']).forEach(tfhd => {\n      // get the track id from the tfhd\n      const id = readUint32(tfhd, 4);\n      const track = initData[id];\n      if (!track) {\n        return;\n      }\n      // assume a 90kHz clock if no timescale was specified\n      const timescale = track.timescale || 90e3;\n      // get the base media decode time from the tfdt\n      findBox(traf, ['tfdt']).forEach(tfdt => {\n        const version = tfdt[0];\n        const offset = timeOffset * timescale;\n        if (offset) {\n          let baseMediaDecodeTime = readUint32(tfdt, 4);\n          if (version === 0) {\n            baseMediaDecodeTime -= offset;\n            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n            writeUint32(tfdt, 4, baseMediaDecodeTime);\n          } else {\n            baseMediaDecodeTime *= Math.pow(2, 32);\n            baseMediaDecodeTime += readUint32(tfdt, 8);\n            baseMediaDecodeTime -= offset;\n            baseMediaDecodeTime = Math.max(baseMediaDecodeTime, 0);\n            const upper = Math.floor(baseMediaDecodeTime / (UINT32_MAX$1 + 1));\n            const lower = Math.floor(baseMediaDecodeTime % (UINT32_MAX$1 + 1));\n            writeUint32(tfdt, 4, upper);\n            writeUint32(tfdt, 8, lower);\n          }\n        }\n      });\n    });\n  });\n}\n\n// TODO: Check if the last moof+mdat pair is part of the valid range\nfunction segmentValidRange(data) {\n  const segmentedRange = {\n    valid: null,\n    remainder: null\n  };\n  const moofs = findBox(data, ['moof']);\n  if (moofs.length < 2) {\n    segmentedRange.remainder = data;\n    return segmentedRange;\n  }\n  const last = moofs[moofs.length - 1];\n  // Offset by 8 bytes; findBox offsets the start by as much\n  segmentedRange.valid = sliceUint8(data, 0, last.byteOffset - 8);\n  segmentedRange.remainder = sliceUint8(data, last.byteOffset - 8);\n  return segmentedRange;\n}\nfunction appendUint8Array(data1, data2) {\n  const temp = new Uint8Array(data1.length + data2.length);\n  temp.set(data1);\n  temp.set(data2, data1.length);\n  return temp;\n}\nfunction parseSamples(timeOffset, track) {\n  const seiSamples = [];\n  const videoData = track.samples;\n  const timescale = track.timescale;\n  const trackId = track.id;\n  let isHEVCFlavor = false;\n  const moofs = findBox(videoData, ['moof']);\n  moofs.map(moof => {\n    const moofOffset = moof.byteOffset - 8;\n    const trafs = findBox(moof, ['traf']);\n    trafs.map(traf => {\n      // get the base media decode time from the tfdt\n      const baseTime = findBox(traf, ['tfdt']).map(tfdt => {\n        const version = tfdt[0];\n        let result = readUint32(tfdt, 4);\n        if (version === 1) {\n          result *= Math.pow(2, 32);\n          result += readUint32(tfdt, 8);\n        }\n        return result / timescale;\n      })[0];\n      if (baseTime !== undefined) {\n        timeOffset = baseTime;\n      }\n      return findBox(traf, ['tfhd']).map(tfhd => {\n        const id = readUint32(tfhd, 4);\n        const tfhdFlags = readUint32(tfhd, 0) & 0xffffff;\n        const baseDataOffsetPresent = (tfhdFlags & 0x000001) !== 0;\n        const sampleDescriptionIndexPresent = (tfhdFlags & 0x000002) !== 0;\n        const defaultSampleDurationPresent = (tfhdFlags & 0x000008) !== 0;\n        let defaultSampleDuration = 0;\n        const defaultSampleSizePresent = (tfhdFlags & 0x000010) !== 0;\n        let defaultSampleSize = 0;\n        const defaultSampleFlagsPresent = (tfhdFlags & 0x000020) !== 0;\n        let tfhdOffset = 8;\n        if (id === trackId) {\n          if (baseDataOffsetPresent) {\n            tfhdOffset += 8;\n          }\n          if (sampleDescriptionIndexPresent) {\n            tfhdOffset += 4;\n          }\n          if (defaultSampleDurationPresent) {\n            defaultSampleDuration = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleSizePresent) {\n            defaultSampleSize = readUint32(tfhd, tfhdOffset);\n            tfhdOffset += 4;\n          }\n          if (defaultSampleFlagsPresent) {\n            tfhdOffset += 4;\n          }\n          if (track.type === 'video') {\n            isHEVCFlavor = isHEVC(track.codec);\n          }\n          findBox(traf, ['trun']).map(trun => {\n            const version = trun[0];\n            const flags = readUint32(trun, 0) & 0xffffff;\n            const dataOffsetPresent = (flags & 0x000001) !== 0;\n            let dataOffset = 0;\n            const firstSampleFlagsPresent = (flags & 0x000004) !== 0;\n            const sampleDurationPresent = (flags & 0x000100) !== 0;\n            let sampleDuration = 0;\n            const sampleSizePresent = (flags & 0x000200) !== 0;\n            let sampleSize = 0;\n            const sampleFlagsPresent = (flags & 0x000400) !== 0;\n            const sampleCompositionOffsetsPresent = (flags & 0x000800) !== 0;\n            let compositionOffset = 0;\n            const sampleCount = readUint32(trun, 4);\n            let trunOffset = 8; // past version, flags, and sample count\n\n            if (dataOffsetPresent) {\n              dataOffset = readUint32(trun, trunOffset);\n              trunOffset += 4;\n            }\n            if (firstSampleFlagsPresent) {\n              trunOffset += 4;\n            }\n            let sampleOffset = dataOffset + moofOffset;\n            for (let ix = 0; ix < sampleCount; ix++) {\n              if (sampleDurationPresent) {\n                sampleDuration = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleDuration = defaultSampleDuration;\n              }\n              if (sampleSizePresent) {\n                sampleSize = readUint32(trun, trunOffset);\n                trunOffset += 4;\n              } else {\n                sampleSize = defaultSampleSize;\n              }\n              if (sampleFlagsPresent) {\n                trunOffset += 4;\n              }\n              if (sampleCompositionOffsetsPresent) {\n                if (version === 0) {\n                  compositionOffset = readUint32(trun, trunOffset);\n                } else {\n                  compositionOffset = readSint32(trun, trunOffset);\n                }\n                trunOffset += 4;\n              }\n              if (track.type === ElementaryStreamTypes.VIDEO) {\n                let naluTotalSize = 0;\n                while (naluTotalSize < sampleSize) {\n                  const naluSize = readUint32(videoData, sampleOffset);\n                  sampleOffset += 4;\n                  if (isSEIMessage(isHEVCFlavor, videoData[sampleOffset])) {\n                    const data = videoData.subarray(sampleOffset, sampleOffset + naluSize);\n                    parseSEIMessageFromNALu(data, isHEVCFlavor ? 2 : 1, timeOffset + compositionOffset / timescale, seiSamples);\n                  }\n                  sampleOffset += naluSize;\n                  naluTotalSize += naluSize + 4;\n                }\n              }\n              timeOffset += sampleDuration / timescale;\n            }\n          });\n        }\n      });\n    });\n  });\n  return seiSamples;\n}\nfunction isHEVC(codec) {\n  if (!codec) {\n    return false;\n  }\n  const delimit = codec.indexOf('.');\n  const baseCodec = delimit < 0 ? codec : codec.substring(0, delimit);\n  return baseCodec === 'hvc1' || baseCodec === 'hev1' ||\n  // Dolby Vision\n  baseCodec === 'dvh1' || baseCodec === 'dvhe';\n}\nfunction isSEIMessage(isHEVCFlavor, naluHeader) {\n  if (isHEVCFlavor) {\n    const naluType = naluHeader >> 1 & 0x3f;\n    return naluType === 39 || naluType === 40;\n  } else {\n    const naluType = naluHeader & 0x1f;\n    return naluType === 6;\n  }\n}\nfunction parseSEIMessageFromNALu(unescapedData, headerSize, pts, samples) {\n  const data = discardEPB(unescapedData);\n  let seiPtr = 0;\n  // skip nal header\n  seiPtr += headerSize;\n  let payloadType = 0;\n  let payloadSize = 0;\n  let b = 0;\n  while (seiPtr < data.length) {\n    payloadType = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadType += b;\n    } while (b === 0xff);\n\n    // Parse payload size.\n    payloadSize = 0;\n    do {\n      if (seiPtr >= data.length) {\n        break;\n      }\n      b = data[seiPtr++];\n      payloadSize += b;\n    } while (b === 0xff);\n    const leftOver = data.length - seiPtr;\n    // Create a variable to process the payload\n    let payPtr = seiPtr;\n\n    // Increment the seiPtr to the end of the payload\n    if (payloadSize < leftOver) {\n      seiPtr += payloadSize;\n    } else if (payloadSize > leftOver) {\n      // Some type of corruption has happened?\n      logger.error(`Malformed SEI payload. ${payloadSize} is too small, only ${leftOver} bytes left to parse.`);\n      // We might be able to parse some data, but let's be safe and ignore it.\n      break;\n    }\n    if (payloadType === 4) {\n      const countryCode = data[payPtr++];\n      if (countryCode === 181) {\n        const providerCode = readUint16(data, payPtr);\n        payPtr += 2;\n        if (providerCode === 49) {\n          const userStructure = readUint32(data, payPtr);\n          payPtr += 4;\n          if (userStructure === 0x47413934) {\n            const userDataType = data[payPtr++];\n\n            // Raw CEA-608 bytes wrapped in CEA-708 packet\n            if (userDataType === 3) {\n              const firstByte = data[payPtr++];\n              const totalCCs = 0x1f & firstByte;\n              const enabled = 0x40 & firstByte;\n              const totalBytes = enabled ? 2 + totalCCs * 3 : 0;\n              const byteArray = new Uint8Array(totalBytes);\n              if (enabled) {\n                byteArray[0] = firstByte;\n                for (let i = 1; i < totalBytes; i++) {\n                  byteArray[i] = data[payPtr++];\n                }\n              }\n              samples.push({\n                type: userDataType,\n                payloadType,\n                pts,\n                bytes: byteArray\n              });\n            }\n          }\n        }\n      }\n    } else if (payloadType === 5) {\n      if (payloadSize > 16) {\n        const uuidStrArray = [];\n        for (let i = 0; i < 16; i++) {\n          const _b = data[payPtr++].toString(16);\n          uuidStrArray.push(_b.length == 1 ? '0' + _b : _b);\n          if (i === 3 || i === 5 || i === 7 || i === 9) {\n            uuidStrArray.push('-');\n          }\n        }\n        const length = payloadSize - 16;\n        const userDataBytes = new Uint8Array(length);\n        for (let i = 0; i < length; i++) {\n          userDataBytes[i] = data[payPtr++];\n        }\n        samples.push({\n          payloadType,\n          pts,\n          uuid: uuidStrArray.join(''),\n          userData: utf8ArrayToStr(userDataBytes),\n          userDataBytes\n        });\n      }\n    }\n  }\n}\n\n/**\n * remove Emulation Prevention bytes from a RBSP\n */\nfunction discardEPB(data) {\n  const length = data.byteLength;\n  const EPBPositions = [];\n  let i = 1;\n\n  // Find all `Emulation Prevention Bytes`\n  while (i < length - 2) {\n    if (data[i] === 0 && data[i + 1] === 0 && data[i + 2] === 0x03) {\n      EPBPositions.push(i + 2);\n      i += 2;\n    } else {\n      i++;\n    }\n  }\n\n  // If no Emulation Prevention Bytes were found just return the original\n  // array\n  if (EPBPositions.length === 0) {\n    return data;\n  }\n\n  // Create a new array to hold the NAL unit data\n  const newLength = length - EPBPositions.length;\n  const newData = new Uint8Array(newLength);\n  let sourceIndex = 0;\n  for (i = 0; i < newLength; sourceIndex++, i++) {\n    if (sourceIndex === EPBPositions[0]) {\n      // Skip this byte\n      sourceIndex++;\n      // Remove this position index\n      EPBPositions.shift();\n    }\n    newData[i] = data[sourceIndex];\n  }\n  return newData;\n}\nfunction parseEmsg(data) {\n  const version = data[0];\n  let schemeIdUri = '';\n  let value = '';\n  let timeScale = 0;\n  let presentationTimeDelta = 0;\n  let presentationTime = 0;\n  let eventDuration = 0;\n  let id = 0;\n  let offset = 0;\n  if (version === 0) {\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    timeScale = readUint32(data, 12);\n    presentationTimeDelta = readUint32(data, 16);\n    eventDuration = readUint32(data, 20);\n    id = readUint32(data, 24);\n    offset = 28;\n  } else if (version === 1) {\n    offset += 4;\n    timeScale = readUint32(data, offset);\n    offset += 4;\n    const leftPresentationTime = readUint32(data, offset);\n    offset += 4;\n    const rightPresentationTime = readUint32(data, offset);\n    offset += 4;\n    presentationTime = 2 ** 32 * leftPresentationTime + rightPresentationTime;\n    if (!isSafeInteger(presentationTime)) {\n      presentationTime = Number.MAX_SAFE_INTEGER;\n      logger.warn('Presentation time exceeds safe integer limit and wrapped to max safe integer in parsing emsg box');\n    }\n    eventDuration = readUint32(data, offset);\n    offset += 4;\n    id = readUint32(data, offset);\n    offset += 4;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    schemeIdUri += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n    while (bin2str(data.subarray(offset, offset + 1)) !== '\\0') {\n      value += bin2str(data.subarray(offset, offset + 1));\n      offset += 1;\n    }\n    value += bin2str(data.subarray(offset, offset + 1));\n    offset += 1;\n  }\n  const payload = data.subarray(offset, data.byteLength);\n  return {\n    schemeIdUri,\n    value,\n    timeScale,\n    presentationTime,\n    presentationTimeDelta,\n    eventDuration,\n    id,\n    payload\n  };\n}\nfunction mp4Box(type, ...payload) {\n  const len = payload.length;\n  let size = 8;\n  let i = len;\n  while (i--) {\n    size += payload[i].byteLength;\n  }\n  const result = new Uint8Array(size);\n  result[0] = size >> 24 & 0xff;\n  result[1] = size >> 16 & 0xff;\n  result[2] = size >> 8 & 0xff;\n  result[3] = size & 0xff;\n  result.set(type, 4);\n  for (i = 0, size = 8; i < len; i++) {\n    result.set(payload[i], size);\n    size += payload[i].byteLength;\n  }\n  return result;\n}\nfunction mp4pssh(systemId, keyids, data) {\n  if (systemId.byteLength !== 16) {\n    throw new RangeError('Invalid system id');\n  }\n  let version;\n  let kids;\n  if (keyids) {\n    version = 1;\n    kids = new Uint8Array(keyids.length * 16);\n    for (let ix = 0; ix < keyids.length; ix++) {\n      const k = keyids[ix]; // uint8array\n      if (k.byteLength !== 16) {\n        throw new RangeError('Invalid key');\n      }\n      kids.set(k, ix * 16);\n    }\n  } else {\n    version = 0;\n    kids = new Uint8Array();\n  }\n  let kidCount;\n  if (version > 0) {\n    kidCount = new Uint8Array(4);\n    if (keyids.length > 0) {\n      new DataView(kidCount.buffer).setUint32(0, keyids.length, false);\n    }\n  } else {\n    kidCount = new Uint8Array();\n  }\n  const dataSize = new Uint8Array(4);\n  if (data && data.byteLength > 0) {\n    new DataView(dataSize.buffer).setUint32(0, data.byteLength, false);\n  }\n  return mp4Box([112, 115, 115, 104], new Uint8Array([version, 0x00, 0x00, 0x00 // Flags\n  ]), systemId,\n  // 16 bytes\n  kidCount, kids, dataSize, data || new Uint8Array());\n}\nfunction parseMultiPssh(initData) {\n  const results = [];\n  if (initData instanceof ArrayBuffer) {\n    const length = initData.byteLength;\n    let offset = 0;\n    while (offset + 32 < length) {\n      const view = new DataView(initData, offset);\n      const pssh = parsePssh(view);\n      results.push(pssh);\n      offset += pssh.size;\n    }\n  }\n  return results;\n}\nfunction parsePssh(view) {\n  const size = view.getUint32(0);\n  const offset = view.byteOffset;\n  const length = view.byteLength;\n  if (length < size) {\n    return {\n      offset,\n      size: length\n    };\n  }\n  const type = view.getUint32(4);\n  if (type !== 0x70737368) {\n    return {\n      offset,\n      size\n    };\n  }\n  const version = view.getUint32(8) >>> 24;\n  if (version !== 0 && version !== 1) {\n    return {\n      offset,\n      size\n    };\n  }\n  const buffer = view.buffer;\n  const systemId = Hex.hexDump(new Uint8Array(buffer, offset + 12, 16));\n  const dataSizeOrKidCount = view.getUint32(28);\n  let kids = null;\n  let data = null;\n  if (version === 0) {\n    if (size - 32 < dataSizeOrKidCount || dataSizeOrKidCount < 22) {\n      return {\n        offset,\n        size\n      };\n    }\n    data = new Uint8Array(buffer, offset + 32, dataSizeOrKidCount);\n  } else if (version === 1) {\n    if (!dataSizeOrKidCount || length < offset + 32 + dataSizeOrKidCount * 16 + 16) {\n      return {\n        offset,\n        size\n      };\n    }\n    kids = [];\n    for (let i = 0; i < dataSizeOrKidCount; i++) {\n      kids.push(new Uint8Array(buffer, offset + 32 + i * 16, 16));\n    }\n  }\n  return {\n    version,\n    systemId,\n    kids,\n    data,\n    offset,\n    size\n  };\n}\n\nlet keyUriToKeyIdMap = {};\nclass LevelKey {\n  static clearKeyUriToKeyIdMap() {\n    keyUriToKeyIdMap = {};\n  }\n  constructor(method, uri, format, formatversions = [1], iv = null) {\n    this.uri = void 0;\n    this.method = void 0;\n    this.keyFormat = void 0;\n    this.keyFormatVersions = void 0;\n    this.encrypted = void 0;\n    this.isCommonEncryption = void 0;\n    this.iv = null;\n    this.key = null;\n    this.keyId = null;\n    this.pssh = null;\n    this.method = method;\n    this.uri = uri;\n    this.keyFormat = format;\n    this.keyFormatVersions = formatversions;\n    this.iv = iv;\n    this.encrypted = method ? method !== 'NONE' : false;\n    this.isCommonEncryption = this.encrypted && method !== 'AES-128';\n  }\n  isSupported() {\n    // If it's Segment encryption or No encryption, just select that key system\n    if (this.method) {\n      if (this.method === 'AES-128' || this.method === 'NONE') {\n        return true;\n      }\n      if (this.keyFormat === 'identity') {\n        // Maintain support for clear SAMPLE-AES with MPEG-3 TS\n        return this.method === 'SAMPLE-AES';\n      } else {\n        switch (this.keyFormat) {\n          case KeySystemFormats.FAIRPLAY:\n          case KeySystemFormats.WIDEVINE:\n          case KeySystemFormats.PLAYREADY:\n          case KeySystemFormats.CLEARKEY:\n            return ['ISO-23001-7', 'SAMPLE-AES', 'SAMPLE-AES-CENC', 'SAMPLE-AES-CTR'].indexOf(this.method) !== -1;\n        }\n      }\n    }\n    return false;\n  }\n  getDecryptData(sn) {\n    if (!this.encrypted || !this.uri) {\n      return null;\n    }\n    if (this.method === 'AES-128' && this.uri && !this.iv) {\n      if (typeof sn !== 'number') {\n        // We are fetching decryption data for a initialization segment\n        // If the segment was encrypted with AES-128\n        // It must have an IV defined. We cannot substitute the Segment Number in.\n        if (this.method === 'AES-128' && !this.iv) {\n          logger.warn(`missing IV for initialization segment with method=\"${this.method}\" - compliance issue`);\n        }\n        // Explicitly set sn to resulting value from implicit conversions 'initSegment' values for IV generation.\n        sn = 0;\n      }\n      const iv = createInitializationVector(sn);\n      const decryptdata = new LevelKey(this.method, this.uri, 'identity', this.keyFormatVersions, iv);\n      return decryptdata;\n    }\n\n    // Initialize keyId if possible\n    const keyBytes = convertDataUriToArrayBytes(this.uri);\n    if (keyBytes) {\n      switch (this.keyFormat) {\n        case KeySystemFormats.WIDEVINE:\n          this.pssh = keyBytes;\n          // In case of widevine keyID is embedded in PSSH box. Read Key ID.\n          if (keyBytes.length >= 22) {\n            this.keyId = keyBytes.subarray(keyBytes.length - 22, keyBytes.length - 6);\n          }\n          break;\n        case KeySystemFormats.PLAYREADY:\n          {\n            const PlayReadyKeySystemUUID = new Uint8Array([0x9a, 0x04, 0xf0, 0x79, 0x98, 0x40, 0x42, 0x86, 0xab, 0x92, 0xe6, 0x5b, 0xe0, 0x88, 0x5f, 0x95]);\n            this.pssh = mp4pssh(PlayReadyKeySystemUUID, null, keyBytes);\n            const keyBytesUtf16 = new Uint16Array(keyBytes.buffer, keyBytes.byteOffset, keyBytes.byteLength / 2);\n            const keyByteStr = String.fromCharCode.apply(null, Array.from(keyBytesUtf16));\n\n            // Parse Playready WRMHeader XML\n            const xmlKeyBytes = keyByteStr.substring(keyByteStr.indexOf('<'), keyByteStr.length);\n            const parser = new DOMParser();\n            const xmlDoc = parser.parseFromString(xmlKeyBytes, 'text/xml');\n            const keyData = xmlDoc.getElementsByTagName('KID')[0];\n            if (keyData) {\n              const keyId = keyData.childNodes[0] ? keyData.childNodes[0].nodeValue : keyData.getAttribute('VALUE');\n              if (keyId) {\n                const keyIdArray = base64Decode(keyId).subarray(0, 16);\n                // KID value in PRO is a base64-encoded little endian GUID interpretation of UUID\n                // KID value in tenc is a big endian UUID GUID interpretation of UUID\n                changeEndianness(keyIdArray);\n                this.keyId = keyIdArray;\n              }\n            }\n            break;\n          }\n        default:\n          {\n            let keydata = keyBytes.subarray(0, 16);\n            if (keydata.length !== 16) {\n              const padded = new Uint8Array(16);\n              padded.set(keydata, 16 - keydata.length);\n              keydata = padded;\n            }\n            this.keyId = keydata;\n            break;\n          }\n      }\n    }\n\n    // Default behavior: assign a new keyId for each uri\n    if (!this.keyId || this.keyId.byteLength !== 16) {\n      let keyId = keyUriToKeyIdMap[this.uri];\n      if (!keyId) {\n        const val = Object.keys(keyUriToKeyIdMap).length % Number.MAX_SAFE_INTEGER;\n        keyId = new Uint8Array(16);\n        const dv = new DataView(keyId.buffer, 12, 4); // Just set the last 4 bytes\n        dv.setUint32(0, val);\n        keyUriToKeyIdMap[this.uri] = keyId;\n      }\n      this.keyId = keyId;\n    }\n    return this;\n  }\n}\nfunction createInitializationVector(segmentNumber) {\n  const uint8View = new Uint8Array(16);\n  for (let i = 12; i < 16; i++) {\n    uint8View[i] = segmentNumber >> 8 * (15 - i) & 0xff;\n  }\n  return uint8View;\n}\n\nconst VARIABLE_REPLACEMENT_REGEX = /\\{\\$([a-zA-Z0-9-_]+)\\}/g;\nfunction hasVariableReferences(str) {\n  return VARIABLE_REPLACEMENT_REGEX.test(str);\n}\nfunction substituteVariablesInAttributes(parsed, attr, attributeNames) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    for (let i = attributeNames.length; i--;) {\n      const name = attributeNames[i];\n      const value = attr[name];\n      if (value) {\n        attr[name] = substituteVariables(parsed, value);\n      }\n    }\n  }\n}\nfunction substituteVariables(parsed, value) {\n  if (parsed.variableList !== null || parsed.hasVariableRefs) {\n    const variableList = parsed.variableList;\n    return value.replace(VARIABLE_REPLACEMENT_REGEX, variableReference => {\n      const variableName = variableReference.substring(2, variableReference.length - 1);\n      const variableValue = variableList == null ? void 0 : variableList[variableName];\n      if (variableValue === undefined) {\n        parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`Missing preceding EXT-X-DEFINE tag for Variable Reference: \"${variableName}\"`));\n        return variableReference;\n      }\n      return variableValue;\n    });\n  }\n  return value;\n}\nfunction addVariableDefinition(parsed, attr, parentUrl) {\n  let variableList = parsed.variableList;\n  if (!variableList) {\n    parsed.variableList = variableList = {};\n  }\n  let NAME;\n  let VALUE;\n  if ('QUERYPARAM' in attr) {\n    NAME = attr.QUERYPARAM;\n    try {\n      const searchParams = new self.URL(parentUrl).searchParams;\n      if (searchParams.has(NAME)) {\n        VALUE = searchParams.get(NAME);\n      } else {\n        throw new Error(`\"${NAME}\" does not match any query parameter in URI: \"${parentUrl}\"`);\n      }\n    } catch (error) {\n      parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE QUERYPARAM: ${error.message}`));\n    }\n  } else {\n    NAME = attr.NAME;\n    VALUE = attr.VALUE;\n  }\n  if (NAME in variableList) {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE duplicate Variable Name declarations: \"${NAME}\"`));\n  } else {\n    variableList[NAME] = VALUE || '';\n  }\n}\nfunction importVariableDefinition(parsed, attr, sourceVariableList) {\n  const IMPORT = attr.IMPORT;\n  if (sourceVariableList && IMPORT in sourceVariableList) {\n    let variableList = parsed.variableList;\n    if (!variableList) {\n      parsed.variableList = variableList = {};\n    }\n    variableList[IMPORT] = sourceVariableList[IMPORT];\n  } else {\n    parsed.playlistParsingError || (parsed.playlistParsingError = new Error(`EXT-X-DEFINE IMPORT attribute not found in Multivariant Playlist: \"${IMPORT}\"`));\n  }\n}\n\n/**\n * MediaSource helper\n */\n\nfunction getMediaSource(preferManagedMediaSource = true) {\n  if (typeof self === 'undefined') return undefined;\n  const mms = (preferManagedMediaSource || !self.MediaSource) && self.ManagedMediaSource;\n  return mms || self.MediaSource || self.WebKitMediaSource;\n}\nfunction isManagedMediaSource(source) {\n  return typeof self !== 'undefined' && source === self.ManagedMediaSource;\n}\n\n// from http://mp4ra.org/codecs.html\n// values indicate codec selection preference (lower is higher priority)\nconst sampleEntryCodesISO = {\n  audio: {\n    a3ds: 1,\n    'ac-3': 0.95,\n    'ac-4': 1,\n    alac: 0.9,\n    alaw: 1,\n    dra1: 1,\n    'dts+': 1,\n    'dts-': 1,\n    dtsc: 1,\n    dtse: 1,\n    dtsh: 1,\n    'ec-3': 0.9,\n    enca: 1,\n    fLaC: 0.9,\n    // MP4-RA listed codec entry for FLAC\n    flac: 0.9,\n    // legacy browser codec name for FLAC\n    FLAC: 0.9,\n    // some manifests may list \"FLAC\" with Apple's tools\n    g719: 1,\n    g726: 1,\n    m4ae: 1,\n    mha1: 1,\n    mha2: 1,\n    mhm1: 1,\n    mhm2: 1,\n    mlpa: 1,\n    mp4a: 1,\n    'raw ': 1,\n    Opus: 1,\n    opus: 1,\n    // browsers expect this to be lowercase despite MP4RA says 'Opus'\n    samr: 1,\n    sawb: 1,\n    sawp: 1,\n    sevc: 1,\n    sqcp: 1,\n    ssmv: 1,\n    twos: 1,\n    ulaw: 1\n  },\n  video: {\n    avc1: 1,\n    avc2: 1,\n    avc3: 1,\n    avc4: 1,\n    avcp: 1,\n    av01: 0.8,\n    drac: 1,\n    dva1: 1,\n    dvav: 1,\n    dvh1: 0.7,\n    dvhe: 0.7,\n    encv: 1,\n    hev1: 0.75,\n    hvc1: 0.75,\n    mjp2: 1,\n    mp4v: 1,\n    mvc1: 1,\n    mvc2: 1,\n    mvc3: 1,\n    mvc4: 1,\n    resv: 1,\n    rv60: 1,\n    s263: 1,\n    svc1: 1,\n    svc2: 1,\n    'vc-1': 1,\n    vp08: 1,\n    vp09: 0.9\n  },\n  text: {\n    stpp: 1,\n    wvtt: 1\n  }\n};\nfunction isCodecType(codec, type) {\n  const typeCodes = sampleEntryCodesISO[type];\n  return !!typeCodes && !!typeCodes[codec.slice(0, 4)];\n}\nfunction areCodecsMediaSourceSupported(codecs, type, preferManagedMediaSource = true) {\n  return !codecs.split(',').some(codec => !isCodecMediaSourceSupported(codec, type, preferManagedMediaSource));\n}\nfunction isCodecMediaSourceSupported(codec, type, preferManagedMediaSource = true) {\n  var _MediaSource$isTypeSu;\n  const MediaSource = getMediaSource(preferManagedMediaSource);\n  return (_MediaSource$isTypeSu = MediaSource == null ? void 0 : MediaSource.isTypeSupported(mimeTypeForCodec(codec, type))) != null ? _MediaSource$isTypeSu : false;\n}\nfunction mimeTypeForCodec(codec, type) {\n  return `${type}/mp4;codecs=\"${codec}\"`;\n}\nfunction videoCodecPreferenceValue(videoCodec) {\n  if (videoCodec) {\n    const fourCC = videoCodec.substring(0, 4);\n    return sampleEntryCodesISO.video[fourCC];\n  }\n  return 2;\n}\nfunction codecsSetSelectionPreferenceValue(codecSet) {\n  return codecSet.split(',').reduce((num, fourCC) => {\n    const preferenceValue = sampleEntryCodesISO.video[fourCC];\n    if (preferenceValue) {\n      return (preferenceValue * 2 + num) / (num ? 3 : 2);\n    }\n    return (sampleEntryCodesISO.audio[fourCC] + num) / (num ? 2 : 1);\n  }, 0);\n}\nconst CODEC_COMPATIBLE_NAMES = {};\nfunction getCodecCompatibleNameLower(lowerCaseCodec, preferManagedMediaSource = true) {\n  if (CODEC_COMPATIBLE_NAMES[lowerCaseCodec]) {\n    return CODEC_COMPATIBLE_NAMES[lowerCaseCodec];\n  }\n\n  // Idealy fLaC and Opus would be first (spec-compliant) but\n  // some browsers will report that fLaC is supported then fail.\n  // see: https://bugs.chromium.org/p/chromium/issues/detail?id=1422728\n  const codecsToCheck = {\n    flac: ['flac', 'fLaC', 'FLAC'],\n    opus: ['opus', 'Opus']\n  }[lowerCaseCodec];\n  for (let i = 0; i < codecsToCheck.length; i++) {\n    if (isCodecMediaSourceSupported(codecsToCheck[i], 'audio', preferManagedMediaSource)) {\n      CODEC_COMPATIBLE_NAMES[lowerCaseCodec] = codecsToCheck[i];\n      return codecsToCheck[i];\n    }\n  }\n  return lowerCaseCodec;\n}\nconst AUDIO_CODEC_REGEXP = /flac|opus/i;\nfunction getCodecCompatibleName(codec, preferManagedMediaSource = true) {\n  return codec.replace(AUDIO_CODEC_REGEXP, m => getCodecCompatibleNameLower(m.toLowerCase(), preferManagedMediaSource));\n}\nfunction pickMostCompleteCodecName(parsedCodec, levelCodec) {\n  // Parsing of mp4a codecs strings in mp4-tools from media is incomplete as of d8c6c7a\n  // so use level codec is parsed codec is unavailable or incomplete\n  if (parsedCodec && parsedCodec !== 'mp4a') {\n    return parsedCodec;\n  }\n  return levelCodec ? levelCodec.split(',')[0] : levelCodec;\n}\nfunction convertAVC1ToAVCOTI(codec) {\n  // Convert avc1 codec string from RFC-4281 to RFC-6381 for MediaSource.isTypeSupported\n  // Examples: avc1.66.30 to avc1.42001e and avc1.77.30,avc1.66.30 to avc1.4d001e,avc1.42001e.\n  const codecs = codec.split(',');\n  for (let i = 0; i < codecs.length; i++) {\n    const avcdata = codecs[i].split('.');\n    if (avcdata.length > 2) {\n      let result = avcdata.shift() + '.';\n      result += parseInt(avcdata.shift()).toString(16);\n      result += ('000' + parseInt(avcdata.shift()).toString(16)).slice(-4);\n      codecs[i] = result;\n    }\n  }\n  return codecs.join(',');\n}\n\nconst MASTER_PLAYLIST_REGEX = /#EXT-X-STREAM-INF:([^\\r\\n]*)(?:[\\r\\n](?:#[^\\r\\n]*)?)*([^\\r\\n]+)|#EXT-X-(SESSION-DATA|SESSION-KEY|DEFINE|CONTENT-STEERING|START):([^\\r\\n]*)[\\r\\n]+/g;\nconst MASTER_PLAYLIST_MEDIA_REGEX = /#EXT-X-MEDIA:(.*)/g;\nconst IS_MEDIA_PLAYLIST = /^#EXT(?:INF|-X-TARGETDURATION):/m; // Handle empty Media Playlist (first EXTINF not signaled, but TARGETDURATION present)\n\nconst LEVEL_PLAYLIST_REGEX_FAST = new RegExp([/#EXTINF:\\s*(\\d*(?:\\.\\d+)?)(?:,(.*)\\s+)?/.source,\n// duration (#EXTINF:<duration>,<title>), group 1 => duration, group 2 => title\n/(?!#) *(\\S[^\\r\\n]*)/.source,\n// segment URI, group 3 => the URI (note newline is not eaten)\n/#EXT-X-BYTERANGE:*(.+)/.source,\n// next segment's byterange, group 4 => range spec (x@y)\n/#EXT-X-PROGRAM-DATE-TIME:(.+)/.source,\n// next segment's program date/time group 5 => the datetime spec\n/#.*/.source // All other non-segment oriented tags will match with all groups empty\n].join('|'), 'g');\nconst LEVEL_PLAYLIST_REGEX_SLOW = new RegExp([/#(EXTM3U)/.source, /#EXT-X-(DATERANGE|DEFINE|KEY|MAP|PART|PART-INF|PLAYLIST-TYPE|PRELOAD-HINT|RENDITION-REPORT|SERVER-CONTROL|SKIP|START):(.+)/.source, /#EXT-X-(BITRATE|DISCONTINUITY-SEQUENCE|MEDIA-SEQUENCE|TARGETDURATION|VERSION): *(\\d+)/.source, /#EXT-X-(DISCONTINUITY|ENDLIST|GAP|INDEPENDENT-SEGMENTS)/.source, /(#)([^:]*):(.*)/.source, /(#)(.*)(?:.*)\\r?\\n?/.source].join('|'));\nclass M3U8Parser {\n  static findGroup(groups, mediaGroupId) {\n    for (let i = 0; i < groups.length; i++) {\n      const group = groups[i];\n      if (group.id === mediaGroupId) {\n        return group;\n      }\n    }\n  }\n  static resolve(url, baseUrl) {\n    return urlToolkitExports.buildAbsoluteURL(baseUrl, url, {\n      alwaysNormalize: true\n    });\n  }\n  static isMediaPlaylist(str) {\n    return IS_MEDIA_PLAYLIST.test(str);\n  }\n  static parseMasterPlaylist(string, baseurl) {\n    const hasVariableRefs = hasVariableReferences(string) ;\n    const parsed = {\n      contentSteering: null,\n      levels: [],\n      playlistParsingError: null,\n      sessionData: null,\n      sessionKeys: null,\n      startTimeOffset: null,\n      variableList: null,\n      hasVariableRefs\n    };\n    const levelsWithKnownCodecs = [];\n    MASTER_PLAYLIST_REGEX.lastIndex = 0;\n    let result;\n    while ((result = MASTER_PLAYLIST_REGEX.exec(string)) != null) {\n      if (result[1]) {\n        var _level$unknownCodecs;\n        // '#EXT-X-STREAM-INF' is found, parse level tag  in group 1\n        const attrs = new AttrList(result[1]);\n        {\n          substituteVariablesInAttributes(parsed, attrs, ['CODECS', 'SUPPLEMENTAL-CODECS', 'ALLOWED-CPC', 'PATHWAY-ID', 'STABLE-VARIANT-ID', 'AUDIO', 'VIDEO', 'SUBTITLES', 'CLOSED-CAPTIONS', 'NAME']);\n        }\n        const uri = substituteVariables(parsed, result[2]) ;\n        const level = {\n          attrs,\n          bitrate: attrs.decimalInteger('BANDWIDTH') || attrs.decimalInteger('AVERAGE-BANDWIDTH'),\n          name: attrs.NAME,\n          url: M3U8Parser.resolve(uri, baseurl)\n        };\n        const resolution = attrs.decimalResolution('RESOLUTION');\n        if (resolution) {\n          level.width = resolution.width;\n          level.height = resolution.height;\n        }\n        setCodecs(attrs.CODECS, level);\n        if (!((_level$unknownCodecs = level.unknownCodecs) != null && _level$unknownCodecs.length)) {\n          levelsWithKnownCodecs.push(level);\n        }\n        parsed.levels.push(level);\n      } else if (result[3]) {\n        const tag = result[3];\n        const attributes = result[4];\n        switch (tag) {\n          case 'SESSION-DATA':\n            {\n              // #EXT-X-SESSION-DATA\n              const sessionAttrs = new AttrList(attributes);\n              {\n                substituteVariablesInAttributes(parsed, sessionAttrs, ['DATA-ID', 'LANGUAGE', 'VALUE', 'URI']);\n              }\n              const dataId = sessionAttrs['DATA-ID'];\n              if (dataId) {\n                if (parsed.sessionData === null) {\n                  parsed.sessionData = {};\n                }\n                parsed.sessionData[dataId] = sessionAttrs;\n              }\n              break;\n            }\n          case 'SESSION-KEY':\n            {\n              // #EXT-X-SESSION-KEY\n              const sessionKey = parseKey(attributes, baseurl, parsed);\n              if (sessionKey.encrypted && sessionKey.isSupported()) {\n                if (parsed.sessionKeys === null) {\n                  parsed.sessionKeys = [];\n                }\n                parsed.sessionKeys.push(sessionKey);\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-SESSION-KEY tag: \"${attributes}\"`);\n              }\n              break;\n            }\n          case 'DEFINE':\n            {\n              // #EXT-X-DEFINE\n              {\n                const variableAttributes = new AttrList(attributes);\n                substituteVariablesInAttributes(parsed, variableAttributes, ['NAME', 'VALUE', 'QUERYPARAM']);\n                addVariableDefinition(parsed, variableAttributes, baseurl);\n              }\n              break;\n            }\n          case 'CONTENT-STEERING':\n            {\n              // #EXT-X-CONTENT-STEERING\n              const contentSteeringAttributes = new AttrList(attributes);\n              {\n                substituteVariablesInAttributes(parsed, contentSteeringAttributes, ['SERVER-URI', 'PATHWAY-ID']);\n              }\n              parsed.contentSteering = {\n                uri: M3U8Parser.resolve(contentSteeringAttributes['SERVER-URI'], baseurl),\n                pathwayId: contentSteeringAttributes['PATHWAY-ID'] || '.'\n              };\n              break;\n            }\n          case 'START':\n            {\n              // #EXT-X-START\n              parsed.startTimeOffset = parseStartTimeOffset(attributes);\n              break;\n            }\n        }\n      }\n    }\n    // Filter out levels with unknown codecs if it does not remove all levels\n    const stripUnknownCodecLevels = levelsWithKnownCodecs.length > 0 && levelsWithKnownCodecs.length < parsed.levels.length;\n    parsed.levels = stripUnknownCodecLevels ? levelsWithKnownCodecs : parsed.levels;\n    if (parsed.levels.length === 0) {\n      parsed.playlistParsingError = new Error('no levels found in manifest');\n    }\n    return parsed;\n  }\n  static parseMasterPlaylistMedia(string, baseurl, parsed) {\n    let result;\n    const results = {};\n    const levels = parsed.levels;\n    const groupsByType = {\n      AUDIO: levels.map(level => ({\n        id: level.attrs.AUDIO,\n        audioCodec: level.audioCodec\n      })),\n      SUBTITLES: levels.map(level => ({\n        id: level.attrs.SUBTITLES,\n        textCodec: level.textCodec\n      })),\n      'CLOSED-CAPTIONS': []\n    };\n    let id = 0;\n    MASTER_PLAYLIST_MEDIA_REGEX.lastIndex = 0;\n    while ((result = MASTER_PLAYLIST_MEDIA_REGEX.exec(string)) !== null) {\n      const attrs = new AttrList(result[1]);\n      const type = attrs.TYPE;\n      if (type) {\n        const groups = groupsByType[type];\n        const medias = results[type] || [];\n        results[type] = medias;\n        {\n          substituteVariablesInAttributes(parsed, attrs, ['URI', 'GROUP-ID', 'LANGUAGE', 'ASSOC-LANGUAGE', 'STABLE-RENDITION-ID', 'NAME', 'INSTREAM-ID', 'CHARACTERISTICS', 'CHANNELS']);\n        }\n        const lang = attrs.LANGUAGE;\n        const assocLang = attrs['ASSOC-LANGUAGE'];\n        const channels = attrs.CHANNELS;\n        const characteristics = attrs.CHARACTERISTICS;\n        const instreamId = attrs['INSTREAM-ID'];\n        const media = {\n          attrs,\n          bitrate: 0,\n          id: id++,\n          groupId: attrs['GROUP-ID'] || '',\n          name: attrs.NAME || lang || '',\n          type,\n          default: attrs.bool('DEFAULT'),\n          autoselect: attrs.bool('AUTOSELECT'),\n          forced: attrs.bool('FORCED'),\n          lang,\n          url: attrs.URI ? M3U8Parser.resolve(attrs.URI, baseurl) : ''\n        };\n        if (assocLang) {\n          media.assocLang = assocLang;\n        }\n        if (channels) {\n          media.channels = channels;\n        }\n        if (characteristics) {\n          media.characteristics = characteristics;\n        }\n        if (instreamId) {\n          media.instreamId = instreamId;\n        }\n        if (groups != null && groups.length) {\n          // If there are audio or text groups signalled in the manifest, let's look for a matching codec string for this track\n          // If we don't find the track signalled, lets use the first audio groups codec we have\n          // Acting as a best guess\n          const groupCodec = M3U8Parser.findGroup(groups, media.groupId) || groups[0];\n          assignCodec(media, groupCodec, 'audioCodec');\n          assignCodec(media, groupCodec, 'textCodec');\n        }\n        medias.push(media);\n      }\n    }\n    return results;\n  }\n  static parseLevelPlaylist(string, baseurl, id, type, levelUrlId, multivariantVariableList) {\n    const level = new LevelDetails(baseurl);\n    const fragments = level.fragments;\n    // The most recent init segment seen (applies to all subsequent segments)\n    let currentInitSegment = null;\n    let currentSN = 0;\n    let currentPart = 0;\n    let totalduration = 0;\n    let discontinuityCounter = 0;\n    let prevFrag = null;\n    let frag = new Fragment(type, baseurl);\n    let result;\n    let i;\n    let levelkeys;\n    let firstPdtIndex = -1;\n    let createNextFrag = false;\n    let nextByteRange = null;\n    LEVEL_PLAYLIST_REGEX_FAST.lastIndex = 0;\n    level.m3u8 = string;\n    level.hasVariableRefs = hasVariableReferences(string) ;\n    while ((result = LEVEL_PLAYLIST_REGEX_FAST.exec(string)) !== null) {\n      if (createNextFrag) {\n        createNextFrag = false;\n        frag = new Fragment(type, baseurl);\n        // setup the next fragment for part loading\n        frag.start = totalduration;\n        frag.sn = currentSN;\n        frag.cc = discontinuityCounter;\n        frag.level = id;\n        if (currentInitSegment) {\n          frag.initSegment = currentInitSegment;\n          frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n          currentInitSegment.rawProgramDateTime = null;\n          if (nextByteRange) {\n            frag.setByteRange(nextByteRange);\n            nextByteRange = null;\n          }\n        }\n      }\n      const duration = result[1];\n      if (duration) {\n        // INF\n        frag.duration = parseFloat(duration);\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const title = (' ' + result[2]).slice(1);\n        frag.title = title || null;\n        frag.tagList.push(title ? ['INF', duration, title] : ['INF', duration]);\n      } else if (result[3]) {\n        // url\n        if (isFiniteNumber(frag.duration)) {\n          frag.start = totalduration;\n          if (levelkeys) {\n            setFragLevelKeys(frag, levelkeys, level);\n          }\n          frag.sn = currentSN;\n          frag.level = id;\n          frag.cc = discontinuityCounter;\n          fragments.push(frag);\n          // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n          const uri = (' ' + result[3]).slice(1);\n          frag.relurl = substituteVariables(level, uri) ;\n          assignProgramDateTime(frag, prevFrag);\n          prevFrag = frag;\n          totalduration += frag.duration;\n          currentSN++;\n          currentPart = 0;\n          createNextFrag = true;\n        }\n      } else if (result[4]) {\n        // X-BYTERANGE\n        const data = (' ' + result[4]).slice(1);\n        if (prevFrag) {\n          frag.setByteRange(data, prevFrag);\n        } else {\n          frag.setByteRange(data);\n        }\n      } else if (result[5]) {\n        // PROGRAM-DATE-TIME\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        frag.rawProgramDateTime = (' ' + result[5]).slice(1);\n        frag.tagList.push(['PROGRAM-DATE-TIME', frag.rawProgramDateTime]);\n        if (firstPdtIndex === -1) {\n          firstPdtIndex = fragments.length;\n        }\n      } else {\n        result = result[0].match(LEVEL_PLAYLIST_REGEX_SLOW);\n        if (!result) {\n          logger.warn('No matches on slow regex match for level playlist!');\n          continue;\n        }\n        for (i = 1; i < result.length; i++) {\n          if (typeof result[i] !== 'undefined') {\n            break;\n          }\n        }\n\n        // avoid sliced strings    https://github.com/video-dev/hls.js/issues/939\n        const tag = (' ' + result[i]).slice(1);\n        const value1 = (' ' + result[i + 1]).slice(1);\n        const value2 = result[i + 2] ? (' ' + result[i + 2]).slice(1) : '';\n        switch (tag) {\n          case 'PLAYLIST-TYPE':\n            level.type = value1.toUpperCase();\n            break;\n          case 'MEDIA-SEQUENCE':\n            currentSN = level.startSN = parseInt(value1);\n            break;\n          case 'SKIP':\n            {\n              const skipAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, skipAttrs, ['RECENTLY-REMOVED-DATERANGES']);\n              }\n              const skippedSegments = skipAttrs.decimalInteger('SKIPPED-SEGMENTS');\n              if (isFiniteNumber(skippedSegments)) {\n                level.skippedSegments = skippedSegments;\n                // This will result in fragments[] containing undefined values, which we will fill in with `mergeDetails`\n                for (let _i = skippedSegments; _i--;) {\n                  fragments.unshift(null);\n                }\n                currentSN += skippedSegments;\n              }\n              const recentlyRemovedDateranges = skipAttrs.enumeratedString('RECENTLY-REMOVED-DATERANGES');\n              if (recentlyRemovedDateranges) {\n                level.recentlyRemovedDateranges = recentlyRemovedDateranges.split('\\t');\n              }\n              break;\n            }\n          case 'TARGETDURATION':\n            level.targetduration = Math.max(parseInt(value1), 1);\n            break;\n          case 'VERSION':\n            level.version = parseInt(value1);\n            break;\n          case 'INDEPENDENT-SEGMENTS':\n          case 'EXTM3U':\n            break;\n          case 'ENDLIST':\n            level.live = false;\n            break;\n          case '#':\n            if (value1 || value2) {\n              frag.tagList.push(value2 ? [value1, value2] : [value1]);\n            }\n            break;\n          case 'DISCONTINUITY':\n            discontinuityCounter++;\n            frag.tagList.push(['DIS']);\n            break;\n          case 'GAP':\n            frag.gap = true;\n            frag.tagList.push([tag]);\n            break;\n          case 'BITRATE':\n            frag.tagList.push([tag, value1]);\n            break;\n          case 'DATERANGE':\n            {\n              const dateRangeAttr = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, dateRangeAttr, ['ID', 'CLASS', 'START-DATE', 'END-DATE', 'SCTE35-CMD', 'SCTE35-OUT', 'SCTE35-IN']);\n                substituteVariablesInAttributes(level, dateRangeAttr, dateRangeAttr.clientAttrs);\n              }\n              const dateRange = new DateRange(dateRangeAttr, level.dateRanges[dateRangeAttr.ID]);\n              if (dateRange.isValid || level.skippedSegments) {\n                level.dateRanges[dateRange.id] = dateRange;\n              } else {\n                logger.warn(`Ignoring invalid DATERANGE tag: \"${value1}\"`);\n              }\n              // Add to fragment tag list for backwards compatibility (< v1.2.0)\n              frag.tagList.push(['EXT-X-DATERANGE', value1]);\n              break;\n            }\n          case 'DEFINE':\n            {\n              {\n                const variableAttributes = new AttrList(value1);\n                substituteVariablesInAttributes(level, variableAttributes, ['NAME', 'VALUE', 'IMPORT', 'QUERYPARAM']);\n                if ('IMPORT' in variableAttributes) {\n                  importVariableDefinition(level, variableAttributes, multivariantVariableList);\n                } else {\n                  addVariableDefinition(level, variableAttributes, baseurl);\n                }\n              }\n              break;\n            }\n          case 'DISCONTINUITY-SEQUENCE':\n            discontinuityCounter = parseInt(value1);\n            break;\n          case 'KEY':\n            {\n              const levelKey = parseKey(value1, baseurl, level);\n              if (levelKey.isSupported()) {\n                if (levelKey.method === 'NONE') {\n                  levelkeys = undefined;\n                  break;\n                }\n                if (!levelkeys) {\n                  levelkeys = {};\n                }\n                if (levelkeys[levelKey.keyFormat]) {\n                  levelkeys = _extends({}, levelkeys);\n                }\n                levelkeys[levelKey.keyFormat] = levelKey;\n              } else {\n                logger.warn(`[Keys] Ignoring invalid EXT-X-KEY tag: \"${value1}\"`);\n              }\n              break;\n            }\n          case 'START':\n            level.startTimeOffset = parseStartTimeOffset(value1);\n            break;\n          case 'MAP':\n            {\n              const mapAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, mapAttrs, ['BYTERANGE', 'URI']);\n              }\n              if (frag.duration) {\n                // Initial segment tag is after segment duration tag.\n                //   #EXTINF: 6.0\n                //   #EXT-X-MAP:URI=\"init.mp4\n                const init = new Fragment(type, baseurl);\n                setInitSegment(init, mapAttrs, id, levelkeys);\n                currentInitSegment = init;\n                frag.initSegment = currentInitSegment;\n                if (currentInitSegment.rawProgramDateTime && !frag.rawProgramDateTime) {\n                  frag.rawProgramDateTime = currentInitSegment.rawProgramDateTime;\n                }\n              } else {\n                // Initial segment tag is before segment duration tag\n                // Handle case where EXT-X-MAP is declared after EXT-X-BYTERANGE\n                const end = frag.byteRangeEndOffset;\n                if (end) {\n                  const start = frag.byteRangeStartOffset;\n                  nextByteRange = `${end - start}@${start}`;\n                } else {\n                  nextByteRange = null;\n                }\n                setInitSegment(frag, mapAttrs, id, levelkeys);\n                currentInitSegment = frag;\n                createNextFrag = true;\n              }\n              break;\n            }\n          case 'SERVER-CONTROL':\n            {\n              const serverControlAttrs = new AttrList(value1);\n              level.canBlockReload = serverControlAttrs.bool('CAN-BLOCK-RELOAD');\n              level.canSkipUntil = serverControlAttrs.optionalFloat('CAN-SKIP-UNTIL', 0);\n              level.canSkipDateRanges = level.canSkipUntil > 0 && serverControlAttrs.bool('CAN-SKIP-DATERANGES');\n              level.partHoldBack = serverControlAttrs.optionalFloat('PART-HOLD-BACK', 0);\n              level.holdBack = serverControlAttrs.optionalFloat('HOLD-BACK', 0);\n              break;\n            }\n          case 'PART-INF':\n            {\n              const partInfAttrs = new AttrList(value1);\n              level.partTarget = partInfAttrs.decimalFloatingPoint('PART-TARGET');\n              break;\n            }\n          case 'PART':\n            {\n              let partList = level.partList;\n              if (!partList) {\n                partList = level.partList = [];\n              }\n              const previousFragmentPart = currentPart > 0 ? partList[partList.length - 1] : undefined;\n              const index = currentPart++;\n              const partAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, partAttrs, ['BYTERANGE', 'URI']);\n              }\n              const part = new Part(partAttrs, frag, baseurl, index, previousFragmentPart);\n              partList.push(part);\n              frag.duration += part.duration;\n              break;\n            }\n          case 'PRELOAD-HINT':\n            {\n              const preloadHintAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, preloadHintAttrs, ['URI']);\n              }\n              level.preloadHint = preloadHintAttrs;\n              break;\n            }\n          case 'RENDITION-REPORT':\n            {\n              const renditionReportAttrs = new AttrList(value1);\n              {\n                substituteVariablesInAttributes(level, renditionReportAttrs, ['URI']);\n              }\n              level.renditionReports = level.renditionReports || [];\n              level.renditionReports.push(renditionReportAttrs);\n              break;\n            }\n          default:\n            logger.warn(`line parsed but not handled: ${result}`);\n            break;\n        }\n      }\n    }\n    if (prevFrag && !prevFrag.relurl) {\n      fragments.pop();\n      totalduration -= prevFrag.duration;\n      if (level.partList) {\n        level.fragmentHint = prevFrag;\n      }\n    } else if (level.partList) {\n      assignProgramDateTime(frag, prevFrag);\n      frag.cc = discontinuityCounter;\n      level.fragmentHint = frag;\n      if (levelkeys) {\n        setFragLevelKeys(frag, levelkeys, level);\n      }\n    }\n    const fragmentLength = fragments.length;\n    const firstFragment = fragments[0];\n    const lastFragment = fragments[fragmentLength - 1];\n    totalduration += level.skippedSegments * level.targetduration;\n    if (totalduration > 0 && fragmentLength && lastFragment) {\n      level.averagetargetduration = totalduration / fragmentLength;\n      const lastSn = lastFragment.sn;\n      level.endSN = lastSn !== 'initSegment' ? lastSn : 0;\n      if (!level.live) {\n        lastFragment.endList = true;\n      }\n      if (firstFragment) {\n        level.startCC = firstFragment.cc;\n      }\n    } else {\n      level.endSN = 0;\n      level.startCC = 0;\n    }\n    if (level.fragmentHint) {\n      totalduration += level.fragmentHint.duration;\n    }\n    level.totalduration = totalduration;\n    level.endCC = discontinuityCounter;\n\n    /**\n     * Backfill any missing PDT values\n     * \"If the first EXT-X-PROGRAM-DATE-TIME tag in a Playlist appears after\n     * one or more Media Segment URIs, the client SHOULD extrapolate\n     * backward from that tag (using EXTINF durations and/or media\n     * timestamps) to associate dates with those segments.\"\n     * We have already extrapolated forward, but all fragments up to the first instance of PDT do not have their PDTs\n     * computed.\n     */\n    if (firstPdtIndex > 0) {\n      backfillProgramDateTimes(fragments, firstPdtIndex);\n    }\n    return level;\n  }\n}\nfunction parseKey(keyTagAttributes, baseurl, parsed) {\n  var _keyAttrs$METHOD, _keyAttrs$KEYFORMAT;\n  // https://tools.ietf.org/html/rfc8216#section-4.3.2.4\n  const keyAttrs = new AttrList(keyTagAttributes);\n  {\n    substituteVariablesInAttributes(parsed, keyAttrs, ['KEYFORMAT', 'KEYFORMATVERSIONS', 'URI', 'IV', 'URI']);\n  }\n  const decryptmethod = (_keyAttrs$METHOD = keyAttrs.METHOD) != null ? _keyAttrs$METHOD : '';\n  const decrypturi = keyAttrs.URI;\n  const decryptiv = keyAttrs.hexadecimalInteger('IV');\n  const decryptkeyformatversions = keyAttrs.KEYFORMATVERSIONS;\n  // From RFC: This attribute is OPTIONAL; its absence indicates an implicit value of \"identity\".\n  const decryptkeyformat = (_keyAttrs$KEYFORMAT = keyAttrs.KEYFORMAT) != null ? _keyAttrs$KEYFORMAT : 'identity';\n  if (decrypturi && keyAttrs.IV && !decryptiv) {\n    logger.error(`Invalid IV: ${keyAttrs.IV}`);\n  }\n  // If decrypturi is a URI with a scheme, then baseurl will be ignored\n  // No uri is allowed when METHOD is NONE\n  const resolvedUri = decrypturi ? M3U8Parser.resolve(decrypturi, baseurl) : '';\n  const keyFormatVersions = (decryptkeyformatversions ? decryptkeyformatversions : '1').split('/').map(Number).filter(Number.isFinite);\n  return new LevelKey(decryptmethod, resolvedUri, decryptkeyformat, keyFormatVersions, decryptiv);\n}\nfunction parseStartTimeOffset(startAttributes) {\n  const startAttrs = new AttrList(startAttributes);\n  const startTimeOffset = startAttrs.decimalFloatingPoint('TIME-OFFSET');\n  if (isFiniteNumber(startTimeOffset)) {\n    return startTimeOffset;\n  }\n  return null;\n}\nfunction setCodecs(codecsAttributeValue, level) {\n  let codecs = (codecsAttributeValue || '').split(/[ ,]+/).filter(c => c);\n  ['video', 'audio', 'text'].forEach(type => {\n    const filtered = codecs.filter(codec => isCodecType(codec, type));\n    if (filtered.length) {\n      // Comma separated list of all codecs for type\n      level[`${type}Codec`] = filtered.join(',');\n      // Remove known codecs so that only unknownCodecs are left after iterating through each type\n      codecs = codecs.filter(codec => filtered.indexOf(codec) === -1);\n    }\n  });\n  level.unknownCodecs = codecs;\n}\nfunction assignCodec(media, groupItem, codecProperty) {\n  const codecValue = groupItem[codecProperty];\n  if (codecValue) {\n    media[codecProperty] = codecValue;\n  }\n}\nfunction backfillProgramDateTimes(fragments, firstPdtIndex) {\n  let fragPrev = fragments[firstPdtIndex];\n  for (let i = firstPdtIndex; i--;) {\n    const frag = fragments[i];\n    // Exit on delta-playlist skipped segments\n    if (!frag) {\n      return;\n    }\n    frag.programDateTime = fragPrev.programDateTime - frag.duration * 1000;\n    fragPrev = frag;\n  }\n}\nfunction assignProgramDateTime(frag, prevFrag) {\n  if (frag.rawProgramDateTime) {\n    frag.programDateTime = Date.parse(frag.rawProgramDateTime);\n  } else if (prevFrag != null && prevFrag.programDateTime) {\n    frag.programDateTime = prevFrag.endProgramDateTime;\n  }\n  if (!isFiniteNumber(frag.programDateTime)) {\n    frag.programDateTime = null;\n    frag.rawProgramDateTime = null;\n  }\n}\nfunction setInitSegment(frag, mapAttrs, id, levelkeys) {\n  frag.relurl = mapAttrs.URI;\n  if (mapAttrs.BYTERANGE) {\n    frag.setByteRange(mapAttrs.BYTERANGE);\n  }\n  frag.level = id;\n  frag.sn = 'initSegment';\n  if (levelkeys) {\n    frag.levelkeys = levelkeys;\n  }\n  frag.initSegment = null;\n}\nfunction setFragLevelKeys(frag, levelkeys, level) {\n  frag.levelkeys = levelkeys;\n  const {\n    encryptedFragments\n  } = level;\n  if ((!encryptedFragments.length || encryptedFragments[encryptedFragments.length - 1].levelkeys !== levelkeys) && Object.keys(levelkeys).some(format => levelkeys[format].isCommonEncryption)) {\n    encryptedFragments.push(frag);\n  }\n}\n\nvar PlaylistContextType = {\n  MANIFEST: \"manifest\",\n  LEVEL: \"level\",\n  AUDIO_TRACK: \"audioTrack\",\n  SUBTITLE_TRACK: \"subtitleTrack\"\n};\nvar PlaylistLevelType = {\n  MAIN: \"main\",\n  AUDIO: \"audio\",\n  SUBTITLE: \"subtitle\"\n};\n\nfunction mapContextToLevelType(context) {\n  const {\n    type\n  } = context;\n  switch (type) {\n    case PlaylistContextType.AUDIO_TRACK:\n      return PlaylistLevelType.AUDIO;\n    case PlaylistContextType.SUBTITLE_TRACK:\n      return PlaylistLevelType.SUBTITLE;\n    default:\n      return PlaylistLevelType.MAIN;\n  }\n}\nfunction getResponseUrl(response, context) {\n  let url = response.url;\n  // responseURL not supported on some browsers (it is used to detect URL redirection)\n  // data-uri mode also not supported (but no need to detect redirection)\n  if (url === undefined || url.indexOf('data:') === 0) {\n    // fallback to initial URL\n    url = context.url;\n  }\n  return url;\n}\nclass PlaylistLoader {\n  constructor(hls) {\n    this.hls = void 0;\n    this.loaders = Object.create(null);\n    this.variableList = null;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.destroyInternalLoaders();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.AUDIO_TRACK_LOADING, this.onAudioTrackLoading, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADING, this.onSubtitleTrackLoading, this);\n  }\n\n  /**\n   * Returns defaults or configured loader-type overloads (pLoader and loader config params)\n   */\n  createInternalLoader(context) {\n    const config = this.hls.config;\n    const PLoader = config.pLoader;\n    const Loader = config.loader;\n    const InternalLoader = PLoader || Loader;\n    const loader = new InternalLoader(config);\n    this.loaders[context.type] = loader;\n    return loader;\n  }\n  getInternalLoader(context) {\n    return this.loaders[context.type];\n  }\n  resetInternalLoader(contextType) {\n    if (this.loaders[contextType]) {\n      delete this.loaders[contextType];\n    }\n  }\n\n  /**\n   * Call `destroy` on all internal loader instances mapped (one per context type)\n   */\n  destroyInternalLoaders() {\n    for (const contextType in this.loaders) {\n      const loader = this.loaders[contextType];\n      if (loader) {\n        loader.destroy();\n      }\n      this.resetInternalLoader(contextType);\n    }\n  }\n  destroy() {\n    this.variableList = null;\n    this.unregisterListeners();\n    this.destroyInternalLoaders();\n  }\n  onManifestLoading(event, data) {\n    const {\n      url\n    } = data;\n    this.variableList = null;\n    this.load({\n      id: null,\n      level: 0,\n      responseType: 'text',\n      type: PlaylistContextType.MANIFEST,\n      url,\n      deliveryDirectives: null\n    });\n  }\n  onLevelLoading(event, data) {\n    const {\n      id,\n      level,\n      pathwayId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      level,\n      pathwayId,\n      responseType: 'text',\n      type: PlaylistContextType.LEVEL,\n      url,\n      deliveryDirectives\n    });\n  }\n  onAudioTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.AUDIO_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  onSubtitleTrackLoading(event, data) {\n    const {\n      id,\n      groupId,\n      url,\n      deliveryDirectives\n    } = data;\n    this.load({\n      id,\n      groupId,\n      level: null,\n      responseType: 'text',\n      type: PlaylistContextType.SUBTITLE_TRACK,\n      url,\n      deliveryDirectives\n    });\n  }\n  load(context) {\n    var _context$deliveryDire;\n    const config = this.hls.config;\n\n    // logger.debug(`[playlist-loader]: Loading playlist of type ${context.type}, level: ${context.level}, id: ${context.id}`);\n\n    // Check if a loader for this context already exists\n    let loader = this.getInternalLoader(context);\n    if (loader) {\n      const loaderContext = loader.context;\n      if (loaderContext && loaderContext.url === context.url && loaderContext.level === context.level) {\n        // same URL can't overlap\n        logger.trace('[playlist-loader]: playlist request ongoing');\n        return;\n      }\n      logger.log(`[playlist-loader]: aborting previous loader for type: ${context.type}`);\n      loader.abort();\n    }\n\n    // apply different configs for retries depending on\n    // context (manifest, level, audio/subs playlist)\n    let loadPolicy;\n    if (context.type === PlaylistContextType.MANIFEST) {\n      loadPolicy = config.manifestLoadPolicy.default;\n    } else {\n      loadPolicy = _extends({}, config.playlistLoadPolicy.default, {\n        timeoutRetry: null,\n        errorRetry: null\n      });\n    }\n    loader = this.createInternalLoader(context);\n\n    // Override level/track timeout for LL-HLS requests\n    // (the default of 10000ms is counter productive to blocking playlist reload requests)\n    if (isFiniteNumber((_context$deliveryDire = context.deliveryDirectives) == null ? void 0 : _context$deliveryDire.part)) {\n      let levelDetails;\n      if (context.type === PlaylistContextType.LEVEL && context.level !== null) {\n        levelDetails = this.hls.levels[context.level].details;\n      } else if (context.type === PlaylistContextType.AUDIO_TRACK && context.id !== null) {\n        levelDetails = this.hls.audioTracks[context.id].details;\n      } else if (context.type === PlaylistContextType.SUBTITLE_TRACK && context.id !== null) {\n        levelDetails = this.hls.subtitleTracks[context.id].details;\n      }\n      if (levelDetails) {\n        const partTarget = levelDetails.partTarget;\n        const targetDuration = levelDetails.targetduration;\n        if (partTarget && targetDuration) {\n          const maxLowLatencyPlaylistRefresh = Math.max(partTarget * 3, targetDuration * 0.8) * 1000;\n          loadPolicy = _extends({}, loadPolicy, {\n            maxTimeToFirstByteMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs),\n            maxLoadTimeMs: Math.min(maxLowLatencyPlaylistRefresh, loadPolicy.maxTimeToFirstByteMs)\n          });\n        }\n      }\n    }\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const loaderCallbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        const loader = this.getInternalLoader(context);\n        this.resetInternalLoader(context.type);\n        const string = response.data;\n\n        // Validate if it is an M3U8 at all\n        if (string.indexOf('#EXTM3U') !== 0) {\n          this.handleManifestParsingError(response, context, new Error('no EXTM3U delimiter'), networkDetails || null, stats);\n          return;\n        }\n        stats.parsing.start = performance.now();\n        if (M3U8Parser.isMediaPlaylist(string)) {\n          this.handleTrackOrLevelPlaylist(response, stats, context, networkDetails || null, loader);\n        } else {\n          this.handleMasterPlaylist(response, stats, context, networkDetails);\n        }\n      },\n      onError: (response, context, networkDetails, stats) => {\n        this.handleNetworkError(context, networkDetails, false, response, stats);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.handleNetworkError(context, networkDetails, true, undefined, stats);\n      }\n    };\n\n    // logger.debug(`[playlist-loader]: Calling internal loader delegate for URL: ${context.url}`);\n\n    loader.load(context, loaderConfig, loaderCallbacks);\n  }\n  handleMasterPlaylist(response, stats, context, networkDetails) {\n    const hls = this.hls;\n    const string = response.data;\n    const url = getResponseUrl(response, context);\n    const parsedResult = M3U8Parser.parseMasterPlaylist(string, url);\n    if (parsedResult.playlistParsingError) {\n      this.handleManifestParsingError(response, context, parsedResult.playlistParsingError, networkDetails, stats);\n      return;\n    }\n    const {\n      contentSteering,\n      levels,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    } = parsedResult;\n    this.variableList = variableList;\n    const {\n      AUDIO: audioTracks = [],\n      SUBTITLES: subtitles,\n      'CLOSED-CAPTIONS': captions\n    } = M3U8Parser.parseMasterPlaylistMedia(string, url, parsedResult);\n    if (audioTracks.length) {\n      // check if we have found an audio track embedded in main playlist (audio track without URI attribute)\n      const embeddedAudioFound = audioTracks.some(audioTrack => !audioTrack.url);\n\n      // if no embedded audio track defined, but audio codec signaled in quality level,\n      // we need to signal this main audio track this could happen with playlists with\n      // alt audio rendition in which quality levels (main)\n      // contains both audio+video. but with mixed audio track not signaled\n      if (!embeddedAudioFound && levels[0].audioCodec && !levels[0].attrs.AUDIO) {\n        logger.log('[playlist-loader]: audio codec signaled in quality level, but no embedded audio track signaled, create one');\n        audioTracks.unshift({\n          type: 'main',\n          name: 'main',\n          groupId: 'main',\n          default: false,\n          autoselect: false,\n          forced: false,\n          id: -1,\n          attrs: new AttrList({}),\n          bitrate: 0,\n          url: ''\n        });\n      }\n    }\n    hls.trigger(Events.MANIFEST_LOADED, {\n      levels,\n      audioTracks,\n      subtitles,\n      captions,\n      contentSteering,\n      url,\n      stats,\n      networkDetails,\n      sessionData,\n      sessionKeys,\n      startTimeOffset,\n      variableList\n    });\n  }\n  handleTrackOrLevelPlaylist(response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      id,\n      level,\n      type\n    } = context;\n    const url = getResponseUrl(response, context);\n    const levelUrlId = 0;\n    const levelId = isFiniteNumber(level) ? level : isFiniteNumber(id) ? id : 0;\n    const levelType = mapContextToLevelType(context);\n    const levelDetails = M3U8Parser.parseLevelPlaylist(response.data, url, levelId, levelType, levelUrlId, this.variableList);\n\n    // We have done our first request (Manifest-type) and receive\n    // not a master playlist but a chunk-list (track/level)\n    // We fire the manifest-loaded event anyway with the parsed level-details\n    // by creating a single-level structure for it.\n    if (type === PlaylistContextType.MANIFEST) {\n      const singleLevel = {\n        attrs: new AttrList({}),\n        bitrate: 0,\n        details: levelDetails,\n        name: '',\n        url\n      };\n      hls.trigger(Events.MANIFEST_LOADED, {\n        levels: [singleLevel],\n        audioTracks: [],\n        url,\n        stats,\n        networkDetails,\n        sessionData: null,\n        sessionKeys: null,\n        contentSteering: null,\n        startTimeOffset: null,\n        variableList: null\n      });\n    }\n\n    // save parsing time\n    stats.parsing.end = performance.now();\n\n    // extend the context with the new levelDetails property\n    context.levelDetails = levelDetails;\n    this.handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader);\n  }\n  handleManifestParsingError(response, context, error, networkDetails, stats) {\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.NETWORK_ERROR,\n      details: ErrorDetails.MANIFEST_PARSING_ERROR,\n      fatal: context.type === PlaylistContextType.MANIFEST,\n      url: response.url,\n      err: error,\n      error,\n      reason: error.message,\n      response,\n      context,\n      networkDetails,\n      stats\n    });\n  }\n  handleNetworkError(context, networkDetails, timeout = false, response, stats) {\n    let message = `A network ${timeout ? 'timeout' : 'error' + (response ? ' (status ' + response.code + ')' : '')} occurred while loading ${context.type}`;\n    if (context.type === PlaylistContextType.LEVEL) {\n      message += `: ${context.level} id: ${context.id}`;\n    } else if (context.type === PlaylistContextType.AUDIO_TRACK || context.type === PlaylistContextType.SUBTITLE_TRACK) {\n      message += ` id: ${context.id} group-id: \"${context.groupId}\"`;\n    }\n    const error = new Error(message);\n    logger.warn(`[playlist-loader]: ${message}`);\n    let details = ErrorDetails.UNKNOWN;\n    let fatal = false;\n    const loader = this.getInternalLoader(context);\n    switch (context.type) {\n      case PlaylistContextType.MANIFEST:\n        details = timeout ? ErrorDetails.MANIFEST_LOAD_TIMEOUT : ErrorDetails.MANIFEST_LOAD_ERROR;\n        fatal = true;\n        break;\n      case PlaylistContextType.LEVEL:\n        details = timeout ? ErrorDetails.LEVEL_LOAD_TIMEOUT : ErrorDetails.LEVEL_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        details = timeout ? ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT : ErrorDetails.AUDIO_TRACK_LOAD_ERROR;\n        fatal = false;\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        details = timeout ? ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT : ErrorDetails.SUBTITLE_LOAD_ERROR;\n        fatal = false;\n        break;\n    }\n    if (loader) {\n      this.resetInternalLoader(context.type);\n    }\n    const errorData = {\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal,\n      url: context.url,\n      loader,\n      context,\n      error,\n      networkDetails,\n      stats\n    };\n    if (response) {\n      const url = (networkDetails == null ? void 0 : networkDetails.url) || context.url;\n      errorData.response = _objectSpread2({\n        url,\n        data: undefined\n      }, response);\n    }\n    this.hls.trigger(Events.ERROR, errorData);\n  }\n  handlePlaylistLoaded(levelDetails, response, stats, context, networkDetails, loader) {\n    const hls = this.hls;\n    const {\n      type,\n      level,\n      id,\n      groupId,\n      deliveryDirectives\n    } = context;\n    const url = getResponseUrl(response, context);\n    const parent = mapContextToLevelType(context);\n    const levelIndex = typeof context.level === 'number' && parent === PlaylistLevelType.MAIN ? level : undefined;\n    if (!levelDetails.fragments.length) {\n      const _error = new Error('No Segments found in Playlist');\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_EMPTY_ERROR,\n        fatal: false,\n        url,\n        error: _error,\n        reason: _error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (!levelDetails.targetduration) {\n      levelDetails.playlistParsingError = new Error('Missing Target Duration');\n    }\n    const error = levelDetails.playlistParsingError;\n    if (error) {\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.LEVEL_PARSING_ERROR,\n        fatal: false,\n        url,\n        error,\n        reason: error.message,\n        response,\n        context,\n        level: levelIndex,\n        parent,\n        networkDetails,\n        stats\n      });\n      return;\n    }\n    if (levelDetails.live && loader) {\n      if (loader.getCacheAge) {\n        levelDetails.ageHeader = loader.getCacheAge() || 0;\n      }\n      if (!loader.getCacheAge || isNaN(levelDetails.ageHeader)) {\n        levelDetails.ageHeader = 0;\n      }\n    }\n    switch (type) {\n      case PlaylistContextType.MANIFEST:\n      case PlaylistContextType.LEVEL:\n        hls.trigger(Events.LEVEL_LOADED, {\n          details: levelDetails,\n          level: levelIndex || 0,\n          id: id || 0,\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.AUDIO_TRACK:\n        hls.trigger(Events.AUDIO_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n      case PlaylistContextType.SUBTITLE_TRACK:\n        hls.trigger(Events.SUBTITLE_TRACK_LOADED, {\n          details: levelDetails,\n          id: id || 0,\n          groupId: groupId || '',\n          stats,\n          networkDetails,\n          deliveryDirectives\n        });\n        break;\n    }\n  }\n}\n\nfunction sendAddTrackEvent(track, videoEl) {\n  let event;\n  try {\n    event = new Event('addtrack');\n  } catch (err) {\n    // for IE11\n    event = document.createEvent('Event');\n    event.initEvent('addtrack', false, false);\n  }\n  event.track = track;\n  videoEl.dispatchEvent(event);\n}\nfunction addCueToTrack(track, cue) {\n  // Sometimes there are cue overlaps on segmented vtts so the same\n  // cue can appear more than once in different vtt files.\n  // This avoid showing duplicated cues with same timecode and text.\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && !track.cues.getCueById(cue.id)) {\n    try {\n      track.addCue(cue);\n      if (!track.cues.getCueById(cue.id)) {\n        throw new Error(`addCue is failed for: ${cue}`);\n      }\n    } catch (err) {\n      logger.debug(`[texttrack-utils]: ${err}`);\n      try {\n        const textTrackCue = new self.TextTrackCue(cue.startTime, cue.endTime, cue.text);\n        textTrackCue.id = cue.id;\n        track.addCue(textTrackCue);\n      } catch (err2) {\n        logger.debug(`[texttrack-utils]: Legacy TextTrackCue fallback failed: ${err2}`);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction clearCurrentCues(track) {\n  // When track.mode is disabled, track.cues will be null.\n  // To guarantee the removal of cues, we need to temporarily\n  // change the mode to hidden\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues) {\n    for (let i = track.cues.length; i--;) {\n      track.removeCue(track.cues[i]);\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\nfunction removeCuesInRange(track, start, end, predicate) {\n  const mode = track.mode;\n  if (mode === 'disabled') {\n    track.mode = 'hidden';\n  }\n  if (track.cues && track.cues.length > 0) {\n    const cues = getCuesInRange(track.cues, start, end);\n    for (let i = 0; i < cues.length; i++) {\n      if (!predicate || predicate(cues[i])) {\n        track.removeCue(cues[i]);\n      }\n    }\n  }\n  if (mode === 'disabled') {\n    track.mode = mode;\n  }\n}\n\n// Find first cue starting after given time.\n// Modified version of binary search O(log(n)).\nfunction getFirstCueIndexAfterTime(cues, time) {\n  // If first cue starts after time, start there\n  if (time < cues[0].startTime) {\n    return 0;\n  }\n  // If the last cue ends before time there is no overlap\n  const len = cues.length - 1;\n  if (time > cues[len].endTime) {\n    return -1;\n  }\n  let left = 0;\n  let right = len;\n  while (left <= right) {\n    const mid = Math.floor((right + left) / 2);\n    if (time < cues[mid].startTime) {\n      right = mid - 1;\n    } else if (time > cues[mid].startTime && left < len) {\n      left = mid + 1;\n    } else {\n      // If it's not lower or higher, it must be equal.\n      return mid;\n    }\n  }\n  // At this point, left and right have swapped.\n  // No direct match was found, left or right element must be the closest. Check which one has the smallest diff.\n  return cues[left].startTime - time < time - cues[right].startTime ? left : right;\n}\nfunction getCuesInRange(cues, start, end) {\n  const cuesFound = [];\n  const firstCueInRange = getFirstCueIndexAfterTime(cues, start);\n  if (firstCueInRange > -1) {\n    for (let i = firstCueInRange, len = cues.length; i < len; i++) {\n      const cue = cues[i];\n      if (cue.startTime >= start && cue.endTime <= end) {\n        cuesFound.push(cue);\n      } else if (cue.startTime > end) {\n        return cuesFound;\n      }\n    }\n  }\n  return cuesFound;\n}\nfunction filterSubtitleTracks(textTrackList) {\n  const tracks = [];\n  for (let i = 0; i < textTrackList.length; i++) {\n    const track = textTrackList[i];\n    // Edge adds a track without a label; we don't want to use it\n    if ((track.kind === 'subtitles' || track.kind === 'captions') && track.label) {\n      tracks.push(textTrackList[i]);\n    }\n  }\n  return tracks;\n}\n\nvar MetadataSchema = {\n  audioId3: \"org.id3\",\n  dateRange: \"com.apple.quicktime.HLS\",\n  emsg: \"https://aomedia.org/emsg/ID3\"\n};\n\nconst MIN_CUE_DURATION = 0.25;\nfunction getCueClass() {\n  if (typeof self === 'undefined') return undefined;\n  return self.VTTCue || self.TextTrackCue;\n}\nfunction createCueWithDataFields(Cue, startTime, endTime, data, type) {\n  let cue = new Cue(startTime, endTime, '');\n  try {\n    cue.value = data;\n    if (type) {\n      cue.type = type;\n    }\n  } catch (e) {\n    cue = new Cue(startTime, endTime, JSON.stringify(type ? _objectSpread2({\n      type\n    }, data) : data));\n  }\n  return cue;\n}\n\n// VTTCue latest draft allows an infinite duration, fallback\n// to MAX_VALUE if necessary\nconst MAX_CUE_ENDTIME = (() => {\n  const Cue = getCueClass();\n  try {\n    Cue && new Cue(0, Number.POSITIVE_INFINITY, '');\n  } catch (e) {\n    return Number.MAX_VALUE;\n  }\n  return Number.POSITIVE_INFINITY;\n})();\nfunction dateRangeDateToTimelineSeconds(date, offset) {\n  return date.getTime() / 1000 - offset;\n}\nfunction hexToArrayBuffer(str) {\n  return Uint8Array.from(str.replace(/^0x/, '').replace(/([\\da-fA-F]{2}) ?/g, '0x$1 ').replace(/ +$/, '').split(' ')).buffer;\n}\nclass ID3TrackController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    this.hls = hls;\n    this._registerListeners();\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n    // @ts-ignore\n    this.hls = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_PARSING_METADATA, this.onFragParsingMetadata, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n\n  // Add ID3 metatadata text track.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n  }\n  onMediaDetaching() {\n    if (!this.id3Track) {\n      return;\n    }\n    clearCurrentCues(this.id3Track);\n    this.id3Track = null;\n    this.media = null;\n    this.dateRangeCuesAppended = {};\n  }\n  onManifestLoading() {\n    this.dateRangeCuesAppended = {};\n  }\n  createTrack(media) {\n    const track = this.getID3Track(media.textTracks);\n    track.mode = 'hidden';\n    return track;\n  }\n  getID3Track(textTracks) {\n    if (!this.media) {\n      return;\n    }\n    for (let i = 0; i < textTracks.length; i++) {\n      const textTrack = textTracks[i];\n      if (textTrack.kind === 'metadata' && textTrack.label === 'id3') {\n        // send 'addtrack' when reusing the textTrack for metadata,\n        // same as what we do for captions\n        sendAddTrackEvent(textTrack, this.media);\n        return textTrack;\n      }\n    }\n    return this.media.addTextTrack('metadata', 'id3');\n  }\n  onFragParsingMetadata(event, data) {\n    if (!this.media) {\n      return;\n    }\n    const {\n      hls: {\n        config: {\n          enableEmsgMetadataCues,\n          enableID3MetadataCues\n        }\n      }\n    } = this;\n    if (!enableEmsgMetadataCues && !enableID3MetadataCues) {\n      return;\n    }\n    const {\n      samples\n    } = data;\n\n    // create track dynamically\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const Cue = getCueClass();\n    if (!Cue) {\n      return;\n    }\n    for (let i = 0; i < samples.length; i++) {\n      const type = samples[i].type;\n      if (type === MetadataSchema.emsg && !enableEmsgMetadataCues || !enableID3MetadataCues) {\n        continue;\n      }\n      const frames = getID3Frames(samples[i].data);\n      if (frames) {\n        const startTime = samples[i].pts;\n        let endTime = startTime + samples[i].duration;\n        if (endTime > MAX_CUE_ENDTIME) {\n          endTime = MAX_CUE_ENDTIME;\n        }\n        const timeDiff = endTime - startTime;\n        if (timeDiff <= 0) {\n          endTime = startTime + MIN_CUE_DURATION;\n        }\n        for (let j = 0; j < frames.length; j++) {\n          const frame = frames[j];\n          // Safari doesn't put the timestamp frame in the TextTrack\n          if (!isTimeStampFrame(frame)) {\n            // add a bounds to any unbounded cues\n            this.updateId3CueEnds(startTime, type);\n            const cue = createCueWithDataFields(Cue, startTime, endTime, frame, type);\n            if (cue) {\n              this.id3Track.addCue(cue);\n            }\n          }\n        }\n      }\n    }\n  }\n  updateId3CueEnds(startTime, type) {\n    var _this$id3Track;\n    const cues = (_this$id3Track = this.id3Track) == null ? void 0 : _this$id3Track.cues;\n    if (cues) {\n      for (let i = cues.length; i--;) {\n        const cue = cues[i];\n        if (cue.type === type && cue.startTime < startTime && cue.endTime === MAX_CUE_ENDTIME) {\n          cue.endTime = startTime;\n        }\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    type\n  }) {\n    const {\n      id3Track,\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    const {\n      config: {\n        enableEmsgMetadataCues,\n        enableID3MetadataCues\n      }\n    } = hls;\n    if (id3Track && (enableEmsgMetadataCues || enableID3MetadataCues)) {\n      let predicate;\n      if (type === 'audio') {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues;\n      } else if (type === 'video') {\n        predicate = cue => cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      } else {\n        predicate = cue => cue.type === MetadataSchema.audioId3 && enableID3MetadataCues || cue.type === MetadataSchema.emsg && enableEmsgMetadataCues;\n      }\n      removeCuesInRange(id3Track, startOffset, endOffset, predicate);\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!this.media || !details.hasProgramDateTime || !this.hls.config.enableDateRangeMetadataCues) {\n      return;\n    }\n    const {\n      dateRangeCuesAppended,\n      id3Track\n    } = this;\n    const {\n      dateRanges\n    } = details;\n    const ids = Object.keys(dateRanges);\n    // Remove cues from track not found in details.dateRanges\n    if (id3Track) {\n      const idsToRemove = Object.keys(dateRangeCuesAppended).filter(id => !ids.includes(id));\n      for (let i = idsToRemove.length; i--;) {\n        const id = idsToRemove[i];\n        Object.keys(dateRangeCuesAppended[id].cues).forEach(key => {\n          id3Track.removeCue(dateRangeCuesAppended[id].cues[key]);\n        });\n        delete dateRangeCuesAppended[id];\n      }\n    }\n    // Exit if the playlist does not have Date Ranges or does not have Program Date Time\n    const lastFragment = details.fragments[details.fragments.length - 1];\n    if (ids.length === 0 || !isFiniteNumber(lastFragment == null ? void 0 : lastFragment.programDateTime)) {\n      return;\n    }\n    if (!this.id3Track) {\n      this.id3Track = this.createTrack(this.media);\n    }\n    const dateTimeOffset = lastFragment.programDateTime / 1000 - lastFragment.start;\n    const Cue = getCueClass();\n    for (let i = 0; i < ids.length; i++) {\n      const id = ids[i];\n      const dateRange = dateRanges[id];\n      const startTime = dateRangeDateToTimelineSeconds(dateRange.startDate, dateTimeOffset);\n\n      // Process DateRanges to determine end-time (known DURATION, END-DATE, or END-ON-NEXT)\n      const appendedDateRangeCues = dateRangeCuesAppended[id];\n      const cues = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.cues) || {};\n      let durationKnown = (appendedDateRangeCues == null ? void 0 : appendedDateRangeCues.durationKnown) || false;\n      let endTime = MAX_CUE_ENDTIME;\n      const endDate = dateRange.endDate;\n      if (endDate) {\n        endTime = dateRangeDateToTimelineSeconds(endDate, dateTimeOffset);\n        durationKnown = true;\n      } else if (dateRange.endOnNext && !durationKnown) {\n        const nextDateRangeWithSameClass = ids.reduce((candidateDateRange, id) => {\n          if (id !== dateRange.id) {\n            const otherDateRange = dateRanges[id];\n            if (otherDateRange.class === dateRange.class && otherDateRange.startDate > dateRange.startDate && (!candidateDateRange || dateRange.startDate < candidateDateRange.startDate)) {\n              return otherDateRange;\n            }\n          }\n          return candidateDateRange;\n        }, null);\n        if (nextDateRangeWithSameClass) {\n          endTime = dateRangeDateToTimelineSeconds(nextDateRangeWithSameClass.startDate, dateTimeOffset);\n          durationKnown = true;\n        }\n      }\n\n      // Create TextTrack Cues for each MetadataGroup Item (select DateRange attribute)\n      // This is to emulate Safari HLS playback handling of DateRange tags\n      const attributes = Object.keys(dateRange.attr);\n      for (let j = 0; j < attributes.length; j++) {\n        const key = attributes[j];\n        if (!isDateRangeCueAttribute(key)) {\n          continue;\n        }\n        const cue = cues[key];\n        if (cue) {\n          if (durationKnown && !appendedDateRangeCues.durationKnown) {\n            cue.endTime = endTime;\n          }\n        } else if (Cue) {\n          let data = dateRange.attr[key];\n          if (isSCTE35Attribute(key)) {\n            data = hexToArrayBuffer(data);\n          }\n          const _cue = createCueWithDataFields(Cue, startTime, endTime, {\n            key,\n            data\n          }, MetadataSchema.dateRange);\n          if (_cue) {\n            _cue.id = id;\n            this.id3Track.addCue(_cue);\n            cues[key] = _cue;\n          }\n        }\n      }\n\n      // Keep track of processed DateRanges by ID for updating cues with new DateRange tag attributes\n      dateRangeCuesAppended[id] = {\n        cues,\n        dateRange,\n        durationKnown\n      };\n    }\n  }\n}\n\nclass LatencyController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.levelDetails = null;\n    this.currentTime = 0;\n    this.stallCount = 0;\n    this._latency = null;\n    this.timeupdateHandler = () => this.timeupdate();\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  get latency() {\n    return this._latency || 0;\n  }\n  get maxLatency() {\n    const {\n      config,\n      levelDetails\n    } = this;\n    if (config.liveMaxLatencyDuration !== undefined) {\n      return config.liveMaxLatencyDuration;\n    }\n    return levelDetails ? config.liveMaxLatencyDurationCount * levelDetails.targetduration : 0;\n  }\n  get targetLatency() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    const {\n      holdBack,\n      partHoldBack,\n      targetduration\n    } = levelDetails;\n    const {\n      liveSyncDuration,\n      liveSyncDurationCount,\n      lowLatencyMode\n    } = this.config;\n    const userConfig = this.hls.userConfig;\n    let targetLatency = lowLatencyMode ? partHoldBack || holdBack : holdBack;\n    if (userConfig.liveSyncDuration || userConfig.liveSyncDurationCount || targetLatency === 0) {\n      targetLatency = liveSyncDuration !== undefined ? liveSyncDuration : liveSyncDurationCount * targetduration;\n    }\n    const maxLiveSyncOnStallIncrease = targetduration;\n    const liveSyncOnStallIncrease = 1.0;\n    return targetLatency + Math.min(this.stallCount * liveSyncOnStallIncrease, maxLiveSyncOnStallIncrease);\n  }\n  get liveSyncPosition() {\n    const liveEdge = this.estimateLiveEdge();\n    const targetLatency = this.targetLatency;\n    const levelDetails = this.levelDetails;\n    if (liveEdge === null || targetLatency === null || levelDetails === null) {\n      return null;\n    }\n    const edge = levelDetails.edge;\n    const syncPosition = liveEdge - targetLatency - this.edgeStalled;\n    const min = edge - levelDetails.totalduration;\n    const max = edge - (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration);\n    return Math.min(Math.max(min, syncPosition), max);\n  }\n  get drift() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 1;\n    }\n    return levelDetails.drift;\n  }\n  get edgeStalled() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return 0;\n    }\n    const maxLevelUpdateAge = (this.config.lowLatencyMode && levelDetails.partTarget || levelDetails.targetduration) * 3;\n    return Math.max(levelDetails.age - maxLevelUpdateAge, 0);\n  }\n  get forwardBufferLength() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return 0;\n    }\n    const bufferedRanges = media.buffered.length;\n    return (bufferedRanges ? media.buffered.end(bufferedRanges - 1) : levelDetails.edge) - this.currentTime;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetaching();\n    this.levelDetails = null;\n    // @ts-ignore\n    this.hls = this.timeupdateHandler = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    this.hls.off(Events.ERROR, this.onError, this);\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('timeupdate', this.timeupdateHandler);\n  }\n  onMediaDetaching() {\n    if (this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n      this.media = null;\n    }\n  }\n  onManifestLoading() {\n    this.levelDetails = null;\n    this._latency = null;\n    this.stallCount = 0;\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    this.levelDetails = details;\n    if (details.advanced) {\n      this.timeupdate();\n    }\n    if (!details.live && this.media) {\n      this.media.removeEventListener('timeupdate', this.timeupdateHandler);\n    }\n  }\n  onError(event, data) {\n    var _this$levelDetails;\n    if (data.details !== ErrorDetails.BUFFER_STALLED_ERROR) {\n      return;\n    }\n    this.stallCount++;\n    if ((_this$levelDetails = this.levelDetails) != null && _this$levelDetails.live) {\n      logger.warn('[playback-rate-controller]: Stall detected, adjusting target latency');\n    }\n  }\n  timeupdate() {\n    const {\n      media,\n      levelDetails\n    } = this;\n    if (!media || !levelDetails) {\n      return;\n    }\n    this.currentTime = media.currentTime;\n    const latency = this.computeLatency();\n    if (latency === null) {\n      return;\n    }\n    this._latency = latency;\n\n    // Adapt playbackRate to meet target latency in low-latency mode\n    const {\n      lowLatencyMode,\n      maxLiveSyncPlaybackRate\n    } = this.config;\n    if (!lowLatencyMode || maxLiveSyncPlaybackRate === 1 || !levelDetails.live) {\n      return;\n    }\n    const targetLatency = this.targetLatency;\n    if (targetLatency === null) {\n      return;\n    }\n    const distanceFromTarget = latency - targetLatency;\n    // Only adjust playbackRate when within one target duration of targetLatency\n    // and more than one second from under-buffering.\n    // Playback further than one target duration from target can be considered DVR playback.\n    const liveMinLatencyDuration = Math.min(this.maxLatency, targetLatency + levelDetails.targetduration);\n    const inLiveRange = distanceFromTarget < liveMinLatencyDuration;\n    if (inLiveRange && distanceFromTarget > 0.05 && this.forwardBufferLength > 1) {\n      const max = Math.min(2, Math.max(1.0, maxLiveSyncPlaybackRate));\n      const rate = Math.round(2 / (1 + Math.exp(-0.75 * distanceFromTarget - this.edgeStalled)) * 20) / 20;\n      media.playbackRate = Math.min(max, Math.max(1, rate));\n    } else if (media.playbackRate !== 1 && media.playbackRate !== 0) {\n      media.playbackRate = 1;\n    }\n  }\n  estimateLiveEdge() {\n    const {\n      levelDetails\n    } = this;\n    if (levelDetails === null) {\n      return null;\n    }\n    return levelDetails.edge + levelDetails.age;\n  }\n  computeLatency() {\n    const liveEdge = this.estimateLiveEdge();\n    if (liveEdge === null) {\n      return null;\n    }\n    return liveEdge - this.currentTime;\n  }\n}\n\nconst HdcpLevels = ['NONE', 'TYPE-0', 'TYPE-1', null];\nfunction isHdcpLevel(value) {\n  return HdcpLevels.indexOf(value) > -1;\n}\nconst VideoRangeValues = ['SDR', 'PQ', 'HLG'];\nfunction isVideoRange(value) {\n  return !!value && VideoRangeValues.indexOf(value) > -1;\n}\nvar HlsSkip = {\n  No: \"\",\n  Yes: \"YES\",\n  v2: \"v2\"\n};\nfunction getSkipValue(details) {\n  const {\n    canSkipUntil,\n    canSkipDateRanges,\n    age\n  } = details;\n  // A Client SHOULD NOT request a Playlist Delta Update unless it already\n  // has a version of the Playlist that is no older than one-half of the Skip Boundary.\n  // @see: https://datatracker.ietf.org/doc/html/draft-pantos-hls-rfc8216bis#section-6.3.7\n  const playlistRecentEnough = age < canSkipUntil / 2;\n  if (canSkipUntil && playlistRecentEnough) {\n    if (canSkipDateRanges) {\n      return HlsSkip.v2;\n    }\n    return HlsSkip.Yes;\n  }\n  return HlsSkip.No;\n}\nclass HlsUrlParameters {\n  constructor(msn, part, skip) {\n    this.msn = void 0;\n    this.part = void 0;\n    this.skip = void 0;\n    this.msn = msn;\n    this.part = part;\n    this.skip = skip;\n  }\n  addDirectives(uri) {\n    const url = new self.URL(uri);\n    if (this.msn !== undefined) {\n      url.searchParams.set('_HLS_msn', this.msn.toString());\n    }\n    if (this.part !== undefined) {\n      url.searchParams.set('_HLS_part', this.part.toString());\n    }\n    if (this.skip) {\n      url.searchParams.set('_HLS_skip', this.skip);\n    }\n    return url.href;\n  }\n}\nclass Level {\n  constructor(data) {\n    this._attrs = void 0;\n    this.audioCodec = void 0;\n    this.bitrate = void 0;\n    this.codecSet = void 0;\n    this.url = void 0;\n    this.frameRate = void 0;\n    this.height = void 0;\n    this.id = void 0;\n    this.name = void 0;\n    this.videoCodec = void 0;\n    this.width = void 0;\n    this.details = void 0;\n    this.fragmentError = 0;\n    this.loadError = 0;\n    this.loaded = void 0;\n    this.realBitrate = 0;\n    this.supportedPromise = void 0;\n    this.supportedResult = void 0;\n    this._avgBitrate = 0;\n    this._audioGroups = void 0;\n    this._subtitleGroups = void 0;\n    // Deprecated (retained for backwards compatibility)\n    this._urlId = 0;\n    this.url = [data.url];\n    this._attrs = [data.attrs];\n    this.bitrate = data.bitrate;\n    if (data.details) {\n      this.details = data.details;\n    }\n    this.id = data.id || 0;\n    this.name = data.name;\n    this.width = data.width || 0;\n    this.height = data.height || 0;\n    this.frameRate = data.attrs.optionalFloat('FRAME-RATE', 0);\n    this._avgBitrate = data.attrs.decimalInteger('AVERAGE-BANDWIDTH');\n    this.audioCodec = data.audioCodec;\n    this.videoCodec = data.videoCodec;\n    this.codecSet = [data.videoCodec, data.audioCodec].filter(c => !!c).map(s => s.substring(0, 4)).join(',');\n    this.addGroupId('audio', data.attrs.AUDIO);\n    this.addGroupId('text', data.attrs.SUBTITLES);\n  }\n  get maxBitrate() {\n    return Math.max(this.realBitrate, this.bitrate);\n  }\n  get averageBitrate() {\n    return this._avgBitrate || this.realBitrate || this.bitrate;\n  }\n  get attrs() {\n    return this._attrs[0];\n  }\n  get codecs() {\n    return this.attrs.CODECS || '';\n  }\n  get pathwayId() {\n    return this.attrs['PATHWAY-ID'] || '.';\n  }\n  get videoRange() {\n    return this.attrs['VIDEO-RANGE'] || 'SDR';\n  }\n  get score() {\n    return this.attrs.optionalFloat('SCORE', 0);\n  }\n  get uri() {\n    return this.url[0] || '';\n  }\n  hasAudioGroup(groupId) {\n    return hasGroup(this._audioGroups, groupId);\n  }\n  hasSubtitleGroup(groupId) {\n    return hasGroup(this._subtitleGroups, groupId);\n  }\n  get audioGroups() {\n    return this._audioGroups;\n  }\n  get subtitleGroups() {\n    return this._subtitleGroups;\n  }\n  addGroupId(type, groupId) {\n    if (!groupId) {\n      return;\n    }\n    if (type === 'audio') {\n      let audioGroups = this._audioGroups;\n      if (!audioGroups) {\n        audioGroups = this._audioGroups = [];\n      }\n      if (audioGroups.indexOf(groupId) === -1) {\n        audioGroups.push(groupId);\n      }\n    } else if (type === 'text') {\n      let subtitleGroups = this._subtitleGroups;\n      if (!subtitleGroups) {\n        subtitleGroups = this._subtitleGroups = [];\n      }\n      if (subtitleGroups.indexOf(groupId) === -1) {\n        subtitleGroups.push(groupId);\n      }\n    }\n  }\n\n  // Deprecated methods (retained for backwards compatibility)\n  get urlId() {\n    return 0;\n  }\n  set urlId(value) {}\n  get audioGroupIds() {\n    return this.audioGroups ? [this.audioGroupId] : undefined;\n  }\n  get textGroupIds() {\n    return this.subtitleGroups ? [this.textGroupId] : undefined;\n  }\n  get audioGroupId() {\n    var _this$audioGroups;\n    return (_this$audioGroups = this.audioGroups) == null ? void 0 : _this$audioGroups[0];\n  }\n  get textGroupId() {\n    var _this$subtitleGroups;\n    return (_this$subtitleGroups = this.subtitleGroups) == null ? void 0 : _this$subtitleGroups[0];\n  }\n  addFallback() {}\n}\nfunction hasGroup(groups, groupId) {\n  if (!groupId || !groups) {\n    return false;\n  }\n  return groups.indexOf(groupId) !== -1;\n}\n\nfunction updateFromToPTS(fragFrom, fragTo) {\n  const fragToPTS = fragTo.startPTS;\n  // if we know startPTS[toIdx]\n  if (isFiniteNumber(fragToPTS)) {\n    // update fragment duration.\n    // it helps to fix drifts between playlist reported duration and fragment real duration\n    let duration = 0;\n    let frag;\n    if (fragTo.sn > fragFrom.sn) {\n      duration = fragToPTS - fragFrom.start;\n      frag = fragFrom;\n    } else {\n      duration = fragFrom.start - fragToPTS;\n      frag = fragTo;\n    }\n    if (frag.duration !== duration) {\n      frag.duration = duration;\n    }\n    // we dont know startPTS[toIdx]\n  } else if (fragTo.sn > fragFrom.sn) {\n    const contiguous = fragFrom.cc === fragTo.cc;\n    // TODO: With part-loading end/durations we need to confirm the whole fragment is loaded before using (or setting) minEndPTS\n    if (contiguous && fragFrom.minEndPTS) {\n      fragTo.start = fragFrom.start + (fragFrom.minEndPTS - fragFrom.start);\n    } else {\n      fragTo.start = fragFrom.start + fragFrom.duration;\n    }\n  } else {\n    fragTo.start = Math.max(fragFrom.start - fragTo.duration, 0);\n  }\n}\nfunction updateFragPTSDTS(details, frag, startPTS, endPTS, startDTS, endDTS) {\n  const parsedMediaDuration = endPTS - startPTS;\n  if (parsedMediaDuration <= 0) {\n    logger.warn('Fragment should have a positive duration', frag);\n    endPTS = startPTS + frag.duration;\n    endDTS = startDTS + frag.duration;\n  }\n  let maxStartPTS = startPTS;\n  let minEndPTS = endPTS;\n  const fragStartPts = frag.startPTS;\n  const fragEndPts = frag.endPTS;\n  if (isFiniteNumber(fragStartPts)) {\n    // delta PTS between audio and video\n    const deltaPTS = Math.abs(fragStartPts - startPTS);\n    if (!isFiniteNumber(frag.deltaPTS)) {\n      frag.deltaPTS = deltaPTS;\n    } else {\n      frag.deltaPTS = Math.max(deltaPTS, frag.deltaPTS);\n    }\n    maxStartPTS = Math.max(startPTS, fragStartPts);\n    startPTS = Math.min(startPTS, fragStartPts);\n    startDTS = Math.min(startDTS, frag.startDTS);\n    minEndPTS = Math.min(endPTS, fragEndPts);\n    endPTS = Math.max(endPTS, fragEndPts);\n    endDTS = Math.max(endDTS, frag.endDTS);\n  }\n  const drift = startPTS - frag.start;\n  if (frag.start !== 0) {\n    frag.start = startPTS;\n  }\n  frag.duration = endPTS - frag.start;\n  frag.startPTS = startPTS;\n  frag.maxStartPTS = maxStartPTS;\n  frag.startDTS = startDTS;\n  frag.endPTS = endPTS;\n  frag.minEndPTS = minEndPTS;\n  frag.endDTS = endDTS;\n  const sn = frag.sn; // 'initSegment'\n  // exit if sn out of range\n  if (!details || sn < details.startSN || sn > details.endSN) {\n    return 0;\n  }\n  let i;\n  const fragIdx = sn - details.startSN;\n  const fragments = details.fragments;\n  // update frag reference in fragments array\n  // rationale is that fragments array might not contain this frag object.\n  // this will happen if playlist has been refreshed between frag loading and call to updateFragPTSDTS()\n  // if we don't update frag, we won't be able to propagate PTS info on the playlist\n  // resulting in invalid sliding computation\n  fragments[fragIdx] = frag;\n  // adjust fragment PTS/duration from seqnum-1 to frag 0\n  for (i = fragIdx; i > 0; i--) {\n    updateFromToPTS(fragments[i], fragments[i - 1]);\n  }\n\n  // adjust fragment PTS/duration from seqnum to last frag\n  for (i = fragIdx; i < fragments.length - 1; i++) {\n    updateFromToPTS(fragments[i], fragments[i + 1]);\n  }\n  if (details.fragmentHint) {\n    updateFromToPTS(fragments[fragments.length - 1], details.fragmentHint);\n  }\n  details.PTSKnown = details.alignedSliding = true;\n  return drift;\n}\nfunction mergeDetails(oldDetails, newDetails) {\n  // Track the last initSegment processed. Initialize it to the last one on the timeline.\n  let currentInitSegment = null;\n  const oldFragments = oldDetails.fragments;\n  for (let i = oldFragments.length - 1; i >= 0; i--) {\n    const oldInit = oldFragments[i].initSegment;\n    if (oldInit) {\n      currentInitSegment = oldInit;\n      break;\n    }\n  }\n  if (oldDetails.fragmentHint) {\n    // prevent PTS and duration from being adjusted on the next hint\n    delete oldDetails.fragmentHint.endPTS;\n  }\n  // check if old/new playlists have fragments in common\n  // loop through overlapping SN and update startPTS , cc, and duration if any found\n  let ccOffset = 0;\n  let PTSFrag;\n  mapFragmentIntersection(oldDetails, newDetails, (oldFrag, newFrag) => {\n    if (oldFrag.relurl) {\n      // Do not compare CC if the old fragment has no url. This is a level.fragmentHint used by LL-HLS parts.\n      // It maybe be off by 1 if it was created before any parts or discontinuity tags were appended to the end\n      // of the playlist.\n      ccOffset = oldFrag.cc - newFrag.cc;\n    }\n    if (isFiniteNumber(oldFrag.startPTS) && isFiniteNumber(oldFrag.endPTS)) {\n      newFrag.start = newFrag.startPTS = oldFrag.startPTS;\n      newFrag.startDTS = oldFrag.startDTS;\n      newFrag.maxStartPTS = oldFrag.maxStartPTS;\n      newFrag.endPTS = oldFrag.endPTS;\n      newFrag.endDTS = oldFrag.endDTS;\n      newFrag.minEndPTS = oldFrag.minEndPTS;\n      newFrag.duration = oldFrag.endPTS - oldFrag.startPTS;\n      if (newFrag.duration) {\n        PTSFrag = newFrag;\n      }\n\n      // PTS is known when any segment has startPTS and endPTS\n      newDetails.PTSKnown = newDetails.alignedSliding = true;\n    }\n    newFrag.elementaryStreams = oldFrag.elementaryStreams;\n    newFrag.loader = oldFrag.loader;\n    newFrag.stats = oldFrag.stats;\n    if (oldFrag.initSegment) {\n      newFrag.initSegment = oldFrag.initSegment;\n      currentInitSegment = oldFrag.initSegment;\n    }\n  });\n  if (currentInitSegment) {\n    const fragmentsToCheck = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n    fragmentsToCheck.forEach(frag => {\n      var _currentInitSegment;\n      if (frag && (!frag.initSegment || frag.initSegment.relurl === ((_currentInitSegment = currentInitSegment) == null ? void 0 : _currentInitSegment.relurl))) {\n        frag.initSegment = currentInitSegment;\n      }\n    });\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.deltaUpdateFailed = newDetails.fragments.some(frag => !frag);\n    if (newDetails.deltaUpdateFailed) {\n      logger.warn('[level-helper] Previous playlist missing segments skipped in delta playlist');\n      for (let i = newDetails.skippedSegments; i--;) {\n        newDetails.fragments.shift();\n      }\n      newDetails.startSN = newDetails.fragments[0].sn;\n      newDetails.startCC = newDetails.fragments[0].cc;\n    } else if (newDetails.canSkipDateRanges) {\n      newDetails.dateRanges = mergeDateRanges(oldDetails.dateRanges, newDetails.dateRanges, newDetails.recentlyRemovedDateranges);\n    }\n  }\n  const newFragments = newDetails.fragments;\n  if (ccOffset) {\n    logger.warn('discontinuity sliding from playlist, take drift into account');\n    for (let i = 0; i < newFragments.length; i++) {\n      newFragments[i].cc += ccOffset;\n    }\n  }\n  if (newDetails.skippedSegments) {\n    newDetails.startCC = newDetails.fragments[0].cc;\n  }\n\n  // Merge parts\n  mapPartIntersection(oldDetails.partList, newDetails.partList, (oldPart, newPart) => {\n    newPart.elementaryStreams = oldPart.elementaryStreams;\n    newPart.stats = oldPart.stats;\n  });\n\n  // if at least one fragment contains PTS info, recompute PTS information for all fragments\n  if (PTSFrag) {\n    updateFragPTSDTS(newDetails, PTSFrag, PTSFrag.startPTS, PTSFrag.endPTS, PTSFrag.startDTS, PTSFrag.endDTS);\n  } else {\n    // ensure that delta is within oldFragments range\n    // also adjust sliding in case delta is 0 (we could have old=[50-60] and new=old=[50-61])\n    // in that case we also need to adjust start offset of all fragments\n    adjustSliding(oldDetails, newDetails);\n  }\n  if (newFragments.length) {\n    newDetails.totalduration = newDetails.edge - newFragments[0].start;\n  }\n  newDetails.driftStartTime = oldDetails.driftStartTime;\n  newDetails.driftStart = oldDetails.driftStart;\n  const advancedDateTime = newDetails.advancedDateTime;\n  if (newDetails.advanced && advancedDateTime) {\n    const edge = newDetails.edge;\n    if (!newDetails.driftStart) {\n      newDetails.driftStartTime = advancedDateTime;\n      newDetails.driftStart = edge;\n    }\n    newDetails.driftEndTime = advancedDateTime;\n    newDetails.driftEnd = edge;\n  } else {\n    newDetails.driftEndTime = oldDetails.driftEndTime;\n    newDetails.driftEnd = oldDetails.driftEnd;\n    newDetails.advancedDateTime = oldDetails.advancedDateTime;\n  }\n}\nfunction mergeDateRanges(oldDateRanges, deltaDateRanges, recentlyRemovedDateranges) {\n  const dateRanges = _extends({}, oldDateRanges);\n  if (recentlyRemovedDateranges) {\n    recentlyRemovedDateranges.forEach(id => {\n      delete dateRanges[id];\n    });\n  }\n  Object.keys(deltaDateRanges).forEach(id => {\n    const dateRange = new DateRange(deltaDateRanges[id].attr, dateRanges[id]);\n    if (dateRange.isValid) {\n      dateRanges[id] = dateRange;\n    } else {\n      logger.warn(`Ignoring invalid Playlist Delta Update DATERANGE tag: \"${JSON.stringify(deltaDateRanges[id].attr)}\"`);\n    }\n  });\n  return dateRanges;\n}\nfunction mapPartIntersection(oldParts, newParts, intersectionFn) {\n  if (oldParts && newParts) {\n    let delta = 0;\n    for (let i = 0, len = oldParts.length; i <= len; i++) {\n      const oldPart = oldParts[i];\n      const newPart = newParts[i + delta];\n      if (oldPart && newPart && oldPart.index === newPart.index && oldPart.fragment.sn === newPart.fragment.sn) {\n        intersectionFn(oldPart, newPart);\n      } else {\n        delta--;\n      }\n    }\n  }\n}\nfunction mapFragmentIntersection(oldDetails, newDetails, intersectionFn) {\n  const skippedSegments = newDetails.skippedSegments;\n  const start = Math.max(oldDetails.startSN, newDetails.startSN) - newDetails.startSN;\n  const end = (oldDetails.fragmentHint ? 1 : 0) + (skippedSegments ? newDetails.endSN : Math.min(oldDetails.endSN, newDetails.endSN)) - newDetails.startSN;\n  const delta = newDetails.startSN - oldDetails.startSN;\n  const newFrags = newDetails.fragmentHint ? newDetails.fragments.concat(newDetails.fragmentHint) : newDetails.fragments;\n  const oldFrags = oldDetails.fragmentHint ? oldDetails.fragments.concat(oldDetails.fragmentHint) : oldDetails.fragments;\n  for (let i = start; i <= end; i++) {\n    const oldFrag = oldFrags[delta + i];\n    let newFrag = newFrags[i];\n    if (skippedSegments && !newFrag && i < skippedSegments) {\n      // Fill in skipped segments in delta playlist\n      newFrag = newDetails.fragments[i] = oldFrag;\n    }\n    if (oldFrag && newFrag) {\n      intersectionFn(oldFrag, newFrag);\n    }\n  }\n}\nfunction adjustSliding(oldDetails, newDetails) {\n  const delta = newDetails.startSN + newDetails.skippedSegments - oldDetails.startSN;\n  const oldFragments = oldDetails.fragments;\n  if (delta < 0 || delta >= oldFragments.length) {\n    return;\n  }\n  addSliding(newDetails, oldFragments[delta].start);\n}\nfunction addSliding(details, start) {\n  if (start) {\n    const fragments = details.fragments;\n    for (let i = details.skippedSegments; i < fragments.length; i++) {\n      fragments[i].start += start;\n    }\n    if (details.fragmentHint) {\n      details.fragmentHint.start += start;\n    }\n  }\n}\nfunction computeReloadInterval(newDetails, distanceToLiveEdgeMs = Infinity) {\n  let reloadInterval = 1000 * newDetails.targetduration;\n  if (newDetails.updated) {\n    // Use last segment duration when shorter than target duration and near live edge\n    const fragments = newDetails.fragments;\n    const liveEdgeMaxTargetDurations = 4;\n    if (fragments.length && reloadInterval * liveEdgeMaxTargetDurations > distanceToLiveEdgeMs) {\n      const lastSegmentDuration = fragments[fragments.length - 1].duration * 1000;\n      if (lastSegmentDuration < reloadInterval) {\n        reloadInterval = lastSegmentDuration;\n      }\n    }\n  } else {\n    // estimate = 'miss half average';\n    // follow HLS Spec, If the client reloads a Playlist file and finds that it has not\n    // changed then it MUST wait for a period of one-half the target\n    // duration before retrying.\n    reloadInterval /= 2;\n  }\n  return Math.round(reloadInterval);\n}\nfunction getFragmentWithSN(level, sn, fragCurrent) {\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  const levelDetails = level.details;\n  let fragment = levelDetails.fragments[sn - levelDetails.startSN];\n  if (fragment) {\n    return fragment;\n  }\n  fragment = levelDetails.fragmentHint;\n  if (fragment && fragment.sn === sn) {\n    return fragment;\n  }\n  if (sn < levelDetails.startSN && fragCurrent && fragCurrent.sn === sn) {\n    return fragCurrent;\n  }\n  return null;\n}\nfunction getPartWith(level, sn, partIndex) {\n  var _level$details;\n  if (!(level != null && level.details)) {\n    return null;\n  }\n  return findPart((_level$details = level.details) == null ? void 0 : _level$details.partList, sn, partIndex);\n}\nfunction findPart(partList, sn, partIndex) {\n  if (partList) {\n    for (let i = partList.length; i--;) {\n      const part = partList[i];\n      if (part.index === partIndex && part.fragment.sn === sn) {\n        return part;\n      }\n    }\n  }\n  return null;\n}\nfunction reassignFragmentLevelIndexes(levels) {\n  levels.forEach((level, index) => {\n    const {\n      details\n    } = level;\n    if (details != null && details.fragments) {\n      details.fragments.forEach(fragment => {\n        fragment.level = index;\n      });\n    }\n  });\n}\n\nfunction isTimeoutError(error) {\n  switch (error.details) {\n    case ErrorDetails.FRAG_LOAD_TIMEOUT:\n    case ErrorDetails.KEY_LOAD_TIMEOUT:\n    case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n    case ErrorDetails.MANIFEST_LOAD_TIMEOUT:\n      return true;\n  }\n  return false;\n}\nfunction getRetryConfig(loadPolicy, error) {\n  const isTimeout = isTimeoutError(error);\n  return loadPolicy.default[`${isTimeout ? 'timeout' : 'error'}Retry`];\n}\nfunction getRetryDelay(retryConfig, retryCount) {\n  // exponential backoff capped to max retry delay\n  const backoffFactor = retryConfig.backoff === 'linear' ? 1 : Math.pow(2, retryCount);\n  return Math.min(backoffFactor * retryConfig.retryDelayMs, retryConfig.maxRetryDelayMs);\n}\nfunction getLoaderConfigWithoutReties(loderConfig) {\n  return _objectSpread2(_objectSpread2({}, loderConfig), {\n    errorRetry: null,\n    timeoutRetry: null\n  });\n}\nfunction shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse) {\n  if (!retryConfig) {\n    return false;\n  }\n  const httpStatus = loaderResponse == null ? void 0 : loaderResponse.code;\n  const retry = retryCount < retryConfig.maxNumRetry && (retryForHttpStatus(httpStatus) || !!isTimeout);\n  return retryConfig.shouldRetry ? retryConfig.shouldRetry(retryConfig, retryCount, isTimeout, loaderResponse, retry) : retry;\n}\nfunction retryForHttpStatus(httpStatus) {\n  // Do not retry on status 4xx, status 0 (CORS error), or undefined (decrypt/gap/parse error)\n  return httpStatus === 0 && navigator.onLine === false || !!httpStatus && (httpStatus < 400 || httpStatus > 499);\n}\n\nconst BinarySearch = {\n  /**\n   * Searches for an item in an array which matches a certain condition.\n   * This requires the condition to only match one item in the array,\n   * and for the array to be ordered.\n   *\n   * @param list The array to search.\n   * @param comparisonFn\n   *      Called and provided a candidate item as the first argument.\n   *      Should return:\n   *          > -1 if the item should be located at a lower index than the provided item.\n   *          > 1 if the item should be located at a higher index than the provided item.\n   *          > 0 if the item is the item you're looking for.\n   *\n   * @returns the object if found, otherwise returns null\n   */\n  search: function (list, comparisonFn) {\n    let minIndex = 0;\n    let maxIndex = list.length - 1;\n    let currentIndex = null;\n    let currentElement = null;\n    while (minIndex <= maxIndex) {\n      currentIndex = (minIndex + maxIndex) / 2 | 0;\n      currentElement = list[currentIndex];\n      const comparisonResult = comparisonFn(currentElement);\n      if (comparisonResult > 0) {\n        minIndex = currentIndex + 1;\n      } else if (comparisonResult < 0) {\n        maxIndex = currentIndex - 1;\n      } else {\n        return currentElement;\n      }\n    }\n    return null;\n  }\n};\n\n/**\n * Returns first fragment whose endPdt value exceeds the given PDT, or null.\n * @param fragments - The array of candidate fragments\n * @param PDTValue - The PDT value which must be exceeded\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n */\nfunction findFragmentByPDT(fragments, PDTValue, maxFragLookUpTolerance) {\n  if (PDTValue === null || !Array.isArray(fragments) || !fragments.length || !isFiniteNumber(PDTValue)) {\n    return null;\n  }\n\n  // if less than start\n  const startPDT = fragments[0].programDateTime;\n  if (PDTValue < (startPDT || 0)) {\n    return null;\n  }\n  const endPDT = fragments[fragments.length - 1].endProgramDateTime;\n  if (PDTValue >= (endPDT || 0)) {\n    return null;\n  }\n  maxFragLookUpTolerance = maxFragLookUpTolerance || 0;\n  for (let seg = 0; seg < fragments.length; ++seg) {\n    const frag = fragments[seg];\n    if (pdtWithinToleranceTest(PDTValue, maxFragLookUpTolerance, frag)) {\n      return frag;\n    }\n  }\n  return null;\n}\n\n/**\n * Finds a fragment based on the SN of the previous fragment; or based on the needs of the current buffer.\n * This method compensates for small buffer gaps by applying a tolerance to the start of any candidate fragment, thus\n * breaking any traps which would cause the same fragment to be continuously selected within a small range.\n * @param fragPrevious - The last frag successfully appended\n * @param fragments - The array of candidate fragments\n * @param bufferEnd - The end of the contiguous buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start/end can be within in order to be considered contiguous\n * @returns a matching fragment or null\n */\nfunction findFragmentByPTS(fragPrevious, fragments, bufferEnd = 0, maxFragLookUpTolerance = 0, nextFragLookupTolerance = 0.005) {\n  let fragNext = null;\n  if (fragPrevious) {\n    fragNext = fragments[fragPrevious.sn - fragments[0].sn + 1] || null;\n    // check for buffer-end rounding error\n    const bufferEdgeError = fragPrevious.endDTS - bufferEnd;\n    if (bufferEdgeError > 0 && bufferEdgeError < 0.0000015) {\n      bufferEnd += 0.0000015;\n    }\n  } else if (bufferEnd === 0 && fragments[0].start === 0) {\n    fragNext = fragments[0];\n  }\n  // Prefer the next fragment if it's within tolerance\n  if (fragNext && ((!fragPrevious || fragPrevious.level === fragNext.level) && fragmentWithinToleranceTest(bufferEnd, maxFragLookUpTolerance, fragNext) === 0 || fragmentWithinFastStartSwitch(fragNext, fragPrevious, Math.min(nextFragLookupTolerance, maxFragLookUpTolerance)))) {\n    return fragNext;\n  }\n  // We might be seeking past the tolerance so find the best match\n  const foundFragment = BinarySearch.search(fragments, fragmentWithinToleranceTest.bind(null, bufferEnd, maxFragLookUpTolerance));\n  if (foundFragment && (foundFragment !== fragPrevious || !fragNext)) {\n    return foundFragment;\n  }\n  // If no match was found return the next fragment after fragPrevious, or null\n  return fragNext;\n}\nfunction fragmentWithinFastStartSwitch(fragNext, fragPrevious, nextFragLookupTolerance) {\n  if (fragPrevious && fragPrevious.start === 0 && fragPrevious.level < fragNext.level && (fragPrevious.endPTS || 0) > 0) {\n    const firstDuration = fragPrevious.tagList.reduce((duration, tag) => {\n      if (tag[0] === 'INF') {\n        duration += parseFloat(tag[1]);\n      }\n      return duration;\n    }, nextFragLookupTolerance);\n    return fragNext.start <= firstDuration;\n  }\n  return false;\n}\n\n/**\n * The test function used by the findFragmentBySn's BinarySearch to look for the best match to the current buffer conditions.\n * @param candidate - The fragment to test\n * @param bufferEnd - The end of the current buffered range the playhead is currently within\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns 0 if it matches, 1 if too low, -1 if too high\n */\nfunction fragmentWithinToleranceTest(bufferEnd = 0, maxFragLookUpTolerance = 0, candidate) {\n  // eagerly accept an accurate match (no tolerance)\n  if (candidate.start <= bufferEnd && candidate.start + candidate.duration > bufferEnd) {\n    return 0;\n  }\n  // offset should be within fragment boundary - config.maxFragLookUpTolerance\n  // this is to cope with situations like\n  // bufferEnd = 9.991\n  // frag[] : [0,10]\n  // frag[1] : [10,20]\n  // bufferEnd is within frag[0] range ... although what we are expecting is to return frag[1] here\n  //              frag start               frag start+duration\n  //                  |-----------------------------|\n  //              <--->                         <--->\n  //  ...--------><-----------------------------><---------....\n  // previous frag         matching fragment         next frag\n  //  return -1             return 0                 return 1\n  // logger.log(`level/sn/start/end/bufEnd:${level}/${candidate.sn}/${candidate.start}/${(candidate.start+candidate.duration)}/${bufferEnd}`);\n  // Set the lookup tolerance to be small enough to detect the current segment - ensures we don't skip over very small segments\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0));\n  if (candidate.start + candidate.duration - candidateLookupTolerance <= bufferEnd) {\n    return 1;\n  } else if (candidate.start - candidateLookupTolerance > bufferEnd && candidate.start) {\n    // if maxFragLookUpTolerance will have negative value then don't return -1 for first element\n    return -1;\n  }\n  return 0;\n}\n\n/**\n * The test function used by the findFragmentByPdt's BinarySearch to look for the best match to the current buffer conditions.\n * This function tests the candidate's program date time values, as represented in Unix time\n * @param candidate - The fragment to test\n * @param pdtBufferEnd - The Unix time representing the end of the current buffered range\n * @param maxFragLookUpTolerance - The amount of time that a fragment's start can be within in order to be considered contiguous\n * @returns true if contiguous, false otherwise\n */\nfunction pdtWithinToleranceTest(pdtBufferEnd, maxFragLookUpTolerance, candidate) {\n  const candidateLookupTolerance = Math.min(maxFragLookUpTolerance, candidate.duration + (candidate.deltaPTS ? candidate.deltaPTS : 0)) * 1000;\n\n  // endProgramDateTime can be null, default to zero\n  const endProgramDateTime = candidate.endProgramDateTime || 0;\n  return endProgramDateTime - candidateLookupTolerance > pdtBufferEnd;\n}\nfunction findFragWithCC(fragments, cc) {\n  return BinarySearch.search(fragments, candidate => {\n    if (candidate.cc < cc) {\n      return 1;\n    } else if (candidate.cc > cc) {\n      return -1;\n    } else {\n      return 0;\n    }\n  });\n}\n\nvar NetworkErrorAction = {\n  DoNothing: 0,\n  SendEndCallback: 1,\n  SendAlternateToPenaltyBox: 2,\n  RemoveAlternatePermanently: 3,\n  InsertDiscontinuity: 4,\n  RetryRequest: 5\n};\nvar ErrorActionFlags = {\n  None: 0,\n  MoveAllAlternatesMatchingHost: 1,\n  MoveAllAlternatesMatchingHDCP: 2,\n  SwitchToSDR: 4\n}; // Reserved for future use\nclass ErrorController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n    this.log = void 0;\n    this.warn = void 0;\n    this.error = void 0;\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[info]:`);\n    this.warn = logger.warn.bind(logger, `[warning]:`);\n    this.error = logger.error.bind(logger, `[error]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.ERROR, this.onErrorOut, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    // @ts-ignore\n    this.hls = null;\n    this.penalizedRenditions = {};\n  }\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.playlistError = 0;\n  }\n  getVariantLevelIndex(frag) {\n    return (frag == null ? void 0 : frag.type) === PlaylistLevelType.MAIN ? frag.level : this.hls.loadLevel;\n  }\n  onManifestLoading() {\n    this.playlistError = 0;\n    this.penalizedRenditions = {};\n  }\n  onLevelUpdated() {\n    this.playlistError = 0;\n  }\n  onError(event, data) {\n    var _data$frag, _data$level;\n    if (data.fatal) {\n      return;\n    }\n    const hls = this.hls;\n    const context = data.context;\n    switch (data.details) {\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        data.errorAction = this.getFragRetryOrSwitchAction(data);\n        return;\n      case ErrorDetails.FRAG_PARSING_ERROR:\n        // ignore empty segment errors marked as gap\n        if ((_data$frag = data.frag) != null && _data$frag.gap) {\n          data.errorAction = {\n            action: NetworkErrorAction.DoNothing,\n            flags: ErrorActionFlags.None\n          };\n          return;\n        }\n      // falls through\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n        {\n          // Switch level if possible, otherwise allow retry count to reach max error retries\n          data.errorAction = this.getFragRetryOrSwitchAction(data);\n          data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n          return;\n        }\n      case ErrorDetails.LEVEL_EMPTY_ERROR:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        {\n          var _data$context, _data$context$levelDe;\n          // Only retry when empty and live\n          const levelIndex = data.parent === PlaylistLevelType.MAIN ? data.level : hls.loadLevel;\n          if (data.details === ErrorDetails.LEVEL_EMPTY_ERROR && !!((_data$context = data.context) != null && (_data$context$levelDe = _data$context.levelDetails) != null && _data$context$levelDe.live)) {\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, levelIndex);\n          } else {\n            // Escalate to fatal if not retrying or switching\n            data.levelRetry = false;\n            data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n          }\n        }\n        return;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n        if (typeof (context == null ? void 0 : context.level) === 'number') {\n          data.errorAction = this.getPlaylistRetryOrSwitchAction(data, context.level);\n        }\n        return;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.SUBTITLE_LOAD_ERROR:\n      case ErrorDetails.SUBTITLE_TRACK_LOAD_TIMEOUT:\n        if (context) {\n          const level = hls.levels[hls.loadLevel];\n          if (level && (context.type === PlaylistContextType.AUDIO_TRACK && level.hasAudioGroup(context.groupId) || context.type === PlaylistContextType.SUBTITLE_TRACK && level.hasSubtitleGroup(context.groupId))) {\n            // Perform Pathway switch or Redundant failover if possible for fastest recovery\n            // otherwise allow playlist retry count to reach max error retries\n            data.errorAction = this.getPlaylistRetryOrSwitchAction(data, hls.loadLevel);\n            data.errorAction.action = NetworkErrorAction.SendAlternateToPenaltyBox;\n            data.errorAction.flags = ErrorActionFlags.MoveAllAlternatesMatchingHost;\n            return;\n          }\n        }\n        return;\n      case ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED:\n        {\n          const level = hls.levels[hls.loadLevel];\n          const restrictedHdcpLevel = level == null ? void 0 : level.attrs['HDCP-LEVEL'];\n          if (restrictedHdcpLevel) {\n            data.errorAction = {\n              action: NetworkErrorAction.SendAlternateToPenaltyBox,\n              flags: ErrorActionFlags.MoveAllAlternatesMatchingHDCP,\n              hdcpLevel: restrictedHdcpLevel\n            };\n          } else {\n            this.keySystemError(data);\n          }\n        }\n        return;\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.REMUX_ALLOC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        data.errorAction = this.getLevelSwitchAction(data, (_data$level = data.level) != null ? _data$level : hls.loadLevel);\n        return;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n      case ErrorDetails.BUFFER_APPENDING_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n      case ErrorDetails.LEVEL_SWITCH_ERROR:\n      case ErrorDetails.BUFFER_STALLED_ERROR:\n      case ErrorDetails.BUFFER_SEEK_OVER_HOLE:\n      case ErrorDetails.BUFFER_NUDGE_ON_STALL:\n        data.errorAction = {\n          action: NetworkErrorAction.DoNothing,\n          flags: ErrorActionFlags.None\n        };\n        return;\n    }\n    if (data.type === ErrorTypes.KEY_SYSTEM_ERROR) {\n      this.keySystemError(data);\n    }\n  }\n  keySystemError(data) {\n    const levelIndex = this.getVariantLevelIndex(data.frag);\n    // Do not retry level. Escalate to fatal if switching levels fails.\n    data.levelRetry = false;\n    data.errorAction = this.getLevelSwitchAction(data, levelIndex);\n  }\n  getPlaylistRetryOrSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    const retryConfig = getRetryConfig(hls.config.playlistLoadPolicy, data);\n    const retryCount = this.playlistError++;\n    const retry = shouldRetry(retryConfig, retryCount, isTimeoutError(data), data.response);\n    if (retry) {\n      return {\n        action: NetworkErrorAction.RetryRequest,\n        flags: ErrorActionFlags.None,\n        retryConfig,\n        retryCount\n      };\n    }\n    const errorAction = this.getLevelSwitchAction(data, levelIndex);\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = retryCount;\n    }\n    return errorAction;\n  }\n  getFragRetryOrSwitchAction(data) {\n    const hls = this.hls;\n    // Share fragment error count accross media options (main, audio, subs)\n    // This allows for level based rendition switching when media option assets fail\n    const variantLevelIndex = this.getVariantLevelIndex(data.frag);\n    const level = hls.levels[variantLevelIndex];\n    const {\n      fragLoadPolicy,\n      keyLoadPolicy\n    } = hls.config;\n    const retryConfig = getRetryConfig(data.details.startsWith('key') ? keyLoadPolicy : fragLoadPolicy, data);\n    const fragmentErrors = hls.levels.reduce((acc, level) => acc + level.fragmentError, 0);\n    // Switch levels when out of retried or level index out of bounds\n    if (level) {\n      if (data.details !== ErrorDetails.FRAG_GAP) {\n        level.fragmentError++;\n      }\n      const retry = shouldRetry(retryConfig, fragmentErrors, isTimeoutError(data), data.response);\n      if (retry) {\n        return {\n          action: NetworkErrorAction.RetryRequest,\n          flags: ErrorActionFlags.None,\n          retryConfig,\n          retryCount: fragmentErrors\n        };\n      }\n    }\n    // Reach max retry count, or Missing level reference\n    // Switch to valid index\n    const errorAction = this.getLevelSwitchAction(data, variantLevelIndex);\n    // Add retry details to allow skipping of FRAG_PARSING_ERROR\n    if (retryConfig) {\n      errorAction.retryConfig = retryConfig;\n      errorAction.retryCount = fragmentErrors;\n    }\n    return errorAction;\n  }\n  getLevelSwitchAction(data, levelIndex) {\n    const hls = this.hls;\n    if (levelIndex === null || levelIndex === undefined) {\n      levelIndex = hls.loadLevel;\n    }\n    const level = this.hls.levels[levelIndex];\n    if (level) {\n      var _data$frag2, _data$context2;\n      const errorDetails = data.details;\n      level.loadError++;\n      if (errorDetails === ErrorDetails.BUFFER_APPEND_ERROR) {\n        level.fragmentError++;\n      }\n      // Search for next level to retry\n      let nextLevel = -1;\n      const {\n        levels,\n        loadLevel,\n        minAutoLevel,\n        maxAutoLevel\n      } = hls;\n      if (!hls.autoLevelEnabled) {\n        hls.loadLevel = -1;\n      }\n      const fragErrorType = (_data$frag2 = data.frag) == null ? void 0 : _data$frag2.type;\n      // Find alternate audio codec if available on audio codec error\n      const isAudioCodecError = fragErrorType === PlaylistLevelType.AUDIO && errorDetails === ErrorDetails.FRAG_PARSING_ERROR || data.sourceBufferName === 'audio' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findAudioCodecAlternate = isAudioCodecError && levels.some(({\n        audioCodec\n      }) => level.audioCodec !== audioCodec);\n      // Find alternate video codec if available on video codec error\n      const isVideoCodecError = data.sourceBufferName === 'video' && (errorDetails === ErrorDetails.BUFFER_ADD_CODEC_ERROR || errorDetails === ErrorDetails.BUFFER_APPEND_ERROR);\n      const findVideoCodecAlternate = isVideoCodecError && levels.some(({\n        codecSet,\n        audioCodec\n      }) => level.codecSet !== codecSet && level.audioCodec === audioCodec);\n      const {\n        type: playlistErrorType,\n        groupId: playlistErrorGroupId\n      } = (_data$context2 = data.context) != null ? _data$context2 : {};\n      for (let i = levels.length; i--;) {\n        const candidate = (i + loadLevel) % levels.length;\n        if (candidate !== loadLevel && candidate >= minAutoLevel && candidate <= maxAutoLevel && levels[candidate].loadError === 0) {\n          var _level$audioGroups, _level$subtitleGroups;\n          const levelCandidate = levels[candidate];\n          // Skip level switch if GAP tag is found in next level at same position\n          if (errorDetails === ErrorDetails.FRAG_GAP && fragErrorType === PlaylistLevelType.MAIN && data.frag) {\n            const levelDetails = levels[candidate].details;\n            if (levelDetails) {\n              const fragCandidate = findFragmentByPTS(data.frag, levelDetails.fragments, data.frag.start);\n              if (fragCandidate != null && fragCandidate.gap) {\n                continue;\n              }\n            }\n          } else if (playlistErrorType === PlaylistContextType.AUDIO_TRACK && levelCandidate.hasAudioGroup(playlistErrorGroupId) || playlistErrorType === PlaylistContextType.SUBTITLE_TRACK && levelCandidate.hasSubtitleGroup(playlistErrorGroupId)) {\n            // For audio/subs playlist errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          } else if (fragErrorType === PlaylistLevelType.AUDIO && (_level$audioGroups = level.audioGroups) != null && _level$audioGroups.some(groupId => levelCandidate.hasAudioGroup(groupId)) || fragErrorType === PlaylistLevelType.SUBTITLE && (_level$subtitleGroups = level.subtitleGroups) != null && _level$subtitleGroups.some(groupId => levelCandidate.hasSubtitleGroup(groupId)) || findAudioCodecAlternate && level.audioCodec === levelCandidate.audioCodec || !findAudioCodecAlternate && level.audioCodec !== levelCandidate.audioCodec || findVideoCodecAlternate && level.codecSet === levelCandidate.codecSet) {\n            // For video/audio/subs frag errors find another group ID or fallthrough to redundant fail-over\n            continue;\n          }\n          nextLevel = candidate;\n          break;\n        }\n      }\n      if (nextLevel > -1 && hls.loadLevel !== nextLevel) {\n        data.levelRetry = true;\n        this.playlistError = 0;\n        return {\n          action: NetworkErrorAction.SendAlternateToPenaltyBox,\n          flags: ErrorActionFlags.None,\n          nextAutoLevel: nextLevel\n        };\n      }\n    }\n    // No levels to switch / Manual level selection / Level not found\n    // Resolve with Pathway switch, Redundant fail-over, or stay on lowest Level\n    return {\n      action: NetworkErrorAction.SendAlternateToPenaltyBox,\n      flags: ErrorActionFlags.MoveAllAlternatesMatchingHost\n    };\n  }\n  onErrorOut(event, data) {\n    var _data$errorAction;\n    switch ((_data$errorAction = data.errorAction) == null ? void 0 : _data$errorAction.action) {\n      case NetworkErrorAction.DoNothing:\n        break;\n      case NetworkErrorAction.SendAlternateToPenaltyBox:\n        this.sendAlternateToPenaltyBox(data);\n        if (!data.errorAction.resolved && data.details !== ErrorDetails.FRAG_GAP) {\n          data.fatal = true;\n        } else if (/MediaSource readyState: ended/.test(data.error.message)) {\n          this.warn(`MediaSource ended after \"${data.sourceBufferName}\" sourceBuffer append error. Attempting to recover from media error.`);\n          this.hls.recoverMediaError();\n        }\n        break;\n      case NetworkErrorAction.RetryRequest:\n        // handled by stream and playlist/level controllers\n        break;\n    }\n    if (data.fatal) {\n      this.hls.stopLoad();\n      return;\n    }\n  }\n  sendAlternateToPenaltyBox(data) {\n    const hls = this.hls;\n    const errorAction = data.errorAction;\n    if (!errorAction) {\n      return;\n    }\n    const {\n      flags,\n      hdcpLevel,\n      nextAutoLevel\n    } = errorAction;\n    switch (flags) {\n      case ErrorActionFlags.None:\n        this.switchLevel(data, nextAutoLevel);\n        break;\n      case ErrorActionFlags.MoveAllAlternatesMatchingHDCP:\n        if (hdcpLevel) {\n          hls.maxHdcpLevel = HdcpLevels[HdcpLevels.indexOf(hdcpLevel) - 1];\n          errorAction.resolved = true;\n        }\n        this.warn(`Restricting playback to HDCP-LEVEL of \"${hls.maxHdcpLevel}\" or lower`);\n        break;\n    }\n    // If not resolved by previous actions try to switch to next level\n    if (!errorAction.resolved) {\n      this.switchLevel(data, nextAutoLevel);\n    }\n  }\n  switchLevel(data, levelIndex) {\n    if (levelIndex !== undefined && data.errorAction) {\n      this.warn(`switching to level ${levelIndex} after ${data.details}`);\n      this.hls.nextAutoLevel = levelIndex;\n      data.errorAction.resolved = true;\n      // Stream controller is responsible for this but won't switch on false start\n      this.hls.nextLoadLevel = this.hls.nextAutoLevel;\n    }\n  }\n}\n\nclass BasePlaylistController {\n  constructor(hls, logPrefix) {\n    this.hls = void 0;\n    this.timer = -1;\n    this.requestScheduled = -1;\n    this.canLoad = false;\n    this.log = void 0;\n    this.warn = void 0;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n  }\n  destroy() {\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this.log = this.warn = null;\n  }\n  clearTimer() {\n    if (this.timer !== -1) {\n      self.clearTimeout(this.timer);\n      this.timer = -1;\n    }\n  }\n  startLoad() {\n    this.canLoad = true;\n    this.requestScheduled = -1;\n    this.loadPlaylist();\n  }\n  stopLoad() {\n    this.canLoad = false;\n    this.clearTimer();\n  }\n  switchParams(playlistUri, previous, current) {\n    const renditionReports = previous == null ? void 0 : previous.renditionReports;\n    if (renditionReports) {\n      let foundIndex = -1;\n      for (let i = 0; i < renditionReports.length; i++) {\n        const attr = renditionReports[i];\n        let uri;\n        try {\n          uri = new self.URL(attr.URI, previous.url).href;\n        } catch (error) {\n          logger.warn(`Could not construct new URL for Rendition Report: ${error}`);\n          uri = attr.URI || '';\n        }\n        // Use exact match. Otherwise, the last partial match, if any, will be used\n        // (Playlist URI includes a query string that the Rendition Report does not)\n        if (uri === playlistUri) {\n          foundIndex = i;\n          break;\n        } else if (uri === playlistUri.substring(0, uri.length)) {\n          foundIndex = i;\n        }\n      }\n      if (foundIndex !== -1) {\n        const attr = renditionReports[foundIndex];\n        const msn = parseInt(attr['LAST-MSN']) || (previous == null ? void 0 : previous.lastPartSn);\n        let part = parseInt(attr['LAST-PART']) || (previous == null ? void 0 : previous.lastPartIndex);\n        if (this.hls.config.lowLatencyMode) {\n          const currentGoal = Math.min(previous.age - previous.partTarget, previous.targetduration);\n          if (part >= 0 && currentGoal > previous.partTarget) {\n            part += 1;\n          }\n        }\n        const skip = current && getSkipValue(current);\n        return new HlsUrlParameters(msn, part >= 0 ? part : undefined, skip);\n      }\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    if (this.requestScheduled === -1) {\n      this.requestScheduled = self.performance.now();\n    }\n    // Loading is handled by the subclasses\n  }\n  shouldLoadPlaylist(playlist) {\n    return this.canLoad && !!playlist && !!playlist.url && (!playlist.details || playlist.details.live);\n  }\n  shouldReloadPlaylist(playlist) {\n    return this.timer === -1 && this.requestScheduled === -1 && this.shouldLoadPlaylist(playlist);\n  }\n  playlistLoaded(index, data, previousDetails) {\n    const {\n      details,\n      stats\n    } = data;\n\n    // Set last updated date-time\n    const now = self.performance.now();\n    const elapsed = stats.loading.first ? Math.max(0, now - stats.loading.first) : 0;\n    details.advancedDateTime = Date.now() - elapsed;\n\n    // if current playlist is a live playlist, arm a timer to reload it\n    if (details.live || previousDetails != null && previousDetails.live) {\n      details.reloaded(previousDetails);\n      if (previousDetails) {\n        this.log(`live playlist ${index} ${details.advanced ? 'REFRESHED ' + details.lastPartSn + '-' + details.lastPartIndex : details.updated ? 'UPDATED' : 'MISSED'}`);\n      }\n      // Merge live playlists to adjust fragment starts and fill in delta playlist skipped segments\n      if (previousDetails && details.fragments.length > 0) {\n        mergeDetails(previousDetails, details);\n      }\n      if (!this.canLoad || !details.live) {\n        return;\n      }\n      let deliveryDirectives;\n      let msn = undefined;\n      let part = undefined;\n      if (details.canBlockReload && details.endSN && details.advanced) {\n        // Load level with LL-HLS delivery directives\n        const lowLatencyMode = this.hls.config.lowLatencyMode;\n        const lastPartSn = details.lastPartSn;\n        const endSn = details.endSN;\n        const lastPartIndex = details.lastPartIndex;\n        const hasParts = lastPartIndex !== -1;\n        const lastPart = lastPartSn === endSn;\n        // When low latency mode is disabled, we'll skip part requests once the last part index is found\n        const nextSnStartIndex = lowLatencyMode ? 0 : lastPartIndex;\n        if (hasParts) {\n          msn = lastPart ? endSn + 1 : lastPartSn;\n          part = lastPart ? nextSnStartIndex : lastPartIndex + 1;\n        } else {\n          msn = endSn + 1;\n        }\n        // Low-Latency CDN Tune-in: \"age\" header and time since load indicates we're behind by more than one part\n        // Update directives to obtain the Playlist that has the estimated additional duration of media\n        const lastAdvanced = details.age;\n        const cdnAge = lastAdvanced + details.ageHeader;\n        let currentGoal = Math.min(cdnAge - details.partTarget, details.targetduration * 1.5);\n        if (currentGoal > 0) {\n          if (previousDetails && currentGoal > previousDetails.tuneInGoal) {\n            // If we attempted to get the next or latest playlist update, but currentGoal increased,\n            // then we either can't catchup, or the \"age\" header cannot be trusted.\n            this.warn(`CDN Tune-in goal increased from: ${previousDetails.tuneInGoal} to: ${currentGoal} with playlist age: ${details.age}`);\n            currentGoal = 0;\n          } else {\n            const segments = Math.floor(currentGoal / details.targetduration);\n            msn += segments;\n            if (part !== undefined) {\n              const parts = Math.round(currentGoal % details.targetduration / details.partTarget);\n              part += parts;\n            }\n            this.log(`CDN Tune-in age: ${details.ageHeader}s last advanced ${lastAdvanced.toFixed(2)}s goal: ${currentGoal} skip sn ${segments} to part ${part}`);\n          }\n          details.tuneInGoal = currentGoal;\n        }\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n        if (lowLatencyMode || !lastPart) {\n          this.loadPlaylist(deliveryDirectives);\n          return;\n        }\n      } else if (details.canBlockReload || details.canSkipUntil) {\n        deliveryDirectives = this.getDeliveryDirectives(details, data.deliveryDirectives, msn, part);\n      }\n      const bufferInfo = this.hls.mainForwardBufferInfo;\n      const position = bufferInfo ? bufferInfo.end - bufferInfo.len : 0;\n      const distanceToLiveEdgeMs = (details.edge - position) * 1000;\n      const reloadInterval = computeReloadInterval(details, distanceToLiveEdgeMs);\n      if (details.updated && now > this.requestScheduled + reloadInterval) {\n        this.requestScheduled = stats.loading.start;\n      }\n      if (msn !== undefined && details.canBlockReload) {\n        this.requestScheduled = stats.loading.first + reloadInterval - (details.partTarget * 1000 || 1000);\n      } else if (this.requestScheduled === -1 || this.requestScheduled + reloadInterval < now) {\n        this.requestScheduled = now;\n      } else if (this.requestScheduled - now <= 0) {\n        this.requestScheduled += reloadInterval;\n      }\n      let estimatedTimeUntilUpdate = this.requestScheduled - now;\n      estimatedTimeUntilUpdate = Math.max(0, estimatedTimeUntilUpdate);\n      this.log(`reload live playlist ${index} in ${Math.round(estimatedTimeUntilUpdate)} ms`);\n      // this.log(\n      //   `live reload ${details.updated ? 'REFRESHED' : 'MISSED'}\n      // reload in ${estimatedTimeUntilUpdate / 1000}\n      // round trip ${(stats.loading.end - stats.loading.start) / 1000}\n      // diff ${\n      //   (reloadInterval -\n      //     (estimatedTimeUntilUpdate +\n      //       stats.loading.end -\n      //       stats.loading.start)) /\n      //   1000\n      // }\n      // reload interval ${reloadInterval / 1000}\n      // target duration ${details.targetduration}\n      // distance to edge ${distanceToLiveEdgeMs / 1000}`\n      // );\n\n      this.timer = self.setTimeout(() => this.loadPlaylist(deliveryDirectives), estimatedTimeUntilUpdate);\n    } else {\n      this.clearTimer();\n    }\n  }\n  getDeliveryDirectives(details, previousDeliveryDirectives, msn, part) {\n    let skip = getSkipValue(details);\n    if (previousDeliveryDirectives != null && previousDeliveryDirectives.skip && details.deltaUpdateFailed) {\n      msn = previousDeliveryDirectives.msn;\n      part = previousDeliveryDirectives.part;\n      skip = HlsSkip.No;\n    }\n    return new HlsUrlParameters(msn, part, skip);\n  }\n  checkRetry(errorEvent) {\n    const errorDetails = errorEvent.details;\n    const isTimeout = isTimeoutError(errorEvent);\n    const errorAction = errorEvent.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    const retry = !!errorAction && !!retryConfig && (action === NetworkErrorAction.RetryRequest || !errorAction.resolved && action === NetworkErrorAction.SendAlternateToPenaltyBox);\n    if (retry) {\n      var _errorEvent$context;\n      this.requestScheduled = -1;\n      if (retryCount >= retryConfig.maxNumRetry) {\n        return false;\n      }\n      if (isTimeout && (_errorEvent$context = errorEvent.context) != null && _errorEvent$context.deliveryDirectives) {\n        // The LL-HLS request already timed out so retry immediately\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" without delivery-directives`);\n        this.loadPlaylist();\n      } else {\n        const delay = getRetryDelay(retryConfig, retryCount);\n        // Schedule level/track reload\n        this.timer = self.setTimeout(() => this.loadPlaylist(), delay);\n        this.warn(`Retrying playlist loading ${retryCount + 1}/${retryConfig.maxNumRetry} after \"${errorDetails}\" in ${delay}ms`);\n      }\n      // `levelRetry = true` used to inform other controllers that a retry is happening\n      errorEvent.levelRetry = true;\n      errorAction.resolved = true;\n    }\n    return retry;\n  }\n}\n\n/*\n * compute an Exponential Weighted moving average\n * - https://en.wikipedia.org/wiki/Moving_average#Exponential_moving_average\n *  - heavily inspired from shaka-player\n */\n\nclass EWMA {\n  //  About half of the estimated value will be from the last |halfLife| samples by weight.\n  constructor(halfLife, estimate = 0, weight = 0) {\n    this.halfLife = void 0;\n    this.alpha_ = void 0;\n    this.estimate_ = void 0;\n    this.totalWeight_ = void 0;\n    this.halfLife = halfLife;\n    // Larger values of alpha expire historical data more slowly.\n    this.alpha_ = halfLife ? Math.exp(Math.log(0.5) / halfLife) : 0;\n    this.estimate_ = estimate;\n    this.totalWeight_ = weight;\n  }\n  sample(weight, value) {\n    const adjAlpha = Math.pow(this.alpha_, weight);\n    this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;\n    this.totalWeight_ += weight;\n  }\n  getTotalWeight() {\n    return this.totalWeight_;\n  }\n  getEstimate() {\n    if (this.alpha_) {\n      const zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);\n      if (zeroFactor) {\n        return this.estimate_ / zeroFactor;\n      }\n    }\n    return this.estimate_;\n  }\n}\n\n/*\n * EWMA Bandwidth Estimator\n *  - heavily inspired from shaka-player\n * Tracks bandwidth samples and estimates available bandwidth.\n * Based on the minimum of two exponentially-weighted moving averages with\n * different half-lives.\n */\n\nclass EwmaBandWidthEstimator {\n  constructor(slow, fast, defaultEstimate, defaultTTFB = 100) {\n    this.defaultEstimate_ = void 0;\n    this.minWeight_ = void 0;\n    this.minDelayMs_ = void 0;\n    this.slow_ = void 0;\n    this.fast_ = void 0;\n    this.defaultTTFB_ = void 0;\n    this.ttfb_ = void 0;\n    this.defaultEstimate_ = defaultEstimate;\n    this.minWeight_ = 0.001;\n    this.minDelayMs_ = 50;\n    this.slow_ = new EWMA(slow);\n    this.fast_ = new EWMA(fast);\n    this.defaultTTFB_ = defaultTTFB;\n    this.ttfb_ = new EWMA(slow);\n  }\n  update(slow, fast) {\n    const {\n      slow_,\n      fast_,\n      ttfb_\n    } = this;\n    if (slow_.halfLife !== slow) {\n      this.slow_ = new EWMA(slow, slow_.getEstimate(), slow_.getTotalWeight());\n    }\n    if (fast_.halfLife !== fast) {\n      this.fast_ = new EWMA(fast, fast_.getEstimate(), fast_.getTotalWeight());\n    }\n    if (ttfb_.halfLife !== slow) {\n      this.ttfb_ = new EWMA(slow, ttfb_.getEstimate(), ttfb_.getTotalWeight());\n    }\n  }\n  sample(durationMs, numBytes) {\n    durationMs = Math.max(durationMs, this.minDelayMs_);\n    const numBits = 8 * numBytes;\n    // weight is duration in seconds\n    const durationS = durationMs / 1000;\n    // value is bandwidth in bits/s\n    const bandwidthInBps = numBits / durationS;\n    this.fast_.sample(durationS, bandwidthInBps);\n    this.slow_.sample(durationS, bandwidthInBps);\n  }\n  sampleTTFB(ttfb) {\n    // weight is frequency curve applied to TTFB in seconds\n    // (longer times have less weight with expected input under 1 second)\n    const seconds = ttfb / 1000;\n    const weight = Math.sqrt(2) * Math.exp(-Math.pow(seconds, 2) / 2);\n    this.ttfb_.sample(weight, Math.max(ttfb, 5));\n  }\n  canEstimate() {\n    return this.fast_.getTotalWeight() >= this.minWeight_;\n  }\n  getEstimate() {\n    if (this.canEstimate()) {\n      // console.log('slow estimate:'+ Math.round(this.slow_.getEstimate()));\n      // console.log('fast estimate:'+ Math.round(this.fast_.getEstimate()));\n      // Take the minimum of these two estimates.  This should have the effect of\n      // adapting down quickly, but up more slowly.\n      return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());\n    } else {\n      return this.defaultEstimate_;\n    }\n  }\n  getEstimateTTFB() {\n    if (this.ttfb_.getTotalWeight() >= this.minWeight_) {\n      return this.ttfb_.getEstimate();\n    } else {\n      return this.defaultTTFB_;\n    }\n  }\n  destroy() {}\n}\n\nconst SUPPORTED_INFO_DEFAULT = {\n  supported: true,\n  configurations: [],\n  decodingInfoResults: [{\n    supported: true,\n    powerEfficient: true,\n    smooth: true\n  }]\n};\nconst SUPPORTED_INFO_CACHE = {};\nfunction requiresMediaCapabilitiesDecodingInfo(level, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference) {\n  // Only test support when configuration is exceeds minimum options\n  const audioGroups = level.audioCodec ? level.audioGroups : null;\n  const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n  const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n  const maxChannels = channelsPreference ? parseInt(channelsPreference) : audioCodecPreference ? Infinity : 2;\n  let audioChannels = null;\n  if (audioGroups != null && audioGroups.length) {\n    try {\n      if (audioGroups.length === 1 && audioGroups[0]) {\n        audioChannels = audioTracksByGroup.groups[audioGroups[0]].channels;\n      } else {\n        audioChannels = audioGroups.reduce((acc, groupId) => {\n          if (groupId) {\n            const audioTrackGroup = audioTracksByGroup.groups[groupId];\n            if (!audioTrackGroup) {\n              throw new Error(`Audio track group ${groupId} not found`);\n            }\n            // Sum all channel key values\n            Object.keys(audioTrackGroup.channels).forEach(key => {\n              acc[key] = (acc[key] || 0) + audioTrackGroup.channels[key];\n            });\n          }\n          return acc;\n        }, {\n          2: 0\n        });\n      }\n    } catch (error) {\n      return true;\n    }\n  }\n  return level.videoCodec !== undefined && (level.width > 1920 && level.height > 1088 || level.height > 1920 && level.width > 1088 || level.frameRate > Math.max(currentFrameRate, 30) || level.videoRange !== 'SDR' && level.videoRange !== currentVideoRange || level.bitrate > Math.max(currentBw, 8e6)) || !!audioChannels && isFiniteNumber(maxChannels) && Object.keys(audioChannels).some(channels => parseInt(channels) > maxChannels);\n}\nfunction getMediaDecodingInfoPromise(level, audioTracksByGroup, mediaCapabilities) {\n  const videoCodecs = level.videoCodec;\n  const audioCodecs = level.audioCodec;\n  if (!videoCodecs || !audioCodecs || !mediaCapabilities) {\n    return Promise.resolve(SUPPORTED_INFO_DEFAULT);\n  }\n  const baseVideoConfiguration = {\n    width: level.width,\n    height: level.height,\n    bitrate: Math.ceil(Math.max(level.bitrate * 0.9, level.averageBitrate)),\n    // Assume a framerate of 30fps since MediaCapabilities will not accept Level default of 0.\n    framerate: level.frameRate || 30\n  };\n  const videoRange = level.videoRange;\n  if (videoRange !== 'SDR') {\n    baseVideoConfiguration.transferFunction = videoRange.toLowerCase();\n  }\n  const configurations = videoCodecs.split(',').map(videoCodec => ({\n    type: 'media-source',\n    video: _objectSpread2(_objectSpread2({}, baseVideoConfiguration), {}, {\n      contentType: mimeTypeForCodec(videoCodec, 'video')\n    })\n  }));\n  if (audioCodecs && level.audioGroups) {\n    level.audioGroups.forEach(audioGroupId => {\n      var _audioTracksByGroup$g;\n      if (!audioGroupId) {\n        return;\n      }\n      (_audioTracksByGroup$g = audioTracksByGroup.groups[audioGroupId]) == null ? void 0 : _audioTracksByGroup$g.tracks.forEach(audioTrack => {\n        if (audioTrack.groupId === audioGroupId) {\n          const channels = audioTrack.channels || '';\n          const channelsNumber = parseFloat(channels);\n          if (isFiniteNumber(channelsNumber) && channelsNumber > 2) {\n            configurations.push.apply(configurations, audioCodecs.split(',').map(audioCodec => ({\n              type: 'media-source',\n              audio: {\n                contentType: mimeTypeForCodec(audioCodec, 'audio'),\n                channels: '' + channelsNumber\n                // spatialRendering:\n                //   audioCodec === 'ec-3' && channels.indexOf('JOC'),\n              }\n            })));\n          }\n        }\n      });\n    });\n  }\n  return Promise.all(configurations.map(configuration => {\n    // Cache MediaCapabilities promises\n    const decodingInfoKey = getMediaDecodingInfoKey(configuration);\n    return SUPPORTED_INFO_CACHE[decodingInfoKey] || (SUPPORTED_INFO_CACHE[decodingInfoKey] = mediaCapabilities.decodingInfo(configuration));\n  })).then(decodingInfoResults => ({\n    supported: !decodingInfoResults.some(info => !info.supported),\n    configurations,\n    decodingInfoResults\n  })).catch(error => ({\n    supported: false,\n    configurations,\n    decodingInfoResults: [],\n    error\n  }));\n}\nfunction getMediaDecodingInfoKey(config) {\n  const {\n    audio,\n    video\n  } = config;\n  const mediaConfig = video || audio;\n  if (mediaConfig) {\n    const codec = mediaConfig.contentType.split('\"')[1];\n    if (video) {\n      return `r${video.height}x${video.width}f${Math.ceil(video.framerate)}${video.transferFunction || 'sd'}_${codec}_${Math.ceil(video.bitrate / 1e5)}`;\n    }\n    if (audio) {\n      return `c${audio.channels}${audio.spatialRendering ? 's' : 'n'}_${codec}`;\n    }\n  }\n  return '';\n}\n\n/**\n * @returns Whether we can detect and validate HDR capability within the window context\n */\nfunction isHdrSupported() {\n  if (typeof matchMedia === 'function') {\n    const mediaQueryList = matchMedia('(dynamic-range: high)');\n    const badQuery = matchMedia('bad query');\n    if (mediaQueryList.media !== badQuery.media) {\n      return mediaQueryList.matches === true;\n    }\n  }\n  return false;\n}\n\n/**\n * Sanitizes inputs to return the active video selection options for HDR/SDR.\n * When both inputs are null:\n *\n *    `{ preferHDR: false, allowedVideoRanges: [] }`\n *\n * When `currentVideoRange` non-null, maintain the active range:\n *\n *    `{ preferHDR: currentVideoRange !== 'SDR', allowedVideoRanges: [currentVideoRange] }`\n *\n * When VideoSelectionOption non-null:\n *\n *  - Allow all video ranges if `allowedVideoRanges` unspecified.\n *  - If `preferHDR` is non-null use the value to filter `allowedVideoRanges`.\n *  - Else check window for HDR support and set `preferHDR` to the result.\n *\n * @param currentVideoRange\n * @param videoPreference\n */\nfunction getVideoSelectionOptions(currentVideoRange, videoPreference) {\n  let preferHDR = false;\n  let allowedVideoRanges = [];\n  if (currentVideoRange) {\n    preferHDR = currentVideoRange !== 'SDR';\n    allowedVideoRanges = [currentVideoRange];\n  }\n  if (videoPreference) {\n    allowedVideoRanges = videoPreference.allowedVideoRanges || VideoRangeValues.slice(0);\n    preferHDR = videoPreference.preferHDR !== undefined ? videoPreference.preferHDR : isHdrSupported();\n    if (preferHDR) {\n      allowedVideoRanges = allowedVideoRanges.filter(range => range !== 'SDR');\n    } else {\n      allowedVideoRanges = ['SDR'];\n    }\n  }\n  return {\n    preferHDR,\n    allowedVideoRanges\n  };\n}\n\nfunction getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference) {\n  const codecSets = Object.keys(codecTiers);\n  const channelsPreference = audioPreference == null ? void 0 : audioPreference.channels;\n  const audioCodecPreference = audioPreference == null ? void 0 : audioPreference.audioCodec;\n  const preferStereo = channelsPreference && parseInt(channelsPreference) === 2;\n  // Use first level set to determine stereo, and minimum resolution and framerate\n  let hasStereo = true;\n  let hasCurrentVideoRange = false;\n  let minHeight = Infinity;\n  let minFramerate = Infinity;\n  let minBitrate = Infinity;\n  let selectedScore = 0;\n  let videoRanges = [];\n  const {\n    preferHDR,\n    allowedVideoRanges\n  } = getVideoSelectionOptions(currentVideoRange, videoPreference);\n  for (let i = codecSets.length; i--;) {\n    const tier = codecTiers[codecSets[i]];\n    hasStereo = tier.channels[2] > 0;\n    minHeight = Math.min(minHeight, tier.minHeight);\n    minFramerate = Math.min(minFramerate, tier.minFramerate);\n    minBitrate = Math.min(minBitrate, tier.minBitrate);\n    const matchingVideoRanges = allowedVideoRanges.filter(range => tier.videoRanges[range] > 0);\n    if (matchingVideoRanges.length > 0) {\n      hasCurrentVideoRange = true;\n      videoRanges = matchingVideoRanges;\n    }\n  }\n  minHeight = isFiniteNumber(minHeight) ? minHeight : 0;\n  minFramerate = isFiniteNumber(minFramerate) ? minFramerate : 0;\n  const maxHeight = Math.max(1080, minHeight);\n  const maxFramerate = Math.max(30, minFramerate);\n  minBitrate = isFiniteNumber(minBitrate) ? minBitrate : currentBw;\n  currentBw = Math.max(minBitrate, currentBw);\n  // If there are no variants with matching preference, set currentVideoRange to undefined\n  if (!hasCurrentVideoRange) {\n    currentVideoRange = undefined;\n    videoRanges = [];\n  }\n  const codecSet = codecSets.reduce((selected, candidate) => {\n    // Remove candiates which do not meet bitrate, default audio, stereo or channels preference, 1080p or lower, 30fps or lower, or SDR/HDR selection if present\n    const candidateTier = codecTiers[candidate];\n    if (candidate === selected) {\n      return selected;\n    }\n    if (candidateTier.minBitrate > currentBw) {\n      logStartCodecCandidateIgnored(candidate, `min bitrate of ${candidateTier.minBitrate} > current estimate of ${currentBw}`);\n      return selected;\n    }\n    if (!candidateTier.hasDefaultAudio) {\n      logStartCodecCandidateIgnored(candidate, `no renditions with default or auto-select sound found`);\n      return selected;\n    }\n    if (audioCodecPreference && candidate.indexOf(audioCodecPreference.substring(0, 4)) % 5 !== 0) {\n      logStartCodecCandidateIgnored(candidate, `audio codec preference \"${audioCodecPreference}\" not found`);\n      return selected;\n    }\n    if (channelsPreference && !preferStereo) {\n      if (!candidateTier.channels[channelsPreference]) {\n        logStartCodecCandidateIgnored(candidate, `no renditions with ${channelsPreference} channel sound found (channels options: ${Object.keys(candidateTier.channels)})`);\n        return selected;\n      }\n    } else if ((!audioCodecPreference || preferStereo) && hasStereo && candidateTier.channels['2'] === 0) {\n      logStartCodecCandidateIgnored(candidate, `no renditions with stereo sound found`);\n      return selected;\n    }\n    if (candidateTier.minHeight > maxHeight) {\n      logStartCodecCandidateIgnored(candidate, `min resolution of ${candidateTier.minHeight} > maximum of ${maxHeight}`);\n      return selected;\n    }\n    if (candidateTier.minFramerate > maxFramerate) {\n      logStartCodecCandidateIgnored(candidate, `min framerate of ${candidateTier.minFramerate} > maximum of ${maxFramerate}`);\n      return selected;\n    }\n    if (!videoRanges.some(range => candidateTier.videoRanges[range] > 0)) {\n      logStartCodecCandidateIgnored(candidate, `no variants with VIDEO-RANGE of ${JSON.stringify(videoRanges)} found`);\n      return selected;\n    }\n    if (candidateTier.maxScore < selectedScore) {\n      logStartCodecCandidateIgnored(candidate, `max score of ${candidateTier.maxScore} < selected max of ${selectedScore}`);\n      return selected;\n    }\n    // Remove candiates with less preferred codecs or more errors\n    if (selected && (codecsSetSelectionPreferenceValue(candidate) >= codecsSetSelectionPreferenceValue(selected) || candidateTier.fragmentError > codecTiers[selected].fragmentError)) {\n      return selected;\n    }\n    selectedScore = candidateTier.maxScore;\n    return candidate;\n  }, undefined);\n  return {\n    codecSet,\n    videoRanges,\n    preferHDR,\n    minFramerate,\n    minBitrate\n  };\n}\nfunction logStartCodecCandidateIgnored(codeSet, reason) {\n  logger.log(`[abr] start candidates with \"${codeSet}\" ignored because ${reason}`);\n}\nfunction getAudioTracksByGroup(allAudioTracks) {\n  return allAudioTracks.reduce((audioTracksByGroup, track) => {\n    let trackGroup = audioTracksByGroup.groups[track.groupId];\n    if (!trackGroup) {\n      trackGroup = audioTracksByGroup.groups[track.groupId] = {\n        tracks: [],\n        channels: {\n          2: 0\n        },\n        hasDefault: false,\n        hasAutoSelect: false\n      };\n    }\n    trackGroup.tracks.push(track);\n    const channelsKey = track.channels || '2';\n    trackGroup.channels[channelsKey] = (trackGroup.channels[channelsKey] || 0) + 1;\n    trackGroup.hasDefault = trackGroup.hasDefault || track.default;\n    trackGroup.hasAutoSelect = trackGroup.hasAutoSelect || track.autoselect;\n    if (trackGroup.hasDefault) {\n      audioTracksByGroup.hasDefaultAudio = true;\n    }\n    if (trackGroup.hasAutoSelect) {\n      audioTracksByGroup.hasAutoSelectAudio = true;\n    }\n    return audioTracksByGroup;\n  }, {\n    hasDefaultAudio: false,\n    hasAutoSelectAudio: false,\n    groups: {}\n  });\n}\nfunction getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel) {\n  return levels.slice(minAutoLevel, maxAutoLevel + 1).reduce((tiers, level) => {\n    if (!level.codecSet) {\n      return tiers;\n    }\n    const audioGroups = level.audioGroups;\n    let tier = tiers[level.codecSet];\n    if (!tier) {\n      tiers[level.codecSet] = tier = {\n        minBitrate: Infinity,\n        minHeight: Infinity,\n        minFramerate: Infinity,\n        maxScore: 0,\n        videoRanges: {\n          SDR: 0\n        },\n        channels: {\n          '2': 0\n        },\n        hasDefaultAudio: !audioGroups,\n        fragmentError: 0\n      };\n    }\n    tier.minBitrate = Math.min(tier.minBitrate, level.bitrate);\n    const lesserWidthOrHeight = Math.min(level.height, level.width);\n    tier.minHeight = Math.min(tier.minHeight, lesserWidthOrHeight);\n    tier.minFramerate = Math.min(tier.minFramerate, level.frameRate);\n    tier.maxScore = Math.max(tier.maxScore, level.score);\n    tier.fragmentError += level.fragmentError;\n    tier.videoRanges[level.videoRange] = (tier.videoRanges[level.videoRange] || 0) + 1;\n    if (audioGroups) {\n      audioGroups.forEach(audioGroupId => {\n        if (!audioGroupId) {\n          return;\n        }\n        const audioGroup = audioTracksByGroup.groups[audioGroupId];\n        if (!audioGroup) {\n          return;\n        }\n        // Default audio is any group with DEFAULT=YES, or if missing then any group with AUTOSELECT=YES, or all variants\n        tier.hasDefaultAudio = tier.hasDefaultAudio || audioTracksByGroup.hasDefaultAudio ? audioGroup.hasDefault : audioGroup.hasAutoSelect || !audioTracksByGroup.hasDefaultAudio && !audioTracksByGroup.hasAutoSelectAudio;\n        Object.keys(audioGroup.channels).forEach(channels => {\n          tier.channels[channels] = (tier.channels[channels] || 0) + audioGroup.channels[channels];\n        });\n      });\n    }\n    return tiers;\n  }, {});\n}\nfunction findMatchingOption(option, tracks, matchPredicate) {\n  if ('attrs' in option) {\n    const index = tracks.indexOf(option);\n    if (index !== -1) {\n      return index;\n    }\n  }\n  for (let i = 0; i < tracks.length; i++) {\n    const track = tracks[i];\n    if (matchesOption(option, track, matchPredicate)) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction matchesOption(option, track, matchPredicate) {\n  const {\n    groupId,\n    name,\n    lang,\n    assocLang,\n    characteristics,\n    default: isDefault\n  } = option;\n  const forced = option.forced;\n  return (groupId === undefined || track.groupId === groupId) && (name === undefined || track.name === name) && (lang === undefined || track.lang === lang) && (lang === undefined || track.assocLang === assocLang) && (isDefault === undefined || track.default === isDefault) && (forced === undefined || track.forced === forced) && (characteristics === undefined || characteristicsMatch(characteristics, track.characteristics)) && (matchPredicate === undefined || matchPredicate(option, track));\n}\nfunction characteristicsMatch(characteristicsA, characteristicsB = '') {\n  const arrA = characteristicsA.split(',');\n  const arrB = characteristicsB.split(',');\n  // Expects each item to be unique:\n  return arrA.length === arrB.length && !arrA.some(el => arrB.indexOf(el) === -1);\n}\nfunction audioMatchPredicate(option, track) {\n  const {\n    audioCodec,\n    channels\n  } = option;\n  return (audioCodec === undefined || (track.audioCodec || '').substring(0, 4) === audioCodec.substring(0, 4)) && (channels === undefined || channels === (track.channels || '2'));\n}\nfunction findClosestLevelWithAudioGroup(option, levels, allAudioTracks, searchIndex, matchPredicate) {\n  const currentLevel = levels[searchIndex];\n  // Are there variants with same URI as current level?\n  // If so, find a match that does not require any level URI change\n  const variants = levels.reduce((variantMap, level, index) => {\n    const uri = level.uri;\n    const renditions = variantMap[uri] || (variantMap[uri] = []);\n    renditions.push(index);\n    return variantMap;\n  }, {});\n  const renditions = variants[currentLevel.uri];\n  if (renditions.length > 1) {\n    searchIndex = Math.max.apply(Math, renditions);\n  }\n  // Find best match\n  const currentVideoRange = currentLevel.videoRange;\n  const currentFrameRate = currentLevel.frameRate;\n  const currentVideoCodec = currentLevel.codecSet.substring(0, 4);\n  const matchingVideo = searchDownAndUpList(levels, searchIndex, level => {\n    if (level.videoRange !== currentVideoRange || level.frameRate !== currentFrameRate || level.codecSet.substring(0, 4) !== currentVideoCodec) {\n      return false;\n    }\n    const audioGroups = level.audioGroups;\n    const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n    return findMatchingOption(option, tracks, matchPredicate) > -1;\n  });\n  if (matchingVideo > -1) {\n    return matchingVideo;\n  }\n  return searchDownAndUpList(levels, searchIndex, level => {\n    const audioGroups = level.audioGroups;\n    const tracks = allAudioTracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n    return findMatchingOption(option, tracks, matchPredicate) > -1;\n  });\n}\nfunction searchDownAndUpList(arr, searchIndex, predicate) {\n  for (let i = searchIndex; i; i--) {\n    if (predicate(arr[i])) {\n      return i;\n    }\n  }\n  for (let i = searchIndex + 1; i < arr.length; i++) {\n    if (predicate(arr[i])) {\n      return i;\n    }\n  }\n  return -1;\n}\n\nclass AbrController {\n  constructor(_hls) {\n    this.hls = void 0;\n    this.lastLevelLoadSec = 0;\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this._nextAutoLevel = -1;\n    this.nextAutoLevelKey = '';\n    this.audioTracksByGroup = null;\n    this.codecTiers = null;\n    this.timer = -1;\n    this.fragCurrent = null;\n    this.partCurrent = null;\n    this.bitrateTestDelay = 0;\n    this.bwEstimator = void 0;\n    /*\n        This method monitors the download rate of the current fragment, and will downswitch if that fragment will not load\n        quickly enough to prevent underbuffering\n      */\n    this._abandonRulesCheck = () => {\n      const {\n        fragCurrent: frag,\n        partCurrent: part,\n        hls\n      } = this;\n      const {\n        autoLevelEnabled,\n        media\n      } = hls;\n      if (!frag || !media) {\n        return;\n      }\n      const now = performance.now();\n      const stats = part ? part.stats : frag.stats;\n      const duration = part ? part.duration : frag.duration;\n      const timeLoading = now - stats.loading.start;\n      const minAutoLevel = hls.minAutoLevel;\n      // If frag loading is aborted, complete, or from lowest level, stop timer and return\n      if (stats.aborted || stats.loaded && stats.loaded === stats.total || frag.level <= minAutoLevel) {\n        this.clearTimer();\n        // reset forced auto level value so that next level will be selected\n        this._nextAutoLevel = -1;\n        return;\n      }\n\n      // This check only runs if we're in ABR mode and actually playing\n      if (!autoLevelEnabled || media.paused || !media.playbackRate || !media.readyState) {\n        return;\n      }\n      const bufferInfo = hls.mainForwardBufferInfo;\n      if (bufferInfo === null) {\n        return;\n      }\n      const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n      const playbackRate = Math.abs(media.playbackRate);\n      // To maintain stable adaptive playback, only begin monitoring frag loading after half or more of its playback duration has passed\n      if (timeLoading <= Math.max(ttfbEstimate, 1000 * (duration / (playbackRate * 2)))) {\n        return;\n      }\n\n      // bufferStarvationDelay is an estimate of the amount time (in seconds) it will take to exhaust the buffer\n      const bufferStarvationDelay = bufferInfo.len / playbackRate;\n      const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n      const loadedFirstByte = stats.loaded && ttfb > -1;\n      const bwEstimate = this.getBwEstimate();\n      const levels = hls.levels;\n      const level = levels[frag.level];\n      const expectedLen = stats.total || Math.max(stats.loaded, Math.round(duration * level.averageBitrate / 8));\n      let timeStreaming = loadedFirstByte ? timeLoading - ttfb : timeLoading;\n      if (timeStreaming < 1 && loadedFirstByte) {\n        timeStreaming = Math.min(timeLoading, stats.loaded * 8 / bwEstimate);\n      }\n      const loadRate = loadedFirstByte ? stats.loaded * 1000 / timeStreaming : 0;\n      // fragLoadDelay is an estimate of the time (in seconds) it will take to buffer the remainder of the fragment\n      const fragLoadedDelay = loadRate ? (expectedLen - stats.loaded) / loadRate : expectedLen * 8 / bwEstimate + ttfbEstimate / 1000;\n      // Only downswitch if the time to finish loading the current fragment is greater than the amount of buffer left\n      if (fragLoadedDelay <= bufferStarvationDelay) {\n        return;\n      }\n      const bwe = loadRate ? loadRate * 8 : bwEstimate;\n      let fragLevelNextLoadedDelay = Number.POSITIVE_INFINITY;\n      let nextLoadLevel;\n      // Iterate through lower level and try to find the largest one that avoids rebuffering\n      for (nextLoadLevel = frag.level - 1; nextLoadLevel > minAutoLevel; nextLoadLevel--) {\n        // compute time to load next fragment at lower level\n        // 8 = bits per byte (bps/Bps)\n        const levelNextBitrate = levels[nextLoadLevel].maxBitrate;\n        fragLevelNextLoadedDelay = this.getTimeToLoadFrag(ttfbEstimate / 1000, bwe, duration * levelNextBitrate, !levels[nextLoadLevel].details);\n        if (fragLevelNextLoadedDelay < bufferStarvationDelay) {\n          break;\n        }\n      }\n      // Only emergency switch down if it takes less time to load a new fragment at lowest level instead of continuing\n      // to load the current one\n      if (fragLevelNextLoadedDelay >= fragLoadedDelay) {\n        return;\n      }\n\n      // if estimated load time of new segment is completely unreasonable, ignore and do not emergency switch down\n      if (fragLevelNextLoadedDelay > duration * 10) {\n        return;\n      }\n      hls.nextLoadLevel = hls.nextAutoLevel = nextLoadLevel;\n      if (loadedFirstByte) {\n        // If there has been loading progress, sample bandwidth using loading time offset by minimum TTFB time\n        this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n      } else {\n        // If there has been no loading progress, sample TTFB\n        this.bwEstimator.sampleTTFB(timeLoading);\n      }\n      const nextLoadLevelBitrate = levels[nextLoadLevel].maxBitrate;\n      if (this.getBwEstimate() * this.hls.config.abrBandWidthUpFactor > nextLoadLevelBitrate) {\n        this.resetEstimator(nextLoadLevelBitrate);\n      }\n      this.clearTimer();\n      logger.warn(`[abr] Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} is loading too slowly;\n      Time to underbuffer: ${bufferStarvationDelay.toFixed(3)} s\n      Estimated load time for current fragment: ${fragLoadedDelay.toFixed(3)} s\n      Estimated load time for down switch fragment: ${fragLevelNextLoadedDelay.toFixed(3)} s\n      TTFB estimate: ${ttfb | 0} ms\n      Current BW estimate: ${isFiniteNumber(bwEstimate) ? bwEstimate | 0 : 'Unknown'} bps\n      New BW estimate: ${this.getBwEstimate() | 0} bps\n      Switching to level ${nextLoadLevel} @ ${nextLoadLevelBitrate | 0} bps`);\n      hls.trigger(Events.FRAG_LOAD_EMERGENCY_ABORTED, {\n        frag,\n        part,\n        stats\n      });\n    };\n    this.hls = _hls;\n    this.bwEstimator = this.initEstimator();\n    this.registerListeners();\n  }\n  resetEstimator(abrEwmaDefaultEstimate) {\n    if (abrEwmaDefaultEstimate) {\n      logger.log(`setting initial bwe to ${abrEwmaDefaultEstimate}`);\n      this.hls.config.abrEwmaDefaultEstimate = abrEwmaDefaultEstimate;\n    }\n    this.firstSelection = -1;\n    this.bwEstimator = this.initEstimator();\n  }\n  initEstimator() {\n    const config = this.hls.config;\n    return new EwmaBandWidthEstimator(config.abrEwmaSlowVoD, config.abrEwmaFastVoD, config.abrEwmaDefaultEstimate);\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.MAX_AUTO_LEVEL_UPDATED, this.onMaxAutoLevelUpdated, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.clearTimer();\n    // @ts-ignore\n    this.hls = this._abandonRulesCheck = null;\n    this.fragCurrent = this.partCurrent = null;\n  }\n  onManifestLoading(event, data) {\n    this.lastLoadedFragLevel = -1;\n    this.firstSelection = -1;\n    this.lastLevelLoadSec = 0;\n    this.fragCurrent = this.partCurrent = null;\n    this.onLevelsUpdated();\n    this.clearTimer();\n  }\n  onLevelsUpdated() {\n    if (this.lastLoadedFragLevel > -1 && this.fragCurrent) {\n      this.lastLoadedFragLevel = this.fragCurrent.level;\n    }\n    this._nextAutoLevel = -1;\n    this.onMaxAutoLevelUpdated();\n    this.codecTiers = null;\n    this.audioTracksByGroup = null;\n  }\n  onMaxAutoLevelUpdated() {\n    this.firstSelection = -1;\n    this.nextAutoLevelKey = '';\n  }\n  onFragLoading(event, data) {\n    const frag = data.frag;\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    if (!frag.bitrateTest) {\n      var _data$part;\n      this.fragCurrent = frag;\n      this.partCurrent = (_data$part = data.part) != null ? _data$part : null;\n    }\n    this.clearTimer();\n    this.timer = self.setInterval(this._abandonRulesCheck, 100);\n  }\n  onLevelSwitching(event, data) {\n    this.clearTimer();\n  }\n  onError(event, data) {\n    if (data.fatal) {\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.BUFFER_ADD_CODEC_ERROR:\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n        // Reset last loaded level so that a new selection can be made after calling recoverMediaError\n        this.lastLoadedFragLevel = -1;\n        this.firstSelection = -1;\n        break;\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n        {\n          const frag = data.frag;\n          const {\n            fragCurrent,\n            partCurrent: part\n          } = this;\n          if (frag && fragCurrent && frag.sn === fragCurrent.sn && frag.level === fragCurrent.level) {\n            const now = performance.now();\n            const stats = part ? part.stats : frag.stats;\n            const timeLoading = now - stats.loading.start;\n            const ttfb = stats.loading.first ? stats.loading.first - stats.loading.start : -1;\n            const loadedFirstByte = stats.loaded && ttfb > -1;\n            if (loadedFirstByte) {\n              const ttfbEstimate = this.bwEstimator.getEstimateTTFB();\n              this.bwEstimator.sample(timeLoading - Math.min(ttfbEstimate, ttfb), stats.loaded);\n            } else {\n              this.bwEstimator.sampleTTFB(timeLoading);\n            }\n          }\n          break;\n        }\n    }\n  }\n  getTimeToLoadFrag(timeToFirstByteSec, bandwidth, fragSizeBits, isSwitch) {\n    const fragLoadSec = timeToFirstByteSec + fragSizeBits / bandwidth;\n    const playlistLoadSec = isSwitch ? this.lastLevelLoadSec : 0;\n    return fragLoadSec + playlistLoadSec;\n  }\n  onLevelLoaded(event, data) {\n    const config = this.hls.config;\n    const {\n      loading\n    } = data.stats;\n    const timeLoadingMs = loading.end - loading.start;\n    if (isFiniteNumber(timeLoadingMs)) {\n      this.lastLevelLoadSec = timeLoadingMs / 1000;\n    }\n    if (data.details.live) {\n      this.bwEstimator.update(config.abrEwmaSlowLive, config.abrEwmaFastLive);\n    } else {\n      this.bwEstimator.update(config.abrEwmaSlowVoD, config.abrEwmaFastVoD);\n    }\n  }\n  onFragLoaded(event, {\n    frag,\n    part\n  }) {\n    const stats = part ? part.stats : frag.stats;\n    if (frag.type === PlaylistLevelType.MAIN) {\n      this.bwEstimator.sampleTTFB(stats.loading.first - stats.loading.start);\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // stop monitoring bw once frag loaded\n    this.clearTimer();\n    // reset forced auto level value so that next level will be selected\n    if (frag.level === this._nextAutoLevel) {\n      this._nextAutoLevel = -1;\n    }\n    this.firstSelection = -1;\n\n    // compute level average bitrate\n    if (this.hls.config.abrMaxWithRealBitrate) {\n      const duration = part ? part.duration : frag.duration;\n      const level = this.hls.levels[frag.level];\n      const loadedBytes = (level.loaded ? level.loaded.bytes : 0) + stats.loaded;\n      const loadedDuration = (level.loaded ? level.loaded.duration : 0) + duration;\n      level.loaded = {\n        bytes: loadedBytes,\n        duration: loadedDuration\n      };\n      level.realBitrate = Math.round(8 * loadedBytes / loadedDuration);\n    }\n    if (frag.bitrateTest) {\n      const fragBufferedData = {\n        stats,\n        frag,\n        part,\n        id: frag.type\n      };\n      this.onFragBuffered(Events.FRAG_BUFFERED, fragBufferedData);\n      frag.bitrateTest = false;\n    } else {\n      // store level id after successful fragment load for playback\n      this.lastLoadedFragLevel = frag.level;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const stats = part != null && part.stats.loaded ? part.stats : frag.stats;\n    if (stats.aborted) {\n      return;\n    }\n    if (this.ignoreFragment(frag)) {\n      return;\n    }\n    // Use the difference between parsing and request instead of buffering and request to compute fragLoadingProcessing;\n    // rationale is that buffer appending only happens once media is attached. This can happen when config.startFragPrefetch\n    // is used. If we used buffering in that case, our BW estimate sample will be very large.\n    const processingMs = stats.parsing.end - stats.loading.start - Math.min(stats.loading.first - stats.loading.start, this.bwEstimator.getEstimateTTFB());\n    this.bwEstimator.sample(processingMs, stats.loaded);\n    stats.bwEstimate = this.getBwEstimate();\n    if (frag.bitrateTest) {\n      this.bitrateTestDelay = processingMs / 1000;\n    } else {\n      this.bitrateTestDelay = 0;\n    }\n  }\n  ignoreFragment(frag) {\n    // Only count non-alt-audio frags which were actually buffered in our BW calculations\n    return frag.type !== PlaylistLevelType.MAIN || frag.sn === 'initSegment';\n  }\n  clearTimer() {\n    if (this.timer > -1) {\n      self.clearInterval(this.timer);\n      this.timer = -1;\n    }\n  }\n  get firstAutoLevel() {\n    const {\n      maxAutoLevel,\n      minAutoLevel\n    } = this.hls;\n    const bwEstimate = this.getBwEstimate();\n    const maxStartDelay = this.hls.config.maxStarvationDelay;\n    const abrAutoLevel = this.findBestLevel(bwEstimate, minAutoLevel, maxAutoLevel, 0, maxStartDelay, 1, 1);\n    if (abrAutoLevel > -1) {\n      return abrAutoLevel;\n    }\n    const firstLevel = this.hls.firstLevel;\n    const clamped = Math.min(Math.max(firstLevel, minAutoLevel), maxAutoLevel);\n    logger.warn(`[abr] Could not find best starting auto level. Defaulting to first in playlist ${firstLevel} clamped to ${clamped}`);\n    return clamped;\n  }\n  get forcedAutoLevel() {\n    if (this.nextAutoLevelKey) {\n      return -1;\n    }\n    return this._nextAutoLevel;\n  }\n\n  // return next auto level\n  get nextAutoLevel() {\n    const forcedAutoLevel = this.forcedAutoLevel;\n    const bwEstimator = this.bwEstimator;\n    const useEstimate = bwEstimator.canEstimate();\n    const loadedFirstFrag = this.lastLoadedFragLevel > -1;\n    // in case next auto level has been forced, and bw not available or not reliable, return forced value\n    if (forcedAutoLevel !== -1 && (!useEstimate || !loadedFirstFrag || this.nextAutoLevelKey === this.getAutoLevelKey())) {\n      return forcedAutoLevel;\n    }\n\n    // compute next level using ABR logic\n    const nextABRAutoLevel = useEstimate && loadedFirstFrag ? this.getNextABRAutoLevel() : this.firstAutoLevel;\n\n    // use forced auto level while it hasn't errored more than ABR selection\n    if (forcedAutoLevel !== -1) {\n      const levels = this.hls.levels;\n      if (levels.length > Math.max(forcedAutoLevel, nextABRAutoLevel) && levels[forcedAutoLevel].loadError <= levels[nextABRAutoLevel].loadError) {\n        return forcedAutoLevel;\n      }\n    }\n\n    // save result until state has changed\n    this._nextAutoLevel = nextABRAutoLevel;\n    this.nextAutoLevelKey = this.getAutoLevelKey();\n    return nextABRAutoLevel;\n  }\n  getAutoLevelKey() {\n    return `${this.getBwEstimate()}_${this.getStarvationDelay().toFixed(2)}`;\n  }\n  getNextABRAutoLevel() {\n    const {\n      fragCurrent,\n      partCurrent,\n      hls\n    } = this;\n    const {\n      maxAutoLevel,\n      config,\n      minAutoLevel\n    } = hls;\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const avgbw = this.getBwEstimate();\n    // bufferStarvationDelay is the wall-clock time left until the playback buffer is exhausted.\n    const bufferStarvationDelay = this.getStarvationDelay();\n    let bwFactor = config.abrBandWidthFactor;\n    let bwUpFactor = config.abrBandWidthUpFactor;\n\n    // First, look to see if we can find a level matching with our avg bandwidth AND that could also guarantee no rebuffering at all\n    if (bufferStarvationDelay) {\n      const _bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, 0, bwFactor, bwUpFactor);\n      if (_bestLevel >= 0) {\n        return _bestLevel;\n      }\n    }\n    // not possible to get rid of rebuffering... try to find level that will guarantee less than maxStarvationDelay of rebuffering\n    let maxStarvationDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxStarvationDelay) : config.maxStarvationDelay;\n    if (!bufferStarvationDelay) {\n      // in case buffer is empty, let's check if previous fragment was loaded to perform a bitrate test\n      const bitrateTestDelay = this.bitrateTestDelay;\n      if (bitrateTestDelay) {\n        // if it is the case, then we need to adjust our max starvation delay using maxLoadingDelay config value\n        // max video loading delay used in  automatic start level selection :\n        // in that mode ABR controller will ensure that video loading time (ie the time to fetch the first fragment at lowest quality level +\n        // the time to fetch the fragment at the appropriate quality level is less than ```maxLoadingDelay``` )\n        // cap maxLoadingDelay and ensure it is not bigger 'than bitrate test' frag duration\n        const maxLoadingDelay = currentFragDuration ? Math.min(currentFragDuration, config.maxLoadingDelay) : config.maxLoadingDelay;\n        maxStarvationDelay = maxLoadingDelay - bitrateTestDelay;\n        logger.info(`[abr] bitrate test took ${Math.round(1000 * bitrateTestDelay)}ms, set first fragment max fetchDuration to ${Math.round(1000 * maxStarvationDelay)} ms`);\n        // don't use conservative factor on bitrate test\n        bwFactor = bwUpFactor = 1;\n      }\n    }\n    const bestLevel = this.findBestLevel(avgbw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor);\n    logger.info(`[abr] ${bufferStarvationDelay ? 'rebuffering expected' : 'buffer is empty'}, optimal quality level ${bestLevel}`);\n    if (bestLevel > -1) {\n      return bestLevel;\n    }\n    // If no matching level found, see if min auto level would be a better option\n    const minLevel = hls.levels[minAutoLevel];\n    const autoLevel = hls.levels[hls.loadLevel];\n    if ((minLevel == null ? void 0 : minLevel.bitrate) < (autoLevel == null ? void 0 : autoLevel.bitrate)) {\n      return minAutoLevel;\n    }\n    // or if bitrate is not lower, continue to use loadLevel\n    return hls.loadLevel;\n  }\n  getStarvationDelay() {\n    const hls = this.hls;\n    const media = hls.media;\n    if (!media) {\n      return Infinity;\n    }\n    // playbackRate is the absolute value of the playback rate; if media.playbackRate is 0, we use 1 to load as\n    // if we're playing back at the normal rate.\n    const playbackRate = media && media.playbackRate !== 0 ? Math.abs(media.playbackRate) : 1.0;\n    const bufferInfo = hls.mainForwardBufferInfo;\n    return (bufferInfo ? bufferInfo.len : 0) / playbackRate;\n  }\n  getBwEstimate() {\n    return this.bwEstimator.canEstimate() ? this.bwEstimator.getEstimate() : this.hls.config.abrEwmaDefaultEstimate;\n  }\n  findBestLevel(currentBw, minAutoLevel, maxAutoLevel, bufferStarvationDelay, maxStarvationDelay, bwFactor, bwUpFactor) {\n    var _level$details;\n    const maxFetchDuration = bufferStarvationDelay + maxStarvationDelay;\n    const lastLoadedFragLevel = this.lastLoadedFragLevel;\n    const selectionBaseLevel = lastLoadedFragLevel === -1 ? this.hls.firstLevel : lastLoadedFragLevel;\n    const {\n      fragCurrent,\n      partCurrent\n    } = this;\n    const {\n      levels,\n      allAudioTracks,\n      loadLevel,\n      config\n    } = this.hls;\n    if (levels.length === 1) {\n      return 0;\n    }\n    const level = levels[selectionBaseLevel];\n    const live = !!(level != null && (_level$details = level.details) != null && _level$details.live);\n    const firstSelection = loadLevel === -1 || lastLoadedFragLevel === -1;\n    let currentCodecSet;\n    let currentVideoRange = 'SDR';\n    let currentFrameRate = (level == null ? void 0 : level.frameRate) || 0;\n    const {\n      audioPreference,\n      videoPreference\n    } = config;\n    const audioTracksByGroup = this.audioTracksByGroup || (this.audioTracksByGroup = getAudioTracksByGroup(allAudioTracks));\n    if (firstSelection) {\n      if (this.firstSelection !== -1) {\n        return this.firstSelection;\n      }\n      const codecTiers = this.codecTiers || (this.codecTiers = getCodecTiers(levels, audioTracksByGroup, minAutoLevel, maxAutoLevel));\n      const startTier = getStartCodecTier(codecTiers, currentVideoRange, currentBw, audioPreference, videoPreference);\n      const {\n        codecSet,\n        videoRanges,\n        minFramerate,\n        minBitrate,\n        preferHDR\n      } = startTier;\n      currentCodecSet = codecSet;\n      currentVideoRange = preferHDR ? videoRanges[videoRanges.length - 1] : videoRanges[0];\n      currentFrameRate = minFramerate;\n      currentBw = Math.max(currentBw, minBitrate);\n      logger.log(`[abr] picked start tier ${JSON.stringify(startTier)}`);\n    } else {\n      currentCodecSet = level == null ? void 0 : level.codecSet;\n      currentVideoRange = level == null ? void 0 : level.videoRange;\n    }\n    const currentFragDuration = partCurrent ? partCurrent.duration : fragCurrent ? fragCurrent.duration : 0;\n    const ttfbEstimateSec = this.bwEstimator.getEstimateTTFB() / 1000;\n    const levelsSkipped = [];\n    for (let i = maxAutoLevel; i >= minAutoLevel; i--) {\n      var _levelInfo$supportedR;\n      const levelInfo = levels[i];\n      const upSwitch = i > selectionBaseLevel;\n      if (!levelInfo) {\n        continue;\n      }\n      if (config.useMediaCapabilities && !levelInfo.supportedResult && !levelInfo.supportedPromise) {\n        const mediaCapabilities = navigator.mediaCapabilities;\n        if (typeof (mediaCapabilities == null ? void 0 : mediaCapabilities.decodingInfo) === 'function' && requiresMediaCapabilitiesDecodingInfo(levelInfo, audioTracksByGroup, currentVideoRange, currentFrameRate, currentBw, audioPreference)) {\n          levelInfo.supportedPromise = getMediaDecodingInfoPromise(levelInfo, audioTracksByGroup, mediaCapabilities);\n          levelInfo.supportedPromise.then(decodingInfo => {\n            if (!this.hls) {\n              return;\n            }\n            levelInfo.supportedResult = decodingInfo;\n            const levels = this.hls.levels;\n            const index = levels.indexOf(levelInfo);\n            if (decodingInfo.error) {\n              logger.warn(`[abr] MediaCapabilities decodingInfo error: \"${decodingInfo.error}\" for level ${index} ${JSON.stringify(decodingInfo)}`);\n            } else if (!decodingInfo.supported) {\n              logger.warn(`[abr] Unsupported MediaCapabilities decodingInfo result for level ${index} ${JSON.stringify(decodingInfo)}`);\n              if (index > -1 && levels.length > 1) {\n                logger.log(`[abr] Removing unsupported level ${index}`);\n                this.hls.removeLevel(index);\n              }\n            }\n          });\n        } else {\n          levelInfo.supportedResult = SUPPORTED_INFO_DEFAULT;\n        }\n      }\n\n      // skip candidates which change codec-family or video-range,\n      // and which decrease or increase frame-rate for up and down-switch respectfully\n      if (currentCodecSet && levelInfo.codecSet !== currentCodecSet || currentVideoRange && levelInfo.videoRange !== currentVideoRange || upSwitch && currentFrameRate > levelInfo.frameRate || !upSwitch && currentFrameRate > 0 && currentFrameRate < levelInfo.frameRate || levelInfo.supportedResult && !((_levelInfo$supportedR = levelInfo.supportedResult.decodingInfoResults) != null && _levelInfo$supportedR[0].smooth)) {\n        levelsSkipped.push(i);\n        continue;\n      }\n      const levelDetails = levelInfo.details;\n      const avgDuration = (partCurrent ? levelDetails == null ? void 0 : levelDetails.partTarget : levelDetails == null ? void 0 : levelDetails.averagetargetduration) || currentFragDuration;\n      let adjustedbw;\n      // follow algorithm captured from stagefright :\n      // https://android.googlesource.com/platform/frameworks/av/+/master/media/libstagefright/httplive/LiveSession.cpp\n      // Pick the highest bandwidth stream below or equal to estimated bandwidth.\n      // consider only 80% of the available bandwidth, but if we are switching up,\n      // be even more conservative (70%) to avoid overestimating and immediately\n      // switching back.\n      if (!upSwitch) {\n        adjustedbw = bwFactor * currentBw;\n      } else {\n        adjustedbw = bwUpFactor * currentBw;\n      }\n\n      // Use average bitrate when starvation delay (buffer length) is gt or eq two segment durations and rebuffering is not expected (maxStarvationDelay > 0)\n      const bitrate = currentFragDuration && bufferStarvationDelay >= currentFragDuration * 2 && maxStarvationDelay === 0 ? levels[i].averageBitrate : levels[i].maxBitrate;\n      const fetchDuration = this.getTimeToLoadFrag(ttfbEstimateSec, adjustedbw, bitrate * avgDuration, levelDetails === undefined);\n      const canSwitchWithinTolerance =\n      // if adjusted bw is greater than level bitrate AND\n      adjustedbw >= bitrate && (\n      // no level change, or new level has no error history\n      i === lastLoadedFragLevel || levelInfo.loadError === 0 && levelInfo.fragmentError === 0) && (\n      // fragment fetchDuration unknown OR live stream OR fragment fetchDuration less than max allowed fetch duration, then this level matches\n      // we don't account for max Fetch Duration for live streams, this is to avoid switching down when near the edge of live sliding window ...\n      // special case to support startLevel = -1 (bitrateTest) on live streams : in that case we should not exit loop so that findBestLevel will return -1\n      fetchDuration <= ttfbEstimateSec || !isFiniteNumber(fetchDuration) || live && !this.bitrateTestDelay || fetchDuration < maxFetchDuration);\n      if (canSwitchWithinTolerance) {\n        const forcedAutoLevel = this.forcedAutoLevel;\n        if (i !== loadLevel && (forcedAutoLevel === -1 || forcedAutoLevel !== loadLevel)) {\n          if (levelsSkipped.length) {\n            logger.trace(`[abr] Skipped level(s) ${levelsSkipped.join(',')} of ${maxAutoLevel} max with CODECS and VIDEO-RANGE:\"${levels[levelsSkipped[0]].codecs}\" ${levels[levelsSkipped[0]].videoRange}; not compatible with \"${level.codecs}\" ${currentVideoRange}`);\n          }\n          logger.info(`[abr] switch candidate:${selectionBaseLevel}->${i} adjustedbw(${Math.round(adjustedbw)})-bitrate=${Math.round(adjustedbw - bitrate)} ttfb:${ttfbEstimateSec.toFixed(1)} avgDuration:${avgDuration.toFixed(1)} maxFetchDuration:${maxFetchDuration.toFixed(1)} fetchDuration:${fetchDuration.toFixed(1)} firstSelection:${firstSelection} codecSet:${currentCodecSet} videoRange:${currentVideoRange} hls.loadLevel:${loadLevel}`);\n        }\n        if (firstSelection) {\n          this.firstSelection = i;\n        }\n        // as we are looping from highest to lowest, this will return the best achievable quality level\n        return i;\n      }\n    }\n    // not enough time budget even with quality level 0 ... rebuffering might happen\n    return -1;\n  }\n  set nextAutoLevel(nextLevel) {\n    const {\n      maxAutoLevel,\n      minAutoLevel\n    } = this.hls;\n    const value = Math.min(Math.max(nextLevel, minAutoLevel), maxAutoLevel);\n    if (this._nextAutoLevel !== value) {\n      this.nextAutoLevelKey = '';\n      this._nextAutoLevel = value;\n    }\n  }\n}\n\n/**\n * @ignore\n * Sub-class specialization of EventHandler base class.\n *\n * TaskLoop allows to schedule a task function being called (optionnaly repeatedly) on the main loop,\n * scheduled asynchroneously, avoiding recursive calls in the same tick.\n *\n * The task itself is implemented in `doTick`. It can be requested and called for single execution\n * using the `tick` method.\n *\n * It will be assured that the task execution method (`tick`) only gets called once per main loop \"tick\",\n * no matter how often it gets requested for execution. Execution in further ticks will be scheduled accordingly.\n *\n * If further execution requests have already been scheduled on the next tick, it can be checked with `hasNextTick`,\n * and cancelled with `clearNextTick`.\n *\n * The task can be scheduled as an interval repeatedly with a period as parameter (see `setInterval`, `clearInterval`).\n *\n * Sub-classes need to implement the `doTick` method which will effectively have the task execution routine.\n *\n * Further explanations:\n *\n * The baseclass has a `tick` method that will schedule the doTick call. It may be called synchroneously\n * only for a stack-depth of one. On re-entrant calls, sub-sequent calls are scheduled for next main loop ticks.\n *\n * When the task execution (`tick` method) is called in re-entrant way this is detected and\n * we are limiting the task execution per call stack to exactly one, but scheduling/post-poning further\n * task processing on the next main loop iteration (also known as \"next tick\" in the Node/JS runtime lingo).\n */\nclass TaskLoop {\n  constructor() {\n    this._boundTick = void 0;\n    this._tickTimer = null;\n    this._tickInterval = null;\n    this._tickCallCount = 0;\n    this._boundTick = this.tick.bind(this);\n  }\n  destroy() {\n    this.onHandlerDestroying();\n    this.onHandlerDestroyed();\n  }\n  onHandlerDestroying() {\n    // clear all timers before unregistering from event bus\n    this.clearNextTick();\n    this.clearInterval();\n  }\n  onHandlerDestroyed() {}\n  hasInterval() {\n    return !!this._tickInterval;\n  }\n  hasNextTick() {\n    return !!this._tickTimer;\n  }\n\n  /**\n   * @param millis - Interval time (ms)\n   * @eturns True when interval has been scheduled, false when already scheduled (no effect)\n   */\n  setInterval(millis) {\n    if (!this._tickInterval) {\n      this._tickCallCount = 0;\n      this._tickInterval = self.setInterval(this._boundTick, millis);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when interval was cleared, false when none was set (no effect)\n   */\n  clearInterval() {\n    if (this._tickInterval) {\n      self.clearInterval(this._tickInterval);\n      this._tickInterval = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * @returns True when timeout was cleared, false when none was set (no effect)\n   */\n  clearNextTick() {\n    if (this._tickTimer) {\n      self.clearTimeout(this._tickTimer);\n      this._tickTimer = null;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Will call the subclass doTick implementation in this main loop tick\n   * or in the next one (via setTimeout(,0)) in case it has already been called\n   * in this tick (in case this is a re-entrant call).\n   */\n  tick() {\n    this._tickCallCount++;\n    if (this._tickCallCount === 1) {\n      this.doTick();\n      // re-entrant call to tick from previous doTick call stack\n      // -> schedule a call on the next main loop iteration to process this task processing request\n      if (this._tickCallCount > 1) {\n        // make sure only one timer exists at any time at max\n        this.tickImmediate();\n      }\n      this._tickCallCount = 0;\n    }\n  }\n  tickImmediate() {\n    this.clearNextTick();\n    this._tickTimer = self.setTimeout(this._boundTick, 0);\n  }\n\n  /**\n   * For subclass to implement task logic\n   * @abstract\n   */\n  doTick() {}\n}\n\nvar FragmentState = {\n  NOT_LOADED: \"NOT_LOADED\",\n  APPENDING: \"APPENDING\",\n  PARTIAL: \"PARTIAL\",\n  OK: \"OK\"\n};\nclass FragmentTracker {\n  constructor(hls) {\n    this.activePartLists = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.fragments = Object.create(null);\n    this.timeRanges = Object.create(null);\n    this.bufferPadding = 0.2;\n    this.hls = void 0;\n    this.hasGaps = false;\n    this.hls = hls;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.BUFFER_APPENDED, this.onBufferAppended, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    // @ts-ignore\n    this.fragments =\n    // @ts-ignore\n    this.activePartLists =\n    // @ts-ignore\n    this.endListFragments = this.timeRanges = null;\n  }\n\n  /**\n   * Return a Fragment or Part with an appended range that matches the position and levelType\n   * Otherwise, return null\n   */\n  getAppendedFrag(position, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (activeParts) {\n      for (let i = activeParts.length; i--;) {\n        const activePart = activeParts[i];\n        if (!activePart) {\n          break;\n        }\n        const appendedPTS = activePart.end;\n        if (activePart.start <= position && appendedPTS !== null && position <= appendedPTS) {\n          return activePart;\n        }\n      }\n    }\n    return this.getBufferedFrag(position, levelType);\n  }\n\n  /**\n   * Return a buffered Fragment that matches the position and levelType.\n   * A buffered Fragment is one whose loading, parsing and appending is done (completed or \"partial\" meaning aborted).\n   * If not found any Fragment, return null\n   */\n  getBufferedFrag(position, levelType) {\n    const {\n      fragments\n    } = this;\n    const keys = Object.keys(fragments);\n    for (let i = keys.length; i--;) {\n      const fragmentEntity = fragments[keys[i]];\n      if ((fragmentEntity == null ? void 0 : fragmentEntity.body.type) === levelType && fragmentEntity.buffered) {\n        const frag = fragmentEntity.body;\n        if (frag.start <= position && position <= frag.end) {\n          return frag;\n        }\n      }\n    }\n    return null;\n  }\n\n  /**\n   * Partial fragments effected by coded frame eviction will be removed\n   * The browser will unload parts of the buffer to free up memory for new buffer data\n   * Fragments will need to be reloaded when the buffer is freed up, removing partial fragments will allow them to reload(since there might be parts that are still playable)\n   */\n  detectEvictedFragments(elementaryStream, timeRange, playlistType, appendedPart) {\n    if (this.timeRanges) {\n      this.timeRanges[elementaryStream] = timeRange;\n    }\n    // Check if any flagged fragments have been unloaded\n    // excluding anything newer than appendedPartSn\n    const appendedPartSn = (appendedPart == null ? void 0 : appendedPart.fragment.sn) || -1;\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (appendedPartSn >= fragmentEntity.body.sn) {\n        return;\n      }\n      if (!fragmentEntity.buffered && !fragmentEntity.loaded) {\n        if (fragmentEntity.body.type === playlistType) {\n          this.removeFragment(fragmentEntity.body);\n        }\n        return;\n      }\n      const esData = fragmentEntity.range[elementaryStream];\n      if (!esData) {\n        return;\n      }\n      esData.time.some(time => {\n        const isNotBuffered = !this.isTimeBuffered(time.startPTS, time.endPTS, timeRange);\n        if (isNotBuffered) {\n          // Unregister partial fragment as it needs to load again to be reused\n          this.removeFragment(fragmentEntity.body);\n        }\n        return isNotBuffered;\n      });\n    });\n  }\n\n  /**\n   * Checks if the fragment passed in is loaded in the buffer properly\n   * Partially loaded fragments will be registered as a partial fragment\n   */\n  detectPartialFragments(data) {\n    const timeRanges = this.timeRanges;\n    const {\n      frag,\n      part\n    } = data;\n    if (!timeRanges || frag.sn === 'initSegment') {\n      return;\n    }\n    const fragKey = getFragmentKey(frag);\n    const fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity || fragmentEntity.buffered && frag.gap) {\n      return;\n    }\n    const isFragHint = !frag.relurl;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const streamInfo = frag.elementaryStreams[elementaryStream];\n      if (!streamInfo) {\n        return;\n      }\n      const timeRange = timeRanges[elementaryStream];\n      const partial = isFragHint || streamInfo.partial === true;\n      fragmentEntity.range[elementaryStream] = this.getBufferedTimes(frag, part, partial, timeRange);\n    });\n    fragmentEntity.loaded = null;\n    if (Object.keys(fragmentEntity.range).length) {\n      fragmentEntity.buffered = true;\n      const endList = fragmentEntity.body.endList = frag.endList || fragmentEntity.body.endList;\n      if (endList) {\n        this.endListFragments[fragmentEntity.body.type] = fragmentEntity;\n      }\n      if (!isPartial(fragmentEntity)) {\n        // Remove older fragment parts from lookup after frag is tracked as buffered\n        this.removeParts(frag.sn - 1, frag.type);\n      }\n    } else {\n      // remove fragment if nothing was appended\n      this.removeFragment(fragmentEntity.body);\n    }\n  }\n  removeParts(snToKeep, levelType) {\n    const activeParts = this.activePartLists[levelType];\n    if (!activeParts) {\n      return;\n    }\n    this.activePartLists[levelType] = activeParts.filter(part => part.fragment.sn >= snToKeep);\n  }\n  fragBuffered(frag, force) {\n    const fragKey = getFragmentKey(frag);\n    let fragmentEntity = this.fragments[fragKey];\n    if (!fragmentEntity && force) {\n      fragmentEntity = this.fragments[fragKey] = {\n        body: frag,\n        appendedPTS: null,\n        loaded: null,\n        buffered: false,\n        range: Object.create(null)\n      };\n      if (frag.gap) {\n        this.hasGaps = true;\n      }\n    }\n    if (fragmentEntity) {\n      fragmentEntity.loaded = null;\n      fragmentEntity.buffered = true;\n    }\n  }\n  getBufferedTimes(fragment, part, partial, timeRange) {\n    const buffered = {\n      time: [],\n      partial\n    };\n    const startPTS = fragment.start;\n    const endPTS = fragment.end;\n    const minEndPTS = fragment.minEndPTS || endPTS;\n    const maxStartPTS = fragment.maxStartPTS || startPTS;\n    for (let i = 0; i < timeRange.length; i++) {\n      const startTime = timeRange.start(i) - this.bufferPadding;\n      const endTime = timeRange.end(i) + this.bufferPadding;\n      if (maxStartPTS >= startTime && minEndPTS <= endTime) {\n        // Fragment is entirely contained in buffer\n        // No need to check the other timeRange times since it's completely playable\n        buffered.time.push({\n          startPTS: Math.max(startPTS, timeRange.start(i)),\n          endPTS: Math.min(endPTS, timeRange.end(i))\n        });\n        break;\n      } else if (startPTS < endTime && endPTS > startTime) {\n        const start = Math.max(startPTS, timeRange.start(i));\n        const end = Math.min(endPTS, timeRange.end(i));\n        if (end > start) {\n          buffered.partial = true;\n          // Check for intersection with buffer\n          // Get playable sections of the fragment\n          buffered.time.push({\n            startPTS: start,\n            endPTS: end\n          });\n        }\n      } else if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        break;\n      }\n    }\n    return buffered;\n  }\n\n  /**\n   * Gets the partial fragment for a certain time\n   */\n  getPartialFragment(time) {\n    let bestFragment = null;\n    let timePadding;\n    let startTime;\n    let endTime;\n    let bestOverlap = 0;\n    const {\n      bufferPadding,\n      fragments\n    } = this;\n    Object.keys(fragments).forEach(key => {\n      const fragmentEntity = fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      if (isPartial(fragmentEntity)) {\n        startTime = fragmentEntity.body.start - bufferPadding;\n        endTime = fragmentEntity.body.end + bufferPadding;\n        if (time >= startTime && time <= endTime) {\n          // Use the fragment that has the most padding from start and end time\n          timePadding = Math.min(time - startTime, endTime - time);\n          if (bestOverlap <= timePadding) {\n            bestFragment = fragmentEntity.body;\n            bestOverlap = timePadding;\n          }\n        }\n      }\n    });\n    return bestFragment;\n  }\n  isEndListAppended(type) {\n    const lastFragmentEntity = this.endListFragments[type];\n    return lastFragmentEntity !== undefined && (lastFragmentEntity.buffered || isPartial(lastFragmentEntity));\n  }\n  getState(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    const fragmentEntity = this.fragments[fragKey];\n    if (fragmentEntity) {\n      if (!fragmentEntity.buffered) {\n        return FragmentState.APPENDING;\n      } else if (isPartial(fragmentEntity)) {\n        return FragmentState.PARTIAL;\n      } else {\n        return FragmentState.OK;\n      }\n    }\n    return FragmentState.NOT_LOADED;\n  }\n  isTimeBuffered(startPTS, endPTS, timeRange) {\n    let startTime;\n    let endTime;\n    for (let i = 0; i < timeRange.length; i++) {\n      startTime = timeRange.start(i) - this.bufferPadding;\n      endTime = timeRange.end(i) + this.bufferPadding;\n      if (startPTS >= startTime && endPTS <= endTime) {\n        return true;\n      }\n      if (endPTS <= startTime) {\n        // No need to check the rest of the timeRange as it is in order\n        return false;\n      }\n    }\n    return false;\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    // don't track initsegment (for which sn is not a number)\n    // don't track frags used for bitrateTest, they're irrelevant.\n    if (frag.sn === 'initSegment' || frag.bitrateTest) {\n      return;\n    }\n\n    // Fragment entity `loaded` FragLoadedData is null when loading parts\n    const loaded = part ? null : data;\n    const fragKey = getFragmentKey(frag);\n    this.fragments[fragKey] = {\n      body: frag,\n      appendedPTS: null,\n      loaded,\n      buffered: false,\n      range: Object.create(null)\n    };\n  }\n  onBufferAppended(event, data) {\n    const {\n      frag,\n      part,\n      timeRanges\n    } = data;\n    if (frag.sn === 'initSegment') {\n      return;\n    }\n    const playlistType = frag.type;\n    if (part) {\n      let activeParts = this.activePartLists[playlistType];\n      if (!activeParts) {\n        this.activePartLists[playlistType] = activeParts = [];\n      }\n      activeParts.push(part);\n    }\n    // Store the latest timeRanges loaded in the buffer\n    this.timeRanges = timeRanges;\n    Object.keys(timeRanges).forEach(elementaryStream => {\n      const timeRange = timeRanges[elementaryStream];\n      this.detectEvictedFragments(elementaryStream, timeRange, playlistType, part);\n    });\n  }\n  onFragBuffered(event, data) {\n    this.detectPartialFragments(data);\n  }\n  hasFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    return !!this.fragments[fragKey];\n  }\n  hasParts(type) {\n    var _this$activePartLists;\n    return !!((_this$activePartLists = this.activePartLists[type]) != null && _this$activePartLists.length);\n  }\n  removeFragmentsInRange(start, end, playlistType, withGapOnly, unbufferedOnly) {\n    if (withGapOnly && !this.hasGaps) {\n      return;\n    }\n    Object.keys(this.fragments).forEach(key => {\n      const fragmentEntity = this.fragments[key];\n      if (!fragmentEntity) {\n        return;\n      }\n      const frag = fragmentEntity.body;\n      if (frag.type !== playlistType || withGapOnly && !frag.gap) {\n        return;\n      }\n      if (frag.start < end && frag.end > start && (fragmentEntity.buffered || unbufferedOnly)) {\n        this.removeFragment(frag);\n      }\n    });\n  }\n  removeFragment(fragment) {\n    const fragKey = getFragmentKey(fragment);\n    fragment.stats.loaded = 0;\n    fragment.clearElementaryStreamInfo();\n    const activeParts = this.activePartLists[fragment.type];\n    if (activeParts) {\n      const snToRemove = fragment.sn;\n      this.activePartLists[fragment.type] = activeParts.filter(part => part.fragment.sn !== snToRemove);\n    }\n    delete this.fragments[fragKey];\n    if (fragment.endList) {\n      delete this.endListFragments[fragment.type];\n    }\n  }\n  removeAllFragments() {\n    this.fragments = Object.create(null);\n    this.endListFragments = Object.create(null);\n    this.activePartLists = Object.create(null);\n    this.hasGaps = false;\n  }\n}\nfunction isPartial(fragmentEntity) {\n  var _fragmentEntity$range, _fragmentEntity$range2, _fragmentEntity$range3;\n  return fragmentEntity.buffered && (fragmentEntity.body.gap || ((_fragmentEntity$range = fragmentEntity.range.video) == null ? void 0 : _fragmentEntity$range.partial) || ((_fragmentEntity$range2 = fragmentEntity.range.audio) == null ? void 0 : _fragmentEntity$range2.partial) || ((_fragmentEntity$range3 = fragmentEntity.range.audiovideo) == null ? void 0 : _fragmentEntity$range3.partial));\n}\nfunction getFragmentKey(fragment) {\n  return `${fragment.type}_${fragment.level}_${fragment.sn}`;\n}\n\n/**\n * Provides methods dealing with buffer length retrieval for example.\n *\n * In general, a helper around HTML5 MediaElement TimeRanges gathered from `buffered` property.\n *\n * Also @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/buffered\n */\n\nconst noopBuffered = {\n  length: 0,\n  start: () => 0,\n  end: () => 0\n};\nclass BufferHelper {\n  /**\n   * Return true if `media`'s buffered include `position`\n   */\n  static isBuffered(media, position) {\n    try {\n      if (media) {\n        const buffered = BufferHelper.getBuffered(media);\n        for (let i = 0; i < buffered.length; i++) {\n          if (position >= buffered.start(i) && position <= buffered.end(i)) {\n            return true;\n          }\n        }\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return false;\n  }\n  static bufferInfo(media, pos, maxHoleDuration) {\n    try {\n      if (media) {\n        const vbuffered = BufferHelper.getBuffered(media);\n        const buffered = [];\n        let i;\n        for (i = 0; i < vbuffered.length; i++) {\n          buffered.push({\n            start: vbuffered.start(i),\n            end: vbuffered.end(i)\n          });\n        }\n        return this.bufferedInfo(buffered, pos, maxHoleDuration);\n      }\n    } catch (error) {\n      // this is to catch\n      // InvalidStateError: Failed to read the 'buffered' property from 'SourceBuffer':\n      // This SourceBuffer has been removed from the parent media source\n    }\n    return {\n      len: 0,\n      start: pos,\n      end: pos,\n      nextStart: undefined\n    };\n  }\n  static bufferedInfo(buffered, pos, maxHoleDuration) {\n    pos = Math.max(0, pos);\n    // sort on buffer.start/smaller end (IE does not always return sorted buffered range)\n    buffered.sort(function (a, b) {\n      const diff = a.start - b.start;\n      if (diff) {\n        return diff;\n      } else {\n        return b.end - a.end;\n      }\n    });\n    let buffered2 = [];\n    if (maxHoleDuration) {\n      // there might be some small holes between buffer time range\n      // consider that holes smaller than maxHoleDuration are irrelevant and build another\n      // buffer time range representations that discards those holes\n      for (let i = 0; i < buffered.length; i++) {\n        const buf2len = buffered2.length;\n        if (buf2len) {\n          const buf2end = buffered2[buf2len - 1].end;\n          // if small hole (value between 0 or maxHoleDuration ) or overlapping (negative)\n          if (buffered[i].start - buf2end < maxHoleDuration) {\n            // merge overlapping time ranges\n            // update lastRange.end only if smaller than item.end\n            // e.g.  [ 1, 15] with  [ 2,8] => [ 1,15] (no need to modify lastRange.end)\n            // whereas [ 1, 8] with  [ 2,15] => [ 1,15] ( lastRange should switch from [1,8] to [1,15])\n            if (buffered[i].end > buf2end) {\n              buffered2[buf2len - 1].end = buffered[i].end;\n            }\n          } else {\n            // big hole\n            buffered2.push(buffered[i]);\n          }\n        } else {\n          // first value\n          buffered2.push(buffered[i]);\n        }\n      }\n    } else {\n      buffered2 = buffered;\n    }\n    let bufferLen = 0;\n\n    // bufferStartNext can possibly be undefined based on the conditional logic below\n    let bufferStartNext;\n\n    // bufferStart and bufferEnd are buffer boundaries around current video position\n    let bufferStart = pos;\n    let bufferEnd = pos;\n    for (let i = 0; i < buffered2.length; i++) {\n      const start = buffered2[i].start;\n      const end = buffered2[i].end;\n      // logger.log('buf start/end:' + buffered.start(i) + '/' + buffered.end(i));\n      if (pos + maxHoleDuration >= start && pos < end) {\n        // play position is inside this buffer TimeRange, retrieve end of buffer position and buffer length\n        bufferStart = start;\n        bufferEnd = end;\n        bufferLen = bufferEnd - pos;\n      } else if (pos + maxHoleDuration < start) {\n        bufferStartNext = start;\n        break;\n      }\n    }\n    return {\n      len: bufferLen,\n      start: bufferStart || 0,\n      end: bufferEnd || 0,\n      nextStart: bufferStartNext\n    };\n  }\n\n  /**\n   * Safe method to get buffered property.\n   * SourceBuffer.buffered may throw if SourceBuffer is removed from it's MediaSource\n   */\n  static getBuffered(media) {\n    try {\n      return media.buffered;\n    } catch (e) {\n      logger.log('failed to get media.buffered', e);\n      return noopBuffered;\n    }\n  }\n}\n\nclass ChunkMetadata {\n  constructor(level, sn, id, size = 0, part = -1, partial = false) {\n    this.level = void 0;\n    this.sn = void 0;\n    this.part = void 0;\n    this.id = void 0;\n    this.size = void 0;\n    this.partial = void 0;\n    this.transmuxing = getNewPerformanceTiming();\n    this.buffering = {\n      audio: getNewPerformanceTiming(),\n      video: getNewPerformanceTiming(),\n      audiovideo: getNewPerformanceTiming()\n    };\n    this.level = level;\n    this.sn = sn;\n    this.id = id;\n    this.size = size;\n    this.part = part;\n    this.partial = partial;\n  }\n}\nfunction getNewPerformanceTiming() {\n  return {\n    start: 0,\n    executeStart: 0,\n    executeEnd: 0,\n    end: 0\n  };\n}\n\nfunction findFirstFragWithCC(fragments, cc) {\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    var _fragments$i;\n    if (((_fragments$i = fragments[i]) == null ? void 0 : _fragments$i.cc) === cc) {\n      return fragments[i];\n    }\n  }\n  return null;\n}\nfunction shouldAlignOnDiscontinuities(lastFrag, switchDetails, details) {\n  if (switchDetails) {\n    if (details.endCC > details.startCC || lastFrag && lastFrag.cc < details.startCC) {\n      return true;\n    }\n  }\n  return false;\n}\n\n// Find the first frag in the previous level which matches the CC of the first frag of the new level\nfunction findDiscontinuousReferenceFrag(prevDetails, curDetails) {\n  const prevFrags = prevDetails.fragments;\n  const curFrags = curDetails.fragments;\n  if (!curFrags.length || !prevFrags.length) {\n    logger.log('No fragments to align');\n    return;\n  }\n  const prevStartFrag = findFirstFragWithCC(prevFrags, curFrags[0].cc);\n  if (!prevStartFrag || prevStartFrag && !prevStartFrag.startPTS) {\n    logger.log('No frag in previous level to align on');\n    return;\n  }\n  return prevStartFrag;\n}\nfunction adjustFragmentStart(frag, sliding) {\n  if (frag) {\n    const start = frag.start + sliding;\n    frag.start = frag.startPTS = start;\n    frag.endPTS = start + frag.duration;\n  }\n}\nfunction adjustSlidingStart(sliding, details) {\n  // Update segments\n  const fragments = details.fragments;\n  for (let i = 0, len = fragments.length; i < len; i++) {\n    adjustFragmentStart(fragments[i], sliding);\n  }\n  // Update LL-HLS parts at the end of the playlist\n  if (details.fragmentHint) {\n    adjustFragmentStart(details.fragmentHint, sliding);\n  }\n  details.alignedSliding = true;\n}\n\n/**\n * Using the parameters of the last level, this function computes PTS' of the new fragments so that they form a\n * contiguous stream with the last fragments.\n * The PTS of a fragment lets Hls.js know where it fits into a stream - by knowing every PTS, we know which fragment to\n * download at any given time. PTS is normally computed when the fragment is demuxed, so taking this step saves us time\n * and an extra download.\n * @param lastFrag\n * @param lastLevel\n * @param details\n */\nfunction alignStream(lastFrag, switchDetails, details) {\n  if (!switchDetails) {\n    return;\n  }\n  alignDiscontinuities(lastFrag, details, switchDetails);\n  if (!details.alignedSliding && switchDetails) {\n    // If the PTS wasn't figured out via discontinuity sequence that means there was no CC increase within the level.\n    // Aligning via Program Date Time should therefore be reliable, since PDT should be the same within the same\n    // discontinuity sequence.\n    alignMediaPlaylistByPDT(details, switchDetails);\n  }\n  if (!details.alignedSliding && switchDetails && !details.skippedSegments) {\n    // Try to align on sn so that we pick a better start fragment.\n    // Do not perform this on playlists with delta updates as this is only to align levels on switch\n    // and adjustSliding only adjusts fragments after skippedSegments.\n    adjustSliding(switchDetails, details);\n  }\n}\n\n/**\n * Computes the PTS if a new level's fragments using the PTS of a fragment in the last level which shares the same\n * discontinuity sequence.\n * @param lastFrag - The last Fragment which shares the same discontinuity sequence\n * @param lastLevel - The details of the last loaded level\n * @param details - The details of the new level\n */\nfunction alignDiscontinuities(lastFrag, details, switchDetails) {\n  if (shouldAlignOnDiscontinuities(lastFrag, switchDetails, details)) {\n    const referenceFrag = findDiscontinuousReferenceFrag(switchDetails, details);\n    if (referenceFrag && isFiniteNumber(referenceFrag.start)) {\n      logger.log(`Adjusting PTS using last level due to CC increase within current level ${details.url}`);\n      adjustSlidingStart(referenceFrag.start, details);\n    }\n  }\n}\n\n/**\n * Ensures appropriate time-alignment between renditions based on PDT.\n * This function assumes the timelines represented in `refDetails` are accurate, including the PDTs\n * for the last discontinuity sequence number shared by both playlists when present,\n * and uses the \"wallclock\"/PDT timeline as a cross-reference to `details`, adjusting the presentation\n * times/timelines of `details` accordingly.\n * Given the asynchronous nature of fetches and initial loads of live `main` and audio/subtitle tracks,\n * the primary purpose of this function is to ensure the \"local timelines\" of audio/subtitle tracks\n * are aligned to the main/video timeline, using PDT as the cross-reference/\"anchor\" that should\n * be consistent across playlists, per the HLS spec.\n * @param details - The details of the rendition you'd like to time-align (e.g. an audio rendition).\n * @param refDetails - The details of the reference rendition with start and PDT times for alignment.\n */\nfunction alignMediaPlaylistByPDT(details, refDetails) {\n  if (!details.hasProgramDateTime || !refDetails.hasProgramDateTime) {\n    return;\n  }\n  const fragments = details.fragments;\n  const refFragments = refDetails.fragments;\n  if (!fragments.length || !refFragments.length) {\n    return;\n  }\n\n  // Calculate a delta to apply to all fragments according to the delta in PDT times and start times\n  // of a fragment in the reference details, and a fragment in the target details of the same discontinuity.\n  // If a fragment of the same discontinuity was not found use the middle fragment of both.\n  let refFrag;\n  let frag;\n  const targetCC = Math.min(refDetails.endCC, details.endCC);\n  if (refDetails.startCC < targetCC && details.startCC < targetCC) {\n    refFrag = findFirstFragWithCC(refFragments, targetCC);\n    frag = findFirstFragWithCC(fragments, targetCC);\n  }\n  if (!refFrag || !frag) {\n    refFrag = refFragments[Math.floor(refFragments.length / 2)];\n    frag = findFirstFragWithCC(fragments, refFrag.cc) || fragments[Math.floor(fragments.length / 2)];\n  }\n  const refPDT = refFrag.programDateTime;\n  const targetPDT = frag.programDateTime;\n  if (!refPDT || !targetPDT) {\n    return;\n  }\n  const delta = (targetPDT - refPDT) / 1000 - (frag.start - refFrag.start);\n  adjustSlidingStart(delta, details);\n}\n\nconst MIN_CHUNK_SIZE = Math.pow(2, 17); // 128kb\n\nclass FragmentLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.loader = null;\n    this.partLoadTimeout = -1;\n    this.config = config;\n  }\n  destroy() {\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n  }\n  abort() {\n    if (this.loader) {\n      // Abort the loader for current fragment. Only one may load at any given time\n      this.loader.abort();\n    }\n  }\n  load(frag, onProgress) {\n    const url = frag.url;\n    if (!url) {\n      return Promise.reject(new LoadError({\n        type: ErrorTypes.NETWORK_ERROR,\n        details: ErrorDetails.FRAG_LOAD_ERROR,\n        fatal: false,\n        frag,\n        error: new Error(`Fragment does not have a ${url ? 'part list' : 'url'}`),\n        networkDetails: null\n      }));\n    }\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap) {\n        if (frag.tagList.some(tags => tags[0] === 'GAP')) {\n          reject(createGapLoadError(frag));\n          return;\n        } else {\n          // Reset temporary treatment as GAP tag\n          frag.gap = false;\n        }\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag);\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: frag.sn === 'initSegment' ? Infinity : MIN_CHUNK_SIZE\n      };\n      // Assign frag stats to the loader's stats reference\n      frag.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          let payload = response.data;\n          if (context.resetIV && frag.decryptdata) {\n            frag.decryptdata.iv = new Uint8Array(payload.slice(0, 16));\n            payload = payload.slice(16);\n          }\n          resolve({\n            frag,\n            part: null,\n            payload,\n            networkDetails\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            response: _objectSpread2({\n              url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        },\n        onProgress: (stats, context, data, networkDetails) => {\n          if (onProgress) {\n            onProgress({\n              frag,\n              part: null,\n              payload: data,\n              networkDetails\n            });\n          }\n        }\n      });\n    });\n  }\n  loadPart(frag, part, onProgress) {\n    this.abort();\n    const config = this.config;\n    const FragmentILoader = config.fLoader;\n    const DefaultILoader = config.loader;\n    return new Promise((resolve, reject) => {\n      if (this.loader) {\n        this.loader.destroy();\n      }\n      if (frag.gap || part.gap) {\n        reject(createGapLoadError(frag, part));\n        return;\n      }\n      const loader = this.loader = frag.loader = FragmentILoader ? new FragmentILoader(config) : new DefaultILoader(config);\n      const loaderContext = createLoaderContext(frag, part);\n      // Should we define another load policy for parts?\n      const loadPolicy = getLoaderConfigWithoutReties(config.fragLoadPolicy.default);\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0,\n        highWaterMark: MIN_CHUNK_SIZE\n      };\n      // Assign part stats to the loader's stats reference\n      part.stats = loader.stats;\n      loader.load(loaderContext, loaderConfig, {\n        onSuccess: (response, stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          this.updateStatsFromPart(frag, part);\n          const partLoadedData = {\n            frag,\n            part,\n            payload: response.data,\n            networkDetails\n          };\n          onProgress(partLoadedData);\n          resolve(partLoadedData);\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_ERROR,\n            fatal: false,\n            frag,\n            part,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response),\n            error: new Error(`HTTP Error ${response.code} ${response.text}`),\n            networkDetails,\n            stats\n          }));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          frag.stats.aborted = part.stats.aborted;\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.INTERNAL_ABORTED,\n            fatal: false,\n            frag,\n            part,\n            error: new Error('Aborted'),\n            networkDetails,\n            stats\n          }));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(frag, loader);\n          reject(new LoadError({\n            type: ErrorTypes.NETWORK_ERROR,\n            details: ErrorDetails.FRAG_LOAD_TIMEOUT,\n            fatal: false,\n            frag,\n            part,\n            error: new Error(`Timeout after ${loaderConfig.timeout}ms`),\n            networkDetails,\n            stats\n          }));\n        }\n      });\n    });\n  }\n  updateStatsFromPart(frag, part) {\n    const fragStats = frag.stats;\n    const partStats = part.stats;\n    const partTotal = partStats.total;\n    fragStats.loaded += partStats.loaded;\n    if (partTotal) {\n      const estTotalParts = Math.round(frag.duration / part.duration);\n      const estLoadedParts = Math.min(Math.round(fragStats.loaded / partTotal), estTotalParts);\n      const estRemainingParts = estTotalParts - estLoadedParts;\n      const estRemainingBytes = estRemainingParts * Math.round(fragStats.loaded / estLoadedParts);\n      fragStats.total = fragStats.loaded + estRemainingBytes;\n    } else {\n      fragStats.total = Math.max(fragStats.loaded, fragStats.total);\n    }\n    const fragLoading = fragStats.loading;\n    const partLoading = partStats.loading;\n    if (fragLoading.start) {\n      // add to fragment loader latency\n      fragLoading.first += partLoading.first - partLoading.start;\n    } else {\n      fragLoading.start = partLoading.start;\n      fragLoading.first = partLoading.first;\n    }\n    fragLoading.end = partLoading.end;\n  }\n  resetLoader(frag, loader) {\n    frag.loader = null;\n    if (this.loader === loader) {\n      self.clearTimeout(this.partLoadTimeout);\n      this.loader = null;\n    }\n    loader.destroy();\n  }\n}\nfunction createLoaderContext(frag, part = null) {\n  const segment = part || frag;\n  const loaderContext = {\n    frag,\n    part,\n    responseType: 'arraybuffer',\n    url: segment.url,\n    headers: {},\n    rangeStart: 0,\n    rangeEnd: 0\n  };\n  const start = segment.byteRangeStartOffset;\n  const end = segment.byteRangeEndOffset;\n  if (isFiniteNumber(start) && isFiniteNumber(end)) {\n    var _frag$decryptdata;\n    let byteRangeStart = start;\n    let byteRangeEnd = end;\n    if (frag.sn === 'initSegment' && ((_frag$decryptdata = frag.decryptdata) == null ? void 0 : _frag$decryptdata.method) === 'AES-128') {\n      // MAP segment encrypted with method 'AES-128', when served with HTTP Range,\n      // has the unencrypted size specified in the range.\n      // Ref: https://tools.ietf.org/html/draft-pantos-hls-rfc8216bis-08#section-6.3.6\n      const fragmentLen = end - start;\n      if (fragmentLen % 16) {\n        byteRangeEnd = end + (16 - fragmentLen % 16);\n      }\n      if (start !== 0) {\n        loaderContext.resetIV = true;\n        byteRangeStart = start - 16;\n      }\n    }\n    loaderContext.rangeStart = byteRangeStart;\n    loaderContext.rangeEnd = byteRangeEnd;\n  }\n  return loaderContext;\n}\nfunction createGapLoadError(frag, part) {\n  const error = new Error(`GAP ${frag.gap ? 'tag' : 'attribute'} found`);\n  const errorData = {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_GAP,\n    fatal: false,\n    frag,\n    error,\n    networkDetails: null\n  };\n  if (part) {\n    errorData.part = part;\n  }\n  (part ? part : frag).stats.aborted = true;\n  return new LoadError(errorData);\n}\nclass LoadError extends Error {\n  constructor(data) {\n    super(data.error.message);\n    this.data = void 0;\n    this.data = data;\n  }\n}\n\nclass AESCrypto {\n  constructor(subtle, iv) {\n    this.subtle = void 0;\n    this.aesIV = void 0;\n    this.subtle = subtle;\n    this.aesIV = iv;\n  }\n  decrypt(data, key) {\n    return this.subtle.decrypt({\n      name: 'AES-CBC',\n      iv: this.aesIV\n    }, key, data);\n  }\n}\n\nclass FastAESKey {\n  constructor(subtle, key) {\n    this.subtle = void 0;\n    this.key = void 0;\n    this.subtle = subtle;\n    this.key = key;\n  }\n  expandKey() {\n    return this.subtle.importKey('raw', this.key, {\n      name: 'AES-CBC'\n    }, false, ['encrypt', 'decrypt']);\n  }\n}\n\n// PKCS7\nfunction removePadding(array) {\n  const outputBytes = array.byteLength;\n  const paddingBytes = outputBytes && new DataView(array.buffer).getUint8(outputBytes - 1);\n  if (paddingBytes) {\n    return sliceUint8(array, 0, outputBytes - paddingBytes);\n  }\n  return array;\n}\nclass AESDecryptor {\n  constructor() {\n    this.rcon = [0x0, 0x1, 0x2, 0x4, 0x8, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n    this.subMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.invSubMix = [new Uint32Array(256), new Uint32Array(256), new Uint32Array(256), new Uint32Array(256)];\n    this.sBox = new Uint32Array(256);\n    this.invSBox = new Uint32Array(256);\n    this.key = new Uint32Array(0);\n    this.ksRows = 0;\n    this.keySize = 0;\n    this.keySchedule = void 0;\n    this.invKeySchedule = void 0;\n    this.initTable();\n  }\n\n  // Using view.getUint32() also swaps the byte order.\n  uint8ArrayToUint32Array_(arrayBuffer) {\n    const view = new DataView(arrayBuffer);\n    const newArray = new Uint32Array(4);\n    for (let i = 0; i < 4; i++) {\n      newArray[i] = view.getUint32(i * 4);\n    }\n    return newArray;\n  }\n  initTable() {\n    const sBox = this.sBox;\n    const invSBox = this.invSBox;\n    const subMix = this.subMix;\n    const subMix0 = subMix[0];\n    const subMix1 = subMix[1];\n    const subMix2 = subMix[2];\n    const subMix3 = subMix[3];\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const d = new Uint32Array(256);\n    let x = 0;\n    let xi = 0;\n    let i = 0;\n    for (i = 0; i < 256; i++) {\n      if (i < 128) {\n        d[i] = i << 1;\n      } else {\n        d[i] = i << 1 ^ 0x11b;\n      }\n    }\n    for (i = 0; i < 256; i++) {\n      let sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;\n      sx = sx >>> 8 ^ sx & 0xff ^ 0x63;\n      sBox[x] = sx;\n      invSBox[sx] = x;\n\n      // Compute multiplication\n      const x2 = d[x];\n      const x4 = d[x2];\n      const x8 = d[x4];\n\n      // Compute sub/invSub bytes, mix columns tables\n      let t = d[sx] * 0x101 ^ sx * 0x1010100;\n      subMix0[x] = t << 24 | t >>> 8;\n      subMix1[x] = t << 16 | t >>> 16;\n      subMix2[x] = t << 8 | t >>> 24;\n      subMix3[x] = t;\n\n      // Compute inv sub bytes, inv mix columns tables\n      t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;\n      invSubMix0[sx] = t << 24 | t >>> 8;\n      invSubMix1[sx] = t << 16 | t >>> 16;\n      invSubMix2[sx] = t << 8 | t >>> 24;\n      invSubMix3[sx] = t;\n\n      // Compute next counter\n      if (!x) {\n        x = xi = 1;\n      } else {\n        x = x2 ^ d[d[d[x8 ^ x2]]];\n        xi ^= d[d[xi]];\n      }\n    }\n  }\n  expandKey(keyBuffer) {\n    // convert keyBuffer to Uint32Array\n    const key = this.uint8ArrayToUint32Array_(keyBuffer);\n    let sameKey = true;\n    let offset = 0;\n    while (offset < key.length && sameKey) {\n      sameKey = key[offset] === this.key[offset];\n      offset++;\n    }\n    if (sameKey) {\n      return;\n    }\n    this.key = key;\n    const keySize = this.keySize = key.length;\n    if (keySize !== 4 && keySize !== 6 && keySize !== 8) {\n      throw new Error('Invalid aes key size=' + keySize);\n    }\n    const ksRows = this.ksRows = (keySize + 6 + 1) * 4;\n    let ksRow;\n    let invKsRow;\n    const keySchedule = this.keySchedule = new Uint32Array(ksRows);\n    const invKeySchedule = this.invKeySchedule = new Uint32Array(ksRows);\n    const sbox = this.sBox;\n    const rcon = this.rcon;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    let prev;\n    let t;\n    for (ksRow = 0; ksRow < ksRows; ksRow++) {\n      if (ksRow < keySize) {\n        prev = keySchedule[ksRow] = key[ksRow];\n        continue;\n      }\n      t = prev;\n      if (ksRow % keySize === 0) {\n        // Rot word\n        t = t << 8 | t >>> 24;\n\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n\n        // Mix Rcon\n        t ^= rcon[ksRow / keySize | 0] << 24;\n      } else if (keySize > 6 && ksRow % keySize === 4) {\n        // Sub word\n        t = sbox[t >>> 24] << 24 | sbox[t >>> 16 & 0xff] << 16 | sbox[t >>> 8 & 0xff] << 8 | sbox[t & 0xff];\n      }\n      keySchedule[ksRow] = prev = (keySchedule[ksRow - keySize] ^ t) >>> 0;\n    }\n    for (invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n      ksRow = ksRows - invKsRow;\n      if (invKsRow & 3) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = invSubMix0[sbox[t >>> 24]] ^ invSubMix1[sbox[t >>> 16 & 0xff]] ^ invSubMix2[sbox[t >>> 8 & 0xff]] ^ invSubMix3[sbox[t & 0xff]];\n      }\n      invKeySchedule[invKsRow] = invKeySchedule[invKsRow] >>> 0;\n    }\n  }\n\n  // Adding this as a method greatly improves performance.\n  networkToHostOrderSwap(word) {\n    return word << 24 | (word & 0xff00) << 8 | (word & 0xff0000) >> 8 | word >>> 24;\n  }\n  decrypt(inputArrayBuffer, offset, aesIV) {\n    const nRounds = this.keySize + 6;\n    const invKeySchedule = this.invKeySchedule;\n    const invSBOX = this.invSBox;\n    const invSubMix = this.invSubMix;\n    const invSubMix0 = invSubMix[0];\n    const invSubMix1 = invSubMix[1];\n    const invSubMix2 = invSubMix[2];\n    const invSubMix3 = invSubMix[3];\n    const initVector = this.uint8ArrayToUint32Array_(aesIV);\n    let initVector0 = initVector[0];\n    let initVector1 = initVector[1];\n    let initVector2 = initVector[2];\n    let initVector3 = initVector[3];\n    const inputInt32 = new Int32Array(inputArrayBuffer);\n    const outputInt32 = new Int32Array(inputInt32.length);\n    let t0, t1, t2, t3;\n    let s0, s1, s2, s3;\n    let inputWords0, inputWords1, inputWords2, inputWords3;\n    let ksRow, i;\n    const swapWord = this.networkToHostOrderSwap;\n    while (offset < inputInt32.length) {\n      inputWords0 = swapWord(inputInt32[offset]);\n      inputWords1 = swapWord(inputInt32[offset + 1]);\n      inputWords2 = swapWord(inputInt32[offset + 2]);\n      inputWords3 = swapWord(inputInt32[offset + 3]);\n      s0 = inputWords0 ^ invKeySchedule[0];\n      s1 = inputWords3 ^ invKeySchedule[1];\n      s2 = inputWords2 ^ invKeySchedule[2];\n      s3 = inputWords1 ^ invKeySchedule[3];\n      ksRow = 4;\n\n      // Iterate through the rounds of decryption\n      for (i = 1; i < nRounds; i++) {\n        t0 = invSubMix0[s0 >>> 24] ^ invSubMix1[s1 >> 16 & 0xff] ^ invSubMix2[s2 >> 8 & 0xff] ^ invSubMix3[s3 & 0xff] ^ invKeySchedule[ksRow];\n        t1 = invSubMix0[s1 >>> 24] ^ invSubMix1[s2 >> 16 & 0xff] ^ invSubMix2[s3 >> 8 & 0xff] ^ invSubMix3[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n        t2 = invSubMix0[s2 >>> 24] ^ invSubMix1[s3 >> 16 & 0xff] ^ invSubMix2[s0 >> 8 & 0xff] ^ invSubMix3[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n        t3 = invSubMix0[s3 >>> 24] ^ invSubMix1[s0 >> 16 & 0xff] ^ invSubMix2[s1 >> 8 & 0xff] ^ invSubMix3[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n        // Update state\n        s0 = t0;\n        s1 = t1;\n        s2 = t2;\n        s3 = t3;\n        ksRow = ksRow + 4;\n      }\n\n      // Shift rows, sub bytes, add round key\n      t0 = invSBOX[s0 >>> 24] << 24 ^ invSBOX[s1 >> 16 & 0xff] << 16 ^ invSBOX[s2 >> 8 & 0xff] << 8 ^ invSBOX[s3 & 0xff] ^ invKeySchedule[ksRow];\n      t1 = invSBOX[s1 >>> 24] << 24 ^ invSBOX[s2 >> 16 & 0xff] << 16 ^ invSBOX[s3 >> 8 & 0xff] << 8 ^ invSBOX[s0 & 0xff] ^ invKeySchedule[ksRow + 1];\n      t2 = invSBOX[s2 >>> 24] << 24 ^ invSBOX[s3 >> 16 & 0xff] << 16 ^ invSBOX[s0 >> 8 & 0xff] << 8 ^ invSBOX[s1 & 0xff] ^ invKeySchedule[ksRow + 2];\n      t3 = invSBOX[s3 >>> 24] << 24 ^ invSBOX[s0 >> 16 & 0xff] << 16 ^ invSBOX[s1 >> 8 & 0xff] << 8 ^ invSBOX[s2 & 0xff] ^ invKeySchedule[ksRow + 3];\n\n      // Write\n      outputInt32[offset] = swapWord(t0 ^ initVector0);\n      outputInt32[offset + 1] = swapWord(t3 ^ initVector1);\n      outputInt32[offset + 2] = swapWord(t2 ^ initVector2);\n      outputInt32[offset + 3] = swapWord(t1 ^ initVector3);\n\n      // reset initVector to last 4 unsigned int\n      initVector0 = inputWords0;\n      initVector1 = inputWords1;\n      initVector2 = inputWords2;\n      initVector3 = inputWords3;\n      offset = offset + 4;\n    }\n    return outputInt32.buffer;\n  }\n}\n\nconst CHUNK_SIZE = 16; // 16 bytes, 128 bits\n\nclass Decrypter {\n  constructor(config, {\n    removePKCS7Padding = true\n  } = {}) {\n    this.logEnabled = true;\n    this.removePKCS7Padding = void 0;\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n    this.useSoftware = void 0;\n    this.useSoftware = config.enableSoftwareAES;\n    this.removePKCS7Padding = removePKCS7Padding;\n    // built in decryptor expects PKCS7 padding\n    if (removePKCS7Padding) {\n      try {\n        const browserCrypto = self.crypto;\n        if (browserCrypto) {\n          this.subtle = browserCrypto.subtle || browserCrypto.webkitSubtle;\n        }\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    this.useSoftware = !this.subtle;\n  }\n  destroy() {\n    this.subtle = null;\n    this.softwareDecrypter = null;\n    this.key = null;\n    this.fastAesKey = null;\n    this.remainderData = null;\n    this.currentIV = null;\n    this.currentResult = null;\n  }\n  isSync() {\n    return this.useSoftware;\n  }\n  flush() {\n    const {\n      currentResult,\n      remainderData\n    } = this;\n    if (!currentResult || remainderData) {\n      this.reset();\n      return null;\n    }\n    const data = new Uint8Array(currentResult);\n    this.reset();\n    if (this.removePKCS7Padding) {\n      return removePadding(data);\n    }\n    return data;\n  }\n  reset() {\n    this.currentResult = null;\n    this.currentIV = null;\n    this.remainderData = null;\n    if (this.softwareDecrypter) {\n      this.softwareDecrypter = null;\n    }\n  }\n  decrypt(data, key, iv) {\n    if (this.useSoftware) {\n      return new Promise((resolve, reject) => {\n        this.softwareDecrypt(new Uint8Array(data), key, iv);\n        const decryptResult = this.flush();\n        if (decryptResult) {\n          resolve(decryptResult.buffer);\n        } else {\n          reject(new Error('[softwareDecrypt] Failed to decrypt data'));\n        }\n      });\n    }\n    return this.webCryptoDecrypt(new Uint8Array(data), key, iv);\n  }\n\n  // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n  // data is handled in the flush() call\n  softwareDecrypt(data, key, iv) {\n    const {\n      currentIV,\n      currentResult,\n      remainderData\n    } = this;\n    this.logOnce('JS AES decrypt');\n    // The output is staggered during progressive parsing - the current result is cached, and emitted on the next call\n    // This is done in order to strip PKCS7 padding, which is found at the end of each segment. We only know we've reached\n    // the end on flush(), but by that time we have already received all bytes for the segment.\n    // Progressive decryption does not work with WebCrypto\n\n    if (remainderData) {\n      data = appendUint8Array(remainderData, data);\n      this.remainderData = null;\n    }\n\n    // Byte length must be a multiple of 16 (AES-128 = 128 bit blocks = 16 bytes)\n    const currentChunk = this.getValidChunk(data);\n    if (!currentChunk.length) {\n      return null;\n    }\n    if (currentIV) {\n      iv = currentIV;\n    }\n    let softwareDecrypter = this.softwareDecrypter;\n    if (!softwareDecrypter) {\n      softwareDecrypter = this.softwareDecrypter = new AESDecryptor();\n    }\n    softwareDecrypter.expandKey(key);\n    const result = currentResult;\n    this.currentResult = softwareDecrypter.decrypt(currentChunk.buffer, 0, iv);\n    this.currentIV = sliceUint8(currentChunk, -16).buffer;\n    if (!result) {\n      return null;\n    }\n    return result;\n  }\n  webCryptoDecrypt(data, key, iv) {\n    if (this.key !== key || !this.fastAesKey) {\n      if (!this.subtle) {\n        return Promise.resolve(this.onWebCryptoError(data, key, iv));\n      }\n      this.key = key;\n      this.fastAesKey = new FastAESKey(this.subtle, key);\n    }\n    return this.fastAesKey.expandKey().then(aesKey => {\n      // decrypt using web crypto\n      if (!this.subtle) {\n        return Promise.reject(new Error('web crypto not initialized'));\n      }\n      this.logOnce('WebCrypto AES decrypt');\n      const crypto = new AESCrypto(this.subtle, new Uint8Array(iv));\n      return crypto.decrypt(data.buffer, aesKey);\n    }).catch(err => {\n      logger.warn(`[decrypter]: WebCrypto Error, disable WebCrypto API, ${err.name}: ${err.message}`);\n      return this.onWebCryptoError(data, key, iv);\n    });\n  }\n  onWebCryptoError(data, key, iv) {\n    this.useSoftware = true;\n    this.logEnabled = true;\n    this.softwareDecrypt(data, key, iv);\n    const decryptResult = this.flush();\n    if (decryptResult) {\n      return decryptResult.buffer;\n    }\n    throw new Error('WebCrypto and softwareDecrypt: failed to decrypt data');\n  }\n  getValidChunk(data) {\n    let currentChunk = data;\n    const splitPoint = data.length - data.length % CHUNK_SIZE;\n    if (splitPoint !== data.length) {\n      currentChunk = sliceUint8(data, 0, splitPoint);\n      this.remainderData = sliceUint8(data, splitPoint);\n    }\n    return currentChunk;\n  }\n  logOnce(msg) {\n    if (!this.logEnabled) {\n      return;\n    }\n    logger.log(`[decrypter]: ${msg}`);\n    this.logEnabled = false;\n  }\n}\n\n/**\n *  TimeRanges to string helper\n */\n\nconst TimeRanges = {\n  toString: function (r) {\n    let log = '';\n    const len = r.length;\n    for (let i = 0; i < len; i++) {\n      log += `[${r.start(i).toFixed(3)}-${r.end(i).toFixed(3)}]`;\n    }\n    return log;\n  }\n};\n\nconst State = {\n  STOPPED: 'STOPPED',\n  IDLE: 'IDLE',\n  KEY_LOADING: 'KEY_LOADING',\n  FRAG_LOADING: 'FRAG_LOADING',\n  FRAG_LOADING_WAITING_RETRY: 'FRAG_LOADING_WAITING_RETRY',\n  WAITING_TRACK: 'WAITING_TRACK',\n  PARSING: 'PARSING',\n  PARSED: 'PARSED',\n  ENDED: 'ENDED',\n  ERROR: 'ERROR',\n  WAITING_INIT_PTS: 'WAITING_INIT_PTS',\n  WAITING_LEVEL: 'WAITING_LEVEL'\n};\nclass BaseStreamController extends TaskLoop {\n  constructor(hls, fragmentTracker, keyLoader, logPrefix, playlistType) {\n    super();\n    this.hls = void 0;\n    this.fragPrevious = null;\n    this.fragCurrent = null;\n    this.fragmentTracker = void 0;\n    this.transmuxer = null;\n    this._state = State.STOPPED;\n    this.playlistType = void 0;\n    this.media = null;\n    this.mediaBuffer = null;\n    this.config = void 0;\n    this.bitrateTest = false;\n    this.lastCurrentTime = 0;\n    this.nextLoadPosition = 0;\n    this.startPosition = 0;\n    this.startTimeOffset = null;\n    this.loadedmetadata = false;\n    this.retryDate = 0;\n    this.levels = null;\n    this.fragmentLoader = void 0;\n    this.keyLoader = void 0;\n    this.levelLastLoaded = null;\n    this.startFragRequested = false;\n    this.decrypter = void 0;\n    this.initPTS = [];\n    this.onvseeking = null;\n    this.onvended = null;\n    this.logPrefix = '';\n    this.log = void 0;\n    this.warn = void 0;\n    this.playlistType = playlistType;\n    this.logPrefix = logPrefix;\n    this.log = logger.log.bind(logger, `${logPrefix}:`);\n    this.warn = logger.warn.bind(logger, `${logPrefix}:`);\n    this.hls = hls;\n    this.fragmentLoader = new FragmentLoader(hls.config);\n    this.keyLoader = keyLoader;\n    this.fragmentTracker = fragmentTracker;\n    this.config = hls.config;\n    this.decrypter = new Decrypter(hls.config);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  doTick() {\n    this.onTickEnd();\n  }\n  onTickEnd() {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  startLoad(startPosition) {}\n  stopLoad() {\n    this.fragmentLoader.abort();\n    this.keyLoader.abort(this.playlistType);\n    const frag = this.fragCurrent;\n    if (frag != null && frag.loader) {\n      frag.abortRequests();\n      this.fragmentTracker.removeFragment(frag);\n    }\n    this.resetTransmuxer();\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.clearInterval();\n    this.clearNextTick();\n    this.state = State.STOPPED;\n  }\n  _streamEnded(bufferInfo, levelDetails) {\n    // If playlist is live, there is another buffered range after the current range, nothing buffered, media is detached,\n    // of nothing loading/loaded return false\n    if (levelDetails.live || bufferInfo.nextStart || !bufferInfo.end || !this.media) {\n      return false;\n    }\n    const partList = levelDetails.partList;\n    // Since the last part isn't guaranteed to correspond to the last playlist segment for Low-Latency HLS,\n    // check instead if the last part is buffered.\n    if (partList != null && partList.length) {\n      const lastPart = partList[partList.length - 1];\n\n      // Checking the midpoint of the part for potential margin of error and related issues.\n      // NOTE: Technically I believe parts could yield content that is < the computed duration (including potential a duration of 0)\n      // and still be spec-compliant, so there may still be edge cases here. Likewise, there could be issues in end of stream\n      // part mismatches for independent audio and video playlists/segments.\n      const lastPartBuffered = BufferHelper.isBuffered(this.media, lastPart.start + lastPart.duration / 2);\n      return lastPartBuffered;\n    }\n    const playlistType = levelDetails.fragments[levelDetails.fragments.length - 1].type;\n    return this.fragmentTracker.isEndListAppended(playlistType);\n  }\n  getLevelDetails() {\n    if (this.levels && this.levelLastLoaded !== null) {\n      var _this$levelLastLoaded;\n      return (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details;\n    }\n  }\n  onMediaAttached(event, data) {\n    const media = this.media = this.mediaBuffer = data.media;\n    this.onvseeking = this.onMediaSeeking.bind(this);\n    this.onvended = this.onMediaEnded.bind(this);\n    media.addEventListener('seeking', this.onvseeking);\n    media.addEventListener('ended', this.onvended);\n    const config = this.config;\n    if (this.levels && config.autoStartLoad && this.state === State.STOPPED) {\n      this.startLoad(config.startPosition);\n    }\n  }\n  onMediaDetaching() {\n    const media = this.media;\n    if (media != null && media.ended) {\n      this.log('MSE detaching and video ended, reset startPosition');\n      this.startPosition = this.lastCurrentTime = 0;\n    }\n\n    // remove video listeners\n    if (media && this.onvseeking && this.onvended) {\n      media.removeEventListener('seeking', this.onvseeking);\n      media.removeEventListener('ended', this.onvended);\n      this.onvseeking = this.onvended = null;\n    }\n    if (this.keyLoader) {\n      this.keyLoader.detach();\n    }\n    this.media = this.mediaBuffer = null;\n    this.loadedmetadata = false;\n    this.fragmentTracker.removeAllFragments();\n    this.stopLoad();\n  }\n  onMediaSeeking() {\n    const {\n      config,\n      fragCurrent,\n      media,\n      mediaBuffer,\n      state\n    } = this;\n    const currentTime = media ? media.currentTime : 0;\n    const bufferInfo = BufferHelper.bufferInfo(mediaBuffer ? mediaBuffer : media, currentTime, config.maxBufferHole);\n    this.log(`media seeking to ${isFiniteNumber(currentTime) ? currentTime.toFixed(3) : currentTime}, state: ${state}`);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    } else if (fragCurrent) {\n      // Seeking while frag load is in progress\n      const tolerance = config.maxFragLookUpTolerance;\n      const fragStartOffset = fragCurrent.start - tolerance;\n      const fragEndOffset = fragCurrent.start + fragCurrent.duration + tolerance;\n      // if seeking out of buffered range or into new one\n      if (!bufferInfo.len || fragEndOffset < bufferInfo.start || fragStartOffset > bufferInfo.end) {\n        const pastFragment = currentTime > fragEndOffset;\n        // if the seek position is outside the current fragment range\n        if (currentTime < fragStartOffset || pastFragment) {\n          if (pastFragment && fragCurrent.loader) {\n            this.log('seeking outside of buffer while fragment load in progress, cancel fragment load');\n            fragCurrent.abortRequests();\n            this.resetLoadingState();\n          }\n          this.fragPrevious = null;\n        }\n      }\n    }\n    if (media) {\n      // Remove gap fragments\n      this.fragmentTracker.removeFragmentsInRange(currentTime, Infinity, this.playlistType, true);\n      this.lastCurrentTime = currentTime;\n    }\n\n    // in case seeking occurs although no media buffered, adjust startPosition and nextLoadPosition to seek target\n    if (!this.loadedmetadata && !bufferInfo.len) {\n      this.nextLoadPosition = this.startPosition = currentTime;\n    }\n\n    // Async tick to speed up processing\n    this.tickImmediate();\n  }\n  onMediaEnded() {\n    // reset startPosition and lastCurrentTime to restart playback @ stream beginning\n    this.startPosition = this.lastCurrentTime = 0;\n  }\n  onManifestLoaded(event, data) {\n    this.startTimeOffset = data.startTimeOffset;\n    this.initPTS = [];\n  }\n  onHandlerDestroying() {\n    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    this.stopLoad();\n    super.onHandlerDestroying();\n    // @ts-ignore\n    this.hls = null;\n  }\n  onHandlerDestroyed() {\n    this.state = State.STOPPED;\n    if (this.fragmentLoader) {\n      this.fragmentLoader.destroy();\n    }\n    if (this.keyLoader) {\n      this.keyLoader.destroy();\n    }\n    if (this.decrypter) {\n      this.decrypter.destroy();\n    }\n    this.hls = this.log = this.warn = this.decrypter = this.keyLoader = this.fragmentLoader = this.fragmentTracker = null;\n    super.onHandlerDestroyed();\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this._loadFragForPlayback(frag, level, targetBufferTime);\n  }\n  _loadFragForPlayback(frag, level, targetBufferTime) {\n    const progressCallback = data => {\n      if (this.fragContextChanged(frag)) {\n        this.warn(`Fragment ${frag.sn}${data.part ? ' p: ' + data.part.index : ''} of level ${frag.level} was dropped during download.`);\n        this.fragmentTracker.removeFragment(frag);\n        return;\n      }\n      frag.stats.chunkCount++;\n      this._handleFragmentLoadProgress(data);\n    };\n    this._doFragLoad(frag, level, targetBufferTime, progressCallback).then(data => {\n      if (!data) {\n        // if we're here we probably needed to backtrack or are waiting for more parts\n        return;\n      }\n      const state = this.state;\n      if (this.fragContextChanged(frag)) {\n        if (state === State.FRAG_LOADING || !this.fragCurrent && state === State.PARSING) {\n          this.fragmentTracker.removeFragment(frag);\n          this.state = State.IDLE;\n        }\n        return;\n      }\n      if ('payload' in data) {\n        this.log(`Loaded fragment ${frag.sn} of level ${frag.level}`);\n        this.hls.trigger(Events.FRAG_LOADED, data);\n      }\n\n      // Pass through the whole payload; controllers not implementing progressive loading receive data from this callback\n      this._handleFragmentLoadComplete(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(`Frag error: ${(reason == null ? void 0 : reason.message) || reason}`);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  clearTrackerIfNeeded(frag) {\n    var _this$mediaBuffer;\n    const {\n      fragmentTracker\n    } = this;\n    const fragState = fragmentTracker.getState(frag);\n    if (fragState === FragmentState.APPENDING) {\n      // Lower the max buffer length and try again\n      const playlistType = frag.type;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      const minForwardBufferLength = Math.max(frag.duration, bufferedInfo ? bufferedInfo.len : this.config.maxBufferLength);\n      // If backtracking, always remove from the tracker without reducing max buffer length\n      const backtrackFragment = this.backtrackFragment;\n      const backtracked = backtrackFragment ? frag.sn - backtrackFragment.sn : 0;\n      if (backtracked === 1 || this.reduceMaxBufferLength(minForwardBufferLength, frag.duration)) {\n        fragmentTracker.removeFragment(frag);\n      }\n    } else if (((_this$mediaBuffer = this.mediaBuffer) == null ? void 0 : _this$mediaBuffer.buffered.length) === 0) {\n      // Stop gap for bad tracker / buffer flush behavior\n      fragmentTracker.removeAllFragments();\n    } else if (fragmentTracker.hasParts(frag.type)) {\n      // In low latency mode, remove fragments for which only some parts were buffered\n      fragmentTracker.detectPartialFragments({\n        frag,\n        part: null,\n        stats: frag.stats,\n        id: frag.type\n      });\n      if (fragmentTracker.getState(frag) === FragmentState.PARTIAL) {\n        fragmentTracker.removeFragment(frag);\n      }\n    }\n  }\n  checkLiveUpdate(details) {\n    if (details.updated && !details.live) {\n      // Live stream ended, update fragment tracker\n      const lastFragment = details.fragments[details.fragments.length - 1];\n      this.fragmentTracker.detectPartialFragments({\n        frag: lastFragment,\n        part: null,\n        stats: lastFragment.stats,\n        id: lastFragment.type\n      });\n    }\n    if (!details.fragments[0]) {\n      details.deltaUpdateFailed = true;\n    }\n  }\n  flushMainBuffer(startOffset, endOffset, type = null) {\n    if (!(startOffset - endOffset)) {\n      return;\n    }\n    // When alternate audio is playing, the audio-stream-controller is responsible for the audio buffer. Otherwise,\n    // passing a null type flushes both buffers\n    const flushScope = {\n      startOffset,\n      endOffset,\n      type\n    };\n    this.hls.trigger(Events.BUFFER_FLUSHING, flushScope);\n  }\n  _loadInitSegment(frag, level) {\n    this._doFragLoad(frag, level).then(data => {\n      if (!data || this.fragContextChanged(frag) || !this.levels) {\n        throw new Error('init load aborted');\n      }\n      return data;\n    }).then(data => {\n      const {\n        hls\n      } = this;\n      const {\n        payload\n      } = data;\n      const decryptData = frag.decryptdata;\n\n      // check to see if the payload needs to be decrypted\n      if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n        const startTime = self.performance.now();\n        // decrypt init segment data\n        return this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.FRAG_DECRYPT_ERROR,\n            fatal: false,\n            error: err,\n            reason: err.message,\n            frag\n          });\n          throw err;\n        }).then(decryptedData => {\n          const endTime = self.performance.now();\n          hls.trigger(Events.FRAG_DECRYPTED, {\n            frag,\n            payload: decryptedData,\n            stats: {\n              tstart: startTime,\n              tdecrypt: endTime\n            }\n          });\n          data.payload = decryptedData;\n          return this.completeInitSegmentLoad(data);\n        });\n      }\n      return this.completeInitSegmentLoad(data);\n    }).catch(reason => {\n      if (this.state === State.STOPPED || this.state === State.ERROR) {\n        return;\n      }\n      this.warn(reason);\n      this.resetFragmentLoading(frag);\n    });\n  }\n  completeInitSegmentLoad(data) {\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      throw new Error('init load aborted, missing levels');\n    }\n    const stats = data.frag.stats;\n    this.state = State.IDLE;\n    data.frag.data = new Uint8Array(data.payload);\n    stats.parsing.start = stats.buffering.start = self.performance.now();\n    stats.parsing.end = stats.buffering.end = self.performance.now();\n    this.tick();\n  }\n  fragContextChanged(frag) {\n    const {\n      fragCurrent\n    } = this;\n    return !frag || !fragCurrent || frag.sn !== fragCurrent.sn || frag.level !== fragCurrent.level;\n  }\n  fragBufferedComplete(frag, part) {\n    var _frag$startPTS, _frag$endPTS, _this$fragCurrent, _this$fragPrevious;\n    const media = this.mediaBuffer ? this.mediaBuffer : this.media;\n    this.log(`Buffered ${frag.type} sn: ${frag.sn}${part ? ' part: ' + part.index : ''} of ${this.playlistType === PlaylistLevelType.MAIN ? 'level' : 'track'} ${frag.level} (frag:[${((_frag$startPTS = frag.startPTS) != null ? _frag$startPTS : NaN).toFixed(3)}-${((_frag$endPTS = frag.endPTS) != null ? _frag$endPTS : NaN).toFixed(3)}] > buffer:${media ? TimeRanges.toString(BufferHelper.getBuffered(media)) : '(detached)'})`);\n    if (frag.sn !== 'initSegment') {\n      var _this$levels;\n      if (frag.type !== PlaylistLevelType.SUBTITLE) {\n        const el = frag.elementaryStreams;\n        if (!Object.keys(el).some(type => !!el[type])) {\n          // empty segment\n          this.state = State.IDLE;\n          return;\n        }\n      }\n      const level = (_this$levels = this.levels) == null ? void 0 : _this$levels[frag.level];\n      if (level != null && level.fragmentError) {\n        this.log(`Resetting level fragment error count of ${level.fragmentError} on frag buffered`);\n        level.fragmentError = 0;\n      }\n    }\n    this.state = State.IDLE;\n    if (!media) {\n      return;\n    }\n    if (!this.loadedmetadata && frag.type == PlaylistLevelType.MAIN && media.buffered.length && ((_this$fragCurrent = this.fragCurrent) == null ? void 0 : _this$fragCurrent.sn) === ((_this$fragPrevious = this.fragPrevious) == null ? void 0 : _this$fragPrevious.sn)) {\n      this.loadedmetadata = true;\n      this.seekToStartPos();\n    }\n    this.tick();\n  }\n  seekToStartPos() {}\n  _handleFragmentLoadComplete(fragLoadedEndData) {\n    const {\n      transmuxer\n    } = this;\n    if (!transmuxer) {\n      return;\n    }\n    const {\n      frag,\n      part,\n      partsLoaded\n    } = fragLoadedEndData;\n    // If we did not load parts, or loaded all parts, we have complete (not partial) fragment data\n    const complete = !partsLoaded || partsLoaded.length === 0 || partsLoaded.some(fragLoaded => !fragLoaded);\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount + 1, 0, part ? part.index : -1, !complete);\n    transmuxer.flush(chunkMeta);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  _handleFragmentLoadProgress(frag) {}\n  _doFragLoad(frag, level, targetBufferTime = null, progressCallback) {\n    var _frag$decryptdata;\n    const details = level == null ? void 0 : level.details;\n    if (!this.levels || !details) {\n      throw new Error(`frag load aborted, missing level${details ? '' : ' detail'}s`);\n    }\n    let keyLoadingPromise = null;\n    if (frag.encrypted && !((_frag$decryptdata = frag.decryptdata) != null && _frag$decryptdata.key)) {\n      this.log(`Loading key for ${frag.sn} of [${details.startSN}-${details.endSN}], ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'} ${frag.level}`);\n      this.state = State.KEY_LOADING;\n      this.fragCurrent = frag;\n      keyLoadingPromise = this.keyLoader.load(frag).then(keyLoadedData => {\n        if (!this.fragContextChanged(keyLoadedData.frag)) {\n          this.hls.trigger(Events.KEY_LOADED, keyLoadedData);\n          if (this.state === State.KEY_LOADING) {\n            this.state = State.IDLE;\n          }\n          return keyLoadedData;\n        }\n      });\n      this.hls.trigger(Events.KEY_LOADING, {\n        frag\n      });\n      if (this.fragCurrent === null) {\n        keyLoadingPromise = Promise.reject(new Error(`frag load aborted, context changed in KEY_LOADING`));\n      }\n    } else if (!frag.encrypted && details.encryptedFragments.length) {\n      this.keyLoader.loadClear(frag, details.encryptedFragments);\n    }\n    targetBufferTime = Math.max(frag.start, targetBufferTime || 0);\n    if (this.config.lowLatencyMode && frag.sn !== 'initSegment') {\n      const partList = details.partList;\n      if (partList && progressCallback) {\n        if (targetBufferTime > frag.end && details.fragmentHint) {\n          frag = details.fragmentHint;\n        }\n        const partIndex = this.getNextPart(partList, frag, targetBufferTime);\n        if (partIndex > -1) {\n          const part = partList[partIndex];\n          this.log(`Loading part sn: ${frag.sn} p: ${part.index} cc: ${frag.cc} of playlist [${details.startSN}-${details.endSN}] parts [0-${partIndex}-${partList.length - 1}] ${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n          this.nextLoadPosition = part.start + part.duration;\n          this.state = State.FRAG_LOADING;\n          let _result;\n          if (keyLoadingPromise) {\n            _result = keyLoadingPromise.then(keyLoadedData => {\n              if (!keyLoadedData || this.fragContextChanged(keyLoadedData.frag)) {\n                return null;\n              }\n              return this.doFragPartsLoad(frag, part, level, progressCallback);\n            }).catch(error => this.handleFragLoadError(error));\n          } else {\n            _result = this.doFragPartsLoad(frag, part, level, progressCallback).catch(error => this.handleFragLoadError(error));\n          }\n          this.hls.trigger(Events.FRAG_LOADING, {\n            frag,\n            part,\n            targetBufferTime\n          });\n          if (this.fragCurrent === null) {\n            return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING parts`));\n          }\n          return _result;\n        } else if (!frag.url || this.loadedEndOfParts(partList, targetBufferTime)) {\n          // Fragment hint has no parts\n          return Promise.resolve(null);\n        }\n      }\n    }\n    this.log(`Loading fragment ${frag.sn} cc: ${frag.cc} ${details ? 'of [' + details.startSN + '-' + details.endSN + '] ' : ''}${this.logPrefix === '[stream-controller]' ? 'level' : 'track'}: ${frag.level}, target: ${parseFloat(targetBufferTime.toFixed(3))}`);\n    // Don't update nextLoadPosition for fragments which are not buffered\n    if (isFiniteNumber(frag.sn) && !this.bitrateTest) {\n      this.nextLoadPosition = frag.start + frag.duration;\n    }\n    this.state = State.FRAG_LOADING;\n\n    // Load key before streaming fragment data\n    const dataOnProgress = this.config.progressive;\n    let result;\n    if (dataOnProgress && keyLoadingPromise) {\n      result = keyLoadingPromise.then(keyLoadedData => {\n        if (!keyLoadedData || this.fragContextChanged(keyLoadedData == null ? void 0 : keyLoadedData.frag)) {\n          return null;\n        }\n        return this.fragmentLoader.load(frag, progressCallback);\n      }).catch(error => this.handleFragLoadError(error));\n    } else {\n      // load unencrypted fragment data with progress event,\n      // or handle fragment result after key and fragment are finished loading\n      result = Promise.all([this.fragmentLoader.load(frag, dataOnProgress ? progressCallback : undefined), keyLoadingPromise]).then(([fragLoadedData]) => {\n        if (!dataOnProgress && fragLoadedData && progressCallback) {\n          progressCallback(fragLoadedData);\n        }\n        return fragLoadedData;\n      }).catch(error => this.handleFragLoadError(error));\n    }\n    this.hls.trigger(Events.FRAG_LOADING, {\n      frag,\n      targetBufferTime\n    });\n    if (this.fragCurrent === null) {\n      return Promise.reject(new Error(`frag load aborted, context changed in FRAG_LOADING`));\n    }\n    return result;\n  }\n  doFragPartsLoad(frag, fromPart, level, progressCallback) {\n    return new Promise((resolve, reject) => {\n      var _level$details;\n      const partsLoaded = [];\n      const initialPartList = (_level$details = level.details) == null ? void 0 : _level$details.partList;\n      const loadPart = part => {\n        this.fragmentLoader.loadPart(frag, part, progressCallback).then(partLoadedData => {\n          partsLoaded[part.index] = partLoadedData;\n          const loadedPart = partLoadedData.part;\n          this.hls.trigger(Events.FRAG_LOADED, partLoadedData);\n          const nextPart = getPartWith(level, frag.sn, part.index + 1) || findPart(initialPartList, frag.sn, part.index + 1);\n          if (nextPart) {\n            loadPart(nextPart);\n          } else {\n            return resolve({\n              frag,\n              part: loadedPart,\n              partsLoaded\n            });\n          }\n        }).catch(reject);\n      };\n      loadPart(fromPart);\n    });\n  }\n  handleFragLoadError(error) {\n    if ('data' in error) {\n      const data = error.data;\n      if (error.data && data.details === ErrorDetails.INTERNAL_ABORTED) {\n        this.handleFragLoadAborted(data.frag, data.part);\n      } else {\n        this.hls.trigger(Events.ERROR, data);\n      }\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.INTERNAL_EXCEPTION,\n        err: error,\n        error,\n        fatal: true\n      });\n    }\n    return null;\n  }\n  _handleTransmuxerFlush(chunkMeta) {\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context || this.state !== State.PARSING) {\n      if (!this.fragCurrent && this.state !== State.STOPPED && this.state !== State.ERROR) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const now = self.performance.now();\n    frag.stats.parsing.end = now;\n    if (part) {\n      part.stats.parsing.end = now;\n    }\n    this.updateLevelTiming(frag, part, level, chunkMeta.partial);\n  }\n  getCurrentContext(chunkMeta) {\n    const {\n      levels,\n      fragCurrent\n    } = this;\n    const {\n      level: levelIndex,\n      sn,\n      part: partIndex\n    } = chunkMeta;\n    if (!(levels != null && levels[levelIndex])) {\n      this.warn(`Levels object was unset while buffering fragment ${sn} of level ${levelIndex}. The current chunk will not be buffered.`);\n      return null;\n    }\n    const level = levels[levelIndex];\n    const part = partIndex > -1 ? getPartWith(level, sn, partIndex) : null;\n    const frag = part ? part.fragment : getFragmentWithSN(level, sn, fragCurrent);\n    if (!frag) {\n      return null;\n    }\n    if (fragCurrent && fragCurrent !== frag) {\n      frag.stats = fragCurrent.stats;\n    }\n    return {\n      frag,\n      part,\n      level\n    };\n  }\n  bufferFragmentData(data, frag, part, chunkMeta, noBacktracking) {\n    var _buffer;\n    if (!data || this.state !== State.PARSING) {\n      return;\n    }\n    const {\n      data1,\n      data2\n    } = data;\n    let buffer = data1;\n    if (data1 && data2) {\n      // Combine the moof + mdat so that we buffer with a single append\n      buffer = appendUint8Array(data1, data2);\n    }\n    if (!((_buffer = buffer) != null && _buffer.length)) {\n      return;\n    }\n    const segment = {\n      type: data.type,\n      frag,\n      part,\n      chunkMeta,\n      parent: frag.type,\n      data: buffer\n    };\n    this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    if (data.dropped && data.independent && !part) {\n      if (noBacktracking) {\n        return;\n      }\n      // Clear buffer so that we reload previous segments sequentially if required\n      this.flushBufferGap(frag);\n    }\n  }\n  flushBufferGap(frag) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    // If currentTime is not buffered, clear the back buffer so that we can backtrack as much as needed\n    if (!BufferHelper.isBuffered(media, media.currentTime)) {\n      this.flushMainBuffer(0, frag.start);\n      return;\n    }\n    // Remove back-buffer without interrupting playback to allow back tracking\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const fragDuration = frag.duration;\n    const segmentFraction = Math.min(this.config.maxFragLookUpTolerance * 2, fragDuration * 0.25);\n    const start = Math.max(Math.min(frag.start - segmentFraction, bufferInfo.end - segmentFraction), currentTime + segmentFraction);\n    if (frag.start - start > segmentFraction) {\n      this.flushMainBuffer(start, frag.start);\n    }\n  }\n  getFwdBufferInfo(bufferable, type) {\n    const pos = this.getLoadPosition();\n    if (!isFiniteNumber(pos)) {\n      return null;\n    }\n    return this.getFwdBufferInfoAtPos(bufferable, pos, type);\n  }\n  getFwdBufferInfoAtPos(bufferable, pos, type) {\n    const {\n      config: {\n        maxBufferHole\n      }\n    } = this;\n    const bufferInfo = BufferHelper.bufferInfo(bufferable, pos, maxBufferHole);\n    // Workaround flaw in getting forward buffer when maxBufferHole is smaller than gap at current pos\n    if (bufferInfo.len === 0 && bufferInfo.nextStart !== undefined) {\n      const bufferedFragAtPos = this.fragmentTracker.getBufferedFrag(pos, type);\n      if (bufferedFragAtPos && bufferInfo.nextStart < bufferedFragAtPos.end) {\n        return BufferHelper.bufferInfo(bufferable, pos, Math.max(bufferInfo.nextStart, maxBufferHole));\n      }\n    }\n    return bufferInfo;\n  }\n  getMaxBufferLength(levelBitrate) {\n    const {\n      config\n    } = this;\n    let maxBufLen;\n    if (levelBitrate) {\n      maxBufLen = Math.max(8 * config.maxBufferSize / levelBitrate, config.maxBufferLength);\n    } else {\n      maxBufLen = config.maxBufferLength;\n    }\n    return Math.min(maxBufLen, config.maxMaxBufferLength);\n  }\n  reduceMaxBufferLength(threshold, fragDuration) {\n    const config = this.config;\n    const minLength = Math.max(Math.min(threshold - fragDuration, config.maxBufferLength), fragDuration);\n    const reducedLength = Math.max(threshold - fragDuration * 3, config.maxMaxBufferLength / 2, minLength);\n    if (reducedLength >= minLength) {\n      // reduce max buffer length as it might be too high. we do this to avoid loop flushing ...\n      config.maxMaxBufferLength = reducedLength;\n      this.warn(`Reduce max buffer length to ${reducedLength}s`);\n      return true;\n    }\n    return false;\n  }\n  getAppendedFrag(position, playlistType = PlaylistLevelType.MAIN) {\n    const fragOrPart = this.fragmentTracker.getAppendedFrag(position, PlaylistLevelType.MAIN);\n    if (fragOrPart && 'fragment' in fragOrPart) {\n      return fragOrPart.fragment;\n    }\n    return fragOrPart;\n  }\n  getNextFragment(pos, levelDetails) {\n    const fragments = levelDetails.fragments;\n    const fragLen = fragments.length;\n    if (!fragLen) {\n      return null;\n    }\n\n    // find fragment index, contiguous with end of buffer position\n    const {\n      config\n    } = this;\n    const start = fragments[0].start;\n    let frag;\n    if (levelDetails.live) {\n      const initialLiveManifestSize = config.initialLiveManifestSize;\n      if (fragLen < initialLiveManifestSize) {\n        this.warn(`Not enough fragments to start playback (have: ${fragLen}, need: ${initialLiveManifestSize})`);\n        return null;\n      }\n      // The real fragment start times for a live stream are only known after the PTS range for that level is known.\n      // In order to discover the range, we load the best matching fragment for that level and demux it.\n      // Do not load using live logic if the starting frag is requested - we want to use getFragmentAtPosition() so that\n      // we get the fragment matching that start time\n      if (!levelDetails.PTSKnown && !this.startFragRequested && this.startPosition === -1 || pos < start) {\n        frag = this.getInitialLiveFragment(levelDetails, fragments);\n        this.startPosition = this.nextLoadPosition = frag ? this.hls.liveSyncPosition || frag.start : pos;\n      }\n    } else if (pos <= start) {\n      // VoD playlist: if loadPosition before start of playlist, load first fragment\n      frag = fragments[0];\n    }\n\n    // If we haven't run into any special cases already, just load the fragment most closely matching the requested position\n    if (!frag) {\n      const end = config.lowLatencyMode ? levelDetails.partEnd : levelDetails.fragmentEnd;\n      frag = this.getFragmentAtPosition(pos, end, levelDetails);\n    }\n    return this.mapToInitFragWhenRequired(frag);\n  }\n  isLoopLoading(frag, targetBufferTime) {\n    const trackerState = this.fragmentTracker.getState(frag);\n    return (trackerState === FragmentState.OK || trackerState === FragmentState.PARTIAL && !!frag.gap) && this.nextLoadPosition > targetBufferTime;\n  }\n  getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, playlistType, maxBufLen) {\n    const gapStart = frag.gap;\n    const nextFragment = this.getNextFragment(this.nextLoadPosition, levelDetails);\n    if (nextFragment === null) {\n      return nextFragment;\n    }\n    frag = nextFragment;\n    if (gapStart && frag && !frag.gap && bufferInfo.nextStart) {\n      // Media buffered after GAP tags should not make the next buffer timerange exceed forward buffer length\n      const nextbufferInfo = this.getFwdBufferInfoAtPos(this.mediaBuffer ? this.mediaBuffer : this.media, bufferInfo.nextStart, playlistType);\n      if (nextbufferInfo !== null && bufferInfo.len + nextbufferInfo.len >= maxBufLen) {\n        // Returning here might result in not finding an audio and video candiate to skip to\n        this.log(`buffer full after gaps in \"${playlistType}\" playlist starting at sn: ${frag.sn}`);\n        return null;\n      }\n    }\n    return frag;\n  }\n  mapToInitFragWhenRequired(frag) {\n    // If an initSegment is present, it must be buffered first\n    if (frag != null && frag.initSegment && !(frag != null && frag.initSegment.data) && !this.bitrateTest) {\n      return frag.initSegment;\n    }\n    return frag;\n  }\n  getNextPart(partList, frag, targetBufferTime) {\n    let nextPart = -1;\n    let contiguous = false;\n    let independentAttrOmitted = true;\n    for (let i = 0, len = partList.length; i < len; i++) {\n      const part = partList[i];\n      independentAttrOmitted = independentAttrOmitted && !part.independent;\n      if (nextPart > -1 && targetBufferTime < part.start) {\n        break;\n      }\n      const loaded = part.loaded;\n      if (loaded) {\n        nextPart = -1;\n      } else if ((contiguous || part.independent || independentAttrOmitted) && part.fragment === frag) {\n        nextPart = i;\n      }\n      contiguous = loaded;\n    }\n    return nextPart;\n  }\n  loadedEndOfParts(partList, targetBufferTime) {\n    const lastPart = partList[partList.length - 1];\n    return lastPart && targetBufferTime > lastPart.start && lastPart.loaded;\n  }\n\n  /*\n   This method is used find the best matching first fragment for a live playlist. This fragment is used to calculate the\n   \"sliding\" of the playlist, which is its offset from the start of playback. After sliding we can compute the real\n   start and end times for each fragment in the playlist (after which this method will not need to be called).\n  */\n  getInitialLiveFragment(levelDetails, fragments) {\n    const fragPrevious = this.fragPrevious;\n    let frag = null;\n    if (fragPrevious) {\n      if (levelDetails.hasProgramDateTime) {\n        // Prefer using PDT, because it can be accurate enough to choose the correct fragment without knowing the level sliding\n        this.log(`Live playlist, switching playlist, load frag with same PDT: ${fragPrevious.programDateTime}`);\n        frag = findFragmentByPDT(fragments, fragPrevious.endProgramDateTime, this.config.maxFragLookUpTolerance);\n      }\n      if (!frag) {\n        // SN does not need to be accurate between renditions, but depending on the packaging it may be so.\n        const targetSN = fragPrevious.sn + 1;\n        if (targetSN >= levelDetails.startSN && targetSN <= levelDetails.endSN) {\n          const fragNext = fragments[targetSN - levelDetails.startSN];\n          // Ensure that we're staying within the continuity range, since PTS resets upon a new range\n          if (fragPrevious.cc === fragNext.cc) {\n            frag = fragNext;\n            this.log(`Live playlist, switching playlist, load frag with next SN: ${frag.sn}`);\n          }\n        }\n        // It's important to stay within the continuity range if available; otherwise the fragments in the playlist\n        // will have the wrong start times\n        if (!frag) {\n          frag = findFragWithCC(fragments, fragPrevious.cc);\n          if (frag) {\n            this.log(`Live playlist, switching playlist, load frag with same CC: ${frag.sn}`);\n          }\n        }\n      }\n    } else {\n      // Find a new start fragment when fragPrevious is null\n      const liveStart = this.hls.liveSyncPosition;\n      if (liveStart !== null) {\n        frag = this.getFragmentAtPosition(liveStart, this.bitrateTest ? levelDetails.fragmentEnd : levelDetails.edge, levelDetails);\n      }\n    }\n    return frag;\n  }\n\n  /*\n  This method finds the best matching fragment given the provided position.\n   */\n  getFragmentAtPosition(bufferEnd, end, levelDetails) {\n    const {\n      config\n    } = this;\n    let {\n      fragPrevious\n    } = this;\n    let {\n      fragments,\n      endSN\n    } = levelDetails;\n    const {\n      fragmentHint\n    } = levelDetails;\n    const {\n      maxFragLookUpTolerance\n    } = config;\n    const partList = levelDetails.partList;\n    const loadingParts = !!(config.lowLatencyMode && partList != null && partList.length && fragmentHint);\n    if (loadingParts && fragmentHint && !this.bitrateTest) {\n      // Include incomplete fragment with parts at end\n      fragments = fragments.concat(fragmentHint);\n      endSN = fragmentHint.sn;\n    }\n    let frag;\n    if (bufferEnd < end) {\n      const lookupTolerance = bufferEnd > end - maxFragLookUpTolerance ? 0 : maxFragLookUpTolerance;\n      // Remove the tolerance if it would put the bufferEnd past the actual end of stream\n      // Uses buffer and sequence number to calculate switch segment (required if using EXT-X-DISCONTINUITY-SEQUENCE)\n      frag = findFragmentByPTS(fragPrevious, fragments, bufferEnd, lookupTolerance);\n    } else {\n      // reach end of playlist\n      frag = fragments[fragments.length - 1];\n    }\n    if (frag) {\n      const curSNIdx = frag.sn - levelDetails.startSN;\n      // Move fragPrevious forward to support forcing the next fragment to load\n      // when the buffer catches up to a previously buffered range.\n      const fragState = this.fragmentTracker.getState(frag);\n      if (fragState === FragmentState.OK || fragState === FragmentState.PARTIAL && frag.gap) {\n        fragPrevious = frag;\n      }\n      if (fragPrevious && frag.sn === fragPrevious.sn && (!loadingParts || partList[0].fragment.sn > frag.sn)) {\n        // Force the next fragment to load if the previous one was already selected. This can occasionally happen with\n        // non-uniform fragment durations\n        const sameLevel = fragPrevious && frag.level === fragPrevious.level;\n        if (sameLevel) {\n          const nextFrag = fragments[curSNIdx + 1];\n          if (frag.sn < endSN && this.fragmentTracker.getState(nextFrag) !== FragmentState.OK) {\n            frag = nextFrag;\n          } else {\n            frag = null;\n          }\n        }\n      }\n    }\n    return frag;\n  }\n  synchronizeToLiveEdge(levelDetails) {\n    const {\n      config,\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const liveSyncPosition = this.hls.liveSyncPosition;\n    const currentTime = media.currentTime;\n    const start = levelDetails.fragments[0].start;\n    const end = levelDetails.edge;\n    const withinSlidingWindow = currentTime >= start - config.maxFragLookUpTolerance && currentTime <= end;\n    // Continue if we can seek forward to sync position or if current time is outside of sliding window\n    if (liveSyncPosition !== null && media.duration > liveSyncPosition && (currentTime < liveSyncPosition || !withinSlidingWindow)) {\n      // Continue if buffer is starving or if current time is behind max latency\n      const maxLatency = config.liveMaxLatencyDuration !== undefined ? config.liveMaxLatencyDuration : config.liveMaxLatencyDurationCount * levelDetails.targetduration;\n      if (!withinSlidingWindow && media.readyState < 4 || currentTime < end - maxLatency) {\n        if (!this.loadedmetadata) {\n          this.nextLoadPosition = liveSyncPosition;\n        }\n        // Only seek if ready and there is not a significant forward buffer available for playback\n        if (media.readyState) {\n          this.warn(`Playback: ${currentTime.toFixed(3)} is located too far from the end of live sliding playlist: ${end}, reset currentTime to : ${liveSyncPosition.toFixed(3)}`);\n          media.currentTime = liveSyncPosition;\n        }\n      }\n    }\n  }\n  alignPlaylists(details, previousDetails, switchDetails) {\n    // FIXME: If not for `shouldAlignOnDiscontinuities` requiring fragPrevious.cc,\n    //  this could all go in level-helper mergeDetails()\n    const length = details.fragments.length;\n    if (!length) {\n      this.warn(`No fragments in live playlist`);\n      return 0;\n    }\n    const slidingStart = details.fragments[0].start;\n    const firstLevelLoad = !previousDetails;\n    const aligned = details.alignedSliding && isFiniteNumber(slidingStart);\n    if (firstLevelLoad || !aligned && !slidingStart) {\n      const {\n        fragPrevious\n      } = this;\n      alignStream(fragPrevious, switchDetails, details);\n      const alignedSlidingStart = details.fragments[0].start;\n      this.log(`Live playlist sliding: ${alignedSlidingStart.toFixed(2)} start-sn: ${previousDetails ? previousDetails.startSN : 'na'}->${details.startSN} prev-sn: ${fragPrevious ? fragPrevious.sn : 'na'} fragments: ${length}`);\n      return alignedSlidingStart;\n    }\n    return slidingStart;\n  }\n  waitForCdnTuneIn(details) {\n    // Wait for Low-Latency CDN Tune-in to get an updated playlist\n    const advancePartLimit = 3;\n    return details.live && details.canBlockReload && details.partTarget && details.tuneInGoal > Math.max(details.partHoldBack, details.partTarget * advancePartLimit);\n  }\n  setStartPosition(details, sliding) {\n    // compute start position if set to -1. use it straight away if value is defined\n    let startPosition = this.startPosition;\n    if (startPosition < sliding) {\n      startPosition = -1;\n    }\n    if (startPosition === -1 || this.lastCurrentTime === -1) {\n      // Use Playlist EXT-X-START:TIME-OFFSET when set\n      // Prioritize Multivariant Playlist offset so that main, audio, and subtitle stream-controller start times match\n      const offsetInMultivariantPlaylist = this.startTimeOffset !== null;\n      const startTimeOffset = offsetInMultivariantPlaylist ? this.startTimeOffset : details.startTimeOffset;\n      if (startTimeOffset !== null && isFiniteNumber(startTimeOffset)) {\n        startPosition = sliding + startTimeOffset;\n        if (startTimeOffset < 0) {\n          startPosition += details.totalduration;\n        }\n        startPosition = Math.min(Math.max(sliding, startPosition), sliding + details.totalduration);\n        this.log(`Start time offset ${startTimeOffset} found in ${offsetInMultivariantPlaylist ? 'multivariant' : 'media'} playlist, adjust startPosition to ${startPosition}`);\n        this.startPosition = startPosition;\n      } else if (details.live) {\n        // Leave this.startPosition at -1, so that we can use `getInitialLiveFragment` logic when startPosition has\n        // not been specified via the config or an as an argument to startLoad (#3736).\n        startPosition = this.hls.liveSyncPosition || sliding;\n      } else {\n        this.startPosition = startPosition = 0;\n      }\n      this.lastCurrentTime = startPosition;\n    }\n    this.nextLoadPosition = startPosition;\n  }\n  getLoadPosition() {\n    const {\n      media\n    } = this;\n    // if we have not yet loaded any fragment, start loading from start position\n    let pos = 0;\n    if (this.loadedmetadata && media) {\n      pos = media.currentTime;\n    } else if (this.nextLoadPosition) {\n      pos = this.nextLoadPosition;\n    }\n    return pos;\n  }\n  handleFragLoadAborted(frag, part) {\n    if (this.transmuxer && frag.sn !== 'initSegment' && frag.stats.aborted) {\n      this.warn(`Fragment ${frag.sn}${part ? ' part ' + part.index : ''} of level ${frag.level} was aborted`);\n      this.resetFragmentLoading(frag);\n    }\n  }\n  resetFragmentLoading(frag) {\n    if (!this.fragCurrent || !this.fragContextChanged(frag) && this.state !== State.FRAG_LOADING_WAITING_RETRY) {\n      this.state = State.IDLE;\n    }\n  }\n  onFragmentOrKeyLoadError(filterType, data) {\n    if (data.chunkMeta && !data.frag) {\n      const context = this.getCurrentContext(data.chunkMeta);\n      if (context) {\n        data.frag = context.frag;\n      }\n    }\n    const frag = data.frag;\n    // Handle frag error related to caller's filterType\n    if (!frag || frag.type !== filterType || !this.levels) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      var _this$fragCurrent2;\n      this.warn(`Frag load error must match current frag to retry ${frag.url} > ${(_this$fragCurrent2 = this.fragCurrent) == null ? void 0 : _this$fragCurrent2.url}`);\n      return;\n    }\n    const gapTagEncountered = data.details === ErrorDetails.FRAG_GAP;\n    if (gapTagEncountered) {\n      this.fragmentTracker.fragBuffered(frag, true);\n    }\n    // keep retrying until the limit will be reached\n    const errorAction = data.errorAction;\n    const {\n      action,\n      retryCount = 0,\n      retryConfig\n    } = errorAction || {};\n    if (errorAction && action === NetworkErrorAction.RetryRequest && retryConfig) {\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      const delay = getRetryDelay(retryConfig, retryCount);\n      this.warn(`Fragment ${frag.sn} of ${filterType} ${frag.level} errored with ${data.details}, retrying loading ${retryCount + 1}/${retryConfig.maxNumRetry} in ${delay}ms`);\n      errorAction.resolved = true;\n      this.retryDate = self.performance.now() + delay;\n      this.state = State.FRAG_LOADING_WAITING_RETRY;\n    } else if (retryConfig && errorAction) {\n      this.resetFragmentErrors(filterType);\n      if (retryCount < retryConfig.maxNumRetry) {\n        // Network retry is skipped when level switch is preferred\n        if (!gapTagEncountered && action !== NetworkErrorAction.RemoveAlternatePermanently) {\n          errorAction.resolved = true;\n        }\n      } else {\n        logger.warn(`${data.details} reached or exceeded max retry (${retryCount})`);\n        return;\n      }\n    } else if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox) {\n      this.state = State.WAITING_LEVEL;\n    } else {\n      this.state = State.ERROR;\n    }\n    // Perform next async tick sooner to speed up error action resolution\n    this.tickImmediate();\n  }\n  reduceLengthAndFlushBuffer(data) {\n    // if in appending state\n    if (this.state === State.PARSING || this.state === State.PARSED) {\n      const frag = data.frag;\n      const playlistType = data.parent;\n      const bufferedInfo = this.getFwdBufferInfo(this.mediaBuffer, playlistType);\n      // 0.5 : tolerance needed as some browsers stalls playback before reaching buffered end\n      // reduce max buf len if current position is buffered\n      const buffered = bufferedInfo && bufferedInfo.len > 0.5;\n      if (buffered) {\n        this.reduceMaxBufferLength(bufferedInfo.len, (frag == null ? void 0 : frag.duration) || 10);\n      }\n      const flushBuffer = !buffered;\n      if (flushBuffer) {\n        // current position is not buffered, but browser is still complaining about buffer full error\n        // this happens on IE/Edge, refer to https://github.com/video-dev/hls.js/pull/708\n        // in that case flush the whole audio buffer to recover\n        this.warn(`Buffer full error while media.currentTime is not buffered, flush ${playlistType} buffer`);\n      }\n      if (frag) {\n        this.fragmentTracker.removeFragment(frag);\n        this.nextLoadPosition = frag.start;\n      }\n      this.resetLoadingState();\n      return flushBuffer;\n    }\n    return false;\n  }\n  resetFragmentErrors(filterType) {\n    if (filterType === PlaylistLevelType.AUDIO) {\n      // Reset current fragment since audio track audio is essential and may not have a fail-over track\n      this.fragCurrent = null;\n    }\n    // Fragment errors that result in a level switch or redundant fail-over\n    // should reset the stream controller state to idle\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n    }\n    if (this.state !== State.STOPPED) {\n      this.state = State.IDLE;\n    }\n  }\n  afterBufferFlushed(media, bufferType, playlistType) {\n    if (!media) {\n      return;\n    }\n    // After successful buffer flushing, filter flushed fragments from bufferedFrags use mediaBuffered instead of media\n    // (so that we will check against video.buffered ranges in case of alt audio track)\n    const bufferedTimeRanges = BufferHelper.getBuffered(media);\n    this.fragmentTracker.detectEvictedFragments(bufferType, bufferedTimeRanges, playlistType);\n    if (this.state === State.ENDED) {\n      this.resetLoadingState();\n    }\n  }\n  resetLoadingState() {\n    this.log('Reset loading state');\n    this.fragCurrent = null;\n    this.fragPrevious = null;\n    this.state = State.IDLE;\n  }\n  resetStartWhenNotLoaded(level) {\n    // if loadedmetadata is not set, it means that first frag request failed\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      const details = level ? level.details : null;\n      if (details != null && details.live) {\n        // Update the start position and return to IDLE to recover live start\n        this.startPosition = -1;\n        this.setStartPosition(details, 0);\n        this.resetLoadingState();\n      } else {\n        this.nextLoadPosition = this.startPosition;\n      }\n    }\n  }\n  resetWhenMissingContext(chunkMeta) {\n    this.warn(`The loading context changed while buffering fragment ${chunkMeta.sn} of level ${chunkMeta.level}. This chunk will not be buffered.`);\n    this.removeUnbufferedFrags();\n    this.resetStartWhenNotLoaded(this.levelLastLoaded);\n    this.resetLoadingState();\n  }\n  removeUnbufferedFrags(start = 0) {\n    this.fragmentTracker.removeFragmentsInRange(start, Infinity, this.playlistType, false, true);\n  }\n  updateLevelTiming(frag, part, level, partial) {\n    var _this$transmuxer;\n    const details = level.details;\n    if (!details) {\n      this.warn('level.details undefined');\n      return;\n    }\n    const parsed = Object.keys(frag.elementaryStreams).reduce((result, type) => {\n      const info = frag.elementaryStreams[type];\n      if (info) {\n        const parsedDuration = info.endPTS - info.startPTS;\n        if (parsedDuration <= 0) {\n          // Destroy the transmuxer after it's next time offset failed to advance because duration was <= 0.\n          // The new transmuxer will be configured with a time offset matching the next fragment start,\n          // preventing the timeline from shifting.\n          this.warn(`Could not parse fragment ${frag.sn} ${type} duration reliably (${parsedDuration})`);\n          return result || false;\n        }\n        const drift = partial ? 0 : updateFragPTSDTS(details, frag, info.startPTS, info.endPTS, info.startDTS, info.endDTS);\n        this.hls.trigger(Events.LEVEL_PTS_UPDATED, {\n          details,\n          level,\n          drift,\n          type,\n          frag,\n          start: info.startPTS,\n          end: info.endPTS\n        });\n        return true;\n      }\n      return result;\n    }, false);\n    if (!parsed && ((_this$transmuxer = this.transmuxer) == null ? void 0 : _this$transmuxer.error) === null) {\n      const error = new Error(`Found no media in fragment ${frag.sn} of level ${frag.level} resetting transmuxer to fallback to playlist timing`);\n      if (level.fragmentError === 0) {\n        // Mark and track the odd empty segment as a gap to avoid reloading\n        level.fragmentError++;\n        frag.gap = true;\n        this.fragmentTracker.removeFragment(frag);\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      this.warn(error.message);\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.FRAG_PARSING_ERROR,\n        fatal: false,\n        error,\n        frag,\n        reason: `Found no media in msn ${frag.sn} of level \"${level.url}\"`\n      });\n      if (!this.hls) {\n        return;\n      }\n      this.resetTransmuxer();\n      // For this error fallthrough. Marking parsed will allow advancing to next fragment.\n    }\n    this.state = State.PARSED;\n    this.hls.trigger(Events.FRAG_PARSED, {\n      frag,\n      part\n    });\n  }\n  resetTransmuxer() {\n    if (this.transmuxer) {\n      this.transmuxer.destroy();\n      this.transmuxer = null;\n    }\n  }\n  recoverWorkerError(data) {\n    if (data.event === 'demuxerWorker') {\n      this.fragmentTracker.removeAllFragments();\n      this.resetTransmuxer();\n      this.resetStartWhenNotLoaded(this.levelLastLoaded);\n      this.resetLoadingState();\n    }\n  }\n  set state(nextState) {\n    const previousState = this._state;\n    if (previousState !== nextState) {\n      this._state = nextState;\n      this.log(`${previousState}->${nextState}`);\n    }\n  }\n  get state() {\n    return this._state;\n  }\n}\n\nclass ChunkCache {\n  constructor() {\n    this.chunks = [];\n    this.dataLength = 0;\n  }\n  push(chunk) {\n    this.chunks.push(chunk);\n    this.dataLength += chunk.length;\n  }\n  flush() {\n    const {\n      chunks,\n      dataLength\n    } = this;\n    let result;\n    if (!chunks.length) {\n      return new Uint8Array(0);\n    } else if (chunks.length === 1) {\n      result = chunks[0];\n    } else {\n      result = concatUint8Arrays(chunks, dataLength);\n    }\n    this.reset();\n    return result;\n  }\n  reset() {\n    this.chunks.length = 0;\n    this.dataLength = 0;\n  }\n}\nfunction concatUint8Arrays(chunks, dataLength) {\n  const result = new Uint8Array(dataLength);\n  let offset = 0;\n  for (let i = 0; i < chunks.length; i++) {\n    const chunk = chunks[i];\n    result.set(chunk, offset);\n    offset += chunk.length;\n  }\n  return result;\n}\n\n// ensure the worker ends up in the bundle\n// If the worker should not be included this gets aliased to empty.js\nfunction hasUMDWorker() {\n  return typeof __HLS_WORKER_BUNDLE__ === 'function';\n}\nfunction injectWorker() {\n  const blob = new self.Blob([`var exports={};var module={exports:exports};function define(f){f()};define.amd=true;(${__HLS_WORKER_BUNDLE__.toString()})(true);`], {\n    type: 'text/javascript'\n  });\n  const objectURL = self.URL.createObjectURL(blob);\n  const worker = new self.Worker(objectURL);\n  return {\n    worker,\n    objectURL\n  };\n}\nfunction loadWorker(path) {\n  const scriptURL = new self.URL(path, self.location.href).href;\n  const worker = new self.Worker(scriptURL);\n  return {\n    worker,\n    scriptURL\n  };\n}\n\nfunction dummyTrack(type = '', inputTimeScale = 90000) {\n  return {\n    type,\n    id: -1,\n    pid: -1,\n    inputTimeScale,\n    sequenceNumber: -1,\n    samples: [],\n    dropped: 0\n  };\n}\n\nclass BaseAudioDemuxer {\n  constructor() {\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this.frameIndex = 0;\n    this.cachedData = null;\n    this.basePTS = null;\n    this.initPTS = null;\n    this.lastPTS = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this._id3Track = {\n      type: 'id3',\n      id: 3,\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0\n    };\n  }\n  resetTimeStamp(deaultTimestamp) {\n    this.initPTS = deaultTimestamp;\n    this.resetContiguity();\n  }\n  resetContiguity() {\n    this.basePTS = null;\n    this.lastPTS = null;\n    this.frameIndex = 0;\n  }\n  canParse(data, offset) {\n    return false;\n  }\n  appendFrame(track, data, offset) {}\n\n  // feed incoming data to the front of the parsing pipeline\n  demux(data, timeOffset) {\n    if (this.cachedData) {\n      data = appendUint8Array(this.cachedData, data);\n      this.cachedData = null;\n    }\n    let id3Data = getID3Data(data, 0);\n    let offset = id3Data ? id3Data.length : 0;\n    let lastDataIndex;\n    const track = this._audioTrack;\n    const id3Track = this._id3Track;\n    const timestamp = id3Data ? getTimeStamp(id3Data) : undefined;\n    const length = data.length;\n    if (this.basePTS === null || this.frameIndex === 0 && isFiniteNumber(timestamp)) {\n      this.basePTS = initPTSFn(timestamp, timeOffset, this.initPTS);\n      this.lastPTS = this.basePTS;\n    }\n    if (this.lastPTS === null) {\n      this.lastPTS = this.basePTS;\n    }\n\n    // more expressive than alternative: id3Data?.length\n    if (id3Data && id3Data.length > 0) {\n      id3Track.samples.push({\n        pts: this.lastPTS,\n        dts: this.lastPTS,\n        data: id3Data,\n        type: MetadataSchema.audioId3,\n        duration: Number.POSITIVE_INFINITY\n      });\n    }\n    while (offset < length) {\n      if (this.canParse(data, offset)) {\n        const frame = this.appendFrame(track, data, offset);\n        if (frame) {\n          this.frameIndex++;\n          this.lastPTS = frame.sample.pts;\n          offset += frame.length;\n          lastDataIndex = offset;\n        } else {\n          offset = length;\n        }\n      } else if (canParse$2(data, offset)) {\n        // after a ID3.canParse, a call to ID3.getID3Data *should* always returns some data\n        id3Data = getID3Data(data, offset);\n        id3Track.samples.push({\n          pts: this.lastPTS,\n          dts: this.lastPTS,\n          data: id3Data,\n          type: MetadataSchema.audioId3,\n          duration: Number.POSITIVE_INFINITY\n        });\n        offset += id3Data.length;\n        lastDataIndex = offset;\n      } else {\n        offset++;\n      }\n      if (offset === length && lastDataIndex !== length) {\n        const partialData = sliceUint8(data, lastDataIndex);\n        if (this.cachedData) {\n          this.cachedData = appendUint8Array(this.cachedData, partialData);\n        } else {\n          this.cachedData = partialData;\n        }\n      }\n    }\n    return {\n      audioTrack: track,\n      videoTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error(`[${this}] This demuxer does not support Sample-AES decryption`));\n  }\n  flush(timeOffset) {\n    // Parse cache in case of remaining frames.\n    const cachedData = this.cachedData;\n    if (cachedData) {\n      this.cachedData = null;\n      this.demux(cachedData, 0);\n    }\n    return {\n      audioTrack: this._audioTrack,\n      videoTrack: dummyTrack(),\n      id3Track: this._id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  destroy() {}\n}\n\n/**\n * Initialize PTS\n * <p>\n *    use timestamp unless it is undefined, NaN or Infinity\n * </p>\n */\nconst initPTSFn = (timestamp, timeOffset, initPTS) => {\n  if (isFiniteNumber(timestamp)) {\n    return timestamp * 90;\n  }\n  const init90kHz = initPTS ? initPTS.baseTime * 90000 / initPTS.timescale : 0;\n  return timeOffset * 90000 + init90kHz;\n};\n\n/**\n * ADTS parser helper\n * @link https://wiki.multimedia.cx/index.php?title=ADTS\n */\nfunction getAudioConfig(observer, data, offset, audioCodec) {\n  let adtsObjectType;\n  let adtsExtensionSamplingIndex;\n  let adtsChannelConfig;\n  let config;\n  const userAgent = navigator.userAgent.toLowerCase();\n  const manifestCodec = audioCodec;\n  const adtsSamplingRates = [96000, 88200, 64000, 48000, 44100, 32000, 24000, 22050, 16000, 12000, 11025, 8000, 7350];\n  // byte 2\n  adtsObjectType = ((data[offset + 2] & 0xc0) >>> 6) + 1;\n  const adtsSamplingIndex = (data[offset + 2] & 0x3c) >>> 2;\n  if (adtsSamplingIndex > adtsSamplingRates.length - 1) {\n    const error = new Error(`invalid ADTS sampling index:${adtsSamplingIndex}`);\n    observer.emit(Events.ERROR, Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      fatal: true,\n      error,\n      reason: error.message\n    });\n    return;\n  }\n  adtsChannelConfig = (data[offset + 2] & 0x01) << 2;\n  // byte 3\n  adtsChannelConfig |= (data[offset + 3] & 0xc0) >>> 6;\n  logger.log(`manifest codec:${audioCodec}, ADTS type:${adtsObjectType}, samplingIndex:${adtsSamplingIndex}`);\n  // firefox: freq less than 24kHz = AAC SBR (HE-AAC)\n  if (/firefox/i.test(userAgent)) {\n    if (adtsSamplingIndex >= 6) {\n      adtsObjectType = 5;\n      config = new Array(4);\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      adtsObjectType = 2;\n      config = new Array(2);\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n    // Android : always use AAC\n  } else if (userAgent.indexOf('android') !== -1) {\n    adtsObjectType = 2;\n    config = new Array(2);\n    adtsExtensionSamplingIndex = adtsSamplingIndex;\n  } else {\n    /*  for other browsers (Chrome/Vivaldi/Opera ...)\n        always force audio type to be HE-AAC SBR, as some browsers do not support audio codec switch properly (like Chrome ...)\n    */\n    adtsObjectType = 5;\n    config = new Array(4);\n    // if (manifest codec is HE-AAC or HE-AACv2) OR (manifest codec not specified AND frequency less than 24kHz)\n    if (audioCodec && (audioCodec.indexOf('mp4a.40.29') !== -1 || audioCodec.indexOf('mp4a.40.5') !== -1) || !audioCodec && adtsSamplingIndex >= 6) {\n      // HE-AAC uses SBR (Spectral Band Replication) , high frequencies are constructed from low frequencies\n      // there is a factor 2 between frame sample rate and output sample rate\n      // multiply frequency by 2 (see table below, equivalent to substract 3)\n      adtsExtensionSamplingIndex = adtsSamplingIndex - 3;\n    } else {\n      // if (manifest codec is AAC) AND (frequency less than 24kHz AND nb channel is 1) OR (manifest codec not specified and mono audio)\n      // Chrome fails to play back with low frequency AAC LC mono when initialized with HE-AAC.  This is not a problem with stereo.\n      if (audioCodec && audioCodec.indexOf('mp4a.40.2') !== -1 && (adtsSamplingIndex >= 6 && adtsChannelConfig === 1 || /vivaldi/i.test(userAgent)) || !audioCodec && adtsChannelConfig === 1) {\n        adtsObjectType = 2;\n        config = new Array(2);\n      }\n      adtsExtensionSamplingIndex = adtsSamplingIndex;\n    }\n  }\n  /* refer to http://wiki.multimedia.cx/index.php?title=MPEG-4_Audio#Audio_Specific_Config\n      ISO 14496-3 (AAC).pdf - Table 1.13  Syntax of AudioSpecificConfig()\n    Audio Profile / Audio Object Type\n    0: Null\n    1: AAC Main\n    2: AAC LC (Low Complexity)\n    3: AAC SSR (Scalable Sample Rate)\n    4: AAC LTP (Long Term Prediction)\n    5: SBR (Spectral Band Replication)\n    6: AAC Scalable\n   sampling freq\n    0: 96000 Hz\n    1: 88200 Hz\n    2: 64000 Hz\n    3: 48000 Hz\n    4: 44100 Hz\n    5: 32000 Hz\n    6: 24000 Hz\n    7: 22050 Hz\n    8: 16000 Hz\n    9: 12000 Hz\n    10: 11025 Hz\n    11: 8000 Hz\n    12: 7350 Hz\n    13: Reserved\n    14: Reserved\n    15: frequency is written explictly\n    Channel Configurations\n    These are the channel configurations:\n    0: Defined in AOT Specifc Config\n    1: 1 channel: front-center\n    2: 2 channels: front-left, front-right\n  */\n  // audioObjectType = profile => profile, the MPEG-4 Audio Object Type minus 1\n  config[0] = adtsObjectType << 3;\n  // samplingFrequencyIndex\n  config[0] |= (adtsSamplingIndex & 0x0e) >> 1;\n  config[1] |= (adtsSamplingIndex & 0x01) << 7;\n  // channelConfiguration\n  config[1] |= adtsChannelConfig << 3;\n  if (adtsObjectType === 5) {\n    // adtsExtensionSamplingIndex\n    config[1] |= (adtsExtensionSamplingIndex & 0x0e) >> 1;\n    config[2] = (adtsExtensionSamplingIndex & 0x01) << 7;\n    // adtsObjectType (force to 2, chrome is checking that object type is less than 5 ???\n    //    https://chromium.googlesource.com/chromium/src.git/+/master/media/formats/mp4/aac.cc\n    config[2] |= 2 << 2;\n    config[3] = 0;\n  }\n  return {\n    config,\n    samplerate: adtsSamplingRates[adtsSamplingIndex],\n    channelCount: adtsChannelConfig,\n    codec: 'mp4a.40.' + adtsObjectType,\n    manifestCodec\n  };\n}\nfunction isHeaderPattern$1(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xf6) === 0xf0;\n}\nfunction getHeaderLength(data, offset) {\n  return data[offset + 1] & 0x01 ? 7 : 9;\n}\nfunction getFullFrameLength(data, offset) {\n  return (data[offset + 3] & 0x03) << 11 | data[offset + 4] << 3 | (data[offset + 5] & 0xe0) >>> 5;\n}\nfunction canGetFrameLength(data, offset) {\n  return offset + 5 < data.length;\n}\nfunction isHeader$1(data, offset) {\n  // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n  // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n  // More info https://wiki.multimedia.cx/index.php?title=ADTS\n  return offset + 1 < data.length && isHeaderPattern$1(data, offset);\n}\nfunction canParse$1(data, offset) {\n  return canGetFrameLength(data, offset) && isHeaderPattern$1(data, offset) && getFullFrameLength(data, offset) <= data.length - offset;\n}\nfunction probe$1(data, offset) {\n  // same as isHeader but we also check that ADTS frame follows last ADTS frame\n  // or end of data is reached\n  if (isHeader$1(data, offset)) {\n    // ADTS header Length\n    const headerLength = getHeaderLength(data, offset);\n    if (offset + headerLength >= data.length) {\n      return false;\n    }\n    // ADTS frame Length\n    const frameLength = getFullFrameLength(data, offset);\n    if (frameLength <= headerLength) {\n      return false;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader$1(data, newOffset);\n  }\n  return false;\n}\nfunction initTrackConfig(track, observer, data, offset, audioCodec) {\n  if (!track.samplerate) {\n    const config = getAudioConfig(observer, data, offset, audioCodec);\n    if (!config) {\n      return;\n    }\n    track.config = config.config;\n    track.samplerate = config.samplerate;\n    track.channelCount = config.channelCount;\n    track.codec = config.codec;\n    track.manifestCodec = config.manifestCodec;\n    logger.log(`parsed codec:${track.codec}, rate:${config.samplerate}, channels:${config.channelCount}`);\n  }\n}\nfunction getFrameDuration(samplerate) {\n  return 1024 * 90000 / samplerate;\n}\nfunction parseFrameHeader(data, offset) {\n  // The protection skip bit tells us if we have 2 bytes of CRC data at the end of the ADTS header\n  const headerLength = getHeaderLength(data, offset);\n  if (offset + headerLength <= data.length) {\n    // retrieve frame size\n    const frameLength = getFullFrameLength(data, offset) - headerLength;\n    if (frameLength > 0) {\n      // logger.log(`AAC frame, offset/length/total/pts:${offset+headerLength}/${frameLength}/${data.byteLength}`);\n      return {\n        headerLength,\n        frameLength\n      };\n    }\n  }\n}\nfunction appendFrame$2(track, data, offset, pts, frameIndex) {\n  const frameDuration = getFrameDuration(track.samplerate);\n  const stamp = pts + frameIndex * frameDuration;\n  const header = parseFrameHeader(data, offset);\n  let unit;\n  if (header) {\n    const {\n      frameLength,\n      headerLength\n    } = header;\n    const _length = headerLength + frameLength;\n    const missing = Math.max(0, offset + _length - data.length);\n    // logger.log(`AAC frame ${frameIndex}, pts:${stamp} length@offset/total: ${frameLength}@${offset+headerLength}/${data.byteLength} missing: ${missing}`);\n    if (missing) {\n      unit = new Uint8Array(_length - headerLength);\n      unit.set(data.subarray(offset + headerLength, data.length), 0);\n    } else {\n      unit = data.subarray(offset + headerLength, offset + _length);\n    }\n    const _sample = {\n      unit,\n      pts: stamp\n    };\n    if (!missing) {\n      track.samples.push(_sample);\n    }\n    return {\n      sample: _sample,\n      length: _length,\n      missing\n    };\n  }\n  // overflow incomplete header\n  const length = data.length - offset;\n  unit = new Uint8Array(length);\n  unit.set(data.subarray(offset, data.length), 0);\n  const sample = {\n    unit,\n    pts: stamp\n  };\n  return {\n    sample,\n    length,\n    missing: -1\n  };\n}\n\n/**\n *  MPEG parser helper\n */\n\nlet chromeVersion$1 = null;\nconst BitratesMap = [32, 64, 96, 128, 160, 192, 224, 256, 288, 320, 352, 384, 416, 448, 32, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 384, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320, 32, 48, 56, 64, 80, 96, 112, 128, 144, 160, 176, 192, 224, 256, 8, 16, 24, 32, 40, 48, 56, 64, 80, 96, 112, 128, 144, 160];\nconst SamplingRateMap = [44100, 48000, 32000, 22050, 24000, 16000, 11025, 12000, 8000];\nconst SamplesCoefficients = [\n// MPEG 2.5\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// Reserved\n[0,\n// Reserved\n0,\n// Layer3\n0,\n// Layer2\n0 // Layer1\n],\n// MPEG 2\n[0,\n// Reserved\n72,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n],\n// MPEG 1\n[0,\n// Reserved\n144,\n// Layer3\n144,\n// Layer2\n12 // Layer1\n]];\nconst BytesInSlot = [0,\n// Reserved\n1,\n// Layer3\n1,\n// Layer2\n4 // Layer1\n];\nfunction appendFrame$1(track, data, offset, pts, frameIndex) {\n  // Using http://www.datavoyage.com/mpgscript/mpeghdr.htm as a reference\n  if (offset + 24 > data.length) {\n    return;\n  }\n  const header = parseHeader(data, offset);\n  if (header && offset + header.frameLength <= data.length) {\n    const frameDuration = header.samplesPerFrame * 90000 / header.sampleRate;\n    const stamp = pts + frameIndex * frameDuration;\n    const sample = {\n      unit: data.subarray(offset, offset + header.frameLength),\n      pts: stamp,\n      dts: stamp\n    };\n    track.config = [];\n    track.channelCount = header.channelCount;\n    track.samplerate = header.sampleRate;\n    track.samples.push(sample);\n    return {\n      sample,\n      length: header.frameLength,\n      missing: 0\n    };\n  }\n}\nfunction parseHeader(data, offset) {\n  const mpegVersion = data[offset + 1] >> 3 & 3;\n  const mpegLayer = data[offset + 1] >> 1 & 3;\n  const bitRateIndex = data[offset + 2] >> 4 & 15;\n  const sampleRateIndex = data[offset + 2] >> 2 & 3;\n  if (mpegVersion !== 1 && bitRateIndex !== 0 && bitRateIndex !== 15 && sampleRateIndex !== 3) {\n    const paddingBit = data[offset + 2] >> 1 & 1;\n    const channelMode = data[offset + 3] >> 6;\n    const columnInBitrates = mpegVersion === 3 ? 3 - mpegLayer : mpegLayer === 3 ? 3 : 4;\n    const bitRate = BitratesMap[columnInBitrates * 14 + bitRateIndex - 1] * 1000;\n    const columnInSampleRates = mpegVersion === 3 ? 0 : mpegVersion === 2 ? 1 : 2;\n    const sampleRate = SamplingRateMap[columnInSampleRates * 3 + sampleRateIndex];\n    const channelCount = channelMode === 3 ? 1 : 2; // If bits of channel mode are `11` then it is a single channel (Mono)\n    const sampleCoefficient = SamplesCoefficients[mpegVersion][mpegLayer];\n    const bytesInSlot = BytesInSlot[mpegLayer];\n    const samplesPerFrame = sampleCoefficient * 8 * bytesInSlot;\n    const frameLength = Math.floor(sampleCoefficient * bitRate / sampleRate + paddingBit) * bytesInSlot;\n    if (chromeVersion$1 === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion$1 = result ? parseInt(result[1]) : 0;\n    }\n    const needChromeFix = !!chromeVersion$1 && chromeVersion$1 <= 87;\n    if (needChromeFix && mpegLayer === 2 && bitRate >= 224000 && channelMode === 0) {\n      // Work around bug in Chromium by setting channelMode to dual-channel (01) instead of stereo (00)\n      data[offset + 3] = data[offset + 3] | 0x80;\n    }\n    return {\n      sampleRate,\n      channelCount,\n      frameLength,\n      samplesPerFrame\n    };\n  }\n}\nfunction isHeaderPattern(data, offset) {\n  return data[offset] === 0xff && (data[offset + 1] & 0xe0) === 0xe0 && (data[offset + 1] & 0x06) !== 0x00;\n}\nfunction isHeader(data, offset) {\n  // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n  // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n  // More info http://www.mp3-tech.org/programmer/frame_header.html\n  return offset + 1 < data.length && isHeaderPattern(data, offset);\n}\nfunction canParse(data, offset) {\n  const headerSize = 4;\n  return isHeaderPattern(data, offset) && headerSize <= data.length - offset;\n}\nfunction probe(data, offset) {\n  // same as isHeader but we also check that MPEG frame follows last MPEG frame\n  // or end of data is reached\n  if (offset + 1 < data.length && isHeaderPattern(data, offset)) {\n    // MPEG header Length\n    const headerLength = 4;\n    // MPEG frame Length\n    const header = parseHeader(data, offset);\n    let frameLength = headerLength;\n    if (header != null && header.frameLength) {\n      frameLength = header.frameLength;\n    }\n    const newOffset = offset + frameLength;\n    return newOffset === data.length || isHeader(data, newOffset);\n  }\n  return false;\n}\n\n/**\n * AAC demuxer\n */\nclass AACDemuxer extends BaseAudioDemuxer {\n  constructor(observer, config) {\n    super();\n    this.observer = void 0;\n    this.config = void 0;\n    this.observer = observer;\n    this.config = config;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/adts',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'aac',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n\n  // Source for probe info - https://wiki.multimedia.cx/index.php?title=ADTS\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // Check for the ADTS sync word\n    // Look for ADTS header | 1111 1111 | 1111 X00X | where X can be either 0 or 1\n    // Layer bits (position 14 and 15) in header should be always 0 for ADTS\n    // More info https://wiki.multimedia.cx/index.php?title=ADTS\n    const id3Data = getID3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n    if (probe(data, offset)) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe$1(data, offset)) {\n        logger.log('ADTS sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse$1(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    initTrackConfig(track, this.observer, data, offset, track.manifestCodec);\n    const frame = appendFrame$2(track, data, offset, this.basePTS, this.frameIndex);\n    if (frame && frame.missing === 0) {\n      return frame;\n    }\n  }\n}\n\nconst emsgSchemePattern = /\\/emsg[-/]ID3/i;\nclass MP4Demuxer {\n  constructor(observer, config) {\n    this.remainderData = null;\n    this.timeOffset = 0;\n    this.config = void 0;\n    this.videoTrack = void 0;\n    this.audioTrack = void 0;\n    this.id3Track = void 0;\n    this.txtTrack = void 0;\n    this.config = config;\n  }\n  resetTimeStamp() {}\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    const videoTrack = this.videoTrack = dummyTrack('video', 1);\n    const audioTrack = this.audioTrack = dummyTrack('audio', 1);\n    const captionTrack = this.txtTrack = dummyTrack('text', 1);\n    this.id3Track = dummyTrack('id3', 1);\n    this.timeOffset = 0;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      return;\n    }\n    const initData = parseInitSegment(initSegment);\n    if (initData.video) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.video;\n      videoTrack.id = id;\n      videoTrack.timescale = captionTrack.timescale = timescale;\n      videoTrack.codec = codec;\n    }\n    if (initData.audio) {\n      const {\n        id,\n        timescale,\n        codec\n      } = initData.audio;\n      audioTrack.id = id;\n      audioTrack.timescale = timescale;\n      audioTrack.codec = codec;\n    }\n    captionTrack.id = RemuxerTrackIdConfig.text;\n    videoTrack.sampleDuration = 0;\n    videoTrack.duration = audioTrack.duration = trackDuration;\n  }\n  resetContiguity() {\n    this.remainderData = null;\n  }\n  static probe(data) {\n    return hasMoofData(data);\n  }\n  demux(data, timeOffset) {\n    this.timeOffset = timeOffset;\n    // Load all data into the avc track. The CMAF remuxer will look for the data in the samples object; the rest of the fields do not matter\n    let videoSamples = data;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    if (this.config.progressive) {\n      // Split the bytestream into two ranges: one encompassing all data up until the start of the last moof, and everything else.\n      // This is done to guarantee that we're sending valid data to MSE - when demuxing progressively, we have no guarantee\n      // that the fetch loader gives us flush moof+mdat pairs. If we push jagged data to MSE, it will throw an exception.\n      if (this.remainderData) {\n        videoSamples = appendUint8Array(this.remainderData, data);\n      }\n      const segmentedData = segmentValidRange(videoSamples);\n      this.remainderData = segmentedData.remainder;\n      videoTrack.samples = segmentedData.valid || new Uint8Array();\n    } else {\n      videoTrack.samples = videoSamples;\n    }\n    const id3Track = this.extractID3Track(videoTrack, timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: this.audioTrack,\n      id3Track,\n      textTrack: this.txtTrack\n    };\n  }\n  flush() {\n    const timeOffset = this.timeOffset;\n    const videoTrack = this.videoTrack;\n    const textTrack = this.txtTrack;\n    videoTrack.samples = this.remainderData || new Uint8Array();\n    this.remainderData = null;\n    const id3Track = this.extractID3Track(videoTrack, this.timeOffset);\n    textTrack.samples = parseSamples(timeOffset, videoTrack);\n    return {\n      videoTrack,\n      audioTrack: dummyTrack(),\n      id3Track,\n      textTrack: dummyTrack()\n    };\n  }\n  extractID3Track(videoTrack, timeOffset) {\n    const id3Track = this.id3Track;\n    if (videoTrack.samples.length) {\n      const emsgs = findBox(videoTrack.samples, ['emsg']);\n      if (emsgs) {\n        emsgs.forEach(data => {\n          const emsgInfo = parseEmsg(data);\n          if (emsgSchemePattern.test(emsgInfo.schemeIdUri)) {\n            const pts = isFiniteNumber(emsgInfo.presentationTime) ? emsgInfo.presentationTime / emsgInfo.timeScale : timeOffset + emsgInfo.presentationTimeDelta / emsgInfo.timeScale;\n            let duration = emsgInfo.eventDuration === 0xffffffff ? Number.POSITIVE_INFINITY : emsgInfo.eventDuration / emsgInfo.timeScale;\n            // Safari takes anything <= 0.001 seconds and maps it to Infinity\n            if (duration <= 0.001) {\n              duration = Number.POSITIVE_INFINITY;\n            }\n            const payload = emsgInfo.payload;\n            id3Track.samples.push({\n              data: payload,\n              len: payload.byteLength,\n              dts: pts,\n              pts: pts,\n              type: MetadataSchema.emsg,\n              duration: duration\n            });\n          }\n        });\n      }\n    }\n    return id3Track;\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    return Promise.reject(new Error('The MP4 demuxer does not support SAMPLE-AES decryption'));\n  }\n  destroy() {}\n}\n\nconst getAudioBSID = (data, offset) => {\n  // check the bsid to confirm ac-3 | ec-3\n  let bsid = 0;\n  let numBits = 5;\n  offset += numBits;\n  const temp = new Uint32Array(1); // unsigned 32 bit for temporary storage\n  const mask = new Uint32Array(1); // unsigned 32 bit mask value\n  const byte = new Uint8Array(1); // unsigned 8 bit for temporary storage\n  while (numBits > 0) {\n    byte[0] = data[offset];\n    // read remaining bits, upto 8 bits at a time\n    const bits = Math.min(numBits, 8);\n    const shift = 8 - bits;\n    mask[0] = 0xff000000 >>> 24 + shift << shift;\n    temp[0] = (byte[0] & mask[0]) >> shift;\n    bsid = !bsid ? temp[0] : bsid << bits | temp[0];\n    offset += 1;\n    numBits -= bits;\n  }\n  return bsid;\n};\n\nclass AC3Demuxer extends BaseAudioDemuxer {\n  constructor(observer) {\n    super();\n    this.observer = void 0;\n    this.observer = observer;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/ac-3',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'ac3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  canParse(data, offset) {\n    return offset + 64 < data.length;\n  }\n  appendFrame(track, data, offset) {\n    const frameLength = appendFrame(track, data, offset, this.basePTS, this.frameIndex);\n    if (frameLength !== -1) {\n      const sample = track.samples[track.samples.length - 1];\n      return {\n        sample,\n        length: frameLength,\n        missing: 0\n      };\n    }\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n    const id3Data = getID3Data(data, 0);\n    if (!id3Data) {\n      return false;\n    }\n\n    // look for the ac-3 sync bytes\n    const offset = id3Data.length;\n    if (data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined &&\n    // check the bsid to confirm ac-3\n    getAudioBSID(data, offset) < 16) {\n      return true;\n    }\n    return false;\n  }\n}\nfunction appendFrame(track, data, start, pts, frameIndex) {\n  if (start + 8 > data.length) {\n    return -1; // not enough bytes left\n  }\n  if (data[start] !== 0x0b || data[start + 1] !== 0x77) {\n    return -1; // invalid magic\n  }\n\n  // get sample rate\n  const samplingRateCode = data[start + 4] >> 6;\n  if (samplingRateCode >= 3) {\n    return -1; // invalid sampling rate\n  }\n  const samplingRateMap = [48000, 44100, 32000];\n  const sampleRate = samplingRateMap[samplingRateCode];\n\n  // get frame size\n  const frameSizeCode = data[start + 4] & 0x3f;\n  const frameSizeMap = [64, 69, 96, 64, 70, 96, 80, 87, 120, 80, 88, 120, 96, 104, 144, 96, 105, 144, 112, 121, 168, 112, 122, 168, 128, 139, 192, 128, 140, 192, 160, 174, 240, 160, 175, 240, 192, 208, 288, 192, 209, 288, 224, 243, 336, 224, 244, 336, 256, 278, 384, 256, 279, 384, 320, 348, 480, 320, 349, 480, 384, 417, 576, 384, 418, 576, 448, 487, 672, 448, 488, 672, 512, 557, 768, 512, 558, 768, 640, 696, 960, 640, 697, 960, 768, 835, 1152, 768, 836, 1152, 896, 975, 1344, 896, 976, 1344, 1024, 1114, 1536, 1024, 1115, 1536, 1152, 1253, 1728, 1152, 1254, 1728, 1280, 1393, 1920, 1280, 1394, 1920];\n  const frameLength = frameSizeMap[frameSizeCode * 3 + samplingRateCode] * 2;\n  if (start + frameLength > data.length) {\n    return -1;\n  }\n\n  // get channel count\n  const channelMode = data[start + 6] >> 5;\n  let skipCount = 0;\n  if (channelMode === 2) {\n    skipCount += 2;\n  } else {\n    if (channelMode & 1 && channelMode !== 1) {\n      skipCount += 2;\n    }\n    if (channelMode & 4) {\n      skipCount += 2;\n    }\n  }\n  const lfeon = (data[start + 6] << 8 | data[start + 7]) >> 12 - skipCount & 1;\n  const channelsMap = [2, 1, 2, 3, 3, 4, 4, 5];\n  const channelCount = channelsMap[channelMode] + lfeon;\n\n  // build dac3 box\n  const bsid = data[start + 5] >> 3;\n  const bsmod = data[start + 5] & 7;\n  const config = new Uint8Array([samplingRateCode << 6 | bsid << 1 | bsmod >> 2, (bsmod & 3) << 6 | channelMode << 3 | lfeon << 2 | frameSizeCode >> 4, frameSizeCode << 4 & 0xe0]);\n  const frameDuration = 1536 / sampleRate * 90000;\n  const stamp = pts + frameIndex * frameDuration;\n  const unit = data.subarray(start, start + frameLength);\n  track.config = config;\n  track.channelCount = channelCount;\n  track.samplerate = sampleRate;\n  track.samples.push({\n    unit,\n    pts: stamp\n  });\n  return frameLength;\n}\n\nclass BaseVideoParser {\n  constructor() {\n    this.VideoSample = null;\n  }\n  createVideoSample(key, pts, dts, debug) {\n    return {\n      key,\n      frame: false,\n      pts,\n      dts,\n      units: [],\n      debug,\n      length: 0\n    };\n  }\n  getLastNalUnit(samples) {\n    var _VideoSample;\n    let VideoSample = this.VideoSample;\n    let lastUnit;\n    // try to fallback to previous sample if current one is empty\n    if (!VideoSample || VideoSample.units.length === 0) {\n      VideoSample = samples[samples.length - 1];\n    }\n    if ((_VideoSample = VideoSample) != null && _VideoSample.units) {\n      const units = VideoSample.units;\n      lastUnit = units[units.length - 1];\n    }\n    return lastUnit;\n  }\n  pushAccessUnit(VideoSample, videoTrack) {\n    if (VideoSample.units.length && VideoSample.frame) {\n      // if sample does not have PTS/DTS, patch with last sample PTS/DTS\n      if (VideoSample.pts === undefined) {\n        const samples = videoTrack.samples;\n        const nbSamples = samples.length;\n        if (nbSamples) {\n          const lastSample = samples[nbSamples - 1];\n          VideoSample.pts = lastSample.pts;\n          VideoSample.dts = lastSample.dts;\n        } else {\n          // dropping samples, no timestamp found\n          videoTrack.dropped++;\n          return;\n        }\n      }\n      videoTrack.samples.push(VideoSample);\n    }\n    if (VideoSample.debug.length) {\n      logger.log(VideoSample.pts + '/' + VideoSample.dts + ':' + VideoSample.debug);\n    }\n  }\n}\n\n/**\n * Parser for exponential Golomb codes, a variable-bitwidth number encoding scheme used by h264.\n */\n\nclass ExpGolomb {\n  constructor(data) {\n    this.data = void 0;\n    this.bytesAvailable = void 0;\n    this.word = void 0;\n    this.bitsAvailable = void 0;\n    this.data = data;\n    // the number of bytes left to examine in this.data\n    this.bytesAvailable = data.byteLength;\n    // the current word being examined\n    this.word = 0; // :uint\n    // the number of bits left to examine in the current word\n    this.bitsAvailable = 0; // :uint\n  }\n\n  // ():void\n  loadWord() {\n    const data = this.data;\n    const bytesAvailable = this.bytesAvailable;\n    const position = data.byteLength - bytesAvailable;\n    const workingBytes = new Uint8Array(4);\n    const availableBytes = Math.min(4, bytesAvailable);\n    if (availableBytes === 0) {\n      throw new Error('no bytes available');\n    }\n    workingBytes.set(data.subarray(position, position + availableBytes));\n    this.word = new DataView(workingBytes.buffer).getUint32(0);\n    // track the amount of this.data that has been processed\n    this.bitsAvailable = availableBytes * 8;\n    this.bytesAvailable -= availableBytes;\n  }\n\n  // (count:int):void\n  skipBits(count) {\n    let skipBytes; // :int\n    count = Math.min(count, this.bytesAvailable * 8 + this.bitsAvailable);\n    if (this.bitsAvailable > count) {\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    } else {\n      count -= this.bitsAvailable;\n      skipBytes = count >> 3;\n      count -= skipBytes << 3;\n      this.bytesAvailable -= skipBytes;\n      this.loadWord();\n      this.word <<= count;\n      this.bitsAvailable -= count;\n    }\n  }\n\n  // (size:int):uint\n  readBits(size) {\n    let bits = Math.min(this.bitsAvailable, size); // :uint\n    const valu = this.word >>> 32 - bits; // :uint\n    if (size > 32) {\n      logger.error('Cannot read more than 32 bits at a time');\n    }\n    this.bitsAvailable -= bits;\n    if (this.bitsAvailable > 0) {\n      this.word <<= bits;\n    } else if (this.bytesAvailable > 0) {\n      this.loadWord();\n    } else {\n      throw new Error('no bits available');\n    }\n    bits = size - bits;\n    if (bits > 0 && this.bitsAvailable) {\n      return valu << bits | this.readBits(bits);\n    } else {\n      return valu;\n    }\n  }\n\n  // ():uint\n  skipLZ() {\n    let leadingZeroCount; // :uint\n    for (leadingZeroCount = 0; leadingZeroCount < this.bitsAvailable; ++leadingZeroCount) {\n      if ((this.word & 0x80000000 >>> leadingZeroCount) !== 0) {\n        // the first bit of working word is 1\n        this.word <<= leadingZeroCount;\n        this.bitsAvailable -= leadingZeroCount;\n        return leadingZeroCount;\n      }\n    }\n    // we exhausted word and still have not found a 1\n    this.loadWord();\n    return leadingZeroCount + this.skipLZ();\n  }\n\n  // ():void\n  skipUEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():void\n  skipEG() {\n    this.skipBits(1 + this.skipLZ());\n  }\n\n  // ():uint\n  readUEG() {\n    const clz = this.skipLZ(); // :uint\n    return this.readBits(clz + 1) - 1;\n  }\n\n  // ():int\n  readEG() {\n    const valu = this.readUEG(); // :int\n    if (0x01 & valu) {\n      // the number is odd if the low order bit is set\n      return 1 + valu >>> 1; // add 1 to make it even, and divide by 2\n    } else {\n      return -1 * (valu >>> 1); // divide by two then make it negative\n    }\n  }\n\n  // Some convenience functions\n  // :Boolean\n  readBoolean() {\n    return this.readBits(1) === 1;\n  }\n\n  // ():int\n  readUByte() {\n    return this.readBits(8);\n  }\n\n  // ():int\n  readUShort() {\n    return this.readBits(16);\n  }\n\n  // ():int\n  readUInt() {\n    return this.readBits(32);\n  }\n\n  /**\n   * Advance the ExpGolomb decoder past a scaling list. The scaling\n   * list is optionally transmitted as part of a sequence parameter\n   * set and is not relevant to transmuxing.\n   * @param count the number of entries in this scaling list\n   * @see Recommendation ITU-T H.264, Section 7.3.2.1.1.1\n   */\n  skipScalingList(count) {\n    let lastScale = 8;\n    let nextScale = 8;\n    let deltaScale;\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG();\n        nextScale = (lastScale + deltaScale + 256) % 256;\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale;\n    }\n  }\n\n  /**\n   * Read a sequence parameter set and return some interesting video\n   * properties. A sequence parameter set is the H264 metadata that\n   * describes the properties of upcoming video frames.\n   * @returns an object with configuration parsed from the\n   * sequence parameter set, including the dimensions of the\n   * associated video frames.\n   */\n  readSPS() {\n    let frameCropLeftOffset = 0;\n    let frameCropRightOffset = 0;\n    let frameCropTopOffset = 0;\n    let frameCropBottomOffset = 0;\n    let numRefFramesInPicOrderCntCycle;\n    let scalingListCount;\n    let i;\n    const readUByte = this.readUByte.bind(this);\n    const readBits = this.readBits.bind(this);\n    const readUEG = this.readUEG.bind(this);\n    const readBoolean = this.readBoolean.bind(this);\n    const skipBits = this.skipBits.bind(this);\n    const skipEG = this.skipEG.bind(this);\n    const skipUEG = this.skipUEG.bind(this);\n    const skipScalingList = this.skipScalingList.bind(this);\n    readUByte();\n    const profileIdc = readUByte(); // profile_idc\n    readBits(5); // profileCompat constraint_set[0-4]_flag, u(5)\n    skipBits(3); // reserved_zero_3bits u(3),\n    readUByte(); // level_idc u(8)\n    skipUEG(); // seq_parameter_set_id\n    // some profiles have more optional data we don't need\n    if (profileIdc === 100 || profileIdc === 110 || profileIdc === 122 || profileIdc === 244 || profileIdc === 44 || profileIdc === 83 || profileIdc === 86 || profileIdc === 118 || profileIdc === 128) {\n      const chromaFormatIdc = readUEG();\n      if (chromaFormatIdc === 3) {\n        skipBits(1);\n      } // separate_colour_plane_flag\n\n      skipUEG(); // bit_depth_luma_minus8\n      skipUEG(); // bit_depth_chroma_minus8\n      skipBits(1); // qpprime_y_zero_transform_bypass_flag\n      if (readBoolean()) {\n        // seq_scaling_matrix_present_flag\n        scalingListCount = chromaFormatIdc !== 3 ? 8 : 12;\n        for (i = 0; i < scalingListCount; i++) {\n          if (readBoolean()) {\n            // seq_scaling_list_present_flag[ i ]\n            if (i < 6) {\n              skipScalingList(16);\n            } else {\n              skipScalingList(64);\n            }\n          }\n        }\n      }\n    }\n    skipUEG(); // log2_max_frame_num_minus4\n    const picOrderCntType = readUEG();\n    if (picOrderCntType === 0) {\n      readUEG(); // log2_max_pic_order_cnt_lsb_minus4\n    } else if (picOrderCntType === 1) {\n      skipBits(1); // delta_pic_order_always_zero_flag\n      skipEG(); // offset_for_non_ref_pic\n      skipEG(); // offset_for_top_to_bottom_field\n      numRefFramesInPicOrderCntCycle = readUEG();\n      for (i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        skipEG();\n      } // offset_for_ref_frame[ i ]\n    }\n    skipUEG(); // max_num_ref_frames\n    skipBits(1); // gaps_in_frame_num_value_allowed_flag\n    const picWidthInMbsMinus1 = readUEG();\n    const picHeightInMapUnitsMinus1 = readUEG();\n    const frameMbsOnlyFlag = readBits(1);\n    if (frameMbsOnlyFlag === 0) {\n      skipBits(1);\n    } // mb_adaptive_frame_field_flag\n\n    skipBits(1); // direct_8x8_inference_flag\n    if (readBoolean()) {\n      // frame_cropping_flag\n      frameCropLeftOffset = readUEG();\n      frameCropRightOffset = readUEG();\n      frameCropTopOffset = readUEG();\n      frameCropBottomOffset = readUEG();\n    }\n    let pixelRatio = [1, 1];\n    if (readBoolean()) {\n      // vui_parameters_present_flag\n      if (readBoolean()) {\n        // aspect_ratio_info_present_flag\n        const aspectRatioIdc = readUByte();\n        switch (aspectRatioIdc) {\n          case 1:\n            pixelRatio = [1, 1];\n            break;\n          case 2:\n            pixelRatio = [12, 11];\n            break;\n          case 3:\n            pixelRatio = [10, 11];\n            break;\n          case 4:\n            pixelRatio = [16, 11];\n            break;\n          case 5:\n            pixelRatio = [40, 33];\n            break;\n          case 6:\n            pixelRatio = [24, 11];\n            break;\n          case 7:\n            pixelRatio = [20, 11];\n            break;\n          case 8:\n            pixelRatio = [32, 11];\n            break;\n          case 9:\n            pixelRatio = [80, 33];\n            break;\n          case 10:\n            pixelRatio = [18, 11];\n            break;\n          case 11:\n            pixelRatio = [15, 11];\n            break;\n          case 12:\n            pixelRatio = [64, 33];\n            break;\n          case 13:\n            pixelRatio = [160, 99];\n            break;\n          case 14:\n            pixelRatio = [4, 3];\n            break;\n          case 15:\n            pixelRatio = [3, 2];\n            break;\n          case 16:\n            pixelRatio = [2, 1];\n            break;\n          case 255:\n            {\n              pixelRatio = [readUByte() << 8 | readUByte(), readUByte() << 8 | readUByte()];\n              break;\n            }\n        }\n      }\n    }\n    return {\n      width: Math.ceil((picWidthInMbsMinus1 + 1) * 16 - frameCropLeftOffset * 2 - frameCropRightOffset * 2),\n      height: (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 - (frameMbsOnlyFlag ? 2 : 4) * (frameCropTopOffset + frameCropBottomOffset),\n      pixelRatio: pixelRatio\n    };\n  }\n  readSliceType() {\n    // skip NALu type\n    this.readUByte();\n    // discard first_mb_in_slice\n    this.readUEG();\n    // return slice_type\n    return this.readUEG();\n  }\n}\n\nclass AvcVideoParser extends BaseVideoParser {\n  parseAVCPES(track, textTrack, pes, last, duration) {\n    const units = this.parseAVCNALu(track, pes.data);\n    let VideoSample = this.VideoSample;\n    let push;\n    let spsfound = false;\n    // free pes.data to save up some memory\n    pes.data = null;\n\n    // if new NAL units found and last sample still there, let's push ...\n    // this helps parsing streams with missing AUD (only do this if AUD never found)\n    if (VideoSample && units.length && !track.audFound) {\n      this.pushAccessUnit(VideoSample, track);\n      VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, '');\n    }\n    units.forEach(unit => {\n      var _VideoSample2;\n      switch (unit.type) {\n        // NDR\n        case 1:\n          {\n            let iskey = false;\n            push = true;\n            const data = unit.data;\n            // only check slice type to detect KF in case SPS found in same packet (any keyframe is preceded by SPS ...)\n            if (spsfound && data.length > 4) {\n              // retrieve slice type by parsing beginning of NAL unit (follow H264 spec, slice_header definition) to detect keyframe embedded in NDR\n              const sliceType = new ExpGolomb(data).readSliceType();\n              // 2 : I slice, 4 : SI slice, 7 : I slice, 9: SI slice\n              // SI slice : A slice that is coded using intra prediction only and using quantisation of the prediction samples.\n              // An SI slice can be coded such that its decoded samples can be constructed identically to an SP slice.\n              // I slice: A slice that is not an SI slice that is decoded using intra prediction only.\n              // if (sliceType === 2 || sliceType === 7) {\n              if (sliceType === 2 || sliceType === 4 || sliceType === 7 || sliceType === 9) {\n                iskey = true;\n              }\n            }\n            if (iskey) {\n              var _VideoSample;\n              // if we have non-keyframe data already, that cannot belong to the same frame as a keyframe, so force a push\n              if ((_VideoSample = VideoSample) != null && _VideoSample.frame && !VideoSample.key) {\n                this.pushAccessUnit(VideoSample, track);\n                VideoSample = this.VideoSample = null;\n              }\n            }\n            if (!VideoSample) {\n              VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, '');\n            }\n            VideoSample.frame = true;\n            VideoSample.key = iskey;\n            break;\n            // IDR\n          }\n        case 5:\n          push = true;\n          // handle PES not starting with AUD\n          // if we have frame data already, that cannot belong to the same frame, so force a push\n          if ((_VideoSample2 = VideoSample) != null && _VideoSample2.frame && !VideoSample.key) {\n            this.pushAccessUnit(VideoSample, track);\n            VideoSample = this.VideoSample = null;\n          }\n          if (!VideoSample) {\n            VideoSample = this.VideoSample = this.createVideoSample(true, pes.pts, pes.dts, '');\n          }\n          VideoSample.key = true;\n          VideoSample.frame = true;\n          break;\n        // SEI\n        case 6:\n          {\n            push = true;\n            parseSEIMessageFromNALu(unit.data, 1, pes.pts, textTrack.samples);\n            break;\n            // SPS\n          }\n        case 7:\n          {\n            var _track$pixelRatio, _track$pixelRatio2;\n            push = true;\n            spsfound = true;\n            const sps = unit.data;\n            const expGolombDecoder = new ExpGolomb(sps);\n            const config = expGolombDecoder.readSPS();\n            if (!track.sps || track.width !== config.width || track.height !== config.height || ((_track$pixelRatio = track.pixelRatio) == null ? void 0 : _track$pixelRatio[0]) !== config.pixelRatio[0] || ((_track$pixelRatio2 = track.pixelRatio) == null ? void 0 : _track$pixelRatio2[1]) !== config.pixelRatio[1]) {\n              track.width = config.width;\n              track.height = config.height;\n              track.pixelRatio = config.pixelRatio;\n              track.sps = [sps];\n              track.duration = duration;\n              const codecarray = sps.subarray(1, 4);\n              let codecstring = 'avc1.';\n              for (let i = 0; i < 3; i++) {\n                let h = codecarray[i].toString(16);\n                if (h.length < 2) {\n                  h = '0' + h;\n                }\n                codecstring += h;\n              }\n              track.codec = codecstring;\n            }\n            break;\n          }\n        // PPS\n        case 8:\n          push = true;\n          track.pps = [unit.data];\n          break;\n        // AUD\n        case 9:\n          push = true;\n          track.audFound = true;\n          if (VideoSample) {\n            this.pushAccessUnit(VideoSample, track);\n          }\n          VideoSample = this.VideoSample = this.createVideoSample(false, pes.pts, pes.dts, '');\n          break;\n        // Filler Data\n        case 12:\n          push = true;\n          break;\n        default:\n          push = false;\n          if (VideoSample) {\n            VideoSample.debug += 'unknown NAL ' + unit.type + ' ';\n          }\n          break;\n      }\n      if (VideoSample && push) {\n        const units = VideoSample.units;\n        units.push(unit);\n      }\n    });\n    // if last PES packet, push samples\n    if (last && VideoSample) {\n      this.pushAccessUnit(VideoSample, track);\n      this.VideoSample = null;\n    }\n  }\n  parseAVCNALu(track, array) {\n    const len = array.byteLength;\n    let state = track.naluState || 0;\n    const lastState = state;\n    const units = [];\n    let i = 0;\n    let value;\n    let overflow;\n    let unitType;\n    let lastUnitStart = -1;\n    let lastUnitType = 0;\n    // logger.log('PES:' + Hex.hexDump(array));\n\n    if (state === -1) {\n      // special use case where we found 3 or 4-byte start codes exactly at the end of previous PES packet\n      lastUnitStart = 0;\n      // NALu type is value read from offset 0\n      lastUnitType = array[0] & 0x1f;\n      state = 0;\n      i = 1;\n    }\n    while (i < len) {\n      value = array[i++];\n      // optimization. state 0 and 1 are the predominant case. let's handle them outside of the switch/case\n      if (!state) {\n        state = value ? 0 : 1;\n        continue;\n      }\n      if (state === 1) {\n        state = value ? 0 : 2;\n        continue;\n      }\n      // here we have state either equal to 2 or 3\n      if (!value) {\n        state = 3;\n      } else if (value === 1) {\n        overflow = i - state - 1;\n        if (lastUnitStart >= 0) {\n          const unit = {\n            data: array.subarray(lastUnitStart, overflow),\n            type: lastUnitType\n          };\n          // logger.log('pushing NALU, type/size:' + unit.type + '/' + unit.data.byteLength);\n          units.push(unit);\n        } else {\n          // lastUnitStart is undefined => this is the first start code found in this PES packet\n          // first check if start code delimiter is overlapping between 2 PES packets,\n          // ie it started in last packet (lastState not zero)\n          // and ended at the beginning of this PES packet (i <= 4 - lastState)\n          const lastUnit = this.getLastNalUnit(track.samples);\n          if (lastUnit) {\n            if (lastState && i <= 4 - lastState) {\n              // start delimiter overlapping between PES packets\n              // strip start delimiter bytes from the end of last NAL unit\n              // check if lastUnit had a state different from zero\n              if (lastUnit.state) {\n                // strip last bytes\n                lastUnit.data = lastUnit.data.subarray(0, lastUnit.data.byteLength - lastState);\n              }\n            }\n            // If NAL units are not starting right at the beginning of the PES packet, push preceding data into previous NAL unit.\n\n            if (overflow > 0) {\n              // logger.log('first NALU found with overflow:' + overflow);\n              lastUnit.data = appendUint8Array(lastUnit.data, array.subarray(0, overflow));\n              lastUnit.state = 0;\n            }\n          }\n        }\n        // check if we can read unit type\n        if (i < len) {\n          unitType = array[i] & 0x1f;\n          // logger.log('find NALU @ offset:' + i + ',type:' + unitType);\n          lastUnitStart = i;\n          lastUnitType = unitType;\n          state = 0;\n        } else {\n          // not enough byte to read unit type. let's read it on next PES parsing\n          state = -1;\n        }\n      } else {\n        state = 0;\n      }\n    }\n    if (lastUnitStart >= 0 && state >= 0) {\n      const unit = {\n        data: array.subarray(lastUnitStart, len),\n        type: lastUnitType,\n        state: state\n      };\n      units.push(unit);\n      // logger.log('pushing NALU, type/size/state:' + unit.type + '/' + unit.data.byteLength + '/' + state);\n    }\n    // no NALu found\n    if (units.length === 0) {\n      // append pes.data to previous NAL unit\n      const lastUnit = this.getLastNalUnit(track.samples);\n      if (lastUnit) {\n        lastUnit.data = appendUint8Array(lastUnit.data, array);\n      }\n    }\n    track.naluState = state;\n    return units;\n  }\n}\n\n/**\n * SAMPLE-AES decrypter\n */\n\nclass SampleAesDecrypter {\n  constructor(observer, config, keyData) {\n    this.keyData = void 0;\n    this.decrypter = void 0;\n    this.keyData = keyData;\n    this.decrypter = new Decrypter(config, {\n      removePKCS7Padding: false\n    });\n  }\n  decryptBuffer(encryptedData) {\n    return this.decrypter.decrypt(encryptedData, this.keyData.key.buffer, this.keyData.iv.buffer);\n  }\n\n  // AAC - encrypt all full 16 bytes blocks starting from offset 16\n  decryptAacSample(samples, sampleIndex, callback) {\n    const curUnit = samples[sampleIndex].unit;\n    if (curUnit.length <= 16) {\n      // No encrypted portion in this sample (first 16 bytes is not\n      // encrypted, see https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/HLS_Sample_Encryption/Encryption/Encryption.html),\n      return;\n    }\n    const encryptedData = curUnit.subarray(16, curUnit.length - curUnit.length % 16);\n    const encryptedBuffer = encryptedData.buffer.slice(encryptedData.byteOffset, encryptedData.byteOffset + encryptedData.length);\n    this.decryptBuffer(encryptedBuffer).then(decryptedBuffer => {\n      const decryptedData = new Uint8Array(decryptedBuffer);\n      curUnit.set(decryptedData, 16);\n      if (!this.decrypter.isSync()) {\n        this.decryptAacSamples(samples, sampleIndex + 1, callback);\n      }\n    });\n  }\n  decryptAacSamples(samples, sampleIndex, callback) {\n    for (;; sampleIndex++) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      if (samples[sampleIndex].unit.length < 32) {\n        continue;\n      }\n      this.decryptAacSample(samples, sampleIndex, callback);\n      if (!this.decrypter.isSync()) {\n        return;\n      }\n    }\n  }\n\n  // AVC - encrypt one 16 bytes block out of ten, starting from offset 32\n  getAvcEncryptedData(decodedData) {\n    const encryptedDataLen = Math.floor((decodedData.length - 48) / 160) * 16 + 16;\n    const encryptedData = new Int8Array(encryptedDataLen);\n    let outputPos = 0;\n    for (let inputPos = 32; inputPos < decodedData.length - 16; inputPos += 160, outputPos += 16) {\n      encryptedData.set(decodedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return encryptedData;\n  }\n  getAvcDecryptedUnit(decodedData, decryptedData) {\n    const uint8DecryptedData = new Uint8Array(decryptedData);\n    let inputPos = 0;\n    for (let outputPos = 32; outputPos < decodedData.length - 16; outputPos += 160, inputPos += 16) {\n      decodedData.set(uint8DecryptedData.subarray(inputPos, inputPos + 16), outputPos);\n    }\n    return decodedData;\n  }\n  decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit) {\n    const decodedData = discardEPB(curUnit.data);\n    const encryptedData = this.getAvcEncryptedData(decodedData);\n    this.decryptBuffer(encryptedData.buffer).then(decryptedBuffer => {\n      curUnit.data = this.getAvcDecryptedUnit(decodedData, decryptedBuffer);\n      if (!this.decrypter.isSync()) {\n        this.decryptAvcSamples(samples, sampleIndex, unitIndex + 1, callback);\n      }\n    });\n  }\n  decryptAvcSamples(samples, sampleIndex, unitIndex, callback) {\n    if (samples instanceof Uint8Array) {\n      throw new Error('Cannot decrypt samples of type Uint8Array');\n    }\n    for (;; sampleIndex++, unitIndex = 0) {\n      if (sampleIndex >= samples.length) {\n        callback();\n        return;\n      }\n      const curUnits = samples[sampleIndex].units;\n      for (;; unitIndex++) {\n        if (unitIndex >= curUnits.length) {\n          break;\n        }\n        const curUnit = curUnits[unitIndex];\n        if (curUnit.data.length <= 48 || curUnit.type !== 1 && curUnit.type !== 5) {\n          continue;\n        }\n        this.decryptAvcSample(samples, sampleIndex, unitIndex, callback, curUnit);\n        if (!this.decrypter.isSync()) {\n          return;\n        }\n      }\n    }\n  }\n}\n\nconst PACKET_LENGTH = 188;\nclass TSDemuxer {\n  constructor(observer, config, typeSupported) {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.sampleAes = null;\n    this.pmtParsed = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this._duration = 0;\n    this._pmtId = -1;\n    this._videoTrack = void 0;\n    this._audioTrack = void 0;\n    this._id3Track = void 0;\n    this._txtTrack = void 0;\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.videoParser = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.videoParser = new AvcVideoParser();\n  }\n  static probe(data) {\n    const syncOffset = TSDemuxer.syncOffset(data);\n    if (syncOffset > 0) {\n      logger.warn(`MPEG2-TS detected but first sync word found @ offset ${syncOffset}`);\n    }\n    return syncOffset !== -1;\n  }\n  static syncOffset(data) {\n    const length = data.length;\n    let scanwindow = Math.min(PACKET_LENGTH * 5, length - PACKET_LENGTH) + 1;\n    let i = 0;\n    while (i < scanwindow) {\n      // a TS init segment should contain at least 2 TS packets: PAT and PMT, each starting with 0x47\n      let foundPat = false;\n      let packetStart = -1;\n      let tsPackets = 0;\n      for (let j = i; j < length; j += PACKET_LENGTH) {\n        if (data[j] === 0x47 && (length - j === PACKET_LENGTH || data[j + PACKET_LENGTH] === 0x47)) {\n          tsPackets++;\n          if (packetStart === -1) {\n            packetStart = j;\n            // First sync word found at offset, increase scan length (#5251)\n            if (packetStart !== 0) {\n              scanwindow = Math.min(packetStart + PACKET_LENGTH * 99, data.length - PACKET_LENGTH) + 1;\n            }\n          }\n          if (!foundPat) {\n            foundPat = parsePID(data, j) === 0;\n          }\n          // Sync word found at 0 with 3 packets, or found at offset least 2 packets up to scanwindow (#5501)\n          if (foundPat && tsPackets > 1 && (packetStart === 0 && tsPackets > 2 || j + PACKET_LENGTH > scanwindow)) {\n            return packetStart;\n          }\n        } else if (tsPackets) {\n          // Exit if sync word found, but does not contain contiguous packets\n          return -1;\n        } else {\n          break;\n        }\n      }\n      i++;\n    }\n    return -1;\n  }\n\n  /**\n   * Creates a track model internal to demuxer used to drive remuxing input\n   */\n  static createTrack(type, duration) {\n    return {\n      container: type === 'video' || type === 'audio' ? 'video/mp2t' : undefined,\n      type,\n      id: RemuxerTrackIdConfig[type],\n      pid: -1,\n      inputTimeScale: 90000,\n      sequenceNumber: 0,\n      samples: [],\n      dropped: 0,\n      duration: type === 'audio' ? duration : undefined\n    };\n  }\n\n  /**\n   * Initializes a new init segment on the demuxer/remuxer interface. Needed for discontinuities/track-switches (or at stream start)\n   * Resets all internal track instances of the demuxer.\n   */\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    this.pmtParsed = false;\n    this._pmtId = -1;\n    this._videoTrack = TSDemuxer.createTrack('video');\n    this._audioTrack = TSDemuxer.createTrack('audio', trackDuration);\n    this._id3Track = TSDemuxer.createTrack('id3');\n    this._txtTrack = TSDemuxer.createTrack('text');\n    this._audioTrack.segmentCodec = 'aac';\n\n    // flush any partial content\n    this.aacOverFlow = null;\n    this.remainderData = null;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this._duration = trackDuration;\n  }\n  resetTimeStamp() {}\n  resetContiguity() {\n    const {\n      _audioTrack,\n      _videoTrack,\n      _id3Track\n    } = this;\n    if (_audioTrack) {\n      _audioTrack.pesData = null;\n    }\n    if (_videoTrack) {\n      _videoTrack.pesData = null;\n    }\n    if (_id3Track) {\n      _id3Track.pesData = null;\n    }\n    this.aacOverFlow = null;\n    this.remainderData = null;\n  }\n  demux(data, timeOffset, isSampleAes = false, flush = false) {\n    if (!isSampleAes) {\n      this.sampleAes = null;\n    }\n    let pes;\n    const videoTrack = this._videoTrack;\n    const audioTrack = this._audioTrack;\n    const id3Track = this._id3Track;\n    const textTrack = this._txtTrack;\n    let videoPid = videoTrack.pid;\n    let videoData = videoTrack.pesData;\n    let audioPid = audioTrack.pid;\n    let id3Pid = id3Track.pid;\n    let audioData = audioTrack.pesData;\n    let id3Data = id3Track.pesData;\n    let unknownPID = null;\n    let pmtParsed = this.pmtParsed;\n    let pmtId = this._pmtId;\n    let len = data.length;\n    if (this.remainderData) {\n      data = appendUint8Array(this.remainderData, data);\n      len = data.length;\n      this.remainderData = null;\n    }\n    if (len < PACKET_LENGTH && !flush) {\n      this.remainderData = data;\n      return {\n        audioTrack,\n        videoTrack,\n        id3Track,\n        textTrack\n      };\n    }\n    const syncOffset = Math.max(0, TSDemuxer.syncOffset(data));\n    len -= (len - syncOffset) % PACKET_LENGTH;\n    if (len < data.byteLength && !flush) {\n      this.remainderData = new Uint8Array(data.buffer, len, data.buffer.byteLength - len);\n    }\n\n    // loop through TS packets\n    let tsPacketErrors = 0;\n    for (let start = syncOffset; start < len; start += PACKET_LENGTH) {\n      if (data[start] === 0x47) {\n        const stt = !!(data[start + 1] & 0x40);\n        const pid = parsePID(data, start);\n        const atf = (data[start + 3] & 0x30) >> 4;\n\n        // if an adaption field is present, its length is specified by the fifth byte of the TS packet header.\n        let offset;\n        if (atf > 1) {\n          offset = start + 5 + data[start + 4];\n          // continue if there is only adaptation field\n          if (offset === start + PACKET_LENGTH) {\n            continue;\n          }\n        } else {\n          offset = start + 4;\n        }\n        switch (pid) {\n          case videoPid:\n            if (stt) {\n              if (videoData && (pes = parsePES(videoData))) {\n                this.videoParser.parseAVCPES(videoTrack, textTrack, pes, false, this._duration);\n              }\n              videoData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (videoData) {\n              videoData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              videoData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case audioPid:\n            if (stt) {\n              if (audioData && (pes = parsePES(audioData))) {\n                switch (audioTrack.segmentCodec) {\n                  case 'aac':\n                    this.parseAACPES(audioTrack, pes);\n                    break;\n                  case 'mp3':\n                    this.parseMPEGPES(audioTrack, pes);\n                    break;\n                  case 'ac3':\n                    {\n                      this.parseAC3PES(audioTrack, pes);\n                    }\n                    break;\n                }\n              }\n              audioData = {\n                data: [],\n                size: 0\n              };\n            }\n            if (audioData) {\n              audioData.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              audioData.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case id3Pid:\n            if (stt) {\n              if (id3Data && (pes = parsePES(id3Data))) {\n                this.parseID3PES(id3Track, pes);\n              }\n              id3Data = {\n                data: [],\n                size: 0\n              };\n            }\n            if (id3Data) {\n              id3Data.data.push(data.subarray(offset, start + PACKET_LENGTH));\n              id3Data.size += start + PACKET_LENGTH - offset;\n            }\n            break;\n          case 0:\n            if (stt) {\n              offset += data[offset] + 1;\n            }\n            pmtId = this._pmtId = parsePAT(data, offset);\n            // logger.log('PMT PID:'  + this._pmtId);\n            break;\n          case pmtId:\n            {\n              if (stt) {\n                offset += data[offset] + 1;\n              }\n              const parsedPIDs = parsePMT(data, offset, this.typeSupported, isSampleAes, this.observer);\n\n              // only update track id if track PID found while parsing PMT\n              // this is to avoid resetting the PID to -1 in case\n              // track PID transiently disappears from the stream\n              // this could happen in case of transient missing audio samples for example\n              // NOTE this is only the PID of the track as found in TS,\n              // but we are not using this for MP4 track IDs.\n              videoPid = parsedPIDs.videoPid;\n              if (videoPid > 0) {\n                videoTrack.pid = videoPid;\n                videoTrack.segmentCodec = parsedPIDs.segmentVideoCodec;\n              }\n              audioPid = parsedPIDs.audioPid;\n              if (audioPid > 0) {\n                audioTrack.pid = audioPid;\n                audioTrack.segmentCodec = parsedPIDs.segmentAudioCodec;\n              }\n              id3Pid = parsedPIDs.id3Pid;\n              if (id3Pid > 0) {\n                id3Track.pid = id3Pid;\n              }\n              if (unknownPID !== null && !pmtParsed) {\n                logger.warn(`MPEG-TS PMT found at ${start} after unknown PID '${unknownPID}'. Backtracking to sync byte @${syncOffset} to parse all TS packets.`);\n                unknownPID = null;\n                // we set it to -188, the += 188 in the for loop will reset start to 0\n                start = syncOffset - 188;\n              }\n              pmtParsed = this.pmtParsed = true;\n              break;\n            }\n          case 0x11:\n          case 0x1fff:\n            break;\n          default:\n            unknownPID = pid;\n            break;\n        }\n      } else {\n        tsPacketErrors++;\n      }\n    }\n    if (tsPacketErrors > 0) {\n      emitParsingError(this.observer, new Error(`Found ${tsPacketErrors} TS packet/s that do not start with 0x47`));\n    }\n    videoTrack.pesData = videoData;\n    audioTrack.pesData = audioData;\n    id3Track.pesData = id3Data;\n    const demuxResult = {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    };\n    if (flush) {\n      this.extractRemainingSamples(demuxResult);\n    }\n    return demuxResult;\n  }\n  flush() {\n    const {\n      remainderData\n    } = this;\n    this.remainderData = null;\n    let result;\n    if (remainderData) {\n      result = this.demux(remainderData, -1, false, true);\n    } else {\n      result = {\n        videoTrack: this._videoTrack,\n        audioTrack: this._audioTrack,\n        id3Track: this._id3Track,\n        textTrack: this._txtTrack\n      };\n    }\n    this.extractRemainingSamples(result);\n    if (this.sampleAes) {\n      return this.decrypt(result, this.sampleAes);\n    }\n    return result;\n  }\n  extractRemainingSamples(demuxResult) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const videoData = videoTrack.pesData;\n    const audioData = audioTrack.pesData;\n    const id3Data = id3Track.pesData;\n    // try to parse last PES packets\n    let pes;\n    if (videoData && (pes = parsePES(videoData))) {\n      this.videoParser.parseAVCPES(videoTrack, textTrack, pes, true, this._duration);\n      videoTrack.pesData = null;\n    } else {\n      // either avcData null or PES truncated, keep it for next frag parsing\n      videoTrack.pesData = videoData;\n    }\n    if (audioData && (pes = parsePES(audioData))) {\n      switch (audioTrack.segmentCodec) {\n        case 'aac':\n          this.parseAACPES(audioTrack, pes);\n          break;\n        case 'mp3':\n          this.parseMPEGPES(audioTrack, pes);\n          break;\n        case 'ac3':\n          {\n            this.parseAC3PES(audioTrack, pes);\n          }\n          break;\n      }\n      audioTrack.pesData = null;\n    } else {\n      if (audioData != null && audioData.size) {\n        logger.log('last AAC PES packet truncated,might overlap between fragments');\n      }\n\n      // either audioData null or PES truncated, keep it for next frag parsing\n      audioTrack.pesData = audioData;\n    }\n    if (id3Data && (pes = parsePES(id3Data))) {\n      this.parseID3PES(id3Track, pes);\n      id3Track.pesData = null;\n    } else {\n      // either id3Data null or PES truncated, keep it for next frag parsing\n      id3Track.pesData = id3Data;\n    }\n  }\n  demuxSampleAes(data, keyData, timeOffset) {\n    const demuxResult = this.demux(data, timeOffset, true, !this.config.progressive);\n    const sampleAes = this.sampleAes = new SampleAesDecrypter(this.observer, this.config, keyData);\n    return this.decrypt(demuxResult, sampleAes);\n  }\n  decrypt(demuxResult, sampleAes) {\n    return new Promise(resolve => {\n      const {\n        audioTrack,\n        videoTrack\n      } = demuxResult;\n      if (audioTrack.samples && audioTrack.segmentCodec === 'aac') {\n        sampleAes.decryptAacSamples(audioTrack.samples, 0, () => {\n          if (videoTrack.samples) {\n            sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n              resolve(demuxResult);\n            });\n          } else {\n            resolve(demuxResult);\n          }\n        });\n      } else if (videoTrack.samples) {\n        sampleAes.decryptAvcSamples(videoTrack.samples, 0, 0, () => {\n          resolve(demuxResult);\n        });\n      }\n    });\n  }\n  destroy() {\n    this._duration = 0;\n  }\n  parseAACPES(track, pes) {\n    let startOffset = 0;\n    const aacOverFlow = this.aacOverFlow;\n    let data = pes.data;\n    if (aacOverFlow) {\n      this.aacOverFlow = null;\n      const frameMissingBytes = aacOverFlow.missing;\n      const sampleLength = aacOverFlow.sample.unit.byteLength;\n      // logger.log(`AAC: append overflowing ${sampleLength} bytes to beginning of new PES`);\n      if (frameMissingBytes === -1) {\n        data = appendUint8Array(aacOverFlow.sample.unit, data);\n      } else {\n        const frameOverflowBytes = sampleLength - frameMissingBytes;\n        aacOverFlow.sample.unit.set(data.subarray(0, frameMissingBytes), frameOverflowBytes);\n        track.samples.push(aacOverFlow.sample);\n        startOffset = aacOverFlow.missing;\n      }\n    }\n    // look for ADTS header (0xFFFx)\n    let offset;\n    let len;\n    for (offset = startOffset, len = data.length; offset < len - 1; offset++) {\n      if (isHeader$1(data, offset)) {\n        break;\n      }\n    }\n    // if ADTS header does not start straight from the beginning of the PES payload, raise an error\n    if (offset !== startOffset) {\n      let reason;\n      const recoverable = offset < len - 1;\n      if (recoverable) {\n        reason = `AAC PES did not start with ADTS header,offset:${offset}`;\n      } else {\n        reason = 'No ADTS header found in AAC PES';\n      }\n      emitParsingError(this.observer, new Error(reason), recoverable);\n      if (!recoverable) {\n        return;\n      }\n    }\n    initTrackConfig(track, this.observer, data, offset, this.audioCodec);\n    let pts;\n    if (pes.pts !== undefined) {\n      pts = pes.pts;\n    } else if (aacOverFlow) {\n      // if last AAC frame is overflowing, we should ensure timestamps are contiguous:\n      // first sample PTS should be equal to last sample PTS + frameDuration\n      const frameDuration = getFrameDuration(track.samplerate);\n      pts = aacOverFlow.sample.pts + frameDuration;\n    } else {\n      logger.warn('[tsdemuxer]: AAC PES unknown PTS');\n      return;\n    }\n\n    // scan for aac samples\n    let frameIndex = 0;\n    let frame;\n    while (offset < len) {\n      frame = appendFrame$2(track, data, offset, pts, frameIndex);\n      offset += frame.length;\n      if (!frame.missing) {\n        frameIndex++;\n        for (; offset < len - 1; offset++) {\n          if (isHeader$1(data, offset)) {\n            break;\n          }\n        }\n      } else {\n        this.aacOverFlow = frame;\n        break;\n      }\n    }\n  }\n  parseMPEGPES(track, pes) {\n    const data = pes.data;\n    const length = data.length;\n    let frameIndex = 0;\n    let offset = 0;\n    const pts = pes.pts;\n    if (pts === undefined) {\n      logger.warn('[tsdemuxer]: MPEG PES unknown PTS');\n      return;\n    }\n    while (offset < length) {\n      if (isHeader(data, offset)) {\n        const frame = appendFrame$1(track, data, offset, pts, frameIndex);\n        if (frame) {\n          offset += frame.length;\n          frameIndex++;\n        } else {\n          // logger.log('Unable to parse Mpeg audio frame');\n          break;\n        }\n      } else {\n        // nothing found, keep looking\n        offset++;\n      }\n    }\n  }\n  parseAC3PES(track, pes) {\n    {\n      const data = pes.data;\n      const pts = pes.pts;\n      if (pts === undefined) {\n        logger.warn('[tsdemuxer]: AC3 PES unknown PTS');\n        return;\n      }\n      const length = data.length;\n      let frameIndex = 0;\n      let offset = 0;\n      let parsed;\n      while (offset < length && (parsed = appendFrame(track, data, offset, pts, frameIndex++)) > 0) {\n        offset += parsed;\n      }\n    }\n  }\n  parseID3PES(id3Track, pes) {\n    if (pes.pts === undefined) {\n      logger.warn('[tsdemuxer]: ID3 PES unknown PTS');\n      return;\n    }\n    const id3Sample = _extends({}, pes, {\n      type: this._videoTrack ? MetadataSchema.emsg : MetadataSchema.audioId3,\n      duration: Number.POSITIVE_INFINITY\n    });\n    id3Track.samples.push(id3Sample);\n  }\n}\nfunction parsePID(data, offset) {\n  // pid is a 13-bit field starting at the last bit of TS[1]\n  return ((data[offset + 1] & 0x1f) << 8) + data[offset + 2];\n}\nfunction parsePAT(data, offset) {\n  // skip the PSI header and parse the first PMT entry\n  return (data[offset + 10] & 0x1f) << 8 | data[offset + 11];\n}\nfunction parsePMT(data, offset, typeSupported, isSampleAes, observer) {\n  const result = {\n    audioPid: -1,\n    videoPid: -1,\n    id3Pid: -1,\n    segmentVideoCodec: 'avc',\n    segmentAudioCodec: 'aac'\n  };\n  const sectionLength = (data[offset + 1] & 0x0f) << 8 | data[offset + 2];\n  const tableEnd = offset + 3 + sectionLength - 4;\n  // to determine where the table is, we have to figure out how\n  // long the program info descriptors are\n  const programInfoLength = (data[offset + 10] & 0x0f) << 8 | data[offset + 11];\n  // advance the offset to the first entry in the mapping table\n  offset += 12 + programInfoLength;\n  while (offset < tableEnd) {\n    const pid = parsePID(data, offset);\n    const esInfoLength = (data[offset + 3] & 0x0f) << 8 | data[offset + 4];\n    switch (data[offset]) {\n      case 0xcf:\n        // SAMPLE-AES AAC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('ADTS AAC');\n          break;\n        }\n      /* falls through */\n      case 0x0f:\n        // ISO/IEC 13818-7 ADTS AAC (MPEG-2 lower bit-rate audio)\n        // logger.log('AAC PID:'  + pid);\n        if (result.audioPid === -1) {\n          result.audioPid = pid;\n        }\n        break;\n\n      // Packetized metadata (ID3)\n      case 0x15:\n        // logger.log('ID3 PID:'  + pid);\n        if (result.id3Pid === -1) {\n          result.id3Pid = pid;\n        }\n        break;\n      case 0xdb:\n        // SAMPLE-AES AVC\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('H.264');\n          break;\n        }\n      /* falls through */\n      case 0x1b:\n        // ITU-T Rec. H.264 and ISO/IEC 14496-10 (lower bit-rate video)\n        // logger.log('AVC PID:'  + pid);\n        if (result.videoPid === -1) {\n          result.videoPid = pid;\n          result.segmentVideoCodec = 'avc';\n        }\n        break;\n\n      // ISO/IEC 11172-3 (MPEG-1 audio)\n      // or ISO/IEC 13818-3 (MPEG-2 halved sample rate audio)\n      case 0x03:\n      case 0x04:\n        // logger.log('MPEG PID:'  + pid);\n        if (!typeSupported.mpeg && !typeSupported.mp3) {\n          logger.log('MPEG audio found, not supported in this browser');\n        } else if (result.audioPid === -1) {\n          result.audioPid = pid;\n          result.segmentAudioCodec = 'mp3';\n        }\n        break;\n      case 0xc1:\n        // SAMPLE-AES AC3\n        if (!isSampleAes) {\n          logEncryptedSamplesFoundInUnencryptedStream('AC-3');\n          break;\n        }\n      /* falls through */\n      case 0x81:\n        {\n          if (!typeSupported.ac3) {\n            logger.log('AC-3 audio found, not supported in this browser');\n          } else if (result.audioPid === -1) {\n            result.audioPid = pid;\n            result.segmentAudioCodec = 'ac3';\n          }\n        }\n        break;\n      case 0x06:\n        // stream_type 6 can mean a lot of different things in case of DVB.\n        // We need to look at the descriptors. Right now, we're only interested\n        // in AC-3 audio, so we do the descriptor parsing only when we don't have\n        // an audio PID yet.\n        if (result.audioPid === -1 && esInfoLength > 0) {\n          let parsePos = offset + 5;\n          let remaining = esInfoLength;\n          while (remaining > 2) {\n            const descriptorId = data[parsePos];\n            switch (descriptorId) {\n              case 0x6a:\n                // DVB Descriptor for AC-3\n                {\n                  if (typeSupported.ac3 !== true) {\n                    logger.log('AC-3 audio found, not supported in this browser for now');\n                  } else {\n                    result.audioPid = pid;\n                    result.segmentAudioCodec = 'ac3';\n                  }\n                }\n                break;\n            }\n            const descriptorLen = data[parsePos + 1] + 2;\n            parsePos += descriptorLen;\n            remaining -= descriptorLen;\n          }\n        }\n        break;\n      case 0xc2: // SAMPLE-AES EC3\n      /* falls through */\n      case 0x87:\n        emitParsingError(observer, new Error('Unsupported EC-3 in M2TS found'));\n        return result;\n      case 0x24:\n        emitParsingError(observer, new Error('Unsupported HEVC in M2TS found'));\n        return result;\n    }\n    // move to the next table entry\n    // skip past the elementary stream descriptors, if present\n    offset += esInfoLength + 5;\n  }\n  return result;\n}\nfunction emitParsingError(observer, error, levelRetry) {\n  logger.warn(`parsing error: ${error.message}`);\n  observer.emit(Events.ERROR, Events.ERROR, {\n    type: ErrorTypes.MEDIA_ERROR,\n    details: ErrorDetails.FRAG_PARSING_ERROR,\n    fatal: false,\n    levelRetry,\n    error,\n    reason: error.message\n  });\n}\nfunction logEncryptedSamplesFoundInUnencryptedStream(type) {\n  logger.log(`${type} with AES-128-CBC encryption found in unencrypted stream`);\n}\nfunction parsePES(stream) {\n  let i = 0;\n  let frag;\n  let pesLen;\n  let pesHdrLen;\n  let pesPts;\n  let pesDts;\n  const data = stream.data;\n  // safety check\n  if (!stream || stream.size === 0) {\n    return null;\n  }\n\n  // we might need up to 19 bytes to read PES header\n  // if first chunk of data is less than 19 bytes, let's merge it with following ones until we get 19 bytes\n  // usually only one merge is needed (and this is rare ...)\n  while (data[0].length < 19 && data.length > 1) {\n    data[0] = appendUint8Array(data[0], data[1]);\n    data.splice(1, 1);\n  }\n  // retrieve PTS/DTS from first fragment\n  frag = data[0];\n  const pesPrefix = (frag[0] << 16) + (frag[1] << 8) + frag[2];\n  if (pesPrefix === 1) {\n    pesLen = (frag[4] << 8) + frag[5];\n    // if PES parsed length is not zero and greater than total received length, stop parsing. PES might be truncated\n    // minus 6 : PES header size\n    if (pesLen && pesLen > stream.size - 6) {\n      return null;\n    }\n    const pesFlags = frag[7];\n    if (pesFlags & 0xc0) {\n      /* PES header described here : http://dvd.sourceforge.net/dvdinfo/pes-hdr.html\n          as PTS / DTS is 33 bit we cannot use bitwise operator in JS,\n          as Bitwise operators treat their operands as a sequence of 32 bits */\n      pesPts = (frag[9] & 0x0e) * 536870912 +\n      // 1 << 29\n      (frag[10] & 0xff) * 4194304 +\n      // 1 << 22\n      (frag[11] & 0xfe) * 16384 +\n      // 1 << 14\n      (frag[12] & 0xff) * 128 +\n      // 1 << 7\n      (frag[13] & 0xfe) / 2;\n      if (pesFlags & 0x40) {\n        pesDts = (frag[14] & 0x0e) * 536870912 +\n        // 1 << 29\n        (frag[15] & 0xff) * 4194304 +\n        // 1 << 22\n        (frag[16] & 0xfe) * 16384 +\n        // 1 << 14\n        (frag[17] & 0xff) * 128 +\n        // 1 << 7\n        (frag[18] & 0xfe) / 2;\n        if (pesPts - pesDts > 60 * 90000) {\n          logger.warn(`${Math.round((pesPts - pesDts) / 90000)}s delta between PTS and DTS, align them`);\n          pesPts = pesDts;\n        }\n      } else {\n        pesDts = pesPts;\n      }\n    }\n    pesHdrLen = frag[8];\n    // 9 bytes : 6 bytes for PES header + 3 bytes for PES extension\n    let payloadStartOffset = pesHdrLen + 9;\n    if (stream.size <= payloadStartOffset) {\n      return null;\n    }\n    stream.size -= payloadStartOffset;\n    // reassemble PES packet\n    const pesData = new Uint8Array(stream.size);\n    for (let j = 0, dataLen = data.length; j < dataLen; j++) {\n      frag = data[j];\n      let len = frag.byteLength;\n      if (payloadStartOffset) {\n        if (payloadStartOffset > len) {\n          // trim full frag if PES header bigger than frag\n          payloadStartOffset -= len;\n          continue;\n        } else {\n          // trim partial frag if PES header smaller than frag\n          frag = frag.subarray(payloadStartOffset);\n          len -= payloadStartOffset;\n          payloadStartOffset = 0;\n        }\n      }\n      pesData.set(frag, i);\n      i += len;\n    }\n    if (pesLen) {\n      // payload size : remove PES header + PES extension\n      pesLen -= pesHdrLen + 3;\n    }\n    return {\n      data: pesData,\n      pts: pesPts,\n      dts: pesDts,\n      len: pesLen\n    };\n  }\n  return null;\n}\n\n/**\n * MP3 demuxer\n */\nclass MP3Demuxer extends BaseAudioDemuxer {\n  resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration) {\n    super.resetInitSegment(initSegment, audioCodec, videoCodec, trackDuration);\n    this._audioTrack = {\n      container: 'audio/mpeg',\n      type: 'audio',\n      id: 2,\n      pid: -1,\n      sequenceNumber: 0,\n      segmentCodec: 'mp3',\n      samples: [],\n      manifestCodec: audioCodec,\n      duration: trackDuration,\n      inputTimeScale: 90000,\n      dropped: 0\n    };\n  }\n  static probe(data) {\n    if (!data) {\n      return false;\n    }\n\n    // check if data contains ID3 timestamp and MPEG sync word\n    // Look for MPEG header | 1111 1111 | 111X XYZX | where X can be either 0 or 1 and Y or Z should be 1\n    // Layer bits (position 14 and 15) in header should be always different from 0 (Layer I or Layer II or Layer III)\n    // More info http://www.mp3-tech.org/programmer/frame_header.html\n    const id3Data = getID3Data(data, 0);\n    let offset = (id3Data == null ? void 0 : id3Data.length) || 0;\n\n    // Check for ac-3|ec-3 sync bytes and return false if present\n    if (id3Data && data[offset] === 0x0b && data[offset + 1] === 0x77 && getTimeStamp(id3Data) !== undefined &&\n    // check the bsid to confirm ac-3 or ec-3 (not mp3)\n    getAudioBSID(data, offset) <= 16) {\n      return false;\n    }\n    for (let length = data.length; offset < length; offset++) {\n      if (probe(data, offset)) {\n        logger.log('MPEG Audio sync word found !');\n        return true;\n      }\n    }\n    return false;\n  }\n  canParse(data, offset) {\n    return canParse(data, offset);\n  }\n  appendFrame(track, data, offset) {\n    if (this.basePTS === null) {\n      return;\n    }\n    return appendFrame$1(track, data, offset, this.basePTS, this.frameIndex);\n  }\n}\n\n/**\n *  AAC helper\n */\n\nclass AAC {\n  static getSilentFrame(codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80]);\n        } else if (channelCount === 2) {\n          return new Uint8Array([0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80]);\n        } else if (channelCount === 3) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x8e]);\n        } else if (channelCount === 4) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38]);\n        } else if (channelCount === 5) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38]);\n        } else if (channelCount === 6) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64, 0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2, 0x00, 0x20, 0x08, 0xe0]);\n        }\n        break;\n      // handle HE-AAC below (mp4a.40.5 / mp4a.40.29)\n      default:\n        if (channelCount === 1) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0:d=0.05\" -c:a libfdk_aac -profile:a aac_he -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 2) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        } else if (channelCount === 3) {\n          // ffmpeg -y -f lavfi -i \"aevalsrc=0|0|0:d=0.05\" -c:a libfdk_aac -profile:a aac_he_v2 -b:a 4k output.aac && hexdump -v -e '16/1 \"0x%x,\" \"\\n\"' -v output.aac\n          return new Uint8Array([0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0, 0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5e]);\n        }\n        break;\n    }\n    return undefined;\n  }\n}\n\n/**\n * Generate MP4 Box\n */\n\nconst UINT32_MAX = Math.pow(2, 32) - 1;\nclass MP4 {\n  static init() {\n    MP4.types = {\n      avc1: [],\n      // codingname\n      avcC: [],\n      btrt: [],\n      dinf: [],\n      dref: [],\n      esds: [],\n      ftyp: [],\n      hdlr: [],\n      mdat: [],\n      mdhd: [],\n      mdia: [],\n      mfhd: [],\n      minf: [],\n      moof: [],\n      moov: [],\n      mp4a: [],\n      '.mp3': [],\n      dac3: [],\n      'ac-3': [],\n      mvex: [],\n      mvhd: [],\n      pasp: [],\n      sdtp: [],\n      stbl: [],\n      stco: [],\n      stsc: [],\n      stsd: [],\n      stsz: [],\n      stts: [],\n      tfdt: [],\n      tfhd: [],\n      traf: [],\n      trak: [],\n      trun: [],\n      trex: [],\n      tkhd: [],\n      vmhd: [],\n      smhd: []\n    };\n    let i;\n    for (i in MP4.types) {\n      if (MP4.types.hasOwnProperty(i)) {\n        MP4.types[i] = [i.charCodeAt(0), i.charCodeAt(1), i.charCodeAt(2), i.charCodeAt(3)];\n      }\n    }\n    const videoHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x76, 0x69, 0x64, 0x65,\n    // handler_type: 'vide'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]);\n    const audioHdlr = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0x73, 0x6f, 0x75, 0x6e,\n    // handler_type: 'soun'\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ]);\n    MP4.HDLR_TYPES = {\n      video: videoHdlr,\n      audio: audioHdlr\n    };\n    const dref = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01,\n    // entry_count\n    0x00, 0x00, 0x00, 0x0c,\n    // entry_size\n    0x75, 0x72, 0x6c, 0x20,\n    // 'url' type\n    0x00,\n    // version 0\n    0x00, 0x00, 0x01 // entry_flags\n    ]);\n    const stco = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n    ]);\n    MP4.STTS = MP4.STSC = MP4.STCO = stco;\n    MP4.STSZ = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00,\n    // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n    ]);\n    MP4.VMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x01,\n    // flags\n    0x00, 0x00,\n    // graphicsmode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // opcolor\n    ]);\n    MP4.SMHD = new Uint8Array([0x00,\n    // version\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00,\n    // balance\n    0x00, 0x00 // reserved\n    ]);\n    MP4.STSD = new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x01]); // entry_count\n\n    const majorBrand = new Uint8Array([105, 115, 111, 109]); // isom\n    const avc1Brand = new Uint8Array([97, 118, 99, 49]); // avc1\n    const minorVersion = new Uint8Array([0, 0, 0, 1]);\n    MP4.FTYP = MP4.box(MP4.types.ftyp, majorBrand, minorVersion, majorBrand, avc1Brand);\n    MP4.DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, dref));\n  }\n  static box(type, ...payload) {\n    let size = 8;\n    let i = payload.length;\n    const len = i;\n    // calculate the total size we need to allocate\n    while (i--) {\n      size += payload[i].byteLength;\n    }\n    const result = new Uint8Array(size);\n    result[0] = size >> 24 & 0xff;\n    result[1] = size >> 16 & 0xff;\n    result[2] = size >> 8 & 0xff;\n    result[3] = size & 0xff;\n    result.set(type, 4);\n    // copy the payload into the result\n    for (i = 0, size = 8; i < len; i++) {\n      // copy payload[i] array @ offset size\n      result.set(payload[i], size);\n      size += payload[i].byteLength;\n    }\n    return result;\n  }\n  static hdlr(type) {\n    return MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type]);\n  }\n  static mdat(data) {\n    return MP4.box(MP4.types.mdat, data);\n  }\n  static mdhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.mdhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x55, 0xc4,\n    // 'und' language (undetermined)\n    0x00, 0x00]));\n  }\n  static mdia(track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.timescale, track.duration), MP4.hdlr(track.type), MP4.minf(track));\n  }\n  static mfhd(sequenceNumber) {\n    return MP4.box(MP4.types.mfhd, new Uint8Array([0x00, 0x00, 0x00, 0x00,\n    // flags\n    sequenceNumber >> 24, sequenceNumber >> 16 & 0xff, sequenceNumber >> 8 & 0xff, sequenceNumber & 0xff // sequence_number\n    ]));\n  }\n  static minf(track) {\n    if (track.type === 'audio') {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.smhd, MP4.SMHD), MP4.DINF, MP4.stbl(track));\n    } else {\n      return MP4.box(MP4.types.minf, MP4.box(MP4.types.vmhd, MP4.VMHD), MP4.DINF, MP4.stbl(track));\n    }\n  }\n  static moof(sn, baseMediaDecodeTime, track) {\n    return MP4.box(MP4.types.moof, MP4.mfhd(sn), MP4.traf(track, baseMediaDecodeTime));\n  }\n  static moov(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trak(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.moov, MP4.mvhd(tracks[0].timescale, tracks[0].duration)].concat(boxes).concat(MP4.mvex(tracks)));\n  }\n  static mvex(tracks) {\n    let i = tracks.length;\n    const boxes = [];\n    while (i--) {\n      boxes[i] = MP4.trex(tracks[i]);\n    }\n    return MP4.box.apply(null, [MP4.types.mvex, ...boxes]);\n  }\n  static mvhd(timescale, duration) {\n    duration *= timescale;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    const bytes = new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    timescale >> 24 & 0xff, timescale >> 16 & 0xff, timescale >> 8 & 0xff, timescale & 0xff,\n    // timescale\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x01, 0x00, 0x00,\n    // 1.0 rate\n    0x01, 0x00,\n    // 1.0 volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]);\n    return MP4.box(MP4.types.mvhd, bytes);\n  }\n  static sdtp(track) {\n    const samples = track.samples || [];\n    const bytes = new Uint8Array(4 + samples.length);\n    let i;\n    let flags;\n    // leave the full box header (4 bytes) all zero\n    // write the sample table\n    for (i = 0; i < samples.length; i++) {\n      flags = samples[i].flags;\n      bytes[i + 4] = flags.dependsOn << 4 | flags.isDependedOn << 2 | flags.hasRedundancy;\n    }\n    return MP4.box(MP4.types.sdtp, bytes);\n  }\n  static stbl(track) {\n    return MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.box(MP4.types.stts, MP4.STTS), MP4.box(MP4.types.stsc, MP4.STSC), MP4.box(MP4.types.stsz, MP4.STSZ), MP4.box(MP4.types.stco, MP4.STCO));\n  }\n  static avc1(track) {\n    let sps = [];\n    let pps = [];\n    let i;\n    let data;\n    let len;\n    // assemble the SPSs\n\n    for (i = 0; i < track.sps.length; i++) {\n      data = track.sps[i];\n      len = data.byteLength;\n      sps.push(len >>> 8 & 0xff);\n      sps.push(len & 0xff);\n\n      // SPS\n      sps = sps.concat(Array.prototype.slice.call(data));\n    }\n\n    // assemble the PPSs\n    for (i = 0; i < track.pps.length; i++) {\n      data = track.pps[i];\n      len = data.byteLength;\n      pps.push(len >>> 8 & 0xff);\n      pps.push(len & 0xff);\n      pps = pps.concat(Array.prototype.slice.call(data));\n    }\n    const avcc = MP4.box(MP4.types.avcC, new Uint8Array([0x01,\n    // version\n    sps[3],\n    // profile\n    sps[4],\n    // profile compat\n    sps[5],\n    // level\n    0xfc | 3,\n    // lengthSizeMinusOne, hard-coded to 4 bytes\n    0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(sps).concat([track.pps.length // numOfPictureParameterSets\n    ]).concat(pps))); // \"PPS\"\n    const width = track.width;\n    const height = track.height;\n    const hSpacing = track.pixelRatio[0];\n    const vSpacing = track.pixelRatio[1];\n    return MP4.box(MP4.types.avc1, new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00,\n    // pre_defined\n    0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // pre_defined\n    width >> 8 & 0xff, width & 0xff,\n    // width\n    height >> 8 & 0xff, height & 0xff,\n    // height\n    0x00, 0x48, 0x00, 0x00,\n    // horizresolution\n    0x00, 0x48, 0x00, 0x00,\n    // vertresolution\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // frame_count\n    0x12, 0x64, 0x61, 0x69, 0x6c,\n    // dailymotion/hls.js\n    0x79, 0x6d, 0x6f, 0x74, 0x69, 0x6f, 0x6e, 0x2f, 0x68, 0x6c, 0x73, 0x2e, 0x6a, 0x73, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // compressorname\n    0x00, 0x18,\n    // depth = 24\n    0x11, 0x11]),\n    // pre_defined = -1\n    avcc, MP4.box(MP4.types.btrt, new Uint8Array([0x00, 0x1c, 0x9c, 0x80,\n    // bufferSizeDB\n    0x00, 0x2d, 0xc6, 0xc0,\n    // maxBitrate\n    0x00, 0x2d, 0xc6, 0xc0])),\n    // avgBitrate\n    MP4.box(MP4.types.pasp, new Uint8Array([hSpacing >> 24,\n    // hSpacing\n    hSpacing >> 16 & 0xff, hSpacing >> 8 & 0xff, hSpacing & 0xff, vSpacing >> 24,\n    // vSpacing\n    vSpacing >> 16 & 0xff, vSpacing >> 8 & 0xff, vSpacing & 0xff])));\n  }\n  static esds(track) {\n    const configlen = track.config.length;\n    return new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n\n    0x03,\n    // descriptor_type\n    0x17 + configlen,\n    // length\n    0x00, 0x01,\n    // es_id\n    0x00,\n    // stream_priority\n\n    0x04,\n    // descriptor_type\n    0x0f + configlen,\n    // length\n    0x40,\n    // codec : mpeg4_audio\n    0x15,\n    // stream_type\n    0x00, 0x00, 0x00,\n    // buffer_size\n    0x00, 0x00, 0x00, 0x00,\n    // maxBitrate\n    0x00, 0x00, 0x00, 0x00,\n    // avgBitrate\n\n    0x05 // descriptor_type\n    ].concat([configlen]).concat(track.config).concat([0x06, 0x01, 0x02])); // GASpecificConfig)); // length + audio config descriptor\n  }\n  static audioStsd(track) {\n    const samplerate = track.samplerate;\n    return new Uint8Array([0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x01,\n    // data_reference_index\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, track.channelCount,\n    // channelcount\n    0x00, 0x10,\n    // sampleSize:16bits\n    0x00, 0x00, 0x00, 0x00,\n    // reserved2\n    samplerate >> 8 & 0xff, samplerate & 0xff,\n    //\n    0x00, 0x00]);\n  }\n  static mp4a(track) {\n    return MP4.box(MP4.types.mp4a, MP4.audioStsd(track), MP4.box(MP4.types.esds, MP4.esds(track)));\n  }\n  static mp3(track) {\n    return MP4.box(MP4.types['.mp3'], MP4.audioStsd(track));\n  }\n  static ac3(track) {\n    return MP4.box(MP4.types['ac-3'], MP4.audioStsd(track), MP4.box(MP4.types.dac3, track.config));\n  }\n  static stsd(track) {\n    if (track.type === 'audio') {\n      if (track.segmentCodec === 'mp3' && track.codec === 'mp3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp3(track));\n      }\n      if (track.segmentCodec === 'ac3') {\n        return MP4.box(MP4.types.stsd, MP4.STSD, MP4.ac3(track));\n      }\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.mp4a(track));\n    } else {\n      return MP4.box(MP4.types.stsd, MP4.STSD, MP4.avc1(track));\n    }\n  }\n  static tkhd(track) {\n    const id = track.id;\n    const duration = track.duration * track.timescale;\n    const width = track.width;\n    const height = track.height;\n    const upperWordDuration = Math.floor(duration / (UINT32_MAX + 1));\n    const lowerWordDuration = Math.floor(duration % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.tkhd, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x07,\n    // flags\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02,\n    // creation_time\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03,\n    // modification_time\n    id >> 24 & 0xff, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x00,\n    // reserved\n    upperWordDuration >> 24, upperWordDuration >> 16 & 0xff, upperWordDuration >> 8 & 0xff, upperWordDuration & 0xff, lowerWordDuration >> 24, lowerWordDuration >> 16 & 0xff, lowerWordDuration >> 8 & 0xff, lowerWordDuration & 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    // reserved\n    0x00, 0x00,\n    // layer\n    0x00, 0x00,\n    // alternate_group\n    0x00, 0x00,\n    // non-audio track volume\n    0x00, 0x00,\n    // reserved\n    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,\n    // transformation: unity matrix\n    width >> 8 & 0xff, width & 0xff, 0x00, 0x00,\n    // width\n    height >> 8 & 0xff, height & 0xff, 0x00, 0x00 // height\n    ]));\n  }\n  static traf(track, baseMediaDecodeTime) {\n    const sampleDependencyTable = MP4.sdtp(track);\n    const id = track.id;\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1));\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1));\n    return MP4.box(MP4.types.traf, MP4.box(MP4.types.tfhd, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff // track_ID\n    ])), MP4.box(MP4.types.tfdt, new Uint8Array([0x01,\n    // version 1\n    0x00, 0x00, 0x00,\n    // flags\n    upperWordBaseMediaDecodeTime >> 24, upperWordBaseMediaDecodeTime >> 16 & 0xff, upperWordBaseMediaDecodeTime >> 8 & 0xff, upperWordBaseMediaDecodeTime & 0xff, lowerWordBaseMediaDecodeTime >> 24, lowerWordBaseMediaDecodeTime >> 16 & 0xff, lowerWordBaseMediaDecodeTime >> 8 & 0xff, lowerWordBaseMediaDecodeTime & 0xff])), MP4.trun(track, sampleDependencyTable.length + 16 +\n    // tfhd\n    20 +\n    // tfdt\n    8 +\n    // traf header\n    16 +\n    // mfhd\n    8 +\n    // moof header\n    8),\n    // mdat header\n    sampleDependencyTable);\n  }\n\n  /**\n   * Generate a track box.\n   * @param track a track definition\n   */\n  static trak(track) {\n    track.duration = track.duration || 0xffffffff;\n    return MP4.box(MP4.types.trak, MP4.tkhd(track), MP4.mdia(track));\n  }\n  static trex(track) {\n    const id = track.id;\n    return MP4.box(MP4.types.trex, new Uint8Array([0x00,\n    // version 0\n    0x00, 0x00, 0x00,\n    // flags\n    id >> 24, id >> 16 & 0xff, id >> 8 & 0xff, id & 0xff,\n    // track_ID\n    0x00, 0x00, 0x00, 0x01,\n    // default_sample_description_index\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_duration\n    0x00, 0x00, 0x00, 0x00,\n    // default_sample_size\n    0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]));\n  }\n  static trun(track, offset) {\n    const samples = track.samples || [];\n    const len = samples.length;\n    const arraylen = 12 + 16 * len;\n    const array = new Uint8Array(arraylen);\n    let i;\n    let sample;\n    let duration;\n    let size;\n    let flags;\n    let cts;\n    offset += 8 + arraylen;\n    array.set([track.type === 'video' ? 0x01 : 0x00,\n    // version 1 for video with signed-int sample_composition_time_offset\n    0x00, 0x0f, 0x01,\n    // flags\n    len >>> 24 & 0xff, len >>> 16 & 0xff, len >>> 8 & 0xff, len & 0xff,\n    // sample_count\n    offset >>> 24 & 0xff, offset >>> 16 & 0xff, offset >>> 8 & 0xff, offset & 0xff // data_offset\n    ], 0);\n    for (i = 0; i < len; i++) {\n      sample = samples[i];\n      duration = sample.duration;\n      size = sample.size;\n      flags = sample.flags;\n      cts = sample.cts;\n      array.set([duration >>> 24 & 0xff, duration >>> 16 & 0xff, duration >>> 8 & 0xff, duration & 0xff,\n      // sample_duration\n      size >>> 24 & 0xff, size >>> 16 & 0xff, size >>> 8 & 0xff, size & 0xff,\n      // sample_size\n      flags.isLeading << 2 | flags.dependsOn, flags.isDependedOn << 6 | flags.hasRedundancy << 4 | flags.paddingValue << 1 | flags.isNonSync, flags.degradPrio & 0xf0 << 8, flags.degradPrio & 0x0f,\n      // sample_flags\n      cts >>> 24 & 0xff, cts >>> 16 & 0xff, cts >>> 8 & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i);\n    }\n    return MP4.box(MP4.types.trun, array);\n  }\n  static initSegment(tracks) {\n    if (!MP4.types) {\n      MP4.init();\n    }\n    const movie = MP4.moov(tracks);\n    const result = appendUint8Array(MP4.FTYP, movie);\n    return result;\n  }\n}\nMP4.types = void 0;\nMP4.HDLR_TYPES = void 0;\nMP4.STTS = void 0;\nMP4.STSC = void 0;\nMP4.STCO = void 0;\nMP4.STSZ = void 0;\nMP4.VMHD = void 0;\nMP4.SMHD = void 0;\nMP4.STSD = void 0;\nMP4.FTYP = void 0;\nMP4.DINF = void 0;\n\nconst MPEG_TS_CLOCK_FREQ_HZ = 90000;\nfunction toTimescaleFromBase(baseTime, destScale, srcBase = 1, round = false) {\n  const result = baseTime * destScale * srcBase; // equivalent to `(value * scale) / (1 / base)`\n  return round ? Math.round(result) : result;\n}\nfunction toTimescaleFromScale(baseTime, destScale, srcScale = 1, round = false) {\n  return toTimescaleFromBase(baseTime, destScale, 1 / srcScale, round);\n}\nfunction toMsFromMpegTsClock(baseTime, round = false) {\n  return toTimescaleFromBase(baseTime, 1000, 1 / MPEG_TS_CLOCK_FREQ_HZ, round);\n}\nfunction toMpegTsClockFromTimescale(baseTime, srcScale = 1) {\n  return toTimescaleFromBase(baseTime, MPEG_TS_CLOCK_FREQ_HZ, 1 / srcScale);\n}\n\nconst MAX_SILENT_FRAME_DURATION = 10 * 1000; // 10 seconds\nconst AAC_SAMPLES_PER_FRAME = 1024;\nconst MPEG_AUDIO_SAMPLE_PER_FRAME = 1152;\nconst AC3_SAMPLES_PER_FRAME = 1536;\nlet chromeVersion = null;\nlet safariWebkitVersion = null;\nclass MP4Remuxer {\n  constructor(observer, config, typeSupported, vendor = '') {\n    this.observer = void 0;\n    this.config = void 0;\n    this.typeSupported = void 0;\n    this.ISGenerated = false;\n    this._initPTS = null;\n    this._initDTS = null;\n    this.nextAvcDts = null;\n    this.nextAudioPts = null;\n    this.videoSampleDuration = null;\n    this.isAudioContiguous = false;\n    this.isVideoContiguous = false;\n    this.videoTrackConfig = void 0;\n    this.observer = observer;\n    this.config = config;\n    this.typeSupported = typeSupported;\n    this.ISGenerated = false;\n    if (chromeVersion === null) {\n      const userAgent = navigator.userAgent || '';\n      const result = userAgent.match(/Chrome\\/(\\d+)/i);\n      chromeVersion = result ? parseInt(result[1]) : 0;\n    }\n    if (safariWebkitVersion === null) {\n      const result = navigator.userAgent.match(/Safari\\/(\\d+)/i);\n      safariWebkitVersion = result ? parseInt(result[1]) : 0;\n    }\n  }\n  destroy() {\n    // @ts-ignore\n    this.config = this.videoTrackConfig = this._initPTS = this._initDTS = null;\n  }\n  resetTimeStamp(defaultTimeStamp) {\n    logger.log('[mp4-remuxer]: initPTS & initDTS reset');\n    this._initPTS = this._initDTS = defaultTimeStamp;\n  }\n  resetNextTimestamp() {\n    logger.log('[mp4-remuxer]: reset next timestamp');\n    this.isVideoContiguous = false;\n    this.isAudioContiguous = false;\n  }\n  resetInitSegment() {\n    logger.log('[mp4-remuxer]: ISGenerated flag reset');\n    this.ISGenerated = false;\n    this.videoTrackConfig = undefined;\n  }\n  getVideoStartPts(videoSamples) {\n    let rolloverDetected = false;\n    const startPTS = videoSamples.reduce((minPTS, sample) => {\n      const delta = sample.pts - minPTS;\n      if (delta < -4294967296) {\n        // 2^32, see PTSNormalize for reasoning, but we're hitting a rollover here, and we don't want that to impact the timeOffset calculation\n        rolloverDetected = true;\n        return normalizePts(minPTS, sample.pts);\n      } else if (delta > 0) {\n        return minPTS;\n      } else {\n        return sample.pts;\n      }\n    }, videoSamples[0].pts);\n    if (rolloverDetected) {\n      logger.debug('PTS rollover detected');\n    }\n    return startPTS;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, flush, playlistType) {\n    let video;\n    let audio;\n    let initSegment;\n    let text;\n    let id3;\n    let independent;\n    let audioTimeOffset = timeOffset;\n    let videoTimeOffset = timeOffset;\n\n    // If we're remuxing audio and video progressively, wait until we've received enough samples for each track before proceeding.\n    // This is done to synchronize the audio and video streams. We know if the current segment will have samples if the \"pid\"\n    // parameter is greater than -1. The pid is set when the PMT is parsed, which contains the tracks list.\n    // However, if the initSegment has already been generated, or we've reached the end of a segment (flush),\n    // then we can remux one track without waiting for the other.\n    const hasAudio = audioTrack.pid > -1;\n    const hasVideo = videoTrack.pid > -1;\n    const length = videoTrack.samples.length;\n    const enoughAudioSamples = audioTrack.samples.length > 0;\n    const enoughVideoSamples = flush && length > 0 || length > 1;\n    const canRemuxAvc = (!hasAudio || enoughAudioSamples) && (!hasVideo || enoughVideoSamples) || this.ISGenerated || flush;\n    if (canRemuxAvc) {\n      if (this.ISGenerated) {\n        var _videoTrack$pixelRati, _config$pixelRatio, _videoTrack$pixelRati2, _config$pixelRatio2;\n        const config = this.videoTrackConfig;\n        if (config && (videoTrack.width !== config.width || videoTrack.height !== config.height || ((_videoTrack$pixelRati = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati[0]) !== ((_config$pixelRatio = config.pixelRatio) == null ? void 0 : _config$pixelRatio[0]) || ((_videoTrack$pixelRati2 = videoTrack.pixelRatio) == null ? void 0 : _videoTrack$pixelRati2[1]) !== ((_config$pixelRatio2 = config.pixelRatio) == null ? void 0 : _config$pixelRatio2[1]))) {\n          this.resetInitSegment();\n        }\n      } else {\n        initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n      }\n      const isVideoContiguous = this.isVideoContiguous;\n      let firstKeyFrameIndex = -1;\n      let firstKeyFramePTS;\n      if (enoughVideoSamples) {\n        firstKeyFrameIndex = findKeyframeIndex(videoTrack.samples);\n        if (!isVideoContiguous && this.config.forceKeyFrameOnDiscontinuity) {\n          independent = true;\n          if (firstKeyFrameIndex > 0) {\n            logger.warn(`[mp4-remuxer]: Dropped ${firstKeyFrameIndex} out of ${length} video samples due to a missing keyframe`);\n            const startPTS = this.getVideoStartPts(videoTrack.samples);\n            videoTrack.samples = videoTrack.samples.slice(firstKeyFrameIndex);\n            videoTrack.dropped += firstKeyFrameIndex;\n            videoTimeOffset += (videoTrack.samples[0].pts - startPTS) / videoTrack.inputTimeScale;\n            firstKeyFramePTS = videoTimeOffset;\n          } else if (firstKeyFrameIndex === -1) {\n            logger.warn(`[mp4-remuxer]: No keyframe found out of ${length} video samples`);\n            independent = false;\n          }\n        }\n      }\n      if (this.ISGenerated) {\n        if (enoughAudioSamples && enoughVideoSamples) {\n          // timeOffset is expected to be the offset of the first timestamp of this fragment (first DTS)\n          // if first audio DTS is not aligned with first video DTS then we need to take that into account\n          // when providing timeOffset to remuxAudio / remuxVideo. if we don't do that, there might be a permanent / small\n          // drift between audio and video streams\n          const startPTS = this.getVideoStartPts(videoTrack.samples);\n          const tsDelta = normalizePts(audioTrack.samples[0].pts, startPTS) - startPTS;\n          const audiovideoTimestampDelta = tsDelta / videoTrack.inputTimeScale;\n          audioTimeOffset += Math.max(0, audiovideoTimestampDelta);\n          videoTimeOffset += Math.max(0, -audiovideoTimestampDelta);\n        }\n\n        // Purposefully remuxing audio before video, so that remuxVideo can use nextAudioPts, which is calculated in remuxAudio.\n        if (enoughAudioSamples) {\n          // if initSegment was generated without audio samples, regenerate it again\n          if (!audioTrack.samplerate) {\n            logger.warn('[mp4-remuxer]: regenerate InitSegment as audio detected');\n            initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n          }\n          audio = this.remuxAudio(audioTrack, audioTimeOffset, this.isAudioContiguous, accurateTimeOffset, hasVideo || enoughVideoSamples || playlistType === PlaylistLevelType.AUDIO ? videoTimeOffset : undefined);\n          if (enoughVideoSamples) {\n            const audioTrackLength = audio ? audio.endPTS - audio.startPTS : 0;\n            // if initSegment was generated without video samples, regenerate it again\n            if (!videoTrack.inputTimeScale) {\n              logger.warn('[mp4-remuxer]: regenerate InitSegment as video detected');\n              initSegment = this.generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset);\n            }\n            video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, audioTrackLength);\n          }\n        } else if (enoughVideoSamples) {\n          video = this.remuxVideo(videoTrack, videoTimeOffset, isVideoContiguous, 0);\n        }\n        if (video) {\n          video.firstKeyFrame = firstKeyFrameIndex;\n          video.independent = firstKeyFrameIndex !== -1;\n          video.firstKeyFramePTS = firstKeyFramePTS;\n        }\n      }\n    }\n\n    // Allow ID3 and text to remux, even if more audio/video samples are required\n    if (this.ISGenerated && this._initPTS && this._initDTS) {\n      if (id3Track.samples.length) {\n        id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, this._initPTS, this._initDTS);\n      }\n      if (textTrack.samples.length) {\n        text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, this._initPTS);\n      }\n    }\n    return {\n      audio,\n      video,\n      initSegment,\n      independent,\n      text,\n      id3\n    };\n  }\n  generateIS(audioTrack, videoTrack, timeOffset, accurateTimeOffset) {\n    const audioSamples = audioTrack.samples;\n    const videoSamples = videoTrack.samples;\n    const typeSupported = this.typeSupported;\n    const tracks = {};\n    const _initPTS = this._initPTS;\n    let computePTSDTS = !_initPTS || accurateTimeOffset;\n    let container = 'audio/mp4';\n    let initPTS;\n    let initDTS;\n    let timescale;\n    if (computePTSDTS) {\n      initPTS = initDTS = Infinity;\n    }\n    if (audioTrack.config && audioSamples.length) {\n      // let's use audio sampling rate as MP4 time scale.\n      // rationale is that there is a integer nb of audio frames per audio sample (1024 for AAC)\n      // using audio sampling rate here helps having an integer MP4 frame duration\n      // this avoids potential rounding issue and AV sync issue\n      audioTrack.timescale = audioTrack.samplerate;\n      switch (audioTrack.segmentCodec) {\n        case 'mp3':\n          if (typeSupported.mpeg) {\n            // Chrome and Safari\n            container = 'audio/mpeg';\n            audioTrack.codec = '';\n          } else if (typeSupported.mp3) {\n            // Firefox\n            audioTrack.codec = 'mp3';\n          }\n          break;\n        case 'ac3':\n          audioTrack.codec = 'ac-3';\n          break;\n      }\n      tracks.audio = {\n        id: 'audio',\n        container: container,\n        codec: audioTrack.codec,\n        initSegment: audioTrack.segmentCodec === 'mp3' && typeSupported.mpeg ? new Uint8Array(0) : MP4.initSegment([audioTrack]),\n        metadata: {\n          channelCount: audioTrack.channelCount\n        }\n      };\n      if (computePTSDTS) {\n        timescale = audioTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          // remember first PTS of this demuxing context. for audio, PTS = DTS\n          initPTS = initDTS = audioSamples[0].pts - Math.round(timescale * timeOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n    }\n    if (videoTrack.sps && videoTrack.pps && videoSamples.length) {\n      // let's use input time scale as MP4 video timescale\n      // we use input time scale straight away to avoid rounding issues on frame duration / cts computation\n      videoTrack.timescale = videoTrack.inputTimeScale;\n      tracks.video = {\n        id: 'main',\n        container: 'video/mp4',\n        codec: videoTrack.codec,\n        initSegment: MP4.initSegment([videoTrack]),\n        metadata: {\n          width: videoTrack.width,\n          height: videoTrack.height\n        }\n      };\n      if (computePTSDTS) {\n        timescale = videoTrack.inputTimeScale;\n        if (!_initPTS || timescale !== _initPTS.timescale) {\n          const startPTS = this.getVideoStartPts(videoSamples);\n          const startOffset = Math.round(timescale * timeOffset);\n          initDTS = Math.min(initDTS, normalizePts(videoSamples[0].dts, startPTS) - startOffset);\n          initPTS = Math.min(initPTS, startPTS - startOffset);\n        } else {\n          computePTSDTS = false;\n        }\n      }\n      this.videoTrackConfig = {\n        width: videoTrack.width,\n        height: videoTrack.height,\n        pixelRatio: videoTrack.pixelRatio\n      };\n    }\n    if (Object.keys(tracks).length) {\n      this.ISGenerated = true;\n      if (computePTSDTS) {\n        this._initPTS = {\n          baseTime: initPTS,\n          timescale: timescale\n        };\n        this._initDTS = {\n          baseTime: initDTS,\n          timescale: timescale\n        };\n      } else {\n        initPTS = timescale = undefined;\n      }\n      return {\n        tracks,\n        initPTS,\n        timescale\n      };\n    }\n  }\n  remuxVideo(track, timeOffset, contiguous, audioTrackLength) {\n    const timeScale = track.inputTimeScale;\n    const inputSamples = track.samples;\n    const outputSamples = [];\n    const nbSamples = inputSamples.length;\n    const initPTS = this._initPTS;\n    let nextAvcDts = this.nextAvcDts;\n    let offset = 8;\n    let mp4SampleDuration = this.videoSampleDuration;\n    let firstDTS;\n    let lastDTS;\n    let minPTS = Number.POSITIVE_INFINITY;\n    let maxPTS = Number.NEGATIVE_INFINITY;\n    let sortSamples = false;\n\n    // if parsed fragment is contiguous with last one, let's use last DTS value as reference\n    if (!contiguous || nextAvcDts === null) {\n      const pts = timeOffset * timeScale;\n      const cts = inputSamples[0].pts - normalizePts(inputSamples[0].dts, inputSamples[0].pts);\n      if (chromeVersion && nextAvcDts !== null && Math.abs(pts - cts - nextAvcDts) < 15000) {\n        // treat as contigous to adjust samples that would otherwise produce video buffer gaps in Chrome\n        contiguous = true;\n      } else {\n        // if not contiguous, let's use target timeOffset\n        nextAvcDts = pts - cts;\n      }\n    }\n\n    // PTS is coded on 33bits, and can loop from -2^32 to 2^32\n    // PTSNormalize will make PTS/DTS value monotonic, we use last known DTS value as reference value\n    const initTime = initPTS.baseTime * timeScale / initPTS.timescale;\n    for (let i = 0; i < nbSamples; i++) {\n      const sample = inputSamples[i];\n      sample.pts = normalizePts(sample.pts - initTime, nextAvcDts);\n      sample.dts = normalizePts(sample.dts - initTime, nextAvcDts);\n      if (sample.dts < inputSamples[i > 0 ? i - 1 : i].dts) {\n        sortSamples = true;\n      }\n    }\n\n    // sort video samples by DTS then PTS then demux id order\n    if (sortSamples) {\n      inputSamples.sort(function (a, b) {\n        const deltadts = a.dts - b.dts;\n        const deltapts = a.pts - b.pts;\n        return deltadts || deltapts;\n      });\n    }\n\n    // Get first/last DTS\n    firstDTS = inputSamples[0].dts;\n    lastDTS = inputSamples[inputSamples.length - 1].dts;\n\n    // Sample duration (as expected by trun MP4 boxes), should be the delta between sample DTS\n    // set this constant duration as being the avg delta between consecutive DTS.\n    const inputDuration = lastDTS - firstDTS;\n    const averageSampleDuration = inputDuration ? Math.round(inputDuration / (nbSamples - 1)) : mp4SampleDuration || track.inputTimeScale / 30;\n\n    // if fragment are contiguous, detect hole/overlapping between fragments\n    if (contiguous) {\n      // check timestamp continuity across consecutive fragments (this is to remove inter-fragment gap/hole)\n      const delta = firstDTS - nextAvcDts;\n      const foundHole = delta > averageSampleDuration;\n      const foundOverlap = delta < -1;\n      if (foundHole || foundOverlap) {\n        if (foundHole) {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(delta, true)} ms (${delta}dts) hole between fragments detected at ${timeOffset.toFixed(3)}`);\n        } else {\n          logger.warn(`AVC: ${toMsFromMpegTsClock(-delta, true)} ms (${delta}dts) overlapping between fragments detected at ${timeOffset.toFixed(3)}`);\n        }\n        if (!foundOverlap || nextAvcDts >= inputSamples[0].pts || chromeVersion) {\n          firstDTS = nextAvcDts;\n          const firstPTS = inputSamples[0].pts - delta;\n          if (foundHole) {\n            inputSamples[0].dts = firstDTS;\n            inputSamples[0].pts = firstPTS;\n          } else {\n            for (let i = 0; i < inputSamples.length; i++) {\n              if (inputSamples[i].dts > firstPTS) {\n                break;\n              }\n              inputSamples[i].dts -= delta;\n              inputSamples[i].pts -= delta;\n            }\n          }\n          logger.log(`Video: Initial PTS/DTS adjusted: ${toMsFromMpegTsClock(firstPTS, true)}/${toMsFromMpegTsClock(firstDTS, true)}, delta: ${toMsFromMpegTsClock(delta, true)} ms`);\n        }\n      }\n    }\n    firstDTS = Math.max(0, firstDTS);\n    let nbNalu = 0;\n    let naluLen = 0;\n    let dtsStep = firstDTS;\n    for (let i = 0; i < nbSamples; i++) {\n      // compute total/avc sample length and nb of NAL units\n      const sample = inputSamples[i];\n      const units = sample.units;\n      const nbUnits = units.length;\n      let sampleLen = 0;\n      for (let j = 0; j < nbUnits; j++) {\n        sampleLen += units[j].data.length;\n      }\n      naluLen += sampleLen;\n      nbNalu += nbUnits;\n      sample.length = sampleLen;\n\n      // ensure sample monotonic DTS\n      if (sample.dts < dtsStep) {\n        sample.dts = dtsStep;\n        dtsStep += averageSampleDuration / 4 | 0 || 1;\n      } else {\n        dtsStep = sample.dts;\n      }\n      minPTS = Math.min(sample.pts, minPTS);\n      maxPTS = Math.max(sample.pts, maxPTS);\n    }\n    lastDTS = inputSamples[nbSamples - 1].dts;\n\n    /* concatenate the video data and construct the mdat in place\n      (need 8 more bytes to fill length and mpdat type) */\n    const mdatSize = naluLen + 4 * nbNalu + 8;\n    let mdat;\n    try {\n      mdat = new Uint8Array(mdatSize);\n    } catch (err) {\n      this.observer.emit(Events.ERROR, Events.ERROR, {\n        type: ErrorTypes.MUX_ERROR,\n        details: ErrorDetails.REMUX_ALLOC_ERROR,\n        fatal: false,\n        error: err,\n        bytes: mdatSize,\n        reason: `fail allocating video mdat ${mdatSize}`\n      });\n      return;\n    }\n    const view = new DataView(mdat.buffer);\n    view.setUint32(0, mdatSize);\n    mdat.set(MP4.types.mdat, 4);\n    let stretchedLastFrame = false;\n    let minDtsDelta = Number.POSITIVE_INFINITY;\n    let minPtsDelta = Number.POSITIVE_INFINITY;\n    let maxDtsDelta = Number.NEGATIVE_INFINITY;\n    let maxPtsDelta = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < nbSamples; i++) {\n      const VideoSample = inputSamples[i];\n      const VideoSampleUnits = VideoSample.units;\n      let mp4SampleLength = 0;\n      // convert NALU bitstream to MP4 format (prepend NALU with size field)\n      for (let j = 0, nbUnits = VideoSampleUnits.length; j < nbUnits; j++) {\n        const unit = VideoSampleUnits[j];\n        const unitData = unit.data;\n        const unitDataLen = unit.data.byteLength;\n        view.setUint32(offset, unitDataLen);\n        offset += 4;\n        mdat.set(unitData, offset);\n        offset += unitDataLen;\n        mp4SampleLength += 4 + unitDataLen;\n      }\n\n      // expected sample duration is the Decoding Timestamp diff of consecutive samples\n      let ptsDelta;\n      if (i < nbSamples - 1) {\n        mp4SampleDuration = inputSamples[i + 1].dts - VideoSample.dts;\n        ptsDelta = inputSamples[i + 1].pts - VideoSample.pts;\n      } else {\n        const config = this.config;\n        const lastFrameDuration = i > 0 ? VideoSample.dts - inputSamples[i - 1].dts : averageSampleDuration;\n        ptsDelta = i > 0 ? VideoSample.pts - inputSamples[i - 1].pts : averageSampleDuration;\n        if (config.stretchShortVideoTrack && this.nextAudioPts !== null) {\n          // In some cases, a segment's audio track duration may exceed the video track duration.\n          // Since we've already remuxed audio, and we know how long the audio track is, we look to\n          // see if the delta to the next segment is longer than maxBufferHole.\n          // If so, playback would potentially get stuck, so we artificially inflate\n          // the duration of the last frame to minimize any potential gap between segments.\n          const gapTolerance = Math.floor(config.maxBufferHole * timeScale);\n          const deltaToFrameEnd = (audioTrackLength ? minPTS + audioTrackLength * timeScale : this.nextAudioPts) - VideoSample.pts;\n          if (deltaToFrameEnd > gapTolerance) {\n            // We subtract lastFrameDuration from deltaToFrameEnd to try to prevent any video\n            // frame overlap. maxBufferHole should be >> lastFrameDuration anyway.\n            mp4SampleDuration = deltaToFrameEnd - lastFrameDuration;\n            if (mp4SampleDuration < 0) {\n              mp4SampleDuration = lastFrameDuration;\n            } else {\n              stretchedLastFrame = true;\n            }\n            logger.log(`[mp4-remuxer]: It is approximately ${deltaToFrameEnd / 90} ms to the next segment; using duration ${mp4SampleDuration / 90} ms for the last video frame.`);\n          } else {\n            mp4SampleDuration = lastFrameDuration;\n          }\n        } else {\n          mp4SampleDuration = lastFrameDuration;\n        }\n      }\n      const compositionTimeOffset = Math.round(VideoSample.pts - VideoSample.dts);\n      minDtsDelta = Math.min(minDtsDelta, mp4SampleDuration);\n      maxDtsDelta = Math.max(maxDtsDelta, mp4SampleDuration);\n      minPtsDelta = Math.min(minPtsDelta, ptsDelta);\n      maxPtsDelta = Math.max(maxPtsDelta, ptsDelta);\n      outputSamples.push(new Mp4Sample(VideoSample.key, mp4SampleDuration, mp4SampleLength, compositionTimeOffset));\n    }\n    if (outputSamples.length) {\n      if (chromeVersion) {\n        if (chromeVersion < 70) {\n          // Chrome workaround, mark first sample as being a Random Access Point (keyframe) to avoid sourcebuffer append issue\n          // https://code.google.com/p/chromium/issues/detail?id=229412\n          const flags = outputSamples[0].flags;\n          flags.dependsOn = 2;\n          flags.isNonSync = 0;\n        }\n      } else if (safariWebkitVersion) {\n        // Fix for \"CNN special report, with CC\" in test-streams (Safari browser only)\n        // Ignore DTS when frame durations are irregular. Safari MSE does not handle this leading to gaps.\n        if (maxPtsDelta - minPtsDelta < maxDtsDelta - minDtsDelta && averageSampleDuration / maxDtsDelta < 0.025 && outputSamples[0].cts === 0) {\n          logger.warn('Found irregular gaps in sample duration. Using PTS instead of DTS to determine MP4 sample duration.');\n          let dts = firstDTS;\n          for (let i = 0, len = outputSamples.length; i < len; i++) {\n            const nextDts = dts + outputSamples[i].duration;\n            const pts = dts + outputSamples[i].cts;\n            if (i < len - 1) {\n              const nextPts = nextDts + outputSamples[i + 1].cts;\n              outputSamples[i].duration = nextPts - pts;\n            } else {\n              outputSamples[i].duration = i ? outputSamples[i - 1].duration : averageSampleDuration;\n            }\n            outputSamples[i].cts = 0;\n            dts = nextDts;\n          }\n        }\n      }\n    }\n    // next AVC sample DTS should be equal to last sample DTS + last sample duration (in PES timescale)\n    mp4SampleDuration = stretchedLastFrame || !mp4SampleDuration ? averageSampleDuration : mp4SampleDuration;\n    this.nextAvcDts = nextAvcDts = lastDTS + mp4SampleDuration;\n    this.videoSampleDuration = mp4SampleDuration;\n    this.isVideoContiguous = true;\n    const moof = MP4.moof(track.sequenceNumber++, firstDTS, _extends({}, track, {\n      samples: outputSamples\n    }));\n    const type = 'video';\n    const data = {\n      data1: moof,\n      data2: mdat,\n      startPTS: minPTS / timeScale,\n      endPTS: (maxPTS + mp4SampleDuration) / timeScale,\n      startDTS: firstDTS / timeScale,\n      endDTS: nextAvcDts / timeScale,\n      type,\n      hasAudio: false,\n      hasVideo: true,\n      nb: outputSamples.length,\n      dropped: track.dropped\n    };\n    track.samples = [];\n    track.dropped = 0;\n    return data;\n  }\n  getSamplesPerFrame(track) {\n    switch (track.segmentCodec) {\n      case 'mp3':\n        return MPEG_AUDIO_SAMPLE_PER_FRAME;\n      case 'ac3':\n        return AC3_SAMPLES_PER_FRAME;\n      default:\n        return AAC_SAMPLES_PER_FRAME;\n    }\n  }\n  remuxAudio(track, timeOffset, contiguous, accurateTimeOffset, videoTimeOffset) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const mp4SampleDuration = this.getSamplesPerFrame(track);\n    const inputSampleDuration = mp4SampleDuration * scaleFactor;\n    const initPTS = this._initPTS;\n    const rawMPEG = track.segmentCodec === 'mp3' && this.typeSupported.mpeg;\n    const outputSamples = [];\n    const alignedWithVideo = videoTimeOffset !== undefined;\n    let inputSamples = track.samples;\n    let offset = rawMPEG ? 0 : 8;\n    let nextAudioPts = this.nextAudioPts || -1;\n\n    // window.audioSamples ? window.audioSamples.push(inputSamples.map(s => s.pts)) : (window.audioSamples = [inputSamples.map(s => s.pts)]);\n\n    // for audio samples, also consider consecutive fragments as being contiguous (even if a level switch occurs),\n    // for sake of clarity:\n    // consecutive fragments are frags with\n    //  - less than 100ms gaps between new time offset (if accurate) and next expected PTS OR\n    //  - less than 20 audio frames distance\n    // contiguous fragments are consecutive fragments from same quality level (same level, new SN = old SN + 1)\n    // this helps ensuring audio continuity\n    // and this also avoids audio glitches/cut when switching quality, or reporting wrong duration on first audio frame\n    const timeOffsetMpegTS = timeOffset * inputTimeScale;\n    const initTime = initPTS.baseTime * inputTimeScale / initPTS.timescale;\n    this.isAudioContiguous = contiguous = contiguous || inputSamples.length && nextAudioPts > 0 && (accurateTimeOffset && Math.abs(timeOffsetMpegTS - nextAudioPts) < 9000 || Math.abs(normalizePts(inputSamples[0].pts - initTime, timeOffsetMpegTS) - nextAudioPts) < 20 * inputSampleDuration);\n\n    // compute normalized PTS\n    inputSamples.forEach(function (sample) {\n      sample.pts = normalizePts(sample.pts - initTime, timeOffsetMpegTS);\n    });\n    if (!contiguous || nextAudioPts < 0) {\n      // filter out sample with negative PTS that are not playable anyway\n      // if we don't remove these negative samples, they will shift all audio samples forward.\n      // leading to audio overlap between current / next fragment\n      inputSamples = inputSamples.filter(sample => sample.pts >= 0);\n\n      // in case all samples have negative PTS, and have been filtered out, return now\n      if (!inputSamples.length) {\n        return;\n      }\n      if (videoTimeOffset === 0) {\n        // Set the start to 0 to match video so that start gaps larger than inputSampleDuration are filled with silence\n        nextAudioPts = 0;\n      } else if (accurateTimeOffset && !alignedWithVideo) {\n        // When not seeking, not live, and LevelDetails.PTSKnown, use fragment start as predicted next audio PTS\n        nextAudioPts = Math.max(0, timeOffsetMpegTS);\n      } else {\n        // if frags are not contiguous and if we cant trust time offset, let's use first sample PTS as next audio PTS\n        nextAudioPts = inputSamples[0].pts;\n      }\n    }\n\n    // If the audio track is missing samples, the frames seem to get \"left-shifted\" within the\n    // resulting mp4 segment, causing sync issues and leaving gaps at the end of the audio segment.\n    // In an effort to prevent this from happening, we inject frames here where there are gaps.\n    // When possible, we inject a silent frame; when that's not possible, we duplicate the last\n    // frame.\n\n    if (track.segmentCodec === 'aac') {\n      const maxAudioFramesDrift = this.config.maxAudioFramesDrift;\n      for (let i = 0, nextPts = nextAudioPts; i < inputSamples.length; i++) {\n        // First, let's see how far off this frame is from where we expect it to be\n        const sample = inputSamples[i];\n        const pts = sample.pts;\n        const delta = pts - nextPts;\n        const duration = Math.abs(1000 * delta / inputTimeScale);\n\n        // When remuxing with video, if we're overlapping by more than a duration, drop this sample to stay in sync\n        if (delta <= -maxAudioFramesDrift * inputSampleDuration && alignedWithVideo) {\n          if (i === 0) {\n            logger.warn(`Audio frame @ ${(pts / inputTimeScale).toFixed(3)}s overlaps nextAudioPts by ${Math.round(1000 * delta / inputTimeScale)} ms.`);\n            this.nextAudioPts = nextAudioPts = nextPts = pts;\n          }\n        } // eslint-disable-line brace-style\n\n        // Insert missing frames if:\n        // 1: We're more than maxAudioFramesDrift frame away\n        // 2: Not more than MAX_SILENT_FRAME_DURATION away\n        // 3: currentTime (aka nextPtsNorm) is not 0\n        // 4: remuxing with video (videoTimeOffset !== undefined)\n        else if (delta >= maxAudioFramesDrift * inputSampleDuration && duration < MAX_SILENT_FRAME_DURATION && alignedWithVideo) {\n          let missing = Math.round(delta / inputSampleDuration);\n          // Adjust nextPts so that silent samples are aligned with media pts. This will prevent media samples from\n          // later being shifted if nextPts is based on timeOffset and delta is not a multiple of inputSampleDuration.\n          nextPts = pts - missing * inputSampleDuration;\n          if (nextPts < 0) {\n            missing--;\n            nextPts += inputSampleDuration;\n          }\n          if (i === 0) {\n            this.nextAudioPts = nextAudioPts = nextPts;\n          }\n          logger.warn(`[mp4-remuxer]: Injecting ${missing} audio frame @ ${(nextPts / inputTimeScale).toFixed(3)}s due to ${Math.round(1000 * delta / inputTimeScale)} ms gap.`);\n          for (let j = 0; j < missing; j++) {\n            const newStamp = Math.max(nextPts, 0);\n            let fillFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n            if (!fillFrame) {\n              logger.log('[mp4-remuxer]: Unable to get silent frame for given audio codec; duplicating last frame instead.');\n              fillFrame = sample.unit.subarray();\n            }\n            inputSamples.splice(i, 0, {\n              unit: fillFrame,\n              pts: newStamp\n            });\n            nextPts += inputSampleDuration;\n            i++;\n          }\n        }\n        sample.pts = nextPts;\n        nextPts += inputSampleDuration;\n      }\n    }\n    let firstPTS = null;\n    let lastPTS = null;\n    let mdat;\n    let mdatSize = 0;\n    let sampleLength = inputSamples.length;\n    while (sampleLength--) {\n      mdatSize += inputSamples[sampleLength].unit.byteLength;\n    }\n    for (let j = 0, _nbSamples = inputSamples.length; j < _nbSamples; j++) {\n      const audioSample = inputSamples[j];\n      const unit = audioSample.unit;\n      let pts = audioSample.pts;\n      if (lastPTS !== null) {\n        // If we have more than one sample, set the duration of the sample to the \"real\" duration; the PTS diff with\n        // the previous sample\n        const prevSample = outputSamples[j - 1];\n        prevSample.duration = Math.round((pts - lastPTS) / scaleFactor);\n      } else {\n        if (contiguous && track.segmentCodec === 'aac') {\n          // set PTS/DTS to expected PTS/DTS\n          pts = nextAudioPts;\n        }\n        // remember first PTS of our audioSamples\n        firstPTS = pts;\n        if (mdatSize > 0) {\n          /* concatenate the audio data and construct the mdat in place\n            (need 8 more bytes to fill length and mdat type) */\n          mdatSize += offset;\n          try {\n            mdat = new Uint8Array(mdatSize);\n          } catch (err) {\n            this.observer.emit(Events.ERROR, Events.ERROR, {\n              type: ErrorTypes.MUX_ERROR,\n              details: ErrorDetails.REMUX_ALLOC_ERROR,\n              fatal: false,\n              error: err,\n              bytes: mdatSize,\n              reason: `fail allocating audio mdat ${mdatSize}`\n            });\n            return;\n          }\n          if (!rawMPEG) {\n            const view = new DataView(mdat.buffer);\n            view.setUint32(0, mdatSize);\n            mdat.set(MP4.types.mdat, 4);\n          }\n        } else {\n          // no audio samples\n          return;\n        }\n      }\n      mdat.set(unit, offset);\n      const unitLen = unit.byteLength;\n      offset += unitLen;\n      // Default the sample's duration to the computed mp4SampleDuration, which will either be 1024 for AAC or 1152 for MPEG\n      // In the case that we have 1 sample, this will be the duration. If we have more than one sample, the duration\n      // becomes the PTS diff with the previous sample\n      outputSamples.push(new Mp4Sample(true, mp4SampleDuration, unitLen, 0));\n      lastPTS = pts;\n    }\n\n    // We could end up with no audio samples if all input samples were overlapping with the previously remuxed ones\n    const nbSamples = outputSamples.length;\n    if (!nbSamples) {\n      return;\n    }\n\n    // The next audio sample PTS should be equal to last sample PTS + duration\n    const lastSample = outputSamples[outputSamples.length - 1];\n    this.nextAudioPts = nextAudioPts = lastPTS + scaleFactor * lastSample.duration;\n\n    // Set the track samples from inputSamples to outputSamples before remuxing\n    const moof = rawMPEG ? new Uint8Array(0) : MP4.moof(track.sequenceNumber++, firstPTS / scaleFactor, _extends({}, track, {\n      samples: outputSamples\n    }));\n\n    // Clear the track samples. This also clears the samples array in the demuxer, since the reference is shared\n    track.samples = [];\n    const start = firstPTS / inputTimeScale;\n    const end = nextAudioPts / inputTimeScale;\n    const type = 'audio';\n    const audioData = {\n      data1: moof,\n      data2: mdat,\n      startPTS: start,\n      endPTS: end,\n      startDTS: start,\n      endDTS: end,\n      type,\n      hasAudio: true,\n      hasVideo: false,\n      nb: nbSamples\n    };\n    this.isAudioContiguous = true;\n    return audioData;\n  }\n  remuxEmptyAudio(track, timeOffset, contiguous, videoData) {\n    const inputTimeScale = track.inputTimeScale;\n    const mp4timeScale = track.samplerate ? track.samplerate : inputTimeScale;\n    const scaleFactor = inputTimeScale / mp4timeScale;\n    const nextAudioPts = this.nextAudioPts;\n    // sync with video's timestamp\n    const initDTS = this._initDTS;\n    const init90kHz = initDTS.baseTime * 90000 / initDTS.timescale;\n    const startDTS = (nextAudioPts !== null ? nextAudioPts : videoData.startDTS * inputTimeScale) + init90kHz;\n    const endDTS = videoData.endDTS * inputTimeScale + init90kHz;\n    // one sample's duration value\n    const frameDuration = scaleFactor * AAC_SAMPLES_PER_FRAME;\n    // samples count of this segment's duration\n    const nbSamples = Math.ceil((endDTS - startDTS) / frameDuration);\n    // silent frame\n    const silentFrame = AAC.getSilentFrame(track.manifestCodec || track.codec, track.channelCount);\n    logger.warn('[mp4-remuxer]: remux empty Audio');\n    // Can't remux if we can't generate a silent frame...\n    if (!silentFrame) {\n      logger.trace('[mp4-remuxer]: Unable to remuxEmptyAudio since we were unable to get a silent frame for given audio codec');\n      return;\n    }\n    const samples = [];\n    for (let i = 0; i < nbSamples; i++) {\n      const stamp = startDTS + i * frameDuration;\n      samples.push({\n        unit: silentFrame,\n        pts: stamp,\n        dts: stamp\n      });\n    }\n    track.samples = samples;\n    return this.remuxAudio(track, timeOffset, contiguous, false);\n  }\n}\nfunction normalizePts(value, reference) {\n  let offset;\n  if (reference === null) {\n    return value;\n  }\n  if (reference < value) {\n    // - 2^33\n    offset = -8589934592;\n  } else {\n    // + 2^33\n    offset = 8589934592;\n  }\n  /* PTS is 33bit (from 0 to 2^33 -1)\n    if diff between value and reference is bigger than half of the amplitude (2^32) then it means that\n    PTS looping occured. fill the gap */\n  while (Math.abs(value - reference) > 4294967296) {\n    value += offset;\n  }\n  return value;\n}\nfunction findKeyframeIndex(samples) {\n  for (let i = 0; i < samples.length; i++) {\n    if (samples[i].key) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction flushTextTrackMetadataCueSamples(track, timeOffset, initPTS, initDTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting id3 pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n    sample.dts = normalizePts(sample.dts - initDTS.baseTime * inputTimeScale / initDTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nfunction flushTextTrackUserdataCueSamples(track, timeOffset, initPTS) {\n  const length = track.samples.length;\n  if (!length) {\n    return;\n  }\n  const inputTimeScale = track.inputTimeScale;\n  for (let index = 0; index < length; index++) {\n    const sample = track.samples[index];\n    // setting text pts, dts to relative time\n    // using this._initPTS and this._initDTS to calculate relative time\n    sample.pts = normalizePts(sample.pts - initPTS.baseTime * inputTimeScale / initPTS.timescale, timeOffset * inputTimeScale) / inputTimeScale;\n  }\n  track.samples.sort((a, b) => a.pts - b.pts);\n  const samples = track.samples;\n  track.samples = [];\n  return {\n    samples\n  };\n}\nclass Mp4Sample {\n  constructor(isKeyframe, duration, size, cts) {\n    this.size = void 0;\n    this.duration = void 0;\n    this.cts = void 0;\n    this.flags = void 0;\n    this.duration = duration;\n    this.size = size;\n    this.cts = cts;\n    this.flags = {\n      isLeading: 0,\n      isDependedOn: 0,\n      hasRedundancy: 0,\n      degradPrio: 0,\n      dependsOn: isKeyframe ? 2 : 1,\n      isNonSync: isKeyframe ? 0 : 1\n    };\n  }\n}\n\nclass PassThroughRemuxer {\n  constructor() {\n    this.emitInitSegment = false;\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initData = void 0;\n    this.initPTS = null;\n    this.initTracks = void 0;\n    this.lastEndTime = null;\n  }\n  destroy() {}\n  resetTimeStamp(defaultInitPTS) {\n    this.initPTS = defaultInitPTS;\n    this.lastEndTime = null;\n  }\n  resetNextTimestamp() {\n    this.lastEndTime = null;\n  }\n  resetInitSegment(initSegment, audioCodec, videoCodec, decryptdata) {\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.generateInitSegment(patchEncyptionData(initSegment, decryptdata));\n    this.emitInitSegment = true;\n  }\n  generateInitSegment(initSegment) {\n    let {\n      audioCodec,\n      videoCodec\n    } = this;\n    if (!(initSegment != null && initSegment.byteLength)) {\n      this.initTracks = undefined;\n      this.initData = undefined;\n      return;\n    }\n    const initData = this.initData = parseInitSegment(initSegment);\n\n    // Get codec from initSegment or fallback to default\n    if (initData.audio) {\n      audioCodec = getParsedTrackCodec(initData.audio, ElementaryStreamTypes.AUDIO);\n    }\n    if (initData.video) {\n      videoCodec = getParsedTrackCodec(initData.video, ElementaryStreamTypes.VIDEO);\n    }\n    const tracks = {};\n    if (initData.audio && initData.video) {\n      tracks.audiovideo = {\n        container: 'video/mp4',\n        codec: audioCodec + ',' + videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else if (initData.audio) {\n      tracks.audio = {\n        container: 'audio/mp4',\n        codec: audioCodec,\n        initSegment,\n        id: 'audio'\n      };\n    } else if (initData.video) {\n      tracks.video = {\n        container: 'video/mp4',\n        codec: videoCodec,\n        initSegment,\n        id: 'main'\n      };\n    } else {\n      logger.warn('[passthrough-remuxer.ts]: initSegment does not contain moov or trak boxes.');\n    }\n    this.initTracks = tracks;\n  }\n  remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset) {\n    var _initData, _initData2;\n    let {\n      initPTS,\n      lastEndTime\n    } = this;\n    const result = {\n      audio: undefined,\n      video: undefined,\n      text: textTrack,\n      id3: id3Track,\n      initSegment: undefined\n    };\n\n    // If we haven't yet set a lastEndDTS, or it was reset, set it to the provided timeOffset. We want to use the\n    // lastEndDTS over timeOffset whenever possible; during progressive playback, the media source will not update\n    // the media duration (which is what timeOffset is provided as) before we need to process the next chunk.\n    if (!isFiniteNumber(lastEndTime)) {\n      lastEndTime = this.lastEndTime = timeOffset || 0;\n    }\n\n    // The binary segment data is added to the videoTrack in the mp4demuxer. We don't check to see if the data is only\n    // audio or video (or both); adding it to video was an arbitrary choice.\n    const data = videoTrack.samples;\n    if (!(data != null && data.length)) {\n      return result;\n    }\n    const initSegment = {\n      initPTS: undefined,\n      timescale: 1\n    };\n    let initData = this.initData;\n    if (!((_initData = initData) != null && _initData.length)) {\n      this.generateInitSegment(data);\n      initData = this.initData;\n    }\n    if (!((_initData2 = initData) != null && _initData2.length)) {\n      // We can't remux if the initSegment could not be generated\n      logger.warn('[passthrough-remuxer.ts]: Failed to generate initSegment.');\n      return result;\n    }\n    if (this.emitInitSegment) {\n      initSegment.tracks = this.initTracks;\n      this.emitInitSegment = false;\n    }\n    const duration = getDuration(data, initData);\n    const startDTS = getStartDTS(initData, data);\n    const decodeTime = startDTS === null ? timeOffset : startDTS;\n    if (isInvalidInitPts(initPTS, decodeTime, timeOffset, duration) || initSegment.timescale !== initPTS.timescale && accurateTimeOffset) {\n      initSegment.initPTS = decodeTime - timeOffset;\n      if (initPTS && initPTS.timescale === 1) {\n        logger.warn(`Adjusting initPTS by ${initSegment.initPTS - initPTS.baseTime}`);\n      }\n      this.initPTS = initPTS = {\n        baseTime: initSegment.initPTS,\n        timescale: 1\n      };\n    }\n    const startTime = audioTrack ? decodeTime - initPTS.baseTime / initPTS.timescale : lastEndTime;\n    const endTime = startTime + duration;\n    offsetStartDTS(initData, data, initPTS.baseTime / initPTS.timescale);\n    if (duration > 0) {\n      this.lastEndTime = endTime;\n    } else {\n      logger.warn('Duration parsed from mp4 should be greater than zero');\n      this.resetNextTimestamp();\n    }\n    const hasAudio = !!initData.audio;\n    const hasVideo = !!initData.video;\n    let type = '';\n    if (hasAudio) {\n      type += 'audio';\n    }\n    if (hasVideo) {\n      type += 'video';\n    }\n    const track = {\n      data1: data,\n      startPTS: startTime,\n      startDTS: startTime,\n      endPTS: endTime,\n      endDTS: endTime,\n      type,\n      hasAudio,\n      hasVideo,\n      nb: 1,\n      dropped: 0\n    };\n    result.audio = track.type === 'audio' ? track : undefined;\n    result.video = track.type !== 'audio' ? track : undefined;\n    result.initSegment = initSegment;\n    result.id3 = flushTextTrackMetadataCueSamples(id3Track, timeOffset, initPTS, initPTS);\n    if (textTrack.samples.length) {\n      result.text = flushTextTrackUserdataCueSamples(textTrack, timeOffset, initPTS);\n    }\n    return result;\n  }\n}\nfunction isInvalidInitPts(initPTS, startDTS, timeOffset, duration) {\n  if (initPTS === null) {\n    return true;\n  }\n  // InitPTS is invalid when distance from program would be more than segment duration or a minimum of one second\n  const minDuration = Math.max(duration, 1);\n  const startTime = startDTS - initPTS.baseTime / initPTS.timescale;\n  return Math.abs(startTime - timeOffset) > minDuration;\n}\nfunction getParsedTrackCodec(track, type) {\n  const parsedCodec = track == null ? void 0 : track.codec;\n  if (parsedCodec && parsedCodec.length > 4) {\n    return parsedCodec;\n  }\n  if (type === ElementaryStreamTypes.AUDIO) {\n    if (parsedCodec === 'ec-3' || parsedCodec === 'ac-3' || parsedCodec === 'alac') {\n      return parsedCodec;\n    }\n    if (parsedCodec === 'fLaC' || parsedCodec === 'Opus') {\n      // Opting not to get `preferManagedMediaSource` from player config for isSupported() check for simplicity\n      const preferManagedMediaSource = false;\n      return getCodecCompatibleName(parsedCodec, preferManagedMediaSource);\n    }\n    const result = 'mp4a.40.5';\n    logger.info(`Parsed audio codec \"${parsedCodec}\" or audio object type not handled. Using \"${result}\"`);\n    return result;\n  }\n  // Provide defaults based on codec type\n  // This allows for some playback of some fmp4 playlists without CODECS defined in manifest\n  logger.warn(`Unhandled video codec \"${parsedCodec}\"`);\n  if (parsedCodec === 'hvc1' || parsedCodec === 'hev1') {\n    return 'hvc1.1.6.L120.90';\n  }\n  if (parsedCodec === 'av01') {\n    return 'av01.0.04M.08';\n  }\n  return 'avc1.42e01e';\n}\n\nlet now;\n// performance.now() not available on WebWorker, at least on Safari Desktop\ntry {\n  now = self.performance.now.bind(self.performance);\n} catch (err) {\n  logger.debug('Unable to use Performance API on this environment');\n  now = optionalSelf == null ? void 0 : optionalSelf.Date.now;\n}\nconst muxConfig = [{\n  demux: MP4Demuxer,\n  remux: PassThroughRemuxer\n}, {\n  demux: TSDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: AACDemuxer,\n  remux: MP4Remuxer\n}, {\n  demux: MP3Demuxer,\n  remux: MP4Remuxer\n}];\n{\n  muxConfig.splice(2, 0, {\n    demux: AC3Demuxer,\n    remux: MP4Remuxer\n  });\n}\nclass Transmuxer {\n  constructor(observer, typeSupported, config, vendor, id) {\n    this.async = false;\n    this.observer = void 0;\n    this.typeSupported = void 0;\n    this.config = void 0;\n    this.vendor = void 0;\n    this.id = void 0;\n    this.demuxer = void 0;\n    this.remuxer = void 0;\n    this.decrypter = void 0;\n    this.probe = void 0;\n    this.decryptionPromise = null;\n    this.transmuxConfig = void 0;\n    this.currentTransmuxState = void 0;\n    this.observer = observer;\n    this.typeSupported = typeSupported;\n    this.config = config;\n    this.vendor = vendor;\n    this.id = id;\n  }\n  configure(transmuxConfig) {\n    this.transmuxConfig = transmuxConfig;\n    if (this.decrypter) {\n      this.decrypter.reset();\n    }\n  }\n  push(data, decryptdata, chunkMeta, state) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    let uintData = new Uint8Array(data);\n    const {\n      currentTransmuxState,\n      transmuxConfig\n    } = this;\n    if (state) {\n      this.currentTransmuxState = state;\n    }\n    const {\n      contiguous,\n      discontinuity,\n      trackSwitch,\n      accurateTimeOffset,\n      timeOffset,\n      initSegmentChange\n    } = state || currentTransmuxState;\n    const {\n      audioCodec,\n      videoCodec,\n      defaultInitPts,\n      duration,\n      initSegmentData\n    } = transmuxConfig;\n    const keyData = getEncryptionType(uintData, decryptdata);\n    if (keyData && keyData.method === 'AES-128') {\n      const decrypter = this.getDecrypter();\n      // Software decryption is synchronous; webCrypto is not\n      if (decrypter.isSync()) {\n        // Software decryption is progressive. Progressive decryption may not return a result on each call. Any cached\n        // data is handled in the flush() call\n        let decryptedData = decrypter.softwareDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer);\n        // For Low-Latency HLS Parts, decrypt in place, since part parsing is expected on push progress\n        const loadingParts = chunkMeta.part > -1;\n        if (loadingParts) {\n          decryptedData = decrypter.flush();\n        }\n        if (!decryptedData) {\n          stats.executeEnd = now();\n          return emptyResult(chunkMeta);\n        }\n        uintData = new Uint8Array(decryptedData);\n      } else {\n        this.decryptionPromise = decrypter.webCryptoDecrypt(uintData, keyData.key.buffer, keyData.iv.buffer).then(decryptedData => {\n          // Calling push here is important; if flush() is called while this is still resolving, this ensures that\n          // the decrypted data has been transmuxed\n          const result = this.push(decryptedData, null, chunkMeta);\n          this.decryptionPromise = null;\n          return result;\n        });\n        return this.decryptionPromise;\n      }\n    }\n    const resetMuxers = this.needsProbing(discontinuity, trackSwitch);\n    if (resetMuxers) {\n      const error = this.configureTransmuxer(uintData);\n      if (error) {\n        logger.warn(`[transmuxer] ${error.message}`);\n        this.observer.emit(Events.ERROR, Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_PARSING_ERROR,\n          fatal: false,\n          error,\n          reason: error.message\n        });\n        stats.executeEnd = now();\n        return emptyResult(chunkMeta);\n      }\n    }\n    if (discontinuity || trackSwitch || initSegmentChange || resetMuxers) {\n      this.resetInitSegment(initSegmentData, audioCodec, videoCodec, duration, decryptdata);\n    }\n    if (discontinuity || initSegmentChange || resetMuxers) {\n      this.resetInitialTimestamp(defaultInitPts);\n    }\n    if (!contiguous) {\n      this.resetContiguity();\n    }\n    const result = this.transmux(uintData, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    const currentState = this.currentTransmuxState;\n    currentState.contiguous = true;\n    currentState.discontinuity = false;\n    currentState.trackSwitch = false;\n    stats.executeEnd = now();\n    return result;\n  }\n\n  // Due to data caching, flush calls can produce more than one TransmuxerResult (hence the Array type)\n  flush(chunkMeta) {\n    const stats = chunkMeta.transmuxing;\n    stats.executeStart = now();\n    const {\n      decrypter,\n      currentTransmuxState,\n      decryptionPromise\n    } = this;\n    if (decryptionPromise) {\n      // Upon resolution, the decryption promise calls push() and returns its TransmuxerResult up the stack. Therefore\n      // only flushing is required for async decryption\n      return decryptionPromise.then(() => {\n        return this.flush(chunkMeta);\n      });\n    }\n    const transmuxResults = [];\n    const {\n      timeOffset\n    } = currentTransmuxState;\n    if (decrypter) {\n      // The decrypter may have data cached, which needs to be demuxed. In this case we'll have two TransmuxResults\n      // This happens in the case that we receive only 1 push call for a segment (either for non-progressive downloads,\n      // or for progressive downloads with small segments)\n      const decryptedData = decrypter.flush();\n      if (decryptedData) {\n        // Push always returns a TransmuxerResult if decryptdata is null\n        transmuxResults.push(this.push(decryptedData, null, chunkMeta));\n      }\n    }\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      // If probing failed, then Hls.js has been given content its not able to handle\n      stats.executeEnd = now();\n      return [emptyResult(chunkMeta)];\n    }\n    const demuxResultOrPromise = demuxer.flush(timeOffset);\n    if (isPromise(demuxResultOrPromise)) {\n      // Decrypt final SAMPLE-AES samples\n      return demuxResultOrPromise.then(demuxResult => {\n        this.flushRemux(transmuxResults, demuxResult, chunkMeta);\n        return transmuxResults;\n      });\n    }\n    this.flushRemux(transmuxResults, demuxResultOrPromise, chunkMeta);\n    return transmuxResults;\n  }\n  flushRemux(transmuxResults, demuxResult, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = demuxResult;\n    const {\n      accurateTimeOffset,\n      timeOffset\n    } = this.currentTransmuxState;\n    logger.log(`[transmuxer.ts]: Flushed fragment ${chunkMeta.sn}${chunkMeta.part > -1 ? ' p: ' + chunkMeta.part : ''} of level ${chunkMeta.level}`);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, true, this.id);\n    transmuxResults.push({\n      remuxResult,\n      chunkMeta\n    });\n    chunkMeta.transmuxing.executeEnd = now();\n  }\n  resetInitialTimestamp(defaultInitPts) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetTimeStamp(defaultInitPts);\n    remuxer.resetTimeStamp(defaultInitPts);\n  }\n  resetContiguity() {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetContiguity();\n    remuxer.resetNextTimestamp();\n  }\n  resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration, decryptdata) {\n    const {\n      demuxer,\n      remuxer\n    } = this;\n    if (!demuxer || !remuxer) {\n      return;\n    }\n    demuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, trackDuration);\n    remuxer.resetInitSegment(initSegmentData, audioCodec, videoCodec, decryptdata);\n  }\n  destroy() {\n    if (this.demuxer) {\n      this.demuxer.destroy();\n      this.demuxer = undefined;\n    }\n    if (this.remuxer) {\n      this.remuxer.destroy();\n      this.remuxer = undefined;\n    }\n  }\n  transmux(data, keyData, timeOffset, accurateTimeOffset, chunkMeta) {\n    let result;\n    if (keyData && keyData.method === 'SAMPLE-AES') {\n      result = this.transmuxSampleAes(data, keyData, timeOffset, accurateTimeOffset, chunkMeta);\n    } else {\n      result = this.transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta);\n    }\n    return result;\n  }\n  transmuxUnencrypted(data, timeOffset, accurateTimeOffset, chunkMeta) {\n    const {\n      audioTrack,\n      videoTrack,\n      id3Track,\n      textTrack\n    } = this.demuxer.demux(data, timeOffset, false, !this.config.progressive);\n    const remuxResult = this.remuxer.remux(audioTrack, videoTrack, id3Track, textTrack, timeOffset, accurateTimeOffset, false, this.id);\n    return {\n      remuxResult,\n      chunkMeta\n    };\n  }\n  transmuxSampleAes(data, decryptData, timeOffset, accurateTimeOffset, chunkMeta) {\n    return this.demuxer.demuxSampleAes(data, decryptData, timeOffset).then(demuxResult => {\n      const remuxResult = this.remuxer.remux(demuxResult.audioTrack, demuxResult.videoTrack, demuxResult.id3Track, demuxResult.textTrack, timeOffset, accurateTimeOffset, false, this.id);\n      return {\n        remuxResult,\n        chunkMeta\n      };\n    });\n  }\n  configureTransmuxer(data) {\n    const {\n      config,\n      observer,\n      typeSupported,\n      vendor\n    } = this;\n    // probe for content type\n    let mux;\n    for (let i = 0, len = muxConfig.length; i < len; i++) {\n      var _muxConfig$i$demux;\n      if ((_muxConfig$i$demux = muxConfig[i].demux) != null && _muxConfig$i$demux.probe(data)) {\n        mux = muxConfig[i];\n        break;\n      }\n    }\n    if (!mux) {\n      return new Error('Failed to find demuxer by probing fragment data');\n    }\n    // so let's check that current remuxer and demuxer are still valid\n    const demuxer = this.demuxer;\n    const remuxer = this.remuxer;\n    const Remuxer = mux.remux;\n    const Demuxer = mux.demux;\n    if (!remuxer || !(remuxer instanceof Remuxer)) {\n      this.remuxer = new Remuxer(observer, config, typeSupported, vendor);\n    }\n    if (!demuxer || !(demuxer instanceof Demuxer)) {\n      this.demuxer = new Demuxer(observer, config, typeSupported);\n      this.probe = Demuxer.probe;\n    }\n  }\n  needsProbing(discontinuity, trackSwitch) {\n    // in case of continuity change, or track switch\n    // we might switch from content type (AAC container to TS container, or TS to fmp4 for example)\n    return !this.demuxer || !this.remuxer || discontinuity || trackSwitch;\n  }\n  getDecrypter() {\n    let decrypter = this.decrypter;\n    if (!decrypter) {\n      decrypter = this.decrypter = new Decrypter(this.config);\n    }\n    return decrypter;\n  }\n}\nfunction getEncryptionType(data, decryptData) {\n  let encryptionType = null;\n  if (data.byteLength > 0 && (decryptData == null ? void 0 : decryptData.key) != null && decryptData.iv !== null && decryptData.method != null) {\n    encryptionType = decryptData;\n  }\n  return encryptionType;\n}\nconst emptyResult = chunkMeta => ({\n  remuxResult: {},\n  chunkMeta\n});\nfunction isPromise(p) {\n  return 'then' in p && p.then instanceof Function;\n}\nclass TransmuxConfig {\n  constructor(audioCodec, videoCodec, initSegmentData, duration, defaultInitPts) {\n    this.audioCodec = void 0;\n    this.videoCodec = void 0;\n    this.initSegmentData = void 0;\n    this.duration = void 0;\n    this.defaultInitPts = void 0;\n    this.audioCodec = audioCodec;\n    this.videoCodec = videoCodec;\n    this.initSegmentData = initSegmentData;\n    this.duration = duration;\n    this.defaultInitPts = defaultInitPts || null;\n  }\n}\nclass TransmuxState {\n  constructor(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange) {\n    this.discontinuity = void 0;\n    this.contiguous = void 0;\n    this.accurateTimeOffset = void 0;\n    this.trackSwitch = void 0;\n    this.timeOffset = void 0;\n    this.initSegmentChange = void 0;\n    this.discontinuity = discontinuity;\n    this.contiguous = contiguous;\n    this.accurateTimeOffset = accurateTimeOffset;\n    this.trackSwitch = trackSwitch;\n    this.timeOffset = timeOffset;\n    this.initSegmentChange = initSegmentChange;\n  }\n}\n\nvar eventemitter3 = {exports: {}};\n\n(function (module) {\n\n\tvar has = Object.prototype.hasOwnProperty\n\t  , prefix = '~';\n\n\t/**\n\t * Constructor to create a storage for our `EE` objects.\n\t * An `Events` instance is a plain object whose properties are event names.\n\t *\n\t * @constructor\n\t * @private\n\t */\n\tfunction Events() {}\n\n\t//\n\t// We try to not inherit from `Object.prototype`. In some engines creating an\n\t// instance in this way is faster than calling `Object.create(null)` directly.\n\t// If `Object.create(null)` is not supported we prefix the event names with a\n\t// character to make sure that the built-in object properties are not\n\t// overridden or used as an attack vector.\n\t//\n\tif (Object.create) {\n\t  Events.prototype = Object.create(null);\n\n\t  //\n\t  // This hack is needed because the `__proto__` property is still inherited in\n\t  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n\t  //\n\t  if (!new Events().__proto__) prefix = false;\n\t}\n\n\t/**\n\t * Representation of a single event listener.\n\t *\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n\t * @constructor\n\t * @private\n\t */\n\tfunction EE(fn, context, once) {\n\t  this.fn = fn;\n\t  this.context = context;\n\t  this.once = once || false;\n\t}\n\n\t/**\n\t * Add a listener for a given event.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} context The context to invoke the listener with.\n\t * @param {Boolean} once Specify if the listener is a one-time listener.\n\t * @returns {EventEmitter}\n\t * @private\n\t */\n\tfunction addListener(emitter, event, fn, context, once) {\n\t  if (typeof fn !== 'function') {\n\t    throw new TypeError('The listener must be a function');\n\t  }\n\n\t  var listener = new EE(fn, context || emitter, once)\n\t    , evt = prefix ? prefix + event : event;\n\n\t  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n\t  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n\t  else emitter._events[evt] = [emitter._events[evt], listener];\n\n\t  return emitter;\n\t}\n\n\t/**\n\t * Clear event by name.\n\t *\n\t * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n\t * @param {(String|Symbol)} evt The Event name.\n\t * @private\n\t */\n\tfunction clearEvent(emitter, evt) {\n\t  if (--emitter._eventsCount === 0) emitter._events = new Events();\n\t  else delete emitter._events[evt];\n\t}\n\n\t/**\n\t * Minimal `EventEmitter` interface that is molded against the Node.js\n\t * `EventEmitter` interface.\n\t *\n\t * @constructor\n\t * @public\n\t */\n\tfunction EventEmitter() {\n\t  this._events = new Events();\n\t  this._eventsCount = 0;\n\t}\n\n\t/**\n\t * Return an array listing the events for which the emitter has registered\n\t * listeners.\n\t *\n\t * @returns {Array}\n\t * @public\n\t */\n\tEventEmitter.prototype.eventNames = function eventNames() {\n\t  var names = []\n\t    , events\n\t    , name;\n\n\t  if (this._eventsCount === 0) return names;\n\n\t  for (name in (events = this._events)) {\n\t    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n\t  }\n\n\t  if (Object.getOwnPropertySymbols) {\n\t    return names.concat(Object.getOwnPropertySymbols(events));\n\t  }\n\n\t  return names;\n\t};\n\n\t/**\n\t * Return the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Array} The registered listeners.\n\t * @public\n\t */\n\tEventEmitter.prototype.listeners = function listeners(event) {\n\t  var evt = prefix ? prefix + event : event\n\t    , handlers = this._events[evt];\n\n\t  if (!handlers) return [];\n\t  if (handlers.fn) return [handlers.fn];\n\n\t  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n\t    ee[i] = handlers[i].fn;\n\t  }\n\n\t  return ee;\n\t};\n\n\t/**\n\t * Return the number of listeners listening to a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Number} The number of listeners.\n\t * @public\n\t */\n\tEventEmitter.prototype.listenerCount = function listenerCount(event) {\n\t  var evt = prefix ? prefix + event : event\n\t    , listeners = this._events[evt];\n\n\t  if (!listeners) return 0;\n\t  if (listeners.fn) return 1;\n\t  return listeners.length;\n\t};\n\n\t/**\n\t * Calls each of the listeners registered for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @returns {Boolean} `true` if the event had listeners, else `false`.\n\t * @public\n\t */\n\tEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n\t  var evt = prefix ? prefix + event : event;\n\n\t  if (!this._events[evt]) return false;\n\n\t  var listeners = this._events[evt]\n\t    , len = arguments.length\n\t    , args\n\t    , i;\n\n\t  if (listeners.fn) {\n\t    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n\t    switch (len) {\n\t      case 1: return listeners.fn.call(listeners.context), true;\n\t      case 2: return listeners.fn.call(listeners.context, a1), true;\n\t      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n\t      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n\t      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n\t      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n\t    }\n\n\t    for (i = 1, args = new Array(len -1); i < len; i++) {\n\t      args[i - 1] = arguments[i];\n\t    }\n\n\t    listeners.fn.apply(listeners.context, args);\n\t  } else {\n\t    var length = listeners.length\n\t      , j;\n\n\t    for (i = 0; i < length; i++) {\n\t      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n\t      switch (len) {\n\t        case 1: listeners[i].fn.call(listeners[i].context); break;\n\t        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n\t        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n\t        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n\t        default:\n\t          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n\t            args[j - 1] = arguments[j];\n\t          }\n\n\t          listeners[i].fn.apply(listeners[i].context, args);\n\t      }\n\t    }\n\t  }\n\n\t  return true;\n\t};\n\n\t/**\n\t * Add a listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.on = function on(event, fn, context) {\n\t  return addListener(this, event, fn, context, false);\n\t};\n\n\t/**\n\t * Add a one-time listener for a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn The listener function.\n\t * @param {*} [context=this] The context to invoke the listener with.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.once = function once(event, fn, context) {\n\t  return addListener(this, event, fn, context, true);\n\t};\n\n\t/**\n\t * Remove the listeners of a given event.\n\t *\n\t * @param {(String|Symbol)} event The event name.\n\t * @param {Function} fn Only remove the listeners that match this function.\n\t * @param {*} context Only remove the listeners that have this context.\n\t * @param {Boolean} once Only remove one-time listeners.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n\t  var evt = prefix ? prefix + event : event;\n\n\t  if (!this._events[evt]) return this;\n\t  if (!fn) {\n\t    clearEvent(this, evt);\n\t    return this;\n\t  }\n\n\t  var listeners = this._events[evt];\n\n\t  if (listeners.fn) {\n\t    if (\n\t      listeners.fn === fn &&\n\t      (!once || listeners.once) &&\n\t      (!context || listeners.context === context)\n\t    ) {\n\t      clearEvent(this, evt);\n\t    }\n\t  } else {\n\t    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n\t      if (\n\t        listeners[i].fn !== fn ||\n\t        (once && !listeners[i].once) ||\n\t        (context && listeners[i].context !== context)\n\t      ) {\n\t        events.push(listeners[i]);\n\t      }\n\t    }\n\n\t    //\n\t    // Reset the array, or remove it completely if we have no more listeners.\n\t    //\n\t    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n\t    else clearEvent(this, evt);\n\t  }\n\n\t  return this;\n\t};\n\n\t/**\n\t * Remove all listeners, or those of the specified event.\n\t *\n\t * @param {(String|Symbol)} [event] The event name.\n\t * @returns {EventEmitter} `this`.\n\t * @public\n\t */\n\tEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n\t  var evt;\n\n\t  if (event) {\n\t    evt = prefix ? prefix + event : event;\n\t    if (this._events[evt]) clearEvent(this, evt);\n\t  } else {\n\t    this._events = new Events();\n\t    this._eventsCount = 0;\n\t  }\n\n\t  return this;\n\t};\n\n\t//\n\t// Alias methods names because people roll like that.\n\t//\n\tEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\tEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n\t//\n\t// Expose the prefix.\n\t//\n\tEventEmitter.prefixed = prefix;\n\n\t//\n\t// Allow `EventEmitter` to be imported as module namespace.\n\t//\n\tEventEmitter.EventEmitter = EventEmitter;\n\n\t//\n\t// Expose the module.\n\t//\n\t{\n\t  module.exports = EventEmitter;\n\t} \n} (eventemitter3));\n\nvar eventemitter3Exports = eventemitter3.exports;\nvar EventEmitter = /*@__PURE__*/getDefaultExportFromCjs(eventemitter3Exports);\n\nclass TransmuxerInterface {\n  constructor(hls, id, onTransmuxComplete, onFlush) {\n    this.error = null;\n    this.hls = void 0;\n    this.id = void 0;\n    this.observer = void 0;\n    this.frag = null;\n    this.part = null;\n    this.useWorker = void 0;\n    this.workerContext = null;\n    this.onwmsg = void 0;\n    this.transmuxer = null;\n    this.onTransmuxComplete = void 0;\n    this.onFlush = void 0;\n    const config = hls.config;\n    this.hls = hls;\n    this.id = id;\n    this.useWorker = !!config.enableWorker;\n    this.onTransmuxComplete = onTransmuxComplete;\n    this.onFlush = onFlush;\n    const forwardMessage = (ev, data) => {\n      data = data || {};\n      data.frag = this.frag;\n      data.id = this.id;\n      if (ev === Events.ERROR) {\n        this.error = data.error;\n      }\n      this.hls.trigger(ev, data);\n    };\n\n    // forward events to main thread\n    this.observer = new EventEmitter();\n    this.observer.on(Events.FRAG_DECRYPTED, forwardMessage);\n    this.observer.on(Events.ERROR, forwardMessage);\n    const MediaSource = getMediaSource(config.preferManagedMediaSource) || {\n      isTypeSupported: () => false\n    };\n    const m2tsTypeSupported = {\n      mpeg: MediaSource.isTypeSupported('audio/mpeg'),\n      mp3: MediaSource.isTypeSupported('audio/mp4; codecs=\"mp3\"'),\n      ac3: MediaSource.isTypeSupported('audio/mp4; codecs=\"ac-3\"') \n    };\n    if (this.useWorker && typeof Worker !== 'undefined') {\n      const canCreateWorker = config.workerPath || hasUMDWorker();\n      if (canCreateWorker) {\n        try {\n          if (config.workerPath) {\n            logger.log(`loading Web Worker ${config.workerPath} for \"${id}\"`);\n            this.workerContext = loadWorker(config.workerPath);\n          } else {\n            logger.log(`injecting Web Worker for \"${id}\"`);\n            this.workerContext = injectWorker();\n          }\n          this.onwmsg = event => this.onWorkerMessage(event);\n          const {\n            worker\n          } = this.workerContext;\n          worker.addEventListener('message', this.onwmsg);\n          worker.onerror = event => {\n            const error = new Error(`${event.message}  (${event.filename}:${event.lineno})`);\n            config.enableWorker = false;\n            logger.warn(`Error in \"${id}\" Web Worker, fallback to inline`);\n            this.hls.trigger(Events.ERROR, {\n              type: ErrorTypes.OTHER_ERROR,\n              details: ErrorDetails.INTERNAL_EXCEPTION,\n              fatal: false,\n              event: 'demuxerWorker',\n              error\n            });\n          };\n          worker.postMessage({\n            cmd: 'init',\n            typeSupported: m2tsTypeSupported,\n            vendor: '',\n            id: id,\n            config: JSON.stringify(config)\n          });\n        } catch (err) {\n          logger.warn(`Error setting up \"${id}\" Web Worker, fallback to inline`, err);\n          this.resetWorker();\n          this.error = null;\n          this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id);\n        }\n        return;\n      }\n    }\n    this.transmuxer = new Transmuxer(this.observer, m2tsTypeSupported, config, '', id);\n  }\n  resetWorker() {\n    if (this.workerContext) {\n      const {\n        worker,\n        objectURL\n      } = this.workerContext;\n      if (objectURL) {\n        // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n        self.URL.revokeObjectURL(objectURL);\n      }\n      worker.removeEventListener('message', this.onwmsg);\n      worker.onerror = null;\n      worker.terminate();\n      this.workerContext = null;\n    }\n  }\n  destroy() {\n    if (this.workerContext) {\n      this.resetWorker();\n      this.onwmsg = undefined;\n    } else {\n      const transmuxer = this.transmuxer;\n      if (transmuxer) {\n        transmuxer.destroy();\n        this.transmuxer = null;\n      }\n    }\n    const observer = this.observer;\n    if (observer) {\n      observer.removeAllListeners();\n    }\n    this.frag = null;\n    // @ts-ignore\n    this.observer = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  push(data, initSegmentData, audioCodec, videoCodec, frag, part, duration, accurateTimeOffset, chunkMeta, defaultInitPTS) {\n    var _frag$initSegment, _lastFrag$initSegment;\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    const timeOffset = part ? part.start : frag.start;\n    // TODO: push \"clear-lead\" decrypt data for unencrypted fragments in streams with encrypted ones\n    const decryptdata = frag.decryptdata;\n    const lastFrag = this.frag;\n    const discontinuity = !(lastFrag && frag.cc === lastFrag.cc);\n    const trackSwitch = !(lastFrag && chunkMeta.level === lastFrag.level);\n    const snDiff = lastFrag ? chunkMeta.sn - lastFrag.sn : -1;\n    const partDiff = this.part ? chunkMeta.part - this.part.index : -1;\n    const progressive = snDiff === 0 && chunkMeta.id > 1 && chunkMeta.id === (lastFrag == null ? void 0 : lastFrag.stats.chunkCount);\n    const contiguous = !trackSwitch && (snDiff === 1 || snDiff === 0 && (partDiff === 1 || progressive && partDiff <= 0));\n    const now = self.performance.now();\n    if (trackSwitch || snDiff || frag.stats.parsing.start === 0) {\n      frag.stats.parsing.start = now;\n    }\n    if (part && (partDiff || !contiguous)) {\n      part.stats.parsing.start = now;\n    }\n    const initSegmentChange = !(lastFrag && ((_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.url) === ((_lastFrag$initSegment = lastFrag.initSegment) == null ? void 0 : _lastFrag$initSegment.url));\n    const state = new TransmuxState(discontinuity, contiguous, accurateTimeOffset, trackSwitch, timeOffset, initSegmentChange);\n    if (!contiguous || discontinuity || initSegmentChange) {\n      logger.log(`[transmuxer-interface, ${frag.type}]: Starting new transmux session for sn: ${chunkMeta.sn} p: ${chunkMeta.part} level: ${chunkMeta.level} id: ${chunkMeta.id}\n        discontinuity: ${discontinuity}\n        trackSwitch: ${trackSwitch}\n        contiguous: ${contiguous}\n        accurateTimeOffset: ${accurateTimeOffset}\n        timeOffset: ${timeOffset}\n        initSegmentChange: ${initSegmentChange}`);\n      const config = new TransmuxConfig(audioCodec, videoCodec, initSegmentData, duration, defaultInitPTS);\n      this.configureTransmuxer(config);\n    }\n    this.frag = frag;\n    this.part = part;\n\n    // Frags with sn of 'initSegment' are not transmuxed\n    if (this.workerContext) {\n      // post fragment payload as transferable objects for ArrayBuffer (no copy)\n      this.workerContext.worker.postMessage({\n        cmd: 'demux',\n        data,\n        decryptdata,\n        chunkMeta,\n        state\n      }, data instanceof ArrayBuffer ? [data] : []);\n    } else if (transmuxer) {\n      const transmuxResult = transmuxer.push(data, decryptdata, chunkMeta, state);\n      if (isPromise(transmuxResult)) {\n        transmuxer.async = true;\n        transmuxResult.then(data => {\n          this.handleTransmuxComplete(data);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface push error');\n        });\n      } else {\n        transmuxer.async = false;\n        this.handleTransmuxComplete(transmuxResult);\n      }\n    }\n  }\n  flush(chunkMeta) {\n    chunkMeta.transmuxing.start = self.performance.now();\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'flush',\n        chunkMeta\n      });\n    } else if (transmuxer) {\n      let transmuxResult = transmuxer.flush(chunkMeta);\n      const asyncFlush = isPromise(transmuxResult);\n      if (asyncFlush || transmuxer.async) {\n        if (!isPromise(transmuxResult)) {\n          transmuxResult = Promise.resolve(transmuxResult);\n        }\n        transmuxResult.then(data => {\n          this.handleFlushResult(data, chunkMeta);\n        }).catch(error => {\n          this.transmuxerError(error, chunkMeta, 'transmuxer-interface flush error');\n        });\n      } else {\n        this.handleFlushResult(transmuxResult, chunkMeta);\n      }\n    }\n  }\n  transmuxerError(error, chunkMeta, reason) {\n    if (!this.hls) {\n      return;\n    }\n    this.error = error;\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.FRAG_PARSING_ERROR,\n      chunkMeta,\n      frag: this.frag || undefined,\n      fatal: false,\n      error,\n      err: error,\n      reason\n    });\n  }\n  handleFlushResult(results, chunkMeta) {\n    results.forEach(result => {\n      this.handleTransmuxComplete(result);\n    });\n    this.onFlush(chunkMeta);\n  }\n  onWorkerMessage(event) {\n    const data = event.data;\n    if (!(data != null && data.event)) {\n      logger.warn(`worker message received with no ${data ? 'event name' : 'data'}`);\n      return;\n    }\n    const hls = this.hls;\n    if (!this.hls) {\n      return;\n    }\n    switch (data.event) {\n      case 'init':\n        {\n          var _this$workerContext;\n          const objectURL = (_this$workerContext = this.workerContext) == null ? void 0 : _this$workerContext.objectURL;\n          if (objectURL) {\n            // revoke the Object URL that was used to create transmuxer worker, so as not to leak it\n            self.URL.revokeObjectURL(objectURL);\n          }\n          break;\n        }\n      case 'transmuxComplete':\n        {\n          this.handleTransmuxComplete(data.data);\n          break;\n        }\n      case 'flush':\n        {\n          this.onFlush(data.data);\n          break;\n        }\n\n      // pass logs from the worker thread to the main logger\n      case 'workerLog':\n        if (logger[data.data.logType]) {\n          logger[data.data.logType](data.data.message);\n        }\n        break;\n      default:\n        {\n          data.data = data.data || {};\n          data.data.frag = this.frag;\n          data.data.id = this.id;\n          hls.trigger(data.event, data.data);\n          break;\n        }\n    }\n  }\n  configureTransmuxer(config) {\n    const {\n      transmuxer\n    } = this;\n    if (this.workerContext) {\n      this.workerContext.worker.postMessage({\n        cmd: 'configure',\n        config\n      });\n    } else if (transmuxer) {\n      transmuxer.configure(config);\n    }\n  }\n  handleTransmuxComplete(result) {\n    result.chunkMeta.transmuxing.end = self.performance.now();\n    this.onTransmuxComplete(result);\n  }\n}\n\nfunction subtitleOptionsIdentical(trackList1, trackList2) {\n  if (trackList1.length !== trackList2.length) {\n    return false;\n  }\n  for (let i = 0; i < trackList1.length; i++) {\n    if (!mediaAttributesIdentical(trackList1[i].attrs, trackList2[i].attrs)) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction mediaAttributesIdentical(attrs1, attrs2, customAttributes) {\n  // Media options with the same rendition ID must be bit identical\n  const stableRenditionId = attrs1['STABLE-RENDITION-ID'];\n  if (stableRenditionId && !customAttributes) {\n    return stableRenditionId === attrs2['STABLE-RENDITION-ID'];\n  }\n  // When rendition ID is not present, compare attributes\n  return !(customAttributes || ['LANGUAGE', 'NAME', 'CHARACTERISTICS', 'AUTOSELECT', 'DEFAULT', 'FORCED', 'ASSOC-LANGUAGE']).some(subtitleAttribute => attrs1[subtitleAttribute] !== attrs2[subtitleAttribute]);\n}\nfunction subtitleTrackMatchesTextTrack(subtitleTrack, textTrack) {\n  return textTrack.label.toLowerCase() === subtitleTrack.name.toLowerCase() && (!textTrack.language || textTrack.language.toLowerCase() === (subtitleTrack.lang || '').toLowerCase());\n}\n\nconst TICK_INTERVAL$2 = 100; // how often to tick in ms\n\nclass AudioStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[audio-stream-controller]', PlaylistLevelType.AUDIO);\n    this.videoBuffer = null;\n    this.videoTrackCC = -1;\n    this.waitingVideoCC = -1;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n    this.trackId = -1;\n    this.waitingData = null;\n    this.mainDetails = null;\n    this.flushing = false;\n    this.bufferFlushed = false;\n    this.cachedTrackLoadedData = null;\n    this._registerListeners();\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    super.onHandlerDestroying();\n    this.mainDetails = null;\n    this.bufferedTrack = null;\n    this.switchingTrack = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.AUDIO_TRACKS_UPDATED, this.onAudioTracksUpdated, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n\n  // INIT_PTS_FOUND is triggered when the video track parsed in the stream-controller has a new PTS value\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    // Always update the new INIT PTS\n    // Can change due level switch\n    if (id === 'main') {\n      const cc = frag.cc;\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n      this.log(`InitPTS for cc: ${cc} found from main: ${initPTS}`);\n      this.videoTrackCC = cc;\n      // If we are waiting, tick immediately to unblock audio fragment transmuxing\n      if (this.state === State.WAITING_INIT_PTS) {\n        this.tick();\n      }\n    }\n  }\n  startLoad(startPosition) {\n    if (!this.levels) {\n      this.startPosition = startPosition;\n      this.state = State.STOPPED;\n      return;\n    }\n    const lastCurrentTime = this.lastCurrentTime;\n    this.stopLoad();\n    this.setInterval(TICK_INTERVAL$2);\n    if (lastCurrentTime > 0 && startPosition === -1) {\n      this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n      startPosition = lastCurrentTime;\n      this.state = State.IDLE;\n    } else {\n      this.loadedmetadata = false;\n      this.state = State.WAITING_TRACK;\n    }\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.IDLE:\n        this.doTickIdle();\n        break;\n      case State.WAITING_TRACK:\n        {\n          var _levels$trackId;\n          const {\n            levels,\n            trackId\n          } = this;\n          const details = levels == null ? void 0 : (_levels$trackId = levels[trackId]) == null ? void 0 : _levels$trackId.details;\n          if (details) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.WAITING_INIT_PTS;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            const {\n              levels,\n              trackId\n            } = this;\n            this.log('RetryDate reached, switch back to IDLE state');\n            this.resetStartWhenNotLoaded((levels == null ? void 0 : levels[trackId]) || null);\n            this.state = State.IDLE;\n          }\n          break;\n        }\n      case State.WAITING_INIT_PTS:\n        {\n          // Ensure we don't get stuck in the WAITING_INIT_PTS state if the waiting frag CC doesn't match any initPTS\n          const waitingData = this.waitingData;\n          if (waitingData) {\n            const {\n              frag,\n              part,\n              cache,\n              complete\n            } = waitingData;\n            if (this.initPTS[frag.cc] !== undefined) {\n              this.waitingData = null;\n              this.waitingVideoCC = -1;\n              this.state = State.FRAG_LOADING;\n              const payload = cache.flush();\n              const data = {\n                frag,\n                part,\n                payload,\n                networkDetails: null\n              };\n              this._handleFragmentLoadProgress(data);\n              if (complete) {\n                super._handleFragmentLoadComplete(data);\n              }\n            } else if (this.videoTrackCC !== this.waitingVideoCC) {\n              // Drop waiting fragment if videoTrackCC has changed since waitingFragment was set and initPTS was not found\n              this.log(`Waiting fragment cc (${frag.cc}) cancelled because video is at cc ${this.videoTrackCC}`);\n              this.clearWaitingFragment();\n            } else {\n              // Drop waiting fragment if an earlier fragment is needed\n              const pos = this.getLoadPosition();\n              const bufferInfo = BufferHelper.bufferInfo(this.mediaBuffer, pos, this.config.maxBufferHole);\n              const waitingFragmentAtPosition = fragmentWithinToleranceTest(bufferInfo.end, this.config.maxFragLookUpTolerance, frag);\n              if (waitingFragmentAtPosition < 0) {\n                this.log(`Waiting fragment cc (${frag.cc}) @ ${frag.start} cancelled because another fragment at ${bufferInfo.end} is needed`);\n                this.clearWaitingFragment();\n              }\n            }\n          } else {\n            this.state = State.IDLE;\n          }\n        }\n    }\n    this.onTickEnd();\n  }\n  clearWaitingFragment() {\n    const waitingData = this.waitingData;\n    if (waitingData) {\n      this.fragmentTracker.removeFragment(waitingData.frag);\n      this.waitingData = null;\n      this.waitingVideoCC = -1;\n      this.state = State.IDLE;\n    }\n  }\n  resetLoadingState() {\n    this.clearWaitingFragment();\n    super.resetLoadingState();\n  }\n  onTickEnd() {\n    const {\n      media\n    } = this;\n    if (!(media != null && media.readyState)) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levels,\n      media,\n      trackId\n    } = this;\n    const config = hls.config;\n\n    // 1. if video not attached AND\n    //    start fragment already requested OR start frag prefetch not enabled\n    // 2. if tracks or track not loaded and selected\n    // then exit loop\n    // => if media not attached but start frag prefetch is enabled and start frag not requested yet, we will not exit loop\n    if (!media && (this.startFragRequested || !config.startFragPrefetch) || !(levels != null && levels[trackId])) {\n      return;\n    }\n    const levelInfo = levels[trackId];\n    const trackDetails = levelInfo.details;\n    if (!trackDetails || trackDetails.live && this.levelLastLoaded !== levelInfo || this.waitForCdnTuneIn(trackDetails)) {\n      this.state = State.WAITING_TRACK;\n      return;\n    }\n    const bufferable = this.mediaBuffer ? this.mediaBuffer : this.media;\n    if (this.bufferFlushed && bufferable) {\n      this.bufferFlushed = false;\n      this.afterBufferFlushed(bufferable, ElementaryStreamTypes.AUDIO, PlaylistLevelType.AUDIO);\n    }\n    const bufferInfo = this.getFwdBufferInfo(bufferable, PlaylistLevelType.AUDIO);\n    if (bufferInfo === null) {\n      return;\n    }\n    const {\n      bufferedTrack,\n      switchingTrack\n    } = this;\n    if (!switchingTrack && this._streamEnded(bufferInfo, trackDetails)) {\n      hls.trigger(Events.BUFFER_EOS, {\n        type: 'audio'\n      });\n      this.state = State.ENDED;\n      return;\n    }\n    const mainBufferInfo = this.getFwdBufferInfo(this.videoBuffer ? this.videoBuffer : this.media, PlaylistLevelType.MAIN);\n    const bufferLen = bufferInfo.len;\n    const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len);\n    const fragments = trackDetails.fragments;\n    const start = fragments[0].start;\n    let targetBufferTime = this.flushing ? this.getLoadPosition() : bufferInfo.end;\n    if (switchingTrack && media) {\n      const pos = this.getLoadPosition();\n      // STABLE\n      if (bufferedTrack && !mediaAttributesIdentical(switchingTrack.attrs, bufferedTrack.attrs)) {\n        targetBufferTime = pos;\n      }\n      // if currentTime (pos) is less than alt audio playlist start time, it means that alt audio is ahead of currentTime\n      if (trackDetails.PTSKnown && pos < start) {\n        // if everything is buffered from pos to start or if audio buffer upfront, let's seek to start\n        if (bufferInfo.end > start || bufferInfo.nextStart) {\n          this.log('Alt audio track ahead of main track, seek to start of alt audio track');\n          media.currentTime = start + 0.05;\n        }\n      }\n    }\n\n    // if buffer length is less than maxBufLen, or near the end, find a fragment to load\n    if (bufferLen >= maxBufLen && !switchingTrack && targetBufferTime < fragments[fragments.length - 1].start) {\n      return;\n    }\n    let frag = this.getNextFragment(targetBufferTime, trackDetails);\n    let atGap = false;\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      atGap = !!frag.gap;\n      frag = this.getNextFragmentLoopLoading(frag, trackDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      this.bufferFlushed = true;\n      return;\n    }\n\n    // Buffer audio up to one target duration ahead of main buffer\n    const atBufferSyncLimit = mainBufferInfo && frag.start > mainBufferInfo.end + trackDetails.targetduration;\n    if (atBufferSyncLimit ||\n    // Or wait for main buffer after buffing some audio\n    !(mainBufferInfo != null && mainBufferInfo.len) && bufferInfo.len) {\n      // Check fragment-tracker for main fragments since GAP segments do not show up in bufferInfo\n      const mainFrag = this.getAppendedFrag(frag.start, PlaylistLevelType.MAIN);\n      if (mainFrag === null) {\n        return;\n      }\n      // Bridge gaps in main buffer\n      atGap || (atGap = !!mainFrag.gap || !!atBufferSyncLimit && mainBufferInfo.len === 0);\n      if (atBufferSyncLimit && !atGap || atGap && bufferInfo.nextStart && bufferInfo.nextStart < mainFrag.end) {\n        return;\n      }\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  getMaxBufferLength(mainBufferLength) {\n    const maxConfigBuffer = super.getMaxBufferLength();\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.min(Math.max(maxConfigBuffer, mainBufferLength), this.config.maxMaxBufferLength);\n  }\n  onMediaDetaching() {\n    this.videoBuffer = null;\n    this.bufferFlushed = this.flushing = false;\n    super.onMediaDetaching();\n  }\n  onAudioTracksUpdated(event, {\n    audioTracks\n  }) {\n    // Reset tranxmuxer is essential for large context switches (Content Steering)\n    this.resetTransmuxer();\n    this.levels = audioTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const altAudio = !!data.url;\n    this.trackId = data.id;\n    const {\n      fragCurrent\n    } = this;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.removeUnbufferedFrags(fragCurrent.start);\n    }\n    this.resetLoadingState();\n    // destroy useless transmuxer when switching audio to main\n    if (!altAudio) {\n      this.resetTransmuxer();\n    } else {\n      // switching to audio track, start timer if not already started\n      this.setInterval(TICK_INTERVAL$2);\n    }\n\n    // should we switch tracks ?\n    if (altAudio) {\n      this.switchingTrack = data;\n      // main audio track are handled by stream-controller, just do something if switching to alt audio track\n      this.state = State.IDLE;\n      this.flushAudioIfNeeded(data);\n    } else {\n      this.switchingTrack = null;\n      this.bufferedTrack = data;\n      this.state = State.STOPPED;\n    }\n    this.tick();\n  }\n  onManifestLoading() {\n    this.fragmentTracker.removeAllFragments();\n    this.startPosition = this.lastCurrentTime = 0;\n    this.bufferFlushed = this.flushing = false;\n    this.levels = this.mainDetails = this.waitingData = this.bufferedTrack = this.cachedTrackLoadedData = this.switchingTrack = null;\n    this.startFragRequested = false;\n    this.trackId = this.videoTrackCC = this.waitingVideoCC = -1;\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n    if (this.cachedTrackLoadedData !== null) {\n      this.hls.trigger(Events.AUDIO_TRACK_LOADED, this.cachedTrackLoadedData);\n      this.cachedTrackLoadedData = null;\n    }\n  }\n  onAudioTrackLoaded(event, data) {\n    var _track$details;\n    if (this.mainDetails == null) {\n      this.cachedTrackLoadedData = data;\n      return;\n    }\n    const {\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while loading level ${trackId}`);\n      return;\n    }\n    this.log(`Audio track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    const track = levels[trackId];\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      this.checkLiveUpdate(newDetails);\n      const mainDetails = this.mainDetails;\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      if (!track.details && newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n        // Make sure our audio rendition is aligned with the \"main\" rendition, using\n        // pdt as our reference times.\n        alignMediaPlaylistByPDT(newDetails, mainDetails);\n        sliding = newDetails.fragments[0].start;\n      } else {\n        var _this$levelLastLoaded;\n        sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = track;\n\n    // compute start position if we are aligned with the main playlist\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(this.mainDetails || newDetails, sliding);\n    }\n    // only switch back to IDLE state if we were waiting for track to start downloading a new fragment\n    if (this.state === State.WAITING_TRACK && !this.waitForCdnTuneIn(newDetails)) {\n      this.state = State.IDLE;\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      part,\n      payload\n    } = data;\n    const {\n      config,\n      trackId,\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Audio tracks were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const track = levels[trackId];\n    if (!track) {\n      this.warn('Audio track is undefined on fragment load progress');\n      return;\n    }\n    const details = track.details;\n    if (!details) {\n      this.warn('Audio track details undefined on fragment load progress');\n      this.removeUnbufferedFrags(frag.start);\n      return;\n    }\n    const audioCodec = config.defaultAudioCodec || track.audioCodec || 'mp4a.40.2';\n    let transmuxer = this.transmuxer;\n    if (!transmuxer) {\n      transmuxer = this.transmuxer = new TransmuxerInterface(this.hls, PlaylistLevelType.AUDIO, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    }\n\n    // Check if we have video initPTS\n    // If not we need to wait for it\n    const initPTS = this.initPTS[frag.cc];\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    if (initPTS !== undefined) {\n      // this.log(`Transmuxing ${sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n      const accurateTimeOffset = false; // details.PTSKnown || !details.live;\n      const partIndex = part ? part.index : -1;\n      const partial = partIndex !== -1;\n      const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n      transmuxer.push(payload, initSegmentData, audioCodec, '', frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n    } else {\n      this.log(`Unknown video PTS for cc ${frag.cc}, waiting for video PTS before demuxing audio frag ${frag.sn} of [${details.startSN} ,${details.endSN}],track ${trackId}`);\n      const {\n        cache\n      } = this.waitingData = this.waitingData || {\n        frag,\n        part,\n        cache: new ChunkCache(),\n        complete: false\n      };\n      cache.push(new Uint8Array(payload));\n      this.waitingVideoCC = this.videoTrackCC;\n      this.state = State.WAITING_INIT_PTS;\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    if (this.waitingData) {\n      this.waitingData.complete = true;\n      return;\n    }\n    super._handleFragmentLoadComplete(fragLoadedData);\n  }\n  onBufferReset( /* event: Events.BUFFER_RESET */\n  ) {\n    // reset reference to sourcebuffers\n    this.mediaBuffer = this.videoBuffer = null;\n    this.loadedmetadata = false;\n  }\n  onBufferCreated(event, data) {\n    const audioTrack = data.tracks.audio;\n    if (audioTrack) {\n      this.mediaBuffer = audioTrack.buffer || null;\n    }\n    if (data.tracks.video) {\n      this.videoBuffer = data.tracks.video.buffer || null;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag.type !== PlaylistLevelType.AUDIO) {\n      if (!this.loadedmetadata && frag.type === PlaylistLevelType.MAIN) {\n        const bufferable = this.videoBuffer || this.media;\n        if (bufferable) {\n          const bufferedTimeRanges = BufferHelper.getBuffered(bufferable);\n          if (bufferedTimeRanges.length) {\n            this.loadedmetadata = true;\n          }\n        }\n      }\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE or concluding the audio switch; otherwise, the switched-to track will not buffer\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}, audioSwitch: ${this.switchingTrack ? this.switchingTrack.name : 'false'}`);\n      return;\n    }\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n      const track = this.switchingTrack;\n      if (track) {\n        this.bufferedTrack = track;\n        this.switchingTrack = null;\n        this.hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, track));\n      }\n    }\n    this.fragBufferedComplete(frag, part);\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.AUDIO, data);\n        break;\n      case ErrorDetails.AUDIO_TRACK_LOAD_ERROR:\n      case ErrorDetails.AUDIO_TRACK_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading track, if not retrying to load track, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_TRACK && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.AUDIO_TRACK) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (!data.parent || data.parent !== 'audio') {\n          return;\n        }\n        if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n          this.resetLoadingState();\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.bufferedTrack = null;\n          super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n  onBufferFlushing(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.VIDEO) {\n      this.flushing = true;\n    }\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.VIDEO) {\n      this.flushing = false;\n      this.bufferFlushed = true;\n      if (this.state === State.ENDED) {\n        this.state = State.IDLE;\n      }\n      const mediaBuffer = this.mediaBuffer || this.media;\n      if (mediaBuffer) {\n        this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.AUDIO);\n        this.tick();\n      }\n    }\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'audio';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      details\n    } = level;\n    const {\n      audio,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag) || !details) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (this.switchingTrack && audio) {\n      this.completeAudioSwitch(this.switchingTrack);\n    }\n    if (initSegment != null && initSegment.tracks) {\n      const mapFragment = frag.initSegment || frag;\n      this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n      hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n        frag: mapFragment,\n        id,\n        tracks: initSegment.tracks\n      });\n      // Only flush audio from old audio tracks when PTS is known on new audio track\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = _extends({\n        id,\n        frag,\n        details\n      }, id3);\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (text) {\n      const emittedText = _extends({\n        id,\n        frag,\n        details\n      }, text);\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    // delete any video track found on audio transmuxer\n    if (tracks.video) {\n      delete tracks.video;\n    }\n\n    // include levelCodec in audio and video tracks\n    const track = tracks.audio;\n    if (!track) {\n      return;\n    }\n    track.id = 'audio';\n    const variantAudioCodecs = currentLevel.audioCodec;\n    this.log(`Init audio buffer, container:${track.container}, codecs[level/parsed]=[${variantAudioCodecs}/${track.codec}]`);\n    // SourceBuffer will use track.levelCodec if defined\n    if (variantAudioCodecs && variantAudioCodecs.split(',').length === 1) {\n      track.levelCodec = variantAudioCodecs;\n    }\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    const initSegment = track.initSegment;\n    if (initSegment != null && initSegment.byteLength) {\n      const segment = {\n        type: 'audio',\n        frag,\n        part: null,\n        chunkMeta,\n        parent: frag.type,\n        data: initSegment\n      };\n      this.hls.trigger(Events.BUFFER_APPENDING, segment);\n    }\n    // trigger handler right now\n    this.tickImmediate();\n  }\n  loadFragment(frag, track, targetBufferTime) {\n    // only load if fragment is not loaded or if in audio switch\n    const fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n\n    // we force a frag loading in audio switch as fragment tracker might not have evicted previous frags in case of quick audio switch\n    if (this.switchingTrack || fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      var _track$details2;\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, track);\n      } else if ((_track$details2 = track.details) != null && _track$details2.live && !this.initPTS[frag.cc]) {\n        this.log(`Waiting for video PTS in continuity counter ${frag.cc} of live stream before loading audio fragment ${frag.sn} of level ${this.trackId}`);\n        this.state = State.WAITING_INIT_PTS;\n        const mainDetails = this.mainDetails;\n        if (mainDetails && mainDetails.fragments[0].start !== track.details.fragments[0].start) {\n          alignMediaPlaylistByPDT(track.details, mainDetails);\n        }\n      } else {\n        this.startFragRequested = true;\n        super.loadFragment(frag, track, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  flushAudioIfNeeded(switchingTrack) {\n    const {\n      media,\n      bufferedTrack\n    } = this;\n    const bufferedAttributes = bufferedTrack == null ? void 0 : bufferedTrack.attrs;\n    const switchAttributes = switchingTrack.attrs;\n    if (media && bufferedAttributes && (bufferedAttributes.CHANNELS !== switchAttributes.CHANNELS || bufferedTrack.name !== switchingTrack.name || bufferedTrack.lang !== switchingTrack.lang)) {\n      this.log('Switching audio track : flushing all audio');\n      super.flushMainBuffer(0, Number.POSITIVE_INFINITY, 'audio');\n      this.bufferedTrack = null;\n    }\n  }\n  completeAudioSwitch(switchingTrack) {\n    const {\n      hls\n    } = this;\n    this.flushAudioIfNeeded(switchingTrack);\n    this.bufferedTrack = switchingTrack;\n    this.switchingTrack = null;\n    hls.trigger(Events.AUDIO_TRACK_SWITCHED, _objectSpread2({}, switchingTrack));\n  }\n}\n\nclass AudioTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, '[audio-track-controller]');\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.registerListeners();\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.AUDIO_TRACK_LOADED, this.onAudioTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    super.destroy();\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.tracksInGroup = [];\n    this.groupIds = null;\n    this.currentTrack = null;\n    this.trackId = -1;\n    this.selectDefaultTrack = true;\n  }\n  onManifestParsed(event, data) {\n    this.tracks = data.audioTracks || [];\n  }\n  onAudioTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Audio track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`Audio track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!levelInfo) {\n      return;\n    }\n    const audioGroups = levelInfo.audioGroups || null;\n    const currentGroups = this.groupIds;\n    let currentTrack = this.currentTrack;\n    if (!audioGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (audioGroups == null ? void 0 : audioGroups.length) || audioGroups != null && audioGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n      this.groupIds = audioGroups;\n      this.trackId = -1;\n      this.currentTrack = null;\n      const audioTracks = this.tracks.filter(track => !audioGroups || audioGroups.indexOf(track.groupId) !== -1);\n      if (audioTracks.length) {\n        // Disable selectDefaultTrack if there are no default tracks\n        if (this.selectDefaultTrack && !audioTracks.some(track => track.default)) {\n          this.selectDefaultTrack = false;\n        }\n        // track.id should match hls.audioTracks index\n        audioTracks.forEach((track, i) => {\n          track.id = i;\n        });\n      } else if (!currentTrack && !this.tracksInGroup.length) {\n        // Do not dispatch AUDIO_TRACKS_UPDATED when there were and are no tracks\n        return;\n      }\n      this.tracksInGroup = audioTracks;\n\n      // Find preferred track\n      const audioPreference = this.hls.config.audioPreference;\n      if (!currentTrack && audioPreference) {\n        const groupIndex = findMatchingOption(audioPreference, audioTracks, audioMatchPredicate);\n        if (groupIndex > -1) {\n          currentTrack = audioTracks[groupIndex];\n        } else {\n          const allIndex = findMatchingOption(audioPreference, this.tracks);\n          currentTrack = this.tracks[allIndex];\n        }\n      }\n\n      // Select initial track\n      let trackId = this.findTrackId(currentTrack);\n      if (trackId === -1 && currentTrack) {\n        trackId = this.findTrackId(null);\n      }\n\n      // Dispatch events and load track if needed\n      const audioTracksUpdated = {\n        audioTracks\n      };\n      this.log(`Updating audio tracks, ${audioTracks.length} track(s) found in group(s): ${audioGroups == null ? void 0 : audioGroups.join(',')}`);\n      this.hls.trigger(Events.AUDIO_TRACKS_UPDATED, audioTracksUpdated);\n      const selectedTrackId = this.trackId;\n      if (trackId !== -1 && selectedTrackId === -1) {\n        this.setAudioTrack(trackId);\n      } else if (audioTracks.length && selectedTrackId === -1) {\n        var _this$groupIds;\n        const error = new Error(`No audio track selected for current audio group-ID(s): ${(_this$groupIds = this.groupIds) == null ? void 0 : _this$groupIds.join(',')} track count: ${audioTracks.length}`);\n        this.warn(error.message);\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.AUDIO_TRACK_LOAD_ERROR,\n          fatal: true,\n          error\n        });\n      }\n    } else if (this.shouldReloadPlaylist(currentTrack)) {\n      // Retry playlist loading if no playlist is or has been loaded yet\n      this.setAudioTrack(this.trackId);\n    }\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.AUDIO_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n      this.requestScheduled = -1;\n      this.checkRetry(data);\n    }\n  }\n  get allAudioTracks() {\n    return this.tracks;\n  }\n  get audioTracks() {\n    return this.tracksInGroup;\n  }\n  get audioTrack() {\n    return this.trackId;\n  }\n  set audioTrack(newId) {\n    // If audio track is selected from API then don't choose from the manifest default track\n    this.selectDefaultTrack = false;\n    this.setAudioTrack(newId);\n  }\n  setAudioOption(audioOption) {\n    const hls = this.hls;\n    hls.config.audioPreference = audioOption;\n    if (audioOption) {\n      const allAudioTracks = this.allAudioTracks;\n      this.selectDefaultTrack = false;\n      if (allAudioTracks.length) {\n        // First see if current option matches (no switch op)\n        const currentTrack = this.currentTrack;\n        if (currentTrack && matchesOption(audioOption, currentTrack, audioMatchPredicate)) {\n          return currentTrack;\n        }\n        // Find option in available tracks (tracksInGroup)\n        const groupIndex = findMatchingOption(audioOption, this.tracksInGroup, audioMatchPredicate);\n        if (groupIndex > -1) {\n          const track = this.tracksInGroup[groupIndex];\n          this.setAudioTrack(groupIndex);\n          return track;\n        } else if (currentTrack) {\n          // Find option in nearest level audio group\n          let searchIndex = hls.loadLevel;\n          if (searchIndex === -1) {\n            searchIndex = hls.firstAutoLevel;\n          }\n          const switchIndex = findClosestLevelWithAudioGroup(audioOption, hls.levels, allAudioTracks, searchIndex, audioMatchPredicate);\n          if (switchIndex === -1) {\n            // could not find matching variant\n            return null;\n          }\n          // and switch level to acheive the audio group switch\n          hls.nextLoadLevel = switchIndex;\n        }\n        if (audioOption.channels || audioOption.audioCodec) {\n          // Could not find a match with codec / channels predicate\n          // Find a match without channels or codec\n          const withoutCodecAndChannelsMatch = findMatchingOption(audioOption, allAudioTracks);\n          if (withoutCodecAndChannelsMatch > -1) {\n            return allAudioTracks[withoutCodecAndChannelsMatch];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  setAudioTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // check if level idx is valid\n    if (newId < 0 || newId >= tracks.length) {\n      this.warn(`Invalid audio track id: ${newId}`);\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    this.selectDefaultTrack = false;\n    const lastTrack = this.currentTrack;\n    const track = tracks[newId];\n    const trackLoaded = track.details && !track.details.live;\n    if (newId === this.trackId && track === lastTrack && trackLoaded) {\n      return;\n    }\n    this.log(`Switching to audio-track ${newId} \"${track.name}\" lang:${track.lang} group:${track.groupId} channels:${track.channels}`);\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.hls.trigger(Events.AUDIO_TRACK_SWITCHING, _objectSpread2({}, track));\n    // Do not reload track unless live\n    if (trackLoaded) {\n      return;\n    }\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n  findTrackId(currentTrack) {\n    const audioTracks = this.tracksInGroup;\n    for (let i = 0; i < audioTracks.length; i++) {\n      const track = audioTracks[i];\n      if (this.selectDefaultTrack && !track.default) {\n        continue;\n      }\n      if (!currentTrack || matchesOption(currentTrack, track, audioMatchPredicate)) {\n        return i;\n      }\n    }\n    if (currentTrack) {\n      const {\n        name,\n        lang,\n        assocLang,\n        characteristics,\n        audioCodec,\n        channels\n      } = currentTrack;\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (matchesOption({\n          name,\n          lang,\n          assocLang,\n          characteristics,\n          audioCodec,\n          channels\n        }, track, audioMatchPredicate)) {\n          return i;\n        }\n      }\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n          return i;\n        }\n      }\n      for (let i = 0; i < audioTracks.length; i++) {\n        const track = audioTracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    const audioTrack = this.currentTrack;\n    if (this.shouldLoadPlaylist(audioTrack) && audioTrack) {\n      super.loadPlaylist();\n      const id = audioTrack.id;\n      const groupId = audioTrack.groupId;\n      let url = audioTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      // track not retrieved yet, or live playlist we need to (re)load it\n      this.log(`loading audio-track playlist ${id} \"${audioTrack.name}\" lang:${audioTrack.lang} group:${groupId}`);\n      this.clearTimer();\n      this.hls.trigger(Events.AUDIO_TRACK_LOADING, {\n        url,\n        id,\n        groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n}\n\nconst TICK_INTERVAL$1 = 500; // how often to tick in ms\n\nclass SubtitleStreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[subtitle-stream-controller]', PlaylistLevelType.SUBTITLE);\n    this.currentTrackId = -1;\n    this.tracksBuffered = [];\n    this.mainDetails = null;\n    this._registerListeners();\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    super.onHandlerDestroying();\n    this.mainDetails = null;\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.SUBTITLE_TRACK_SWITCH, this.onSubtitleTrackSwitch, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.SUBTITLE_FRAG_PROCESSED, this.onSubtitleFragProcessed, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  startLoad(startPosition) {\n    this.stopLoad();\n    this.state = State.IDLE;\n    this.setInterval(TICK_INTERVAL$1);\n    this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n    this.tick();\n  }\n  onManifestLoading() {\n    this.mainDetails = null;\n    this.fragmentTracker.removeAllFragments();\n  }\n  onMediaDetaching() {\n    this.tracksBuffered = [];\n    super.onMediaDetaching();\n  }\n  onLevelLoaded(event, data) {\n    this.mainDetails = data.details;\n  }\n  onSubtitleFragProcessed(event, data) {\n    const {\n      frag,\n      success\n    } = data;\n    this.fragPrevious = frag;\n    this.state = State.IDLE;\n    if (!success) {\n      return;\n    }\n    const buffered = this.tracksBuffered[this.currentTrackId];\n    if (!buffered) {\n      return;\n    }\n\n    // Create/update a buffered array matching the interface used by BufferHelper.bufferedInfo\n    // so we can re-use the logic used to detect how much has been buffered\n    let timeRange;\n    const fragStart = frag.start;\n    for (let i = 0; i < buffered.length; i++) {\n      if (fragStart >= buffered[i].start && fragStart <= buffered[i].end) {\n        timeRange = buffered[i];\n        break;\n      }\n    }\n    const fragEnd = frag.start + frag.duration;\n    if (timeRange) {\n      timeRange.end = fragEnd;\n    } else {\n      timeRange = {\n        start: fragStart,\n        end: fragEnd\n      };\n      buffered.push(timeRange);\n    }\n    this.fragmentTracker.fragBuffered(frag);\n    this.fragBufferedComplete(frag, null);\n  }\n  onBufferFlushing(event, data) {\n    const {\n      startOffset,\n      endOffset\n    } = data;\n    if (startOffset === 0 && endOffset !== Number.POSITIVE_INFINITY) {\n      const endOffsetSubtitles = endOffset - 1;\n      if (endOffsetSubtitles <= 0) {\n        return;\n      }\n      data.endOffsetSubtitles = Math.max(0, endOffsetSubtitles);\n      this.tracksBuffered.forEach(buffered => {\n        for (let i = 0; i < buffered.length;) {\n          if (buffered[i].end <= endOffsetSubtitles) {\n            buffered.shift();\n            continue;\n          } else if (buffered[i].start < endOffsetSubtitles) {\n            buffered[i].start = endOffsetSubtitles;\n          } else {\n            break;\n          }\n          i++;\n        }\n      });\n      this.fragmentTracker.removeFragmentsInRange(startOffset, endOffsetSubtitles, PlaylistLevelType.SUBTITLE);\n    }\n  }\n  onFragBuffered(event, data) {\n    if (!this.loadedmetadata && data.frag.type === PlaylistLevelType.MAIN) {\n      var _this$media;\n      if ((_this$media = this.media) != null && _this$media.buffered.length) {\n        this.loadedmetadata = true;\n      }\n    }\n  }\n\n  // If something goes wrong, proceed to next frag, if we were processing one.\n  onError(event, data) {\n    const frag = data.frag;\n    if ((frag == null ? void 0 : frag.type) === PlaylistLevelType.SUBTITLE) {\n      if (data.details === ErrorDetails.FRAG_GAP) {\n        this.fragmentTracker.fragBuffered(frag, true);\n      }\n      if (this.fragCurrent) {\n        this.fragCurrent.abortRequests();\n      }\n      if (this.state !== State.STOPPED) {\n        this.state = State.IDLE;\n      }\n    }\n  }\n\n  // Got all new subtitle levels.\n  onSubtitleTracksUpdated(event, {\n    subtitleTracks\n  }) {\n    if (this.levels && subtitleOptionsIdentical(this.levels, subtitleTracks)) {\n      this.levels = subtitleTracks.map(mediaPlaylist => new Level(mediaPlaylist));\n      return;\n    }\n    this.tracksBuffered = [];\n    this.levels = subtitleTracks.map(mediaPlaylist => {\n      const level = new Level(mediaPlaylist);\n      this.tracksBuffered[level.id] = [];\n      return level;\n    });\n    this.fragmentTracker.removeFragmentsInRange(0, Number.POSITIVE_INFINITY, PlaylistLevelType.SUBTITLE);\n    this.fragPrevious = null;\n    this.mediaBuffer = null;\n  }\n  onSubtitleTrackSwitch(event, data) {\n    var _this$levels;\n    this.currentTrackId = data.id;\n    if (!((_this$levels = this.levels) != null && _this$levels.length) || this.currentTrackId === -1) {\n      this.clearInterval();\n      return;\n    }\n\n    // Check if track has the necessary details to load fragments\n    const currentTrack = this.levels[this.currentTrackId];\n    if (currentTrack != null && currentTrack.details) {\n      this.mediaBuffer = this.mediaBufferTimeRanges;\n    } else {\n      this.mediaBuffer = null;\n    }\n    if (currentTrack) {\n      this.setInterval(TICK_INTERVAL$1);\n    }\n  }\n\n  // Got a new set of subtitle fragments.\n  onSubtitleTrackLoaded(event, data) {\n    var _track$details;\n    const {\n      currentTrackId,\n      levels\n    } = this;\n    const {\n      details: newDetails,\n      id: trackId\n    } = data;\n    if (!levels) {\n      this.warn(`Subtitle tracks were reset while loading level ${trackId}`);\n      return;\n    }\n    const track = levels[trackId];\n    if (trackId >= levels.length || !track) {\n      return;\n    }\n    this.log(`Subtitle track ${trackId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''},duration:${newDetails.totalduration}`);\n    this.mediaBuffer = this.mediaBufferTimeRanges;\n    let sliding = 0;\n    if (newDetails.live || (_track$details = track.details) != null && _track$details.live) {\n      const mainDetails = this.mainDetails;\n      if (newDetails.deltaUpdateFailed || !mainDetails) {\n        return;\n      }\n      const mainSlidingStartFragment = mainDetails.fragments[0];\n      if (!track.details) {\n        if (newDetails.hasProgramDateTime && mainDetails.hasProgramDateTime) {\n          alignMediaPlaylistByPDT(newDetails, mainDetails);\n          sliding = newDetails.fragments[0].start;\n        } else if (mainSlidingStartFragment) {\n          // line up live playlist with main so that fragments in range are loaded\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      } else {\n        var _this$levelLastLoaded;\n        sliding = this.alignPlaylists(newDetails, track.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n        if (sliding === 0 && mainSlidingStartFragment) {\n          // realign with main when there is no overlap with last refresh\n          sliding = mainSlidingStartFragment.start;\n          addSliding(newDetails, sliding);\n        }\n      }\n    }\n    track.details = newDetails;\n    this.levelLastLoaded = track;\n    if (trackId !== currentTrackId) {\n      return;\n    }\n    if (!this.startFragRequested && (this.mainDetails || !newDetails.live)) {\n      this.setStartPosition(this.mainDetails || newDetails, sliding);\n    }\n\n    // trigger handler right now\n    this.tick();\n\n    // If playlist is misaligned because of bad PDT or drift, delete details to resync with main on reload\n    if (newDetails.live && !this.fragCurrent && this.media && this.state === State.IDLE) {\n      const foundFrag = findFragmentByPTS(null, newDetails.fragments, this.media.currentTime, 0);\n      if (!foundFrag) {\n        this.warn('Subtitle playlist not aligned with playback');\n        track.details = undefined;\n      }\n    }\n  }\n  _handleFragmentLoadComplete(fragLoadedData) {\n    const {\n      frag,\n      payload\n    } = fragLoadedData;\n    const decryptData = frag.decryptdata;\n    const hls = this.hls;\n    if (this.fragContextChanged(frag)) {\n      return;\n    }\n    // check to see if the payload needs to be decrypted\n    if (payload && payload.byteLength > 0 && decryptData != null && decryptData.key && decryptData.iv && decryptData.method === 'AES-128') {\n      const startTime = performance.now();\n      // decrypt the subtitles\n      this.decrypter.decrypt(new Uint8Array(payload), decryptData.key.buffer, decryptData.iv.buffer).catch(err => {\n        hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.FRAG_DECRYPT_ERROR,\n          fatal: false,\n          error: err,\n          reason: err.message,\n          frag\n        });\n        throw err;\n      }).then(decryptedData => {\n        const endTime = performance.now();\n        hls.trigger(Events.FRAG_DECRYPTED, {\n          frag,\n          payload: decryptedData,\n          stats: {\n            tstart: startTime,\n            tdecrypt: endTime\n          }\n        });\n      }).catch(err => {\n        this.warn(`${err.name}: ${err.message}`);\n        this.state = State.IDLE;\n      });\n    }\n  }\n  doTick() {\n    if (!this.media) {\n      this.state = State.IDLE;\n      return;\n    }\n    if (this.state === State.IDLE) {\n      const {\n        currentTrackId,\n        levels\n      } = this;\n      const track = levels == null ? void 0 : levels[currentTrackId];\n      if (!track || !levels.length || !track.details) {\n        return;\n      }\n      const {\n        config\n      } = this;\n      const currentTime = this.getLoadPosition();\n      const bufferedInfo = BufferHelper.bufferedInfo(this.tracksBuffered[this.currentTrackId] || [], currentTime, config.maxBufferHole);\n      const {\n        end: targetBufferTime,\n        len: bufferLen\n      } = bufferedInfo;\n      const mainBufferInfo = this.getFwdBufferInfo(this.media, PlaylistLevelType.MAIN);\n      const trackDetails = track.details;\n      const maxBufLen = this.getMaxBufferLength(mainBufferInfo == null ? void 0 : mainBufferInfo.len) + trackDetails.levelTargetDuration;\n      if (bufferLen > maxBufLen) {\n        return;\n      }\n      const fragments = trackDetails.fragments;\n      const fragLen = fragments.length;\n      const end = trackDetails.edge;\n      let foundFrag = null;\n      const fragPrevious = this.fragPrevious;\n      if (targetBufferTime < end) {\n        const tolerance = config.maxFragLookUpTolerance;\n        const lookupTolerance = targetBufferTime > end - tolerance ? 0 : tolerance;\n        foundFrag = findFragmentByPTS(fragPrevious, fragments, Math.max(fragments[0].start, targetBufferTime), lookupTolerance);\n        if (!foundFrag && fragPrevious && fragPrevious.start < fragments[0].start) {\n          foundFrag = fragments[0];\n        }\n      } else {\n        foundFrag = fragments[fragLen - 1];\n      }\n      if (!foundFrag) {\n        return;\n      }\n      foundFrag = this.mapToInitFragWhenRequired(foundFrag);\n      if (foundFrag.sn !== 'initSegment') {\n        // Load earlier fragment in same discontinuity to make up for misaligned playlists and cues that extend beyond end of segment\n        const curSNIdx = foundFrag.sn - trackDetails.startSN;\n        const prevFrag = fragments[curSNIdx - 1];\n        if (prevFrag && prevFrag.cc === foundFrag.cc && this.fragmentTracker.getState(prevFrag) === FragmentState.NOT_LOADED) {\n          foundFrag = prevFrag;\n        }\n      }\n      if (this.fragmentTracker.getState(foundFrag) === FragmentState.NOT_LOADED) {\n        // only load if fragment is not loaded\n        this.loadFragment(foundFrag, track, targetBufferTime);\n      }\n    }\n  }\n  getMaxBufferLength(mainBufferLength) {\n    const maxConfigBuffer = super.getMaxBufferLength();\n    if (!mainBufferLength) {\n      return maxConfigBuffer;\n    }\n    return Math.max(maxConfigBuffer, mainBufferLength);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    this.fragCurrent = frag;\n    if (frag.sn === 'initSegment') {\n      this._loadInitSegment(frag, level);\n    } else {\n      this.startFragRequested = true;\n      super.loadFragment(frag, level, targetBufferTime);\n    }\n  }\n  get mediaBufferTimeRanges() {\n    return new BufferableInstance(this.tracksBuffered[this.currentTrackId] || []);\n  }\n}\nclass BufferableInstance {\n  constructor(timeranges) {\n    this.buffered = void 0;\n    const getRange = (name, index, length) => {\n      index = index >>> 0;\n      if (index > length - 1) {\n        throw new DOMException(`Failed to execute '${name}' on 'TimeRanges': The index provided (${index}) is greater than the maximum bound (${length})`);\n      }\n      return timeranges[index][name];\n    };\n    this.buffered = {\n      get length() {\n        return timeranges.length;\n      },\n      end(index) {\n        return getRange('end', index, timeranges.length);\n      },\n      start(index) {\n        return getRange('start', index, timeranges.length);\n      }\n    };\n  }\n}\n\nclass SubtitleTrackController extends BasePlaylistController {\n  constructor(hls) {\n    super(hls, '[subtitle-track-controller]');\n    this.media = null;\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n    this.queuedDefaultTrack = -1;\n    this.asyncPollTrackChange = () => this.pollTrackChange(0);\n    this.useTextTrackPolling = false;\n    this.subtitlePollingInterval = -1;\n    this._subtitleDisplay = true;\n    this.onTextTracksChanged = () => {\n      if (!this.useTextTrackPolling) {\n        self.clearInterval(this.subtitlePollingInterval);\n      }\n      // Media is undefined when switching streams via loadSource()\n      if (!this.media || !this.hls.config.renderTextTracksNatively) {\n        return;\n      }\n      let textTrack = null;\n      const tracks = filterSubtitleTracks(this.media.textTracks);\n      for (let i = 0; i < tracks.length; i++) {\n        if (tracks[i].mode === 'hidden') {\n          // Do not break in case there is a following track with showing.\n          textTrack = tracks[i];\n        } else if (tracks[i].mode === 'showing') {\n          textTrack = tracks[i];\n          break;\n        }\n      }\n\n      // Find internal track index for TextTrack\n      const trackId = this.findTrackForTextTrack(textTrack);\n      if (this.subtitleTrack !== trackId) {\n        this.setSubtitleTrack(trackId);\n      }\n    };\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.tracks.length = 0;\n    this.tracksInGroup.length = 0;\n    this.currentTrack = null;\n    this.onTextTracksChanged = this.asyncPollTrackChange = null;\n    super.destroy();\n  }\n  get subtitleDisplay() {\n    return this._subtitleDisplay;\n  }\n  set subtitleDisplay(value) {\n    this._subtitleDisplay = value;\n    if (this.trackId > -1) {\n      this.toggleTrackModes();\n    }\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.on(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.off(Events.LEVEL_SWITCHING, this.onLevelSwitching, this);\n    hls.off(Events.SUBTITLE_TRACK_LOADED, this.onSubtitleTrackLoaded, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n\n  // Listen for subtitle track change, then extract the current track ID.\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    if (!this.media) {\n      return;\n    }\n    if (this.queuedDefaultTrack > -1) {\n      this.subtitleTrack = this.queuedDefaultTrack;\n      this.queuedDefaultTrack = -1;\n    }\n    this.useTextTrackPolling = !(this.media.textTracks && 'onchange' in this.media.textTracks);\n    if (this.useTextTrackPolling) {\n      this.pollTrackChange(500);\n    } else {\n      this.media.textTracks.addEventListener('change', this.asyncPollTrackChange);\n    }\n  }\n  pollTrackChange(timeout) {\n    self.clearInterval(this.subtitlePollingInterval);\n    this.subtitlePollingInterval = self.setInterval(this.onTextTracksChanged, timeout);\n  }\n  onMediaDetaching() {\n    if (!this.media) {\n      return;\n    }\n    self.clearInterval(this.subtitlePollingInterval);\n    if (!this.useTextTrackPolling) {\n      this.media.textTracks.removeEventListener('change', this.asyncPollTrackChange);\n    }\n    if (this.trackId > -1) {\n      this.queuedDefaultTrack = this.trackId;\n    }\n    const textTracks = filterSubtitleTracks(this.media.textTracks);\n    // Clear loaded cues on media detachment from tracks\n    textTracks.forEach(track => {\n      clearCurrentCues(track);\n    });\n    // Disable all subtitle tracks before detachment so when reattached only tracks in that content are enabled.\n    this.subtitleTrack = -1;\n    this.media = null;\n  }\n  onManifestLoading() {\n    this.tracks = [];\n    this.groupIds = null;\n    this.tracksInGroup = [];\n    this.trackId = -1;\n    this.currentTrack = null;\n    this.selectDefaultTrack = true;\n  }\n\n  // Fired whenever a new manifest is loaded.\n  onManifestParsed(event, data) {\n    this.tracks = data.subtitleTracks;\n  }\n  onSubtitleTrackLoaded(event, data) {\n    const {\n      id,\n      groupId,\n      details\n    } = data;\n    const trackInActiveGroup = this.tracksInGroup[id];\n    if (!trackInActiveGroup || trackInActiveGroup.groupId !== groupId) {\n      this.warn(`Subtitle track with id:${id} and group:${groupId} not found in active group ${trackInActiveGroup == null ? void 0 : trackInActiveGroup.groupId}`);\n      return;\n    }\n    const curDetails = trackInActiveGroup.details;\n    trackInActiveGroup.details = data.details;\n    this.log(`Subtitle track ${id} \"${trackInActiveGroup.name}\" lang:${trackInActiveGroup.lang} group:${groupId} loaded [${details.startSN}-${details.endSN}]`);\n    if (id === this.trackId) {\n      this.playlistLoaded(id, data, curDetails);\n    }\n  }\n  onLevelLoading(event, data) {\n    this.switchLevel(data.level);\n  }\n  onLevelSwitching(event, data) {\n    this.switchLevel(data.level);\n  }\n  switchLevel(levelIndex) {\n    const levelInfo = this.hls.levels[levelIndex];\n    if (!levelInfo) {\n      return;\n    }\n    const subtitleGroups = levelInfo.subtitleGroups || null;\n    const currentGroups = this.groupIds;\n    let currentTrack = this.currentTrack;\n    if (!subtitleGroups || (currentGroups == null ? void 0 : currentGroups.length) !== (subtitleGroups == null ? void 0 : subtitleGroups.length) || subtitleGroups != null && subtitleGroups.some(groupId => (currentGroups == null ? void 0 : currentGroups.indexOf(groupId)) === -1)) {\n      this.groupIds = subtitleGroups;\n      this.trackId = -1;\n      this.currentTrack = null;\n      const subtitleTracks = this.tracks.filter(track => !subtitleGroups || subtitleGroups.indexOf(track.groupId) !== -1);\n      if (subtitleTracks.length) {\n        // Disable selectDefaultTrack if there are no default tracks\n        if (this.selectDefaultTrack && !subtitleTracks.some(track => track.default)) {\n          this.selectDefaultTrack = false;\n        }\n        // track.id should match hls.audioTracks index\n        subtitleTracks.forEach((track, i) => {\n          track.id = i;\n        });\n      } else if (!currentTrack && !this.tracksInGroup.length) {\n        // Do not dispatch SUBTITLE_TRACKS_UPDATED when there were and are no tracks\n        return;\n      }\n      this.tracksInGroup = subtitleTracks;\n\n      // Find preferred track\n      const subtitlePreference = this.hls.config.subtitlePreference;\n      if (!currentTrack && subtitlePreference) {\n        this.selectDefaultTrack = false;\n        const groupIndex = findMatchingOption(subtitlePreference, subtitleTracks);\n        if (groupIndex > -1) {\n          currentTrack = subtitleTracks[groupIndex];\n        } else {\n          const allIndex = findMatchingOption(subtitlePreference, this.tracks);\n          currentTrack = this.tracks[allIndex];\n        }\n      }\n\n      // Select initial track\n      let trackId = this.findTrackId(currentTrack);\n      if (trackId === -1 && currentTrack) {\n        trackId = this.findTrackId(null);\n      }\n\n      // Dispatch events and load track if needed\n      const subtitleTracksUpdated = {\n        subtitleTracks\n      };\n      this.log(`Updating subtitle tracks, ${subtitleTracks.length} track(s) found in \"${subtitleGroups == null ? void 0 : subtitleGroups.join(',')}\" group-id`);\n      this.hls.trigger(Events.SUBTITLE_TRACKS_UPDATED, subtitleTracksUpdated);\n      if (trackId !== -1 && this.trackId === -1) {\n        this.setSubtitleTrack(trackId);\n      }\n    } else if (this.shouldReloadPlaylist(currentTrack)) {\n      // Retry playlist loading if no playlist is or has been loaded yet\n      this.setSubtitleTrack(this.trackId);\n    }\n  }\n  findTrackId(currentTrack) {\n    const tracks = this.tracksInGroup;\n    const selectDefault = this.selectDefaultTrack;\n    for (let i = 0; i < tracks.length; i++) {\n      const track = tracks[i];\n      if (selectDefault && !track.default || !selectDefault && !currentTrack) {\n        continue;\n      }\n      if (!currentTrack || matchesOption(track, currentTrack)) {\n        return i;\n      }\n    }\n    if (currentTrack) {\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE', 'ASSOC-LANGUAGE', 'CHARACTERISTICS'])) {\n          return i;\n        }\n      }\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (mediaAttributesIdentical(currentTrack.attrs, track.attrs, ['LANGUAGE'])) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  findTrackForTextTrack(textTrack) {\n    if (textTrack) {\n      const tracks = this.tracksInGroup;\n      for (let i = 0; i < tracks.length; i++) {\n        const track = tracks[i];\n        if (subtitleTrackMatchesTextTrack(track, textTrack)) {\n          return i;\n        }\n      }\n    }\n    return -1;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.SUBTITLE_TRACK && data.context.id === this.trackId && (!this.groupIds || this.groupIds.indexOf(data.context.groupId) !== -1)) {\n      this.checkRetry(data);\n    }\n  }\n  get allSubtitleTracks() {\n    return this.tracks;\n  }\n\n  /** get alternate subtitle tracks list from playlist **/\n  get subtitleTracks() {\n    return this.tracksInGroup;\n  }\n\n  /** get/set index of the selected subtitle track (based on index in subtitle track lists) **/\n  get subtitleTrack() {\n    return this.trackId;\n  }\n  set subtitleTrack(newId) {\n    this.selectDefaultTrack = false;\n    this.setSubtitleTrack(newId);\n  }\n  setSubtitleOption(subtitleOption) {\n    this.hls.config.subtitlePreference = subtitleOption;\n    if (subtitleOption) {\n      const allSubtitleTracks = this.allSubtitleTracks;\n      this.selectDefaultTrack = false;\n      if (allSubtitleTracks.length) {\n        // First see if current option matches (no switch op)\n        const currentTrack = this.currentTrack;\n        if (currentTrack && matchesOption(subtitleOption, currentTrack)) {\n          return currentTrack;\n        }\n        // Find option in current group\n        const groupIndex = findMatchingOption(subtitleOption, this.tracksInGroup);\n        if (groupIndex > -1) {\n          const track = this.tracksInGroup[groupIndex];\n          this.setSubtitleTrack(groupIndex);\n          return track;\n        } else if (currentTrack) {\n          // If this is not the initial selection return null\n          // option should have matched one in active group\n          return null;\n        } else {\n          // Find the option in all tracks for initial selection\n          const allIndex = findMatchingOption(subtitleOption, allSubtitleTracks);\n          if (allIndex > -1) {\n            return allSubtitleTracks[allIndex];\n          }\n        }\n      }\n    }\n    return null;\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const currentTrack = this.currentTrack;\n    if (this.shouldLoadPlaylist(currentTrack) && currentTrack) {\n      const id = currentTrack.id;\n      const groupId = currentTrack.groupId;\n      let url = currentTrack.url;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      this.log(`Loading subtitle playlist for id ${id}`);\n      this.hls.trigger(Events.SUBTITLE_TRACK_LOADING, {\n        url,\n        id,\n        groupId,\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n\n  /**\n   * Disables the old subtitleTrack and sets current mode on the next subtitleTrack.\n   * This operates on the DOM textTracks.\n   * A value of -1 will disable all subtitle tracks.\n   */\n  toggleTrackModes() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = filterSubtitleTracks(media.textTracks);\n    const currentTrack = this.currentTrack;\n    let nextTrack;\n    if (currentTrack) {\n      nextTrack = textTracks.filter(textTrack => subtitleTrackMatchesTextTrack(currentTrack, textTrack))[0];\n      if (!nextTrack) {\n        this.warn(`Unable to find subtitle TextTrack with name \"${currentTrack.name}\" and language \"${currentTrack.lang}\"`);\n      }\n    }\n    [].slice.call(textTracks).forEach(track => {\n      if (track.mode !== 'disabled' && track !== nextTrack) {\n        track.mode = 'disabled';\n      }\n    });\n    if (nextTrack) {\n      const mode = this.subtitleDisplay ? 'showing' : 'hidden';\n      if (nextTrack.mode !== mode) {\n        nextTrack.mode = mode;\n      }\n    }\n  }\n\n  /**\n   * This method is responsible for validating the subtitle index and periodically reloading if live.\n   * Dispatches the SUBTITLE_TRACK_SWITCH event, which instructs the subtitle-stream-controller to load the selected track.\n   */\n  setSubtitleTrack(newId) {\n    const tracks = this.tracksInGroup;\n\n    // setting this.subtitleTrack will trigger internal logic\n    // if media has not been attached yet, it will fail\n    // we keep a reference to the default track id\n    // and we'll set subtitleTrack when onMediaAttached is triggered\n    if (!this.media) {\n      this.queuedDefaultTrack = newId;\n      return;\n    }\n\n    // exit if track id as already set or invalid\n    if (newId < -1 || newId >= tracks.length || !isFiniteNumber(newId)) {\n      this.warn(`Invalid subtitle track id: ${newId}`);\n      return;\n    }\n\n    // stopping live reloading timer if any\n    this.clearTimer();\n    this.selectDefaultTrack = false;\n    const lastTrack = this.currentTrack;\n    const track = tracks[newId] || null;\n    this.trackId = newId;\n    this.currentTrack = track;\n    this.toggleTrackModes();\n    if (!track) {\n      // switch to -1\n      this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n        id: newId\n      });\n      return;\n    }\n    const trackLoaded = !!track.details && !track.details.live;\n    if (newId === this.trackId && track === lastTrack && trackLoaded) {\n      return;\n    }\n    this.log(`Switching to subtitle-track ${newId}` + (track ? ` \"${track.name}\" lang:${track.lang} group:${track.groupId}` : ''));\n    const {\n      id,\n      groupId = '',\n      name,\n      type,\n      url\n    } = track;\n    this.hls.trigger(Events.SUBTITLE_TRACK_SWITCH, {\n      id,\n      groupId,\n      name,\n      type,\n      url\n    });\n    const hlsUrlParameters = this.switchParams(track.url, lastTrack == null ? void 0 : lastTrack.details, track.details);\n    this.loadPlaylist(hlsUrlParameters);\n  }\n}\n\nclass BufferOperationQueue {\n  constructor(sourceBufferReference) {\n    this.buffers = void 0;\n    this.queues = {\n      video: [],\n      audio: [],\n      audiovideo: []\n    };\n    this.buffers = sourceBufferReference;\n  }\n  append(operation, type, pending) {\n    const queue = this.queues[type];\n    queue.push(operation);\n    if (queue.length === 1 && !pending) {\n      this.executeNext(type);\n    }\n  }\n  insertAbort(operation, type) {\n    const queue = this.queues[type];\n    queue.unshift(operation);\n    this.executeNext(type);\n  }\n  appendBlocker(type) {\n    let execute;\n    const promise = new Promise(resolve => {\n      execute = resolve;\n    });\n    const operation = {\n      execute,\n      onStart: () => {},\n      onComplete: () => {},\n      onError: () => {}\n    };\n    this.append(operation, type);\n    return promise;\n  }\n  executeNext(type) {\n    const queue = this.queues[type];\n    if (queue.length) {\n      const operation = queue[0];\n      try {\n        // Operations are expected to result in an 'updateend' event being fired. If not, the queue will lock. Operations\n        // which do not end with this event must call _onSBUpdateEnd manually\n        operation.execute();\n      } catch (error) {\n        logger.warn(`[buffer-operation-queue]: Exception executing \"${type}\" SourceBuffer operation: ${error}`);\n        operation.onError(error);\n\n        // Only shift the current operation off, otherwise the updateend handler will do this for us\n        const sb = this.buffers[type];\n        if (!(sb != null && sb.updating)) {\n          this.shiftAndExecuteNext(type);\n        }\n      }\n    }\n  }\n  shiftAndExecuteNext(type) {\n    this.queues[type].shift();\n    this.executeNext(type);\n  }\n  current(type) {\n    return this.queues[type][0];\n  }\n}\n\nconst VIDEO_CODEC_PROFILE_REPLACE = /(avc[1234]|hvc1|hev1|dvh[1e]|vp09|av01)(?:\\.[^.,]+)+/;\nclass BufferController {\n  constructor(hls) {\n    // The level details used to determine duration, target-duration and live\n    this.details = null;\n    // cache the self generated object url to detect hijack of video tag\n    this._objectUrl = null;\n    // A queue of buffer operations which require the SourceBuffer to not be updating upon execution\n    this.operationQueue = void 0;\n    // References to event listeners for each SourceBuffer, so that they can be referenced for event removal\n    this.listeners = void 0;\n    this.hls = void 0;\n    // The number of BUFFER_CODEC events received before any sourceBuffers are created\n    this.bufferCodecEventsExpected = 0;\n    // The total number of BUFFER_CODEC events received\n    this._bufferCodecEventsTotal = 0;\n    // A reference to the attached media element\n    this.media = null;\n    // A reference to the active media source\n    this.mediaSource = null;\n    // Last MP3 audio chunk appended\n    this.lastMpegAudioChunk = null;\n    this.appendSource = void 0;\n    // counters\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n    this.tracks = {};\n    this.pendingTracks = {};\n    this.sourceBuffer = void 0;\n    this.log = void 0;\n    this.warn = void 0;\n    this.error = void 0;\n    this._onEndStreaming = event => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.pauseBuffering();\n    };\n    this._onStartStreaming = event => {\n      if (!this.hls) {\n        return;\n      }\n      this.hls.resumeBuffering();\n    };\n    // Keep as arrow functions so that we can directly reference these functions directly as event listeners\n    this._onMediaSourceOpen = () => {\n      const {\n        media,\n        mediaSource\n      } = this;\n      this.log('Media source opened');\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        this.updateMediaElementDuration();\n        this.hls.trigger(Events.MEDIA_ATTACHED, {\n          media,\n          mediaSource: mediaSource\n        });\n      }\n      if (mediaSource) {\n        // once received, don't listen anymore to sourceopen event\n        mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      }\n      this.checkPendingTracks();\n    };\n    this._onMediaSourceClose = () => {\n      this.log('Media source closed');\n    };\n    this._onMediaSourceEnded = () => {\n      this.log('Media source ended');\n    };\n    this._onMediaEmptied = () => {\n      const {\n        mediaSrc,\n        _objectUrl\n      } = this;\n      if (mediaSrc !== _objectUrl) {\n        logger.error(`Media element src was set while attaching MediaSource (${_objectUrl} > ${mediaSrc})`);\n      }\n    };\n    this.hls = hls;\n    const logPrefix = '[buffer-controller]';\n    this.appendSource = isManagedMediaSource(getMediaSource(hls.config.preferManagedMediaSource));\n    this.log = logger.log.bind(logger, logPrefix);\n    this.warn = logger.warn.bind(logger, logPrefix);\n    this.error = logger.error.bind(logger, logPrefix);\n    this._initSourceBuffer();\n    this.registerListeners();\n  }\n  hasSourceTypes() {\n    return this.getSourceBufferTypes().length > 0 || Object.keys(this.pendingTracks).length > 0;\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.details = null;\n    this.lastMpegAudioChunk = null;\n    // @ts-ignore\n    this.hls = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.on(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.on(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.on(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.on(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.BUFFER_RESET, this.onBufferReset, this);\n    hls.off(Events.BUFFER_APPENDING, this.onBufferAppending, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.BUFFER_EOS, this.onBufferEos, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    hls.off(Events.LEVEL_UPDATED, this.onLevelUpdated, this);\n    hls.off(Events.FRAG_PARSED, this.onFragParsed, this);\n    hls.off(Events.FRAG_CHANGED, this.onFragChanged, this);\n  }\n  _initSourceBuffer() {\n    this.sourceBuffer = {};\n    this.operationQueue = new BufferOperationQueue(this.sourceBuffer);\n    this.listeners = {\n      audio: [],\n      video: [],\n      audiovideo: []\n    };\n    this.appendErrors = {\n      audio: 0,\n      video: 0,\n      audiovideo: 0\n    };\n    this.lastMpegAudioChunk = null;\n  }\n  onManifestLoading() {\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = 0;\n    this.details = null;\n  }\n  onManifestParsed(event, data) {\n    // in case of alt audio 2 BUFFER_CODECS events will be triggered, one per stream controller\n    // sourcebuffers will be created all at once when the expected nb of tracks will be reached\n    // in case alt audio is not used, only one BUFFER_CODEC event will be fired from main stream controller\n    // it will contain the expected nb of source buffers, no need to compute it\n    let codecEvents = 2;\n    if (data.audio && !data.video || !data.altAudio || !true) {\n      codecEvents = 1;\n    }\n    this.bufferCodecEventsExpected = this._bufferCodecEventsTotal = codecEvents;\n    this.log(`${this.bufferCodecEventsExpected} bufferCodec event(s) expected`);\n  }\n  onMediaAttaching(event, data) {\n    const media = this.media = data.media;\n    const MediaSource = getMediaSource(this.appendSource);\n    if (media && MediaSource) {\n      var _ms$constructor;\n      const ms = this.mediaSource = new MediaSource();\n      this.log(`created media source: ${(_ms$constructor = ms.constructor) == null ? void 0 : _ms$constructor.name}`);\n      // MediaSource listeners are arrow functions with a lexical scope, and do not need to be bound\n      ms.addEventListener('sourceopen', this._onMediaSourceOpen);\n      ms.addEventListener('sourceended', this._onMediaSourceEnded);\n      ms.addEventListener('sourceclose', this._onMediaSourceClose);\n      if (this.appendSource) {\n        ms.addEventListener('startstreaming', this._onStartStreaming);\n        ms.addEventListener('endstreaming', this._onEndStreaming);\n      }\n\n      // cache the locally generated object url\n      const objectUrl = this._objectUrl = self.URL.createObjectURL(ms);\n      // link video and media Source\n      if (this.appendSource) {\n        try {\n          media.removeAttribute('src');\n          // ManagedMediaSource will not open without disableRemotePlayback set to false or source alternatives\n          const MMS = self.ManagedMediaSource;\n          media.disableRemotePlayback = media.disableRemotePlayback || MMS && ms instanceof MMS;\n          removeSourceChildren(media);\n          addSource(media, objectUrl);\n          media.load();\n        } catch (error) {\n          media.src = objectUrl;\n        }\n      } else {\n        media.src = objectUrl;\n      }\n      media.addEventListener('emptied', this._onMediaEmptied);\n    }\n  }\n  onMediaDetaching() {\n    const {\n      media,\n      mediaSource,\n      _objectUrl\n    } = this;\n    if (mediaSource) {\n      this.log('media source detaching');\n      if (mediaSource.readyState === 'open') {\n        try {\n          // endOfStream could trigger exception if any sourcebuffer is in updating state\n          // we don't really care about checking sourcebuffer state here,\n          // as we are anyway detaching the MediaSource\n          // let's just avoid this exception to propagate\n          mediaSource.endOfStream();\n        } catch (err) {\n          this.warn(`onMediaDetaching: ${err.message} while calling endOfStream`);\n        }\n      }\n      // Clean up the SourceBuffers by invoking onBufferReset\n      this.onBufferReset();\n      mediaSource.removeEventListener('sourceopen', this._onMediaSourceOpen);\n      mediaSource.removeEventListener('sourceended', this._onMediaSourceEnded);\n      mediaSource.removeEventListener('sourceclose', this._onMediaSourceClose);\n      if (this.appendSource) {\n        mediaSource.removeEventListener('startstreaming', this._onStartStreaming);\n        mediaSource.removeEventListener('endstreaming', this._onEndStreaming);\n      }\n\n      // Detach properly the MediaSource from the HTMLMediaElement as\n      // suggested in https://github.com/w3c/media-source/issues/53.\n      if (media) {\n        media.removeEventListener('emptied', this._onMediaEmptied);\n        if (_objectUrl) {\n          self.URL.revokeObjectURL(_objectUrl);\n        }\n\n        // clean up video tag src only if it's our own url. some external libraries might\n        // hijack the video tag and change its 'src' without destroying the Hls instance first\n        if (this.mediaSrc === _objectUrl) {\n          media.removeAttribute('src');\n          if (this.appendSource) {\n            removeSourceChildren(media);\n          }\n          media.load();\n        } else {\n          this.warn('media|source.src was changed by a third party - skip cleanup');\n        }\n      }\n      this.mediaSource = null;\n      this.media = null;\n      this._objectUrl = null;\n      this.bufferCodecEventsExpected = this._bufferCodecEventsTotal;\n      this.pendingTracks = {};\n      this.tracks = {};\n    }\n    this.hls.trigger(Events.MEDIA_DETACHED, undefined);\n  }\n  onBufferReset() {\n    this.getSourceBufferTypes().forEach(type => {\n      this.resetBuffer(type);\n    });\n    this._initSourceBuffer();\n  }\n  resetBuffer(type) {\n    const sb = this.sourceBuffer[type];\n    try {\n      if (sb) {\n        var _this$mediaSource;\n        this.removeBufferListeners(type);\n        // Synchronously remove the SB from the map before the next call in order to prevent an async function from\n        // accessing it\n        this.sourceBuffer[type] = undefined;\n        if ((_this$mediaSource = this.mediaSource) != null && _this$mediaSource.sourceBuffers.length) {\n          this.mediaSource.removeSourceBuffer(sb);\n        }\n      }\n    } catch (err) {\n      this.warn(`onBufferReset ${type}`, err);\n    }\n  }\n  onBufferCodecs(event, data) {\n    const sourceBufferCount = this.getSourceBufferTypes().length;\n    const trackNames = Object.keys(data);\n    trackNames.forEach(trackName => {\n      if (sourceBufferCount) {\n        // check if SourceBuffer codec needs to change\n        const track = this.tracks[trackName];\n        if (track && typeof track.buffer.changeType === 'function') {\n          var _trackCodec;\n          const {\n            id,\n            codec,\n            levelCodec,\n            container,\n            metadata\n          } = data[trackName];\n          const currentCodecFull = pickMostCompleteCodecName(track.codec, track.levelCodec);\n          const currentCodec = currentCodecFull == null ? void 0 : currentCodecFull.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n          let trackCodec = pickMostCompleteCodecName(codec, levelCodec);\n          const nextCodec = (_trackCodec = trackCodec) == null ? void 0 : _trackCodec.replace(VIDEO_CODEC_PROFILE_REPLACE, '$1');\n          if (trackCodec && currentCodec !== nextCodec) {\n            if (trackName.slice(0, 5) === 'audio') {\n              trackCodec = getCodecCompatibleName(trackCodec, this.appendSource);\n            }\n            const mimeType = `${container};codecs=${trackCodec}`;\n            this.appendChangeType(trackName, mimeType);\n            this.log(`switching codec ${currentCodecFull} to ${trackCodec}`);\n            this.tracks[trackName] = {\n              buffer: track.buffer,\n              codec,\n              container,\n              levelCodec,\n              metadata,\n              id\n            };\n          }\n        }\n      } else {\n        // if source buffer(s) not created yet, appended buffer tracks in this.pendingTracks\n        this.pendingTracks[trackName] = data[trackName];\n      }\n    });\n\n    // if sourcebuffers already created, do nothing ...\n    if (sourceBufferCount) {\n      return;\n    }\n    const bufferCodecEventsExpected = Math.max(this.bufferCodecEventsExpected - 1, 0);\n    if (this.bufferCodecEventsExpected !== bufferCodecEventsExpected) {\n      this.log(`${bufferCodecEventsExpected} bufferCodec event(s) expected ${trackNames.join(',')}`);\n      this.bufferCodecEventsExpected = bufferCodecEventsExpected;\n    }\n    if (this.mediaSource && this.mediaSource.readyState === 'open') {\n      this.checkPendingTracks();\n    }\n  }\n  appendChangeType(type, mimeType) {\n    const {\n      operationQueue\n    } = this;\n    const operation = {\n      execute: () => {\n        const sb = this.sourceBuffer[type];\n        if (sb) {\n          this.log(`changing ${type} sourceBuffer type to ${mimeType}`);\n          sb.changeType(mimeType);\n        }\n        operationQueue.shiftAndExecuteNext(type);\n      },\n      onStart: () => {},\n      onComplete: () => {},\n      onError: error => {\n        this.warn(`Failed to change ${type} SourceBuffer type`, error);\n      }\n    };\n    operationQueue.append(operation, type, !!this.pendingTracks[type]);\n  }\n  onBufferAppending(event, eventData) {\n    const {\n      hls,\n      operationQueue,\n      tracks\n    } = this;\n    const {\n      data,\n      type,\n      frag,\n      part,\n      chunkMeta\n    } = eventData;\n    const chunkStats = chunkMeta.buffering[type];\n    const bufferAppendingStart = self.performance.now();\n    chunkStats.start = bufferAppendingStart;\n    const fragBuffering = frag.stats.buffering;\n    const partBuffering = part ? part.stats.buffering : null;\n    if (fragBuffering.start === 0) {\n      fragBuffering.start = bufferAppendingStart;\n    }\n    if (partBuffering && partBuffering.start === 0) {\n      partBuffering.start = bufferAppendingStart;\n    }\n\n    // TODO: Only update timestampOffset when audio/mpeg fragment or part is not contiguous with previously appended\n    // Adjusting `SourceBuffer.timestampOffset` (desired point in the timeline where the next frames should be appended)\n    // in Chrome browser when we detect MPEG audio container and time delta between level PTS and `SourceBuffer.timestampOffset`\n    // is greater than 100ms (this is enough to handle seek for VOD or level change for LIVE videos).\n    // More info here: https://github.com/video-dev/hls.js/issues/332#issuecomment-257986486\n    const audioTrack = tracks.audio;\n    let checkTimestampOffset = false;\n    if (type === 'audio' && (audioTrack == null ? void 0 : audioTrack.container) === 'audio/mpeg') {\n      checkTimestampOffset = !this.lastMpegAudioChunk || chunkMeta.id === 1 || this.lastMpegAudioChunk.sn !== chunkMeta.sn;\n      this.lastMpegAudioChunk = chunkMeta;\n    }\n    const fragStart = frag.start;\n    const operation = {\n      execute: () => {\n        chunkStats.executeStart = self.performance.now();\n        if (checkTimestampOffset) {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            const delta = fragStart - sb.timestampOffset;\n            if (Math.abs(delta) >= 0.1) {\n              this.log(`Updating audio SourceBuffer timestampOffset to ${fragStart} (delta: ${delta}) sn: ${frag.sn})`);\n              sb.timestampOffset = fragStart;\n            }\n          }\n        }\n        this.appendExecutor(data, type);\n      },\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updatestart`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: ${type} SourceBuffer updateend`);\n        const end = self.performance.now();\n        chunkStats.executeEnd = chunkStats.end = end;\n        if (fragBuffering.first === 0) {\n          fragBuffering.first = end;\n        }\n        if (partBuffering && partBuffering.first === 0) {\n          partBuffering.first = end;\n        }\n        const {\n          sourceBuffer\n        } = this;\n        const timeRanges = {};\n        for (const type in sourceBuffer) {\n          timeRanges[type] = BufferHelper.getBuffered(sourceBuffer[type]);\n        }\n        this.appendErrors[type] = 0;\n        if (type === 'audio' || type === 'video') {\n          this.appendErrors.audiovideo = 0;\n        } else {\n          this.appendErrors.audio = 0;\n          this.appendErrors.video = 0;\n        }\n        this.hls.trigger(Events.BUFFER_APPENDED, {\n          type,\n          frag,\n          part,\n          chunkMeta,\n          parent: frag.type,\n          timeRanges\n        });\n      },\n      onError: error => {\n        // in case any error occured while appending, put back segment in segments table\n        const event = {\n          type: ErrorTypes.MEDIA_ERROR,\n          parent: frag.type,\n          details: ErrorDetails.BUFFER_APPEND_ERROR,\n          sourceBufferName: type,\n          frag,\n          part,\n          chunkMeta,\n          error,\n          err: error,\n          fatal: false\n        };\n        if (error.code === DOMException.QUOTA_EXCEEDED_ERR) {\n          // QuotaExceededError: http://www.w3.org/TR/html5/infrastructure.html#quotaexceedederror\n          // let's stop appending any segments, and report BUFFER_FULL_ERROR error\n          event.details = ErrorDetails.BUFFER_FULL_ERROR;\n        } else {\n          const appendErrorCount = ++this.appendErrors[type];\n          event.details = ErrorDetails.BUFFER_APPEND_ERROR;\n          /* with UHD content, we could get loop of quota exceeded error until\n            browser is able to evict some data from sourcebuffer. Retrying can help recover.\n          */\n          this.warn(`Failed ${appendErrorCount}/${hls.config.appendErrorMaxRetry} times to append segment in \"${type}\" sourceBuffer`);\n          if (appendErrorCount >= hls.config.appendErrorMaxRetry) {\n            event.fatal = true;\n          }\n        }\n        hls.trigger(Events.ERROR, event);\n      }\n    };\n    operationQueue.append(operation, type, !!this.pendingTracks[type]);\n  }\n  onBufferFlushing(event, data) {\n    const {\n      operationQueue\n    } = this;\n    const flushOperation = type => ({\n      execute: this.removeExecutor.bind(this, type, data.startOffset, data.endOffset),\n      onStart: () => {\n        // logger.debug(`[buffer-controller]: Started flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n      },\n      onComplete: () => {\n        // logger.debug(`[buffer-controller]: Finished flushing ${data.startOffset} -> ${data.endOffset} for ${type} Source Buffer`);\n        this.hls.trigger(Events.BUFFER_FLUSHED, {\n          type\n        });\n      },\n      onError: error => {\n        this.warn(`Failed to remove from ${type} SourceBuffer`, error);\n      }\n    });\n    if (data.type) {\n      operationQueue.append(flushOperation(data.type), data.type);\n    } else {\n      this.getSourceBufferTypes().forEach(type => {\n        operationQueue.append(flushOperation(type), type);\n      });\n    }\n  }\n  onFragParsed(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    const buffersAppendedTo = [];\n    const elementaryStreams = part ? part.elementaryStreams : frag.elementaryStreams;\n    if (elementaryStreams[ElementaryStreamTypes.AUDIOVIDEO]) {\n      buffersAppendedTo.push('audiovideo');\n    } else {\n      if (elementaryStreams[ElementaryStreamTypes.AUDIO]) {\n        buffersAppendedTo.push('audio');\n      }\n      if (elementaryStreams[ElementaryStreamTypes.VIDEO]) {\n        buffersAppendedTo.push('video');\n      }\n    }\n    const onUnblocked = () => {\n      const now = self.performance.now();\n      frag.stats.buffering.end = now;\n      if (part) {\n        part.stats.buffering.end = now;\n      }\n      const stats = part ? part.stats : frag.stats;\n      this.hls.trigger(Events.FRAG_BUFFERED, {\n        frag,\n        part,\n        stats,\n        id: frag.type\n      });\n    };\n    if (buffersAppendedTo.length === 0) {\n      this.warn(`Fragments must have at least one ElementaryStreamType set. type: ${frag.type} level: ${frag.level} sn: ${frag.sn}`);\n    }\n    this.blockBuffers(onUnblocked, buffersAppendedTo);\n  }\n  onFragChanged(event, data) {\n    this.trimBuffers();\n  }\n\n  // on BUFFER_EOS mark matching sourcebuffer(s) as ended and trigger checkEos()\n  // an undefined data.type will mark all buffers as EOS.\n  onBufferEos(event, data) {\n    const ended = this.getSourceBufferTypes().reduce((acc, type) => {\n      const sb = this.sourceBuffer[type];\n      if (sb && (!data.type || data.type === type)) {\n        sb.ending = true;\n        if (!sb.ended) {\n          sb.ended = true;\n          this.log(`${type} sourceBuffer now EOS`);\n        }\n      }\n      return acc && !!(!sb || sb.ended);\n    }, true);\n    if (ended) {\n      this.log(`Queueing mediaSource.endOfStream()`);\n      this.blockBuffers(() => {\n        this.getSourceBufferTypes().forEach(type => {\n          const sb = this.sourceBuffer[type];\n          if (sb) {\n            sb.ending = false;\n          }\n        });\n        const {\n          mediaSource\n        } = this;\n        if (!mediaSource || mediaSource.readyState !== 'open') {\n          if (mediaSource) {\n            this.log(`Could not call mediaSource.endOfStream(). mediaSource.readyState: ${mediaSource.readyState}`);\n          }\n          return;\n        }\n        this.log(`Calling mediaSource.endOfStream()`);\n        // Allow this to throw and be caught by the enqueueing function\n        mediaSource.endOfStream();\n      });\n    }\n  }\n  onLevelUpdated(event, {\n    details\n  }) {\n    if (!details.fragments.length) {\n      return;\n    }\n    this.details = details;\n    if (this.getSourceBufferTypes().length) {\n      this.blockBuffers(this.updateMediaElementDuration.bind(this));\n    } else {\n      this.updateMediaElementDuration();\n    }\n  }\n  trimBuffers() {\n    const {\n      hls,\n      details,\n      media\n    } = this;\n    if (!media || details === null) {\n      return;\n    }\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    if (!sourceBufferTypes.length) {\n      return;\n    }\n    const config = hls.config;\n    const currentTime = media.currentTime;\n    const targetDuration = details.levelTargetDuration;\n\n    // Support for deprecated liveBackBufferLength\n    const backBufferLength = details.live && config.liveBackBufferLength !== null ? config.liveBackBufferLength : config.backBufferLength;\n    if (isFiniteNumber(backBufferLength) && backBufferLength > 0) {\n      const maxBackBufferLength = Math.max(backBufferLength, targetDuration);\n      const targetBackBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration - maxBackBufferLength;\n      this.flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition);\n    }\n    if (isFiniteNumber(config.frontBufferFlushThreshold) && config.frontBufferFlushThreshold > 0) {\n      const frontBufferLength = Math.max(config.maxBufferLength, config.frontBufferFlushThreshold);\n      const maxFrontBufferLength = Math.max(frontBufferLength, targetDuration);\n      const targetFrontBufferPosition = Math.floor(currentTime / targetDuration) * targetDuration + maxFrontBufferLength;\n      this.flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition);\n    }\n  }\n  flushBackBuffer(currentTime, targetDuration, targetBackBufferPosition) {\n    const {\n      details,\n      sourceBuffer\n    } = this;\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    sourceBufferTypes.forEach(type => {\n      const sb = sourceBuffer[type];\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        // when target buffer start exceeds actual buffer start\n        if (buffered.length > 0 && targetBackBufferPosition > buffered.start(0)) {\n          this.hls.trigger(Events.BACK_BUFFER_REACHED, {\n            bufferEnd: targetBackBufferPosition\n          });\n\n          // Support for deprecated event:\n          if (details != null && details.live) {\n            this.hls.trigger(Events.LIVE_BACK_BUFFER_REACHED, {\n              bufferEnd: targetBackBufferPosition\n            });\n          } else if (sb.ended && buffered.end(buffered.length - 1) - currentTime < targetDuration * 2) {\n            this.log(`Cannot flush ${type} back buffer while SourceBuffer is in ended state`);\n            return;\n          }\n          this.hls.trigger(Events.BUFFER_FLUSHING, {\n            startOffset: 0,\n            endOffset: targetBackBufferPosition,\n            type\n          });\n        }\n      }\n    });\n  }\n  flushFrontBuffer(currentTime, targetDuration, targetFrontBufferPosition) {\n    const {\n      sourceBuffer\n    } = this;\n    const sourceBufferTypes = this.getSourceBufferTypes();\n    sourceBufferTypes.forEach(type => {\n      const sb = sourceBuffer[type];\n      if (sb) {\n        const buffered = BufferHelper.getBuffered(sb);\n        const numBufferedRanges = buffered.length;\n        // The buffer is either empty or contiguous\n        if (numBufferedRanges < 2) {\n          return;\n        }\n        const bufferStart = buffered.start(numBufferedRanges - 1);\n        const bufferEnd = buffered.end(numBufferedRanges - 1);\n        // No flush if we can tolerate the current buffer length or the current buffer range we would flush is contiguous with current position\n        if (targetFrontBufferPosition > bufferStart || currentTime >= bufferStart && currentTime <= bufferEnd) {\n          return;\n        } else if (sb.ended && currentTime - bufferEnd < 2 * targetDuration) {\n          this.log(`Cannot flush ${type} front buffer while SourceBuffer is in ended state`);\n          return;\n        }\n        this.hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: bufferStart,\n          endOffset: Infinity,\n          type\n        });\n      }\n    });\n  }\n\n  /**\n   * Update Media Source duration to current level duration or override to Infinity if configuration parameter\n   * 'liveDurationInfinity` is set to `true`\n   * More details: https://github.com/video-dev/hls.js/issues/355\n   */\n  updateMediaElementDuration() {\n    if (!this.details || !this.media || !this.mediaSource || this.mediaSource.readyState !== 'open') {\n      return;\n    }\n    const {\n      details,\n      hls,\n      media,\n      mediaSource\n    } = this;\n    const levelDuration = details.fragments[0].start + details.totalduration;\n    const mediaDuration = media.duration;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : 0;\n    if (details.live && hls.config.liveDurationInfinity) {\n      // Override duration to Infinity\n      mediaSource.duration = Infinity;\n      this.updateSeekableRange(details);\n    } else if (levelDuration > msDuration && levelDuration > mediaDuration || !isFiniteNumber(mediaDuration)) {\n      // levelDuration was the last value we set.\n      // not using mediaSource.duration as the browser may tweak this value\n      // only update Media Source duration if its value increase, this is to avoid\n      // flushing already buffered portion when switching between quality level\n      this.log(`Updating Media Source duration to ${levelDuration.toFixed(3)}`);\n      mediaSource.duration = levelDuration;\n    }\n  }\n  updateSeekableRange(levelDetails) {\n    const mediaSource = this.mediaSource;\n    const fragments = levelDetails.fragments;\n    const len = fragments.length;\n    if (len && levelDetails.live && mediaSource != null && mediaSource.setLiveSeekableRange) {\n      const start = Math.max(0, fragments[0].start);\n      const end = Math.max(start, start + levelDetails.totalduration);\n      this.log(`Media Source duration is set to ${mediaSource.duration}. Setting seekable range to ${start}-${end}.`);\n      mediaSource.setLiveSeekableRange(start, end);\n    }\n  }\n  checkPendingTracks() {\n    const {\n      bufferCodecEventsExpected,\n      operationQueue,\n      pendingTracks\n    } = this;\n\n    // Check if we've received all of the expected bufferCodec events. When none remain, create all the sourceBuffers at once.\n    // This is important because the MSE spec allows implementations to throw QuotaExceededErrors if creating new sourceBuffers after\n    // data has been appended to existing ones.\n    // 2 tracks is the max (one for audio, one for video). If we've reach this max go ahead and create the buffers.\n    const pendingTracksCount = Object.keys(pendingTracks).length;\n    if (pendingTracksCount && (!bufferCodecEventsExpected || pendingTracksCount === 2 || 'audiovideo' in pendingTracks)) {\n      // ok, let's create them now !\n      this.createSourceBuffers(pendingTracks);\n      this.pendingTracks = {};\n      // append any pending segments now !\n      const buffers = this.getSourceBufferTypes();\n      if (buffers.length) {\n        this.hls.trigger(Events.BUFFER_CREATED, {\n          tracks: this.tracks\n        });\n        buffers.forEach(type => {\n          operationQueue.executeNext(type);\n        });\n      } else {\n        const error = new Error('could not create source buffer for media codec(s)');\n        this.hls.trigger(Events.ERROR, {\n          type: ErrorTypes.MEDIA_ERROR,\n          details: ErrorDetails.BUFFER_INCOMPATIBLE_CODECS_ERROR,\n          fatal: true,\n          error,\n          reason: error.message\n        });\n      }\n    }\n  }\n  createSourceBuffers(tracks) {\n    const {\n      sourceBuffer,\n      mediaSource\n    } = this;\n    if (!mediaSource) {\n      throw Error('createSourceBuffers called when mediaSource was null');\n    }\n    for (const trackName in tracks) {\n      if (!sourceBuffer[trackName]) {\n        var _track$levelCodec;\n        const track = tracks[trackName];\n        if (!track) {\n          throw Error(`source buffer exists for track ${trackName}, however track does not`);\n        }\n        // use levelCodec as first priority unless it contains multiple comma-separated codec values\n        let codec = ((_track$levelCodec = track.levelCodec) == null ? void 0 : _track$levelCodec.indexOf(',')) === -1 ? track.levelCodec : track.codec;\n        if (codec) {\n          if (trackName.slice(0, 5) === 'audio') {\n            codec = getCodecCompatibleName(codec, this.appendSource);\n          }\n        }\n        const mimeType = `${track.container};codecs=${codec}`;\n        this.log(`creating sourceBuffer(${mimeType})`);\n        try {\n          const sb = sourceBuffer[trackName] = mediaSource.addSourceBuffer(mimeType);\n          const sbName = trackName;\n          this.addBufferListener(sbName, 'updatestart', this._onSBUpdateStart);\n          this.addBufferListener(sbName, 'updateend', this._onSBUpdateEnd);\n          this.addBufferListener(sbName, 'error', this._onSBUpdateError);\n          // ManagedSourceBuffer bufferedchange event\n          if (this.appendSource) {\n            this.addBufferListener(sbName, 'bufferedchange', (type, event) => {\n              // If media was ejected check for a change. Added ranges are redundant with changes on 'updateend' event.\n              const removedRanges = event.removedRanges;\n              if (removedRanges != null && removedRanges.length) {\n                this.hls.trigger(Events.BUFFER_FLUSHED, {\n                  type: trackName\n                });\n              }\n            });\n          }\n          this.tracks[trackName] = {\n            buffer: sb,\n            codec: codec,\n            container: track.container,\n            levelCodec: track.levelCodec,\n            metadata: track.metadata,\n            id: track.id\n          };\n        } catch (err) {\n          this.error(`error while trying to add sourceBuffer: ${err.message}`);\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_ADD_CODEC_ERROR,\n            fatal: false,\n            error: err,\n            sourceBufferName: trackName,\n            mimeType: mimeType\n          });\n        }\n      }\n    }\n  }\n  get mediaSrc() {\n    var _this$media, _this$media$querySele;\n    const media = ((_this$media = this.media) == null ? void 0 : (_this$media$querySele = _this$media.querySelector) == null ? void 0 : _this$media$querySele.call(_this$media, 'source')) || this.media;\n    return media == null ? void 0 : media.src;\n  }\n  _onSBUpdateStart(type) {\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onStart();\n  }\n  _onSBUpdateEnd(type) {\n    var _this$mediaSource2;\n    if (((_this$mediaSource2 = this.mediaSource) == null ? void 0 : _this$mediaSource2.readyState) === 'closed') {\n      this.resetBuffer(type);\n      return;\n    }\n    const {\n      operationQueue\n    } = this;\n    const operation = operationQueue.current(type);\n    operation.onComplete();\n    operationQueue.shiftAndExecuteNext(type);\n  }\n  _onSBUpdateError(type, event) {\n    var _this$mediaSource3;\n    const error = new Error(`${type} SourceBuffer error. MediaSource readyState: ${(_this$mediaSource3 = this.mediaSource) == null ? void 0 : _this$mediaSource3.readyState}`);\n    this.error(`${error}`, event);\n    // according to http://www.w3.org/TR/media-source/#sourcebuffer-append-error\n    // SourceBuffer errors are not necessarily fatal; if so, the HTMLMediaElement will fire an error event\n    this.hls.trigger(Events.ERROR, {\n      type: ErrorTypes.MEDIA_ERROR,\n      details: ErrorDetails.BUFFER_APPENDING_ERROR,\n      sourceBufferName: type,\n      error,\n      fatal: false\n    });\n    // updateend is always fired after error, so we'll allow that to shift the current operation off of the queue\n    const operation = this.operationQueue.current(type);\n    if (operation) {\n      operation.onError(error);\n    }\n  }\n\n  // This method must result in an updateend event; if remove is not called, _onSBUpdateEnd must be called manually\n  removeExecutor(type, startOffset, endOffset) {\n    const {\n      media,\n      mediaSource,\n      operationQueue,\n      sourceBuffer\n    } = this;\n    const sb = sourceBuffer[type];\n    if (!media || !mediaSource || !sb) {\n      this.warn(`Attempting to remove from the ${type} SourceBuffer, but it does not exist`);\n      operationQueue.shiftAndExecuteNext(type);\n      return;\n    }\n    const mediaDuration = isFiniteNumber(media.duration) ? media.duration : Infinity;\n    const msDuration = isFiniteNumber(mediaSource.duration) ? mediaSource.duration : Infinity;\n    const removeStart = Math.max(0, startOffset);\n    const removeEnd = Math.min(endOffset, mediaDuration, msDuration);\n    if (removeEnd > removeStart && (!sb.ending || sb.ended)) {\n      sb.ended = false;\n      this.log(`Removing [${removeStart},${removeEnd}] from the ${type} SourceBuffer`);\n      sb.remove(removeStart, removeEnd);\n    } else {\n      // Cycle the queue\n      operationQueue.shiftAndExecuteNext(type);\n    }\n  }\n\n  // This method must result in an updateend event; if append is not called, _onSBUpdateEnd must be called manually\n  appendExecutor(data, type) {\n    const sb = this.sourceBuffer[type];\n    if (!sb) {\n      if (!this.pendingTracks[type]) {\n        throw new Error(`Attempting to append to the ${type} SourceBuffer, but it does not exist`);\n      }\n      return;\n    }\n    sb.ended = false;\n    sb.appendBuffer(data);\n  }\n\n  // Enqueues an operation to each SourceBuffer queue which, upon execution, resolves a promise. When all promises\n  // resolve, the onUnblocked function is executed. Functions calling this method do not need to unblock the queue\n  // upon completion, since we already do it here\n  blockBuffers(onUnblocked, buffers = this.getSourceBufferTypes()) {\n    if (!buffers.length) {\n      this.log('Blocking operation requested, but no SourceBuffers exist');\n      Promise.resolve().then(onUnblocked);\n      return;\n    }\n    const {\n      operationQueue\n    } = this;\n\n    // logger.debug(`[buffer-controller]: Blocking ${buffers} SourceBuffer`);\n    const blockingOperations = buffers.map(type => operationQueue.appendBlocker(type));\n    Promise.all(blockingOperations).then(() => {\n      // logger.debug(`[buffer-controller]: Blocking operation resolved; unblocking ${buffers} SourceBuffer`);\n      onUnblocked();\n      buffers.forEach(type => {\n        const sb = this.sourceBuffer[type];\n        // Only cycle the queue if the SB is not updating. There's a bug in Chrome which sets the SB updating flag to\n        // true when changing the MediaSource duration (https://bugs.chromium.org/p/chromium/issues/detail?id=959359&can=2&q=mediasource%20duration)\n        // While this is a workaround, it's probably useful to have around\n        if (!(sb != null && sb.updating)) {\n          operationQueue.shiftAndExecuteNext(type);\n        }\n      });\n    });\n  }\n  getSourceBufferTypes() {\n    return Object.keys(this.sourceBuffer);\n  }\n  addBufferListener(type, event, fn) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    const listener = fn.bind(this, type);\n    this.listeners[type].push({\n      event,\n      listener\n    });\n    buffer.addEventListener(event, listener);\n  }\n  removeBufferListeners(type) {\n    const buffer = this.sourceBuffer[type];\n    if (!buffer) {\n      return;\n    }\n    this.listeners[type].forEach(l => {\n      buffer.removeEventListener(l.event, l.listener);\n    });\n  }\n}\nfunction removeSourceChildren(node) {\n  const sourceChildren = node.querySelectorAll('source');\n  [].slice.call(sourceChildren).forEach(source => {\n    node.removeChild(source);\n  });\n}\nfunction addSource(media, url) {\n  const source = self.document.createElement('source');\n  source.type = 'video/mp4';\n  source.src = url;\n  media.appendChild(source);\n}\n\n/**\n *\n * This code was ported from the dash.js project at:\n *   https://github.com/Dash-Industry-Forum/dash.js/blob/development/externals/cea608-parser.js\n *   https://github.com/Dash-Industry-Forum/dash.js/commit/8269b26a761e0853bb21d78780ed945144ecdd4d#diff-71bc295a2d6b6b7093a1d3290d53a4b2\n *\n * The original copyright appears below:\n *\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2015-2016, DASH Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  1. Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  2. Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n/**\n *  Exceptions from regular ASCII. CodePoints are mapped to UTF-16 codes\n */\n\nconst specialCea608CharsCodes = {\n  0x2a: 0xe1,\n  // lowercase a, acute accent\n  0x5c: 0xe9,\n  // lowercase e, acute accent\n  0x5e: 0xed,\n  // lowercase i, acute accent\n  0x5f: 0xf3,\n  // lowercase o, acute accent\n  0x60: 0xfa,\n  // lowercase u, acute accent\n  0x7b: 0xe7,\n  // lowercase c with cedilla\n  0x7c: 0xf7,\n  // division symbol\n  0x7d: 0xd1,\n  // uppercase N tilde\n  0x7e: 0xf1,\n  // lowercase n tilde\n  0x7f: 0x2588,\n  // Full block\n  // THIS BLOCK INCLUDES THE 16 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x11 AND LOW BETWEEN 0x30 AND 0x3F\n  // THIS MEANS THAT \\x50 MUST BE ADDED TO THE VALUES\n  0x80: 0xae,\n  // Registered symbol (R)\n  0x81: 0xb0,\n  // degree sign\n  0x82: 0xbd,\n  // 1/2 symbol\n  0x83: 0xbf,\n  // Inverted (open) question mark\n  0x84: 0x2122,\n  // Trademark symbol (TM)\n  0x85: 0xa2,\n  // Cents symbol\n  0x86: 0xa3,\n  // Pounds sterling\n  0x87: 0x266a,\n  // Music 8'th note\n  0x88: 0xe0,\n  // lowercase a, grave accent\n  0x89: 0x20,\n  // transparent space (regular)\n  0x8a: 0xe8,\n  // lowercase e, grave accent\n  0x8b: 0xe2,\n  // lowercase a, circumflex accent\n  0x8c: 0xea,\n  // lowercase e, circumflex accent\n  0x8d: 0xee,\n  // lowercase i, circumflex accent\n  0x8e: 0xf4,\n  // lowercase o, circumflex accent\n  0x8f: 0xfb,\n  // lowercase u, circumflex accent\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x12 AND LOW BETWEEN 0x20 AND 0x3F\n  0x90: 0xc1,\n  // capital letter A with acute\n  0x91: 0xc9,\n  // capital letter E with acute\n  0x92: 0xd3,\n  // capital letter O with acute\n  0x93: 0xda,\n  // capital letter U with acute\n  0x94: 0xdc,\n  // capital letter U with diaresis\n  0x95: 0xfc,\n  // lowercase letter U with diaeresis\n  0x96: 0x2018,\n  // opening single quote\n  0x97: 0xa1,\n  // inverted exclamation mark\n  0x98: 0x2a,\n  // asterisk\n  0x99: 0x2019,\n  // closing single quote\n  0x9a: 0x2501,\n  // box drawings heavy horizontal\n  0x9b: 0xa9,\n  // copyright sign\n  0x9c: 0x2120,\n  // Service mark\n  0x9d: 0x2022,\n  // (round) bullet\n  0x9e: 0x201c,\n  // Left double quotation mark\n  0x9f: 0x201d,\n  // Right double quotation mark\n  0xa0: 0xc0,\n  // uppercase A, grave accent\n  0xa1: 0xc2,\n  // uppercase A, circumflex\n  0xa2: 0xc7,\n  // uppercase C with cedilla\n  0xa3: 0xc8,\n  // uppercase E, grave accent\n  0xa4: 0xca,\n  // uppercase E, circumflex\n  0xa5: 0xcb,\n  // capital letter E with diaresis\n  0xa6: 0xeb,\n  // lowercase letter e with diaresis\n  0xa7: 0xce,\n  // uppercase I, circumflex\n  0xa8: 0xcf,\n  // uppercase I, with diaresis\n  0xa9: 0xef,\n  // lowercase i, with diaresis\n  0xaa: 0xd4,\n  // uppercase O, circumflex\n  0xab: 0xd9,\n  // uppercase U, grave accent\n  0xac: 0xf9,\n  // lowercase u, grave accent\n  0xad: 0xdb,\n  // uppercase U, circumflex\n  0xae: 0xab,\n  // left-pointing double angle quotation mark\n  0xaf: 0xbb,\n  // right-pointing double angle quotation mark\n  // THIS BLOCK INCLUDES THE 32 EXTENDED (TWO-BYTE) LINE 21 CHARACTERS\n  // THAT COME FROM HI BYTE=0x13 AND LOW BETWEEN 0x20 AND 0x3F\n  0xb0: 0xc3,\n  // Uppercase A, tilde\n  0xb1: 0xe3,\n  // Lowercase a, tilde\n  0xb2: 0xcd,\n  // Uppercase I, acute accent\n  0xb3: 0xcc,\n  // Uppercase I, grave accent\n  0xb4: 0xec,\n  // Lowercase i, grave accent\n  0xb5: 0xd2,\n  // Uppercase O, grave accent\n  0xb6: 0xf2,\n  // Lowercase o, grave accent\n  0xb7: 0xd5,\n  // Uppercase O, tilde\n  0xb8: 0xf5,\n  // Lowercase o, tilde\n  0xb9: 0x7b,\n  // Open curly brace\n  0xba: 0x7d,\n  // Closing curly brace\n  0xbb: 0x5c,\n  // Backslash\n  0xbc: 0x5e,\n  // Caret\n  0xbd: 0x5f,\n  // Underscore\n  0xbe: 0x7c,\n  // Pipe (vertical line)\n  0xbf: 0x223c,\n  // Tilde operator\n  0xc0: 0xc4,\n  // Uppercase A, umlaut\n  0xc1: 0xe4,\n  // Lowercase A, umlaut\n  0xc2: 0xd6,\n  // Uppercase O, umlaut\n  0xc3: 0xf6,\n  // Lowercase o, umlaut\n  0xc4: 0xdf,\n  // Esszett (sharp S)\n  0xc5: 0xa5,\n  // Yen symbol\n  0xc6: 0xa4,\n  // Generic currency sign\n  0xc7: 0x2503,\n  // Box drawings heavy vertical\n  0xc8: 0xc5,\n  // Uppercase A, ring\n  0xc9: 0xe5,\n  // Lowercase A, ring\n  0xca: 0xd8,\n  // Uppercase O, stroke\n  0xcb: 0xf8,\n  // Lowercase o, strok\n  0xcc: 0x250f,\n  // Box drawings heavy down and right\n  0xcd: 0x2513,\n  // Box drawings heavy down and left\n  0xce: 0x2517,\n  // Box drawings heavy up and right\n  0xcf: 0x251b // Box drawings heavy up and left\n};\n\n/**\n * Utils\n */\nconst getCharForByte = byte => String.fromCharCode(specialCea608CharsCodes[byte] || byte);\nconst NR_ROWS = 15;\nconst NR_COLS = 100;\n// Tables to look up row from PAC data\nconst rowsLowCh1 = {\n  0x11: 1,\n  0x12: 3,\n  0x15: 5,\n  0x16: 7,\n  0x17: 9,\n  0x10: 11,\n  0x13: 12,\n  0x14: 14\n};\nconst rowsHighCh1 = {\n  0x11: 2,\n  0x12: 4,\n  0x15: 6,\n  0x16: 8,\n  0x17: 10,\n  0x13: 13,\n  0x14: 15\n};\nconst rowsLowCh2 = {\n  0x19: 1,\n  0x1a: 3,\n  0x1d: 5,\n  0x1e: 7,\n  0x1f: 9,\n  0x18: 11,\n  0x1b: 12,\n  0x1c: 14\n};\nconst rowsHighCh2 = {\n  0x19: 2,\n  0x1a: 4,\n  0x1d: 6,\n  0x1e: 8,\n  0x1f: 10,\n  0x1b: 13,\n  0x1c: 15\n};\nconst backgroundColors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'black', 'transparent'];\nclass CaptionsLogger {\n  constructor() {\n    this.time = null;\n    this.verboseLevel = 0;\n  }\n  log(severity, msg) {\n    if (this.verboseLevel >= severity) {\n      const m = typeof msg === 'function' ? msg() : msg;\n      logger.log(`${this.time} [${severity}] ${m}`);\n    }\n  }\n}\nconst numArrayToHexArray = function numArrayToHexArray(numArray) {\n  const hexArray = [];\n  for (let j = 0; j < numArray.length; j++) {\n    hexArray.push(numArray[j].toString(16));\n  }\n  return hexArray;\n};\nclass PenState {\n  constructor() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  reset() {\n    this.foreground = 'white';\n    this.underline = false;\n    this.italics = false;\n    this.background = 'black';\n    this.flash = false;\n  }\n  setStyles(styles) {\n    const attribs = ['foreground', 'underline', 'italics', 'background', 'flash'];\n    for (let i = 0; i < attribs.length; i++) {\n      const style = attribs[i];\n      if (styles.hasOwnProperty(style)) {\n        this[style] = styles[style];\n      }\n    }\n  }\n  isDefault() {\n    return this.foreground === 'white' && !this.underline && !this.italics && this.background === 'black' && !this.flash;\n  }\n  equals(other) {\n    return this.foreground === other.foreground && this.underline === other.underline && this.italics === other.italics && this.background === other.background && this.flash === other.flash;\n  }\n  copy(newPenState) {\n    this.foreground = newPenState.foreground;\n    this.underline = newPenState.underline;\n    this.italics = newPenState.italics;\n    this.background = newPenState.background;\n    this.flash = newPenState.flash;\n  }\n  toString() {\n    return 'color=' + this.foreground + ', underline=' + this.underline + ', italics=' + this.italics + ', background=' + this.background + ', flash=' + this.flash;\n  }\n}\n\n/**\n * Unicode character with styling and background.\n * @constructor\n */\nclass StyledUnicodeChar {\n  constructor() {\n    this.uchar = ' ';\n    this.penState = new PenState();\n  }\n  reset() {\n    this.uchar = ' ';\n    this.penState.reset();\n  }\n  setChar(uchar, newPenState) {\n    this.uchar = uchar;\n    this.penState.copy(newPenState);\n  }\n  setPenState(newPenState) {\n    this.penState.copy(newPenState);\n  }\n  equals(other) {\n    return this.uchar === other.uchar && this.penState.equals(other.penState);\n  }\n  copy(newChar) {\n    this.uchar = newChar.uchar;\n    this.penState.copy(newChar.penState);\n  }\n  isEmpty() {\n    return this.uchar === ' ' && this.penState.isDefault();\n  }\n}\n\n/**\n * CEA-608 row consisting of NR_COLS instances of StyledUnicodeChar.\n * @constructor\n */\nclass Row {\n  constructor(logger) {\n    this.chars = [];\n    this.pos = 0;\n    this.currPenState = new PenState();\n    this.cueStartTime = null;\n    this.logger = void 0;\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars.push(new StyledUnicodeChar());\n    }\n    this.logger = logger;\n  }\n  equals(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].equals(other.chars[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_COLS; i++) {\n      this.chars[i].copy(other.chars[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      if (!this.chars[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n\n  /**\n   *  Set the cursor to a valid column.\n   */\n  setCursor(absPos) {\n    if (this.pos !== absPos) {\n      this.pos = absPos;\n    }\n    if (this.pos < 0) {\n      this.logger.log(3, 'Negative cursor position ' + this.pos);\n      this.pos = 0;\n    } else if (this.pos > NR_COLS) {\n      this.logger.log(3, 'Too large cursor position ' + this.pos);\n      this.pos = NR_COLS;\n    }\n  }\n\n  /**\n   * Move the cursor relative to current position.\n   */\n  moveCursor(relPos) {\n    const newPos = this.pos + relPos;\n    if (relPos > 1) {\n      for (let i = this.pos + 1; i < newPos + 1; i++) {\n        this.chars[i].setPenState(this.currPenState);\n      }\n    }\n    this.setCursor(newPos);\n  }\n\n  /**\n   * Backspace, move one step back and clear character.\n   */\n  backSpace() {\n    this.moveCursor(-1);\n    this.chars[this.pos].setChar(' ', this.currPenState);\n  }\n  insertChar(byte) {\n    if (byte >= 0x90) {\n      // Extended char\n      this.backSpace();\n    }\n    const char = getCharForByte(byte);\n    if (this.pos >= NR_COLS) {\n      this.logger.log(0, () => 'Cannot insert ' + byte.toString(16) + ' (' + char + ') at position ' + this.pos + '. Skipping it!');\n      return;\n    }\n    this.chars[this.pos].setChar(char, this.currPenState);\n    this.moveCursor(1);\n  }\n  clearFromPos(startPos) {\n    let i;\n    for (i = startPos; i < NR_COLS; i++) {\n      this.chars[i].reset();\n    }\n  }\n  clear() {\n    this.clearFromPos(0);\n    this.pos = 0;\n    this.currPenState.reset();\n  }\n  clearToEndOfRow() {\n    this.clearFromPos(this.pos);\n  }\n  getTextString() {\n    const chars = [];\n    let empty = true;\n    for (let i = 0; i < NR_COLS; i++) {\n      const char = this.chars[i].uchar;\n      if (char !== ' ') {\n        empty = false;\n      }\n      chars.push(char);\n    }\n    if (empty) {\n      return '';\n    } else {\n      return chars.join('');\n    }\n  }\n  setPenStyles(styles) {\n    this.currPenState.setStyles(styles);\n    const currChar = this.chars[this.pos];\n    currChar.setPenState(this.currPenState);\n  }\n}\n\n/**\n * Keep a CEA-608 screen of 32x15 styled characters\n * @constructor\n */\nclass CaptionScreen {\n  constructor(logger) {\n    this.rows = [];\n    this.currRow = NR_ROWS - 1;\n    this.nrRollUpRows = null;\n    this.lastOutputScreen = null;\n    this.logger = void 0;\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows.push(new Row(logger));\n    }\n    this.logger = logger;\n  }\n  reset() {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].clear();\n    }\n    this.currRow = NR_ROWS - 1;\n  }\n  equals(other) {\n    let equal = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].equals(other.rows[i])) {\n        equal = false;\n        break;\n      }\n    }\n    return equal;\n  }\n  copy(other) {\n    for (let i = 0; i < NR_ROWS; i++) {\n      this.rows[i].copy(other.rows[i]);\n    }\n  }\n  isEmpty() {\n    let empty = true;\n    for (let i = 0; i < NR_ROWS; i++) {\n      if (!this.rows[i].isEmpty()) {\n        empty = false;\n        break;\n      }\n    }\n    return empty;\n  }\n  backSpace() {\n    const row = this.rows[this.currRow];\n    row.backSpace();\n  }\n  clearToEndOfRow() {\n    const row = this.rows[this.currRow];\n    row.clearToEndOfRow();\n  }\n\n  /**\n   * Insert a character (without styling) in the current row.\n   */\n  insertChar(char) {\n    const row = this.rows[this.currRow];\n    row.insertChar(char);\n  }\n  setPen(styles) {\n    const row = this.rows[this.currRow];\n    row.setPenStyles(styles);\n  }\n  moveCursor(relPos) {\n    const row = this.rows[this.currRow];\n    row.moveCursor(relPos);\n  }\n  setCursor(absPos) {\n    this.logger.log(2, 'setCursor: ' + absPos);\n    const row = this.rows[this.currRow];\n    row.setCursor(absPos);\n  }\n  setPAC(pacData) {\n    this.logger.log(2, () => 'pacData = ' + JSON.stringify(pacData));\n    let newRow = pacData.row - 1;\n    if (this.nrRollUpRows && newRow < this.nrRollUpRows - 1) {\n      newRow = this.nrRollUpRows - 1;\n    }\n\n    // Make sure this only affects Roll-up Captions by checking this.nrRollUpRows\n    if (this.nrRollUpRows && this.currRow !== newRow) {\n      // clear all rows first\n      for (let i = 0; i < NR_ROWS; i++) {\n        this.rows[i].clear();\n      }\n\n      // Copy this.nrRollUpRows rows from lastOutputScreen and place it in the newRow location\n      // topRowIndex - the start of rows to copy (inclusive index)\n      const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n      // We only copy if the last position was already shown.\n      // We use the cueStartTime value to check this.\n      const lastOutputScreen = this.lastOutputScreen;\n      if (lastOutputScreen) {\n        const prevLineTime = lastOutputScreen.rows[topRowIndex].cueStartTime;\n        const time = this.logger.time;\n        if (prevLineTime !== null && time !== null && prevLineTime < time) {\n          for (let i = 0; i < this.nrRollUpRows; i++) {\n            this.rows[newRow - this.nrRollUpRows + i + 1].copy(lastOutputScreen.rows[topRowIndex + i]);\n          }\n        }\n      }\n    }\n    this.currRow = newRow;\n    const row = this.rows[this.currRow];\n    if (pacData.indent !== null) {\n      const indent = pacData.indent;\n      const prevPos = Math.max(indent - 1, 0);\n      row.setCursor(pacData.indent);\n      pacData.color = row.chars[prevPos].penState.foreground;\n    }\n    const styles = {\n      foreground: pacData.color,\n      underline: pacData.underline,\n      italics: pacData.italics,\n      background: 'black',\n      flash: false\n    };\n    this.setPen(styles);\n  }\n\n  /**\n   * Set background/extra foreground, but first do back_space, and then insert space (backwards compatibility).\n   */\n  setBkgData(bkgData) {\n    this.logger.log(2, () => 'bkgData = ' + JSON.stringify(bkgData));\n    this.backSpace();\n    this.setPen(bkgData);\n    this.insertChar(0x20); // Space\n  }\n  setRollUpRows(nrRows) {\n    this.nrRollUpRows = nrRows;\n  }\n  rollUp() {\n    if (this.nrRollUpRows === null) {\n      this.logger.log(3, 'roll_up but nrRollUpRows not set yet');\n      return; // Not properly setup\n    }\n    this.logger.log(1, () => this.getDisplayText());\n    const topRowIndex = this.currRow + 1 - this.nrRollUpRows;\n    const topRow = this.rows.splice(topRowIndex, 1)[0];\n    topRow.clear();\n    this.rows.splice(this.currRow, 0, topRow);\n    this.logger.log(2, 'Rolling up');\n    // this.logger.log(VerboseLevel.TEXT, this.get_display_text())\n  }\n\n  /**\n   * Get all non-empty rows with as unicode text.\n   */\n  getDisplayText(asOneRow) {\n    asOneRow = asOneRow || false;\n    const displayText = [];\n    let text = '';\n    let rowNr = -1;\n    for (let i = 0; i < NR_ROWS; i++) {\n      const rowText = this.rows[i].getTextString();\n      if (rowText) {\n        rowNr = i + 1;\n        if (asOneRow) {\n          displayText.push('Row ' + rowNr + \": '\" + rowText + \"'\");\n        } else {\n          displayText.push(rowText.trim());\n        }\n      }\n    }\n    if (displayText.length > 0) {\n      if (asOneRow) {\n        text = '[' + displayText.join(' | ') + ']';\n      } else {\n        text = displayText.join('\\n');\n      }\n    }\n    return text;\n  }\n  getTextAndFormat() {\n    return this.rows;\n  }\n}\n\n// var modes = ['MODE_ROLL-UP', 'MODE_POP-ON', 'MODE_PAINT-ON', 'MODE_TEXT'];\n\nclass Cea608Channel {\n  constructor(channelNumber, outputFilter, logger) {\n    this.chNr = void 0;\n    this.outputFilter = void 0;\n    this.mode = void 0;\n    this.verbose = void 0;\n    this.displayedMemory = void 0;\n    this.nonDisplayedMemory = void 0;\n    this.lastOutputScreen = void 0;\n    this.currRollUpRow = void 0;\n    this.writeScreen = void 0;\n    this.cueStartTime = void 0;\n    this.logger = void 0;\n    this.chNr = channelNumber;\n    this.outputFilter = outputFilter;\n    this.mode = null;\n    this.verbose = 0;\n    this.displayedMemory = new CaptionScreen(logger);\n    this.nonDisplayedMemory = new CaptionScreen(logger);\n    this.lastOutputScreen = new CaptionScreen(logger);\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null; // Keeps track of where a cue started.\n    this.logger = logger;\n  }\n  reset() {\n    this.mode = null;\n    this.displayedMemory.reset();\n    this.nonDisplayedMemory.reset();\n    this.lastOutputScreen.reset();\n    this.outputFilter.reset();\n    this.currRollUpRow = this.displayedMemory.rows[NR_ROWS - 1];\n    this.writeScreen = this.displayedMemory;\n    this.mode = null;\n    this.cueStartTime = null;\n  }\n  getHandler() {\n    return this.outputFilter;\n  }\n  setHandler(newHandler) {\n    this.outputFilter = newHandler;\n  }\n  setPAC(pacData) {\n    this.writeScreen.setPAC(pacData);\n  }\n  setBkgData(bkgData) {\n    this.writeScreen.setBkgData(bkgData);\n  }\n  setMode(newMode) {\n    if (newMode === this.mode) {\n      return;\n    }\n    this.mode = newMode;\n    this.logger.log(2, () => 'MODE=' + newMode);\n    if (this.mode === 'MODE_POP-ON') {\n      this.writeScreen = this.nonDisplayedMemory;\n    } else {\n      this.writeScreen = this.displayedMemory;\n      this.writeScreen.reset();\n    }\n    if (this.mode !== 'MODE_ROLL-UP') {\n      this.displayedMemory.nrRollUpRows = null;\n      this.nonDisplayedMemory.nrRollUpRows = null;\n    }\n    this.mode = newMode;\n  }\n  insertChars(chars) {\n    for (let i = 0; i < chars.length; i++) {\n      this.writeScreen.insertChar(chars[i]);\n    }\n    const screen = this.writeScreen === this.displayedMemory ? 'DISP' : 'NON_DISP';\n    this.logger.log(2, () => screen + ': ' + this.writeScreen.getDisplayText(true));\n    if (this.mode === 'MODE_PAINT-ON' || this.mode === 'MODE_ROLL-UP') {\n      this.logger.log(1, () => 'DISPLAYED: ' + this.displayedMemory.getDisplayText(true));\n      this.outputDataUpdate();\n    }\n  }\n  ccRCL() {\n    // Resume Caption Loading (switch mode to Pop On)\n    this.logger.log(2, 'RCL - Resume Caption Loading');\n    this.setMode('MODE_POP-ON');\n  }\n  ccBS() {\n    // BackSpace\n    this.logger.log(2, 'BS - BackSpace');\n    if (this.mode === 'MODE_TEXT') {\n      return;\n    }\n    this.writeScreen.backSpace();\n    if (this.writeScreen === this.displayedMemory) {\n      this.outputDataUpdate();\n    }\n  }\n  ccAOF() {\n    // Reserved (formerly Alarm Off)\n  }\n  ccAON() {\n    // Reserved (formerly Alarm On)\n  }\n  ccDER() {\n    // Delete to End of Row\n    this.logger.log(2, 'DER- Delete to End of Row');\n    this.writeScreen.clearToEndOfRow();\n    this.outputDataUpdate();\n  }\n  ccRU(nrRows) {\n    // Roll-Up Captions-2,3,or 4 Rows\n    this.logger.log(2, 'RU(' + nrRows + ') - Roll Up');\n    this.writeScreen = this.displayedMemory;\n    this.setMode('MODE_ROLL-UP');\n    this.writeScreen.setRollUpRows(nrRows);\n  }\n  ccFON() {\n    // Flash On\n    this.logger.log(2, 'FON - Flash On');\n    this.writeScreen.setPen({\n      flash: true\n    });\n  }\n  ccRDC() {\n    // Resume Direct Captioning (switch mode to PaintOn)\n    this.logger.log(2, 'RDC - Resume Direct Captioning');\n    this.setMode('MODE_PAINT-ON');\n  }\n  ccTR() {\n    // Text Restart in text mode (not supported, however)\n    this.logger.log(2, 'TR');\n    this.setMode('MODE_TEXT');\n  }\n  ccRTD() {\n    // Resume Text Display in Text mode (not supported, however)\n    this.logger.log(2, 'RTD');\n    this.setMode('MODE_TEXT');\n  }\n  ccEDM() {\n    // Erase Displayed Memory\n    this.logger.log(2, 'EDM - Erase Displayed Memory');\n    this.displayedMemory.reset();\n    this.outputDataUpdate(true);\n  }\n  ccCR() {\n    // Carriage Return\n    this.logger.log(2, 'CR - Carriage Return');\n    this.writeScreen.rollUp();\n    this.outputDataUpdate(true);\n  }\n  ccENM() {\n    // Erase Non-Displayed Memory\n    this.logger.log(2, 'ENM - Erase Non-displayed Memory');\n    this.nonDisplayedMemory.reset();\n  }\n  ccEOC() {\n    // End of Caption (Flip Memories)\n    this.logger.log(2, 'EOC - End Of Caption');\n    if (this.mode === 'MODE_POP-ON') {\n      const tmp = this.displayedMemory;\n      this.displayedMemory = this.nonDisplayedMemory;\n      this.nonDisplayedMemory = tmp;\n      this.writeScreen = this.nonDisplayedMemory;\n      this.logger.log(1, () => 'DISP: ' + this.displayedMemory.getDisplayText());\n    }\n    this.outputDataUpdate(true);\n  }\n  ccTO(nrCols) {\n    // Tab Offset 1,2, or 3 columns\n    this.logger.log(2, 'TO(' + nrCols + ') - Tab Offset');\n    this.writeScreen.moveCursor(nrCols);\n  }\n  ccMIDROW(secondByte) {\n    // Parse MIDROW command\n    const styles = {\n      flash: false\n    };\n    styles.underline = secondByte % 2 === 1;\n    styles.italics = secondByte >= 0x2e;\n    if (!styles.italics) {\n      const colorIndex = Math.floor(secondByte / 2) - 0x10;\n      const colors = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta'];\n      styles.foreground = colors[colorIndex];\n    } else {\n      styles.foreground = 'white';\n    }\n    this.logger.log(2, 'MIDROW: ' + JSON.stringify(styles));\n    this.writeScreen.setPen(styles);\n  }\n  outputDataUpdate(dispatch = false) {\n    const time = this.logger.time;\n    if (time === null) {\n      return;\n    }\n    if (this.outputFilter) {\n      if (this.cueStartTime === null && !this.displayedMemory.isEmpty()) {\n        // Start of a new cue\n        this.cueStartTime = time;\n      } else {\n        if (!this.displayedMemory.equals(this.lastOutputScreen)) {\n          this.outputFilter.newCue(this.cueStartTime, time, this.lastOutputScreen);\n          if (dispatch && this.outputFilter.dispatchCue) {\n            this.outputFilter.dispatchCue();\n          }\n          this.cueStartTime = this.displayedMemory.isEmpty() ? null : time;\n        }\n      }\n      this.lastOutputScreen.copy(this.displayedMemory);\n    }\n  }\n  cueSplitAtTime(t) {\n    if (this.outputFilter) {\n      if (!this.displayedMemory.isEmpty()) {\n        if (this.outputFilter.newCue) {\n          this.outputFilter.newCue(this.cueStartTime, t, this.displayedMemory);\n        }\n        this.cueStartTime = t;\n      }\n    }\n  }\n}\n\n// Will be 1 or 2 when parsing captions\n\nclass Cea608Parser {\n  constructor(field, out1, out2) {\n    this.channels = void 0;\n    this.currentChannel = 0;\n    this.cmdHistory = createCmdHistory();\n    this.logger = void 0;\n    const logger = this.logger = new CaptionsLogger();\n    this.channels = [null, new Cea608Channel(field, out1, logger), new Cea608Channel(field + 1, out2, logger)];\n  }\n  getHandler(channel) {\n    return this.channels[channel].getHandler();\n  }\n  setHandler(channel, newHandler) {\n    this.channels[channel].setHandler(newHandler);\n  }\n\n  /**\n   * Add data for time t in forms of list of bytes (unsigned ints). The bytes are treated as pairs.\n   */\n  addData(time, byteList) {\n    this.logger.time = time;\n    for (let i = 0; i < byteList.length; i += 2) {\n      const a = byteList[i] & 0x7f;\n      const b = byteList[i + 1] & 0x7f;\n      let cmdFound = false;\n      let charsFound = null;\n      if (a === 0 && b === 0) {\n        continue;\n      } else {\n        this.logger.log(3, () => '[' + numArrayToHexArray([byteList[i], byteList[i + 1]]) + '] -> (' + numArrayToHexArray([a, b]) + ')');\n      }\n      const cmdHistory = this.cmdHistory;\n      const isControlCode = a >= 0x10 && a <= 0x1f;\n      if (isControlCode) {\n        // Skip redundant control codes\n        if (hasCmdRepeated(a, b, cmdHistory)) {\n          setLastCmd(null, null, cmdHistory);\n          this.logger.log(3, () => 'Repeated command (' + numArrayToHexArray([a, b]) + ') is dropped');\n          continue;\n        }\n        setLastCmd(a, b, this.cmdHistory);\n        cmdFound = this.parseCmd(a, b);\n        if (!cmdFound) {\n          cmdFound = this.parseMidrow(a, b);\n        }\n        if (!cmdFound) {\n          cmdFound = this.parsePAC(a, b);\n        }\n        if (!cmdFound) {\n          cmdFound = this.parseBackgroundAttributes(a, b);\n        }\n      } else {\n        setLastCmd(null, null, cmdHistory);\n      }\n      if (!cmdFound) {\n        charsFound = this.parseChars(a, b);\n        if (charsFound) {\n          const currChNr = this.currentChannel;\n          if (currChNr && currChNr > 0) {\n            const channel = this.channels[currChNr];\n            channel.insertChars(charsFound);\n          } else {\n            this.logger.log(2, 'No channel found yet. TEXT-MODE?');\n          }\n        }\n      }\n      if (!cmdFound && !charsFound) {\n        this.logger.log(2, () => \"Couldn't parse cleaned data \" + numArrayToHexArray([a, b]) + ' orig: ' + numArrayToHexArray([byteList[i], byteList[i + 1]]));\n      }\n    }\n  }\n\n  /**\n   * Parse Command.\n   * @returns True if a command was found\n   */\n  parseCmd(a, b) {\n    const cond1 = (a === 0x14 || a === 0x1c || a === 0x15 || a === 0x1d) && b >= 0x20 && b <= 0x2f;\n    const cond2 = (a === 0x17 || a === 0x1f) && b >= 0x21 && b <= 0x23;\n    if (!(cond1 || cond2)) {\n      return false;\n    }\n    const chNr = a === 0x14 || a === 0x15 || a === 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    if (a === 0x14 || a === 0x15 || a === 0x1c || a === 0x1d) {\n      if (b === 0x20) {\n        channel.ccRCL();\n      } else if (b === 0x21) {\n        channel.ccBS();\n      } else if (b === 0x22) {\n        channel.ccAOF();\n      } else if (b === 0x23) {\n        channel.ccAON();\n      } else if (b === 0x24) {\n        channel.ccDER();\n      } else if (b === 0x25) {\n        channel.ccRU(2);\n      } else if (b === 0x26) {\n        channel.ccRU(3);\n      } else if (b === 0x27) {\n        channel.ccRU(4);\n      } else if (b === 0x28) {\n        channel.ccFON();\n      } else if (b === 0x29) {\n        channel.ccRDC();\n      } else if (b === 0x2a) {\n        channel.ccTR();\n      } else if (b === 0x2b) {\n        channel.ccRTD();\n      } else if (b === 0x2c) {\n        channel.ccEDM();\n      } else if (b === 0x2d) {\n        channel.ccCR();\n      } else if (b === 0x2e) {\n        channel.ccENM();\n      } else if (b === 0x2f) {\n        channel.ccEOC();\n      }\n    } else {\n      // a == 0x17 || a == 0x1F\n      channel.ccTO(b - 0x20);\n    }\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Parse midrow styling command\n   */\n  parseMidrow(a, b) {\n    let chNr = 0;\n    if ((a === 0x11 || a === 0x19) && b >= 0x20 && b <= 0x2f) {\n      if (a === 0x11) {\n        chNr = 1;\n      } else {\n        chNr = 2;\n      }\n      if (chNr !== this.currentChannel) {\n        this.logger.log(0, 'Mismatch channel in midrow parsing');\n        return false;\n      }\n      const channel = this.channels[chNr];\n      if (!channel) {\n        return false;\n      }\n      channel.ccMIDROW(b);\n      this.logger.log(3, () => 'MIDROW (' + numArrayToHexArray([a, b]) + ')');\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Parse Preable Access Codes (Table 53).\n   * @returns {Boolean} Tells if PAC found\n   */\n  parsePAC(a, b) {\n    let row;\n    const case1 = (a >= 0x11 && a <= 0x17 || a >= 0x19 && a <= 0x1f) && b >= 0x40 && b <= 0x7f;\n    const case2 = (a === 0x10 || a === 0x18) && b >= 0x40 && b <= 0x5f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    if (b >= 0x40 && b <= 0x5f) {\n      row = chNr === 1 ? rowsLowCh1[a] : rowsLowCh2[a];\n    } else {\n      // 0x60 <= b <= 0x7F\n      row = chNr === 1 ? rowsHighCh1[a] : rowsHighCh2[a];\n    }\n    const channel = this.channels[chNr];\n    if (!channel) {\n      return false;\n    }\n    channel.setPAC(this.interpretPAC(row, b));\n    this.currentChannel = chNr;\n    return true;\n  }\n\n  /**\n   * Interpret the second byte of the pac, and return the information.\n   * @returns pacData with style parameters\n   */\n  interpretPAC(row, byte) {\n    let pacIndex;\n    const pacData = {\n      color: null,\n      italics: false,\n      indent: null,\n      underline: false,\n      row: row\n    };\n    if (byte > 0x5f) {\n      pacIndex = byte - 0x60;\n    } else {\n      pacIndex = byte - 0x40;\n    }\n    pacData.underline = (pacIndex & 1) === 1;\n    if (pacIndex <= 0xd) {\n      pacData.color = ['white', 'green', 'blue', 'cyan', 'red', 'yellow', 'magenta', 'white'][Math.floor(pacIndex / 2)];\n    } else if (pacIndex <= 0xf) {\n      pacData.italics = true;\n      pacData.color = 'white';\n    } else {\n      pacData.indent = Math.floor((pacIndex - 0x10) / 2) * 4;\n    }\n    return pacData; // Note that row has zero offset. The spec uses 1.\n  }\n\n  /**\n   * Parse characters.\n   * @returns An array with 1 to 2 codes corresponding to chars, if found. null otherwise.\n   */\n  parseChars(a, b) {\n    let channelNr;\n    let charCodes = null;\n    let charCode1 = null;\n    if (a >= 0x19) {\n      channelNr = 2;\n      charCode1 = a - 8;\n    } else {\n      channelNr = 1;\n      charCode1 = a;\n    }\n    if (charCode1 >= 0x11 && charCode1 <= 0x13) {\n      // Special character\n      let oneCode;\n      if (charCode1 === 0x11) {\n        oneCode = b + 0x50;\n      } else if (charCode1 === 0x12) {\n        oneCode = b + 0x70;\n      } else {\n        oneCode = b + 0x90;\n      }\n      this.logger.log(2, () => \"Special char '\" + getCharForByte(oneCode) + \"' in channel \" + channelNr);\n      charCodes = [oneCode];\n    } else if (a >= 0x20 && a <= 0x7f) {\n      charCodes = b === 0 ? [a] : [a, b];\n    }\n    if (charCodes) {\n      this.logger.log(3, () => 'Char codes =  ' + numArrayToHexArray(charCodes).join(','));\n    }\n    return charCodes;\n  }\n\n  /**\n   * Parse extended background attributes as well as new foreground color black.\n   * @returns True if background attributes are found\n   */\n  parseBackgroundAttributes(a, b) {\n    const case1 = (a === 0x10 || a === 0x18) && b >= 0x20 && b <= 0x2f;\n    const case2 = (a === 0x17 || a === 0x1f) && b >= 0x2d && b <= 0x2f;\n    if (!(case1 || case2)) {\n      return false;\n    }\n    let index;\n    const bkgData = {};\n    if (a === 0x10 || a === 0x18) {\n      index = Math.floor((b - 0x20) / 2);\n      bkgData.background = backgroundColors[index];\n      if (b % 2 === 1) {\n        bkgData.background = bkgData.background + '_semi';\n      }\n    } else if (b === 0x2d) {\n      bkgData.background = 'transparent';\n    } else {\n      bkgData.foreground = 'black';\n      if (b === 0x2f) {\n        bkgData.underline = true;\n      }\n    }\n    const chNr = a <= 0x17 ? 1 : 2;\n    const channel = this.channels[chNr];\n    channel.setBkgData(bkgData);\n    return true;\n  }\n\n  /**\n   * Reset state of parser and its channels.\n   */\n  reset() {\n    for (let i = 0; i < Object.keys(this.channels).length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.reset();\n      }\n    }\n    setLastCmd(null, null, this.cmdHistory);\n  }\n\n  /**\n   * Trigger the generation of a cue, and the start of a new one if displayScreens are not empty.\n   */\n  cueSplitAtTime(t) {\n    for (let i = 0; i < this.channels.length; i++) {\n      const channel = this.channels[i];\n      if (channel) {\n        channel.cueSplitAtTime(t);\n      }\n    }\n  }\n}\nfunction setLastCmd(a, b, cmdHistory) {\n  cmdHistory.a = a;\n  cmdHistory.b = b;\n}\nfunction hasCmdRepeated(a, b, cmdHistory) {\n  return cmdHistory.a === a && cmdHistory.b === b;\n}\nfunction createCmdHistory() {\n  return {\n    a: null,\n    b: null\n  };\n}\n\nclass OutputFilter {\n  constructor(timelineController, trackName) {\n    this.timelineController = void 0;\n    this.cueRanges = [];\n    this.trackName = void 0;\n    this.startTime = null;\n    this.endTime = null;\n    this.screen = null;\n    this.timelineController = timelineController;\n    this.trackName = trackName;\n  }\n  dispatchCue() {\n    if (this.startTime === null) {\n      return;\n    }\n    this.timelineController.addCues(this.trackName, this.startTime, this.endTime, this.screen, this.cueRanges);\n    this.startTime = null;\n  }\n  newCue(startTime, endTime, screen) {\n    if (this.startTime === null || this.startTime > startTime) {\n      this.startTime = startTime;\n    }\n    this.endTime = endTime;\n    this.screen = screen;\n    this.timelineController.createCaptionsTrack(this.trackName);\n  }\n  reset() {\n    this.cueRanges = [];\n    this.startTime = null;\n  }\n}\n\n/**\n * Copyright 2013 vtt.js Contributors\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar VTTCue = (function () {\n  if (optionalSelf != null && optionalSelf.VTTCue) {\n    return self.VTTCue;\n  }\n  const AllowedDirections = ['', 'lr', 'rl'];\n  const AllowedAlignments = ['start', 'middle', 'end', 'left', 'right'];\n  function isAllowedValue(allowed, value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n    // necessary for assuring the generic conforms to the Array interface\n    if (!Array.isArray(allowed)) {\n      return false;\n    }\n    // reset the type so that the next narrowing works well\n    const lcValue = value.toLowerCase();\n    // use the allow list to narrow the type to a specific subset of strings\n    if (~allowed.indexOf(lcValue)) {\n      return lcValue;\n    }\n    return false;\n  }\n  function findDirectionSetting(value) {\n    return isAllowedValue(AllowedDirections, value);\n  }\n  function findAlignSetting(value) {\n    return isAllowedValue(AllowedAlignments, value);\n  }\n  function extend(obj, ...rest) {\n    let i = 1;\n    for (; i < arguments.length; i++) {\n      const cobj = arguments[i];\n      for (const p in cobj) {\n        obj[p] = cobj[p];\n      }\n    }\n    return obj;\n  }\n  function VTTCue(startTime, endTime, text) {\n    const cue = this;\n    const baseObj = {\n      enumerable: true\n    };\n    /**\n     * Shim implementation specific properties. These properties are not in\n     * the spec.\n     */\n\n    // Lets us know when the VTTCue's data has changed in such a way that we need\n    // to recompute its display state. This lets us compute its display state\n    // lazily.\n    cue.hasBeenReset = false;\n\n    /**\n     * VTTCue and TextTrackCue properties\n     * http://dev.w3.org/html5/webvtt/#vttcue-interface\n     */\n\n    let _id = '';\n    let _pauseOnExit = false;\n    let _startTime = startTime;\n    let _endTime = endTime;\n    let _text = text;\n    let _region = null;\n    let _vertical = '';\n    let _snapToLines = true;\n    let _line = 'auto';\n    let _lineAlign = 'start';\n    let _position = 50;\n    let _positionAlign = 'middle';\n    let _size = 50;\n    let _align = 'middle';\n    Object.defineProperty(cue, 'id', extend({}, baseObj, {\n      get: function () {\n        return _id;\n      },\n      set: function (value) {\n        _id = '' + value;\n      }\n    }));\n    Object.defineProperty(cue, 'pauseOnExit', extend({}, baseObj, {\n      get: function () {\n        return _pauseOnExit;\n      },\n      set: function (value) {\n        _pauseOnExit = !!value;\n      }\n    }));\n    Object.defineProperty(cue, 'startTime', extend({}, baseObj, {\n      get: function () {\n        return _startTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('Start time must be set to a number.');\n        }\n        _startTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'endTime', extend({}, baseObj, {\n      get: function () {\n        return _endTime;\n      },\n      set: function (value) {\n        if (typeof value !== 'number') {\n          throw new TypeError('End time must be set to a number.');\n        }\n        _endTime = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'text', extend({}, baseObj, {\n      get: function () {\n        return _text;\n      },\n      set: function (value) {\n        _text = '' + value;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    // todo: implement VTTRegion polyfill?\n    Object.defineProperty(cue, 'region', extend({}, baseObj, {\n      get: function () {\n        return _region;\n      },\n      set: function (value) {\n        _region = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'vertical', extend({}, baseObj, {\n      get: function () {\n        return _vertical;\n      },\n      set: function (value) {\n        const setting = findDirectionSetting(value);\n        // Have to check for false because the setting an be an empty string.\n        if (setting === false) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _vertical = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'snapToLines', extend({}, baseObj, {\n      get: function () {\n        return _snapToLines;\n      },\n      set: function (value) {\n        _snapToLines = !!value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'line', extend({}, baseObj, {\n      get: function () {\n        return _line;\n      },\n      set: function (value) {\n        if (typeof value !== 'number' && value !== 'auto') {\n          throw new SyntaxError('An invalid number or illegal string was specified.');\n        }\n        _line = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'lineAlign', extend({}, baseObj, {\n      get: function () {\n        return _lineAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _lineAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'position', extend({}, baseObj, {\n      get: function () {\n        return _position;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Position must be between 0 and 100.');\n        }\n        _position = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'positionAlign', extend({}, baseObj, {\n      get: function () {\n        return _positionAlign;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _positionAlign = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'size', extend({}, baseObj, {\n      get: function () {\n        return _size;\n      },\n      set: function (value) {\n        if (value < 0 || value > 100) {\n          throw new Error('Size must be between 0 and 100.');\n        }\n        _size = value;\n        this.hasBeenReset = true;\n      }\n    }));\n    Object.defineProperty(cue, 'align', extend({}, baseObj, {\n      get: function () {\n        return _align;\n      },\n      set: function (value) {\n        const setting = findAlignSetting(value);\n        if (!setting) {\n          throw new SyntaxError('An invalid or illegal string was specified.');\n        }\n        _align = setting;\n        this.hasBeenReset = true;\n      }\n    }));\n\n    /**\n     * Other <track> spec defined properties\n     */\n\n    // http://www.whatwg.org/specs/web-apps/current-work/multipage/the-video-element.html#text-track-cue-display-state\n    cue.displayState = undefined;\n  }\n\n  /**\n   * VTTCue methods\n   */\n\n  VTTCue.prototype.getCueAsHTML = function () {\n    // Assume WebVTT.convertCueToDOMTree is on the global.\n    const WebVTT = self.WebVTT;\n    return WebVTT.convertCueToDOMTree(self, this.text);\n  };\n  // this is a polyfill hack\n  return VTTCue;\n})();\n\n/*\n * Source: https://github.com/mozilla/vtt.js/blob/master/dist/vtt.js\n */\n\nclass StringDecoder {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  decode(data, options) {\n    if (!data) {\n      return '';\n    }\n    if (typeof data !== 'string') {\n      throw new Error('Error - expected string data.');\n    }\n    return decodeURIComponent(encodeURIComponent(data));\n  }\n}\n\n// Try to parse input as a time stamp.\nfunction parseTimeStamp(input) {\n  function computeSeconds(h, m, s, f) {\n    return (h | 0) * 3600 + (m | 0) * 60 + (s | 0) + parseFloat(f || 0);\n  }\n  const m = input.match(/^(?:(\\d+):)?(\\d{2}):(\\d{2})(\\.\\d+)?/);\n  if (!m) {\n    return null;\n  }\n  if (parseFloat(m[2]) > 59) {\n    // Timestamp takes the form of [hours]:[minutes].[milliseconds]\n    // First position is hours as it's over 59.\n    return computeSeconds(m[2], m[3], 0, m[4]);\n  }\n  // Timestamp takes the form of [hours (optional)]:[minutes]:[seconds].[milliseconds]\n  return computeSeconds(m[1], m[2], m[3], m[4]);\n}\n\n// A settings object holds key/value pairs and will ignore anything but the first\n// assignment to a specific key.\nclass Settings {\n  constructor() {\n    this.values = Object.create(null);\n  }\n  // Only accept the first assignment to any key.\n  set(k, v) {\n    if (!this.get(k) && v !== '') {\n      this.values[k] = v;\n    }\n  }\n  // Return the value for a key, or a default value.\n  // If 'defaultKey' is passed then 'dflt' is assumed to be an object with\n  // a number of possible default values as properties where 'defaultKey' is\n  // the key of the property that will be chosen; otherwise it's assumed to be\n  // a single value.\n  get(k, dflt, defaultKey) {\n    if (defaultKey) {\n      return this.has(k) ? this.values[k] : dflt[defaultKey];\n    }\n    return this.has(k) ? this.values[k] : dflt;\n  }\n  // Check whether we have a value for a key.\n  has(k) {\n    return k in this.values;\n  }\n  // Accept a setting if its one of the given alternatives.\n  alt(k, v, a) {\n    for (let n = 0; n < a.length; ++n) {\n      if (v === a[n]) {\n        this.set(k, v);\n        break;\n      }\n    }\n  }\n  // Accept a setting if its a valid (signed) integer.\n  integer(k, v) {\n    if (/^-?\\d+$/.test(v)) {\n      // integer\n      this.set(k, parseInt(v, 10));\n    }\n  }\n  // Accept a setting if its a valid percentage.\n  percent(k, v) {\n    if (/^([\\d]{1,3})(\\.[\\d]*)?%$/.test(v)) {\n      const percent = parseFloat(v);\n      if (percent >= 0 && percent <= 100) {\n        this.set(k, percent);\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// Helper function to parse input into groups separated by 'groupDelim', and\n// interpret each group as a key/value pair separated by 'keyValueDelim'.\nfunction parseOptions(input, callback, keyValueDelim, groupDelim) {\n  const groups = groupDelim ? input.split(groupDelim) : [input];\n  for (const i in groups) {\n    if (typeof groups[i] !== 'string') {\n      continue;\n    }\n    const kv = groups[i].split(keyValueDelim);\n    if (kv.length !== 2) {\n      continue;\n    }\n    const k = kv[0];\n    const v = kv[1];\n    callback(k, v);\n  }\n}\nconst defaults = new VTTCue(0, 0, '');\n// 'middle' was changed to 'center' in the spec: https://github.com/w3c/webvtt/pull/244\n//  Safari doesn't yet support this change, but FF and Chrome do.\nconst center = defaults.align === 'middle' ? 'middle' : 'center';\nfunction parseCue(input, cue, regionList) {\n  // Remember the original input if we need to throw an error.\n  const oInput = input;\n  // 4.1 WebVTT timestamp\n  function consumeTimeStamp() {\n    const ts = parseTimeStamp(input);\n    if (ts === null) {\n      throw new Error('Malformed timestamp: ' + oInput);\n    }\n\n    // Remove time stamp from input.\n    input = input.replace(/^[^\\sa-zA-Z-]+/, '');\n    return ts;\n  }\n\n  // 4.4.2 WebVTT cue settings\n  function consumeCueSettings(input, cue) {\n    const settings = new Settings();\n    parseOptions(input, function (k, v) {\n      let vals;\n      switch (k) {\n        case 'region':\n          // Find the last region we parsed with the same region id.\n          for (let i = regionList.length - 1; i >= 0; i--) {\n            if (regionList[i].id === v) {\n              settings.set(k, regionList[i].region);\n              break;\n            }\n          }\n          break;\n        case 'vertical':\n          settings.alt(k, v, ['rl', 'lr']);\n          break;\n        case 'line':\n          vals = v.split(',');\n          settings.integer(k, vals[0]);\n          if (settings.percent(k, vals[0])) {\n            settings.set('snapToLines', false);\n          }\n          settings.alt(k, vals[0], ['auto']);\n          if (vals.length === 2) {\n            settings.alt('lineAlign', vals[1], ['start', center, 'end']);\n          }\n          break;\n        case 'position':\n          vals = v.split(',');\n          settings.percent(k, vals[0]);\n          if (vals.length === 2) {\n            settings.alt('positionAlign', vals[1], ['start', center, 'end', 'line-left', 'line-right', 'auto']);\n          }\n          break;\n        case 'size':\n          settings.percent(k, v);\n          break;\n        case 'align':\n          settings.alt(k, v, ['start', center, 'end', 'left', 'right']);\n          break;\n      }\n    }, /:/, /\\s/);\n\n    // Apply default values for any missing fields.\n    cue.region = settings.get('region', null);\n    cue.vertical = settings.get('vertical', '');\n    let line = settings.get('line', 'auto');\n    if (line === 'auto' && defaults.line === -1) {\n      // set numeric line number for Safari\n      line = -1;\n    }\n    cue.line = line;\n    cue.lineAlign = settings.get('lineAlign', 'start');\n    cue.snapToLines = settings.get('snapToLines', true);\n    cue.size = settings.get('size', 100);\n    cue.align = settings.get('align', center);\n    let position = settings.get('position', 'auto');\n    if (position === 'auto' && defaults.position === 50) {\n      // set numeric position for Safari\n      position = cue.align === 'start' || cue.align === 'left' ? 0 : cue.align === 'end' || cue.align === 'right' ? 100 : 50;\n    }\n    cue.position = position;\n  }\n  function skipWhitespace() {\n    input = input.replace(/^\\s+/, '');\n  }\n\n  // 4.1 WebVTT cue timings.\n  skipWhitespace();\n  cue.startTime = consumeTimeStamp(); // (1) collect cue start time\n  skipWhitespace();\n  if (input.slice(0, 3) !== '-->') {\n    // (3) next characters must match '-->'\n    throw new Error(\"Malformed time stamp (time stamps must be separated by '-->'): \" + oInput);\n  }\n  input = input.slice(3);\n  skipWhitespace();\n  cue.endTime = consumeTimeStamp(); // (5) collect cue end time\n\n  // 4.1 WebVTT cue settings list.\n  skipWhitespace();\n  consumeCueSettings(input, cue);\n}\nfunction fixLineBreaks(input) {\n  return input.replace(/<br(?: \\/)?>/gi, '\\n');\n}\nclass VTTParser {\n  constructor() {\n    this.state = 'INITIAL';\n    this.buffer = '';\n    this.decoder = new StringDecoder();\n    this.regionList = [];\n    this.cue = null;\n    this.oncue = void 0;\n    this.onparsingerror = void 0;\n    this.onflush = void 0;\n  }\n  parse(data) {\n    const _this = this;\n\n    // If there is no data then we won't decode it, but will just try to parse\n    // whatever is in buffer already. This may occur in circumstances, for\n    // example when flush() is called.\n    if (data) {\n      // Try to decode the data that we received.\n      _this.buffer += _this.decoder.decode(data, {\n        stream: true\n      });\n    }\n    function collectNextLine() {\n      let buffer = _this.buffer;\n      let pos = 0;\n      buffer = fixLineBreaks(buffer);\n      while (pos < buffer.length && buffer[pos] !== '\\r' && buffer[pos] !== '\\n') {\n        ++pos;\n      }\n      const line = buffer.slice(0, pos);\n      // Advance the buffer early in case we fail below.\n      if (buffer[pos] === '\\r') {\n        ++pos;\n      }\n      if (buffer[pos] === '\\n') {\n        ++pos;\n      }\n      _this.buffer = buffer.slice(pos);\n      return line;\n    }\n\n    // 3.2 WebVTT metadata header syntax\n    function parseHeader(input) {\n      parseOptions(input, function (k, v) {\n        // switch (k) {\n        // case 'region':\n        // 3.3 WebVTT region metadata header syntax\n        // console.log('parse region', v);\n        // parseRegion(v);\n        // break;\n        // }\n      }, /:/);\n    }\n\n    // 5.1 WebVTT file parsing.\n    try {\n      let line = '';\n      if (_this.state === 'INITIAL') {\n        // We can't start parsing until we have the first line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        line = collectNextLine();\n        // strip of UTF-8 BOM if any\n        // https://en.wikipedia.org/wiki/Byte_order_mark#UTF-8\n        const m = line.match(/^()?WEBVTT([ \\t].*)?$/);\n        if (!(m != null && m[0])) {\n          throw new Error('Malformed WebVTT signature.');\n        }\n        _this.state = 'HEADER';\n      }\n      let alreadyCollectedLine = false;\n      while (_this.buffer) {\n        // We can't parse a line until we have the full line.\n        if (!/\\r\\n|\\n/.test(_this.buffer)) {\n          return this;\n        }\n        if (!alreadyCollectedLine) {\n          line = collectNextLine();\n        } else {\n          alreadyCollectedLine = false;\n        }\n        switch (_this.state) {\n          case 'HEADER':\n            // 13-18 - Allow a header (metadata) under the WEBVTT line.\n            if (/:/.test(line)) {\n              parseHeader(line);\n            } else if (!line) {\n              // An empty line terminates the header and starts the body (cues).\n              _this.state = 'ID';\n            }\n            continue;\n          case 'NOTE':\n            // Ignore NOTE blocks.\n            if (!line) {\n              _this.state = 'ID';\n            }\n            continue;\n          case 'ID':\n            // Check for the start of NOTE blocks.\n            if (/^NOTE($|[ \\t])/.test(line)) {\n              _this.state = 'NOTE';\n              break;\n            }\n            // 19-29 - Allow any number of line terminators, then initialize new cue values.\n            if (!line) {\n              continue;\n            }\n            _this.cue = new VTTCue(0, 0, '');\n            _this.state = 'CUE';\n            // 30-39 - Check if self line contains an optional identifier or timing data.\n            if (line.indexOf('-->') === -1) {\n              _this.cue.id = line;\n              continue;\n            }\n          // Process line as start of a cue.\n          /* falls through */\n          case 'CUE':\n            // 40 - Collect cue timings and settings.\n            if (!_this.cue) {\n              _this.state = 'BADCUE';\n              continue;\n            }\n            try {\n              parseCue(line, _this.cue, _this.regionList);\n            } catch (e) {\n              // In case of an error ignore rest of the cue.\n              _this.cue = null;\n              _this.state = 'BADCUE';\n              continue;\n            }\n            _this.state = 'CUETEXT';\n            continue;\n          case 'CUETEXT':\n            {\n              const hasSubstring = line.indexOf('-->') !== -1;\n              // 34 - If we have an empty line then report the cue.\n              // 35 - If we have the special substring '-->' then report the cue,\n              // but do not collect the line as we need to process the current\n              // one as a new cue.\n              if (!line || hasSubstring && (alreadyCollectedLine = true)) {\n                // We are done parsing self cue.\n                if (_this.oncue && _this.cue) {\n                  _this.oncue(_this.cue);\n                }\n                _this.cue = null;\n                _this.state = 'ID';\n                continue;\n              }\n              if (_this.cue === null) {\n                continue;\n              }\n              if (_this.cue.text) {\n                _this.cue.text += '\\n';\n              }\n              _this.cue.text += line;\n            }\n            continue;\n          case 'BADCUE':\n            // 54-62 - Collect and discard the remaining cue.\n            if (!line) {\n              _this.state = 'ID';\n            }\n        }\n      }\n    } catch (e) {\n      // If we are currently parsing a cue, report what we have.\n      if (_this.state === 'CUETEXT' && _this.cue && _this.oncue) {\n        _this.oncue(_this.cue);\n      }\n      _this.cue = null;\n      // Enter BADWEBVTT state if header was not parsed correctly otherwise\n      // another exception occurred so enter BADCUE state.\n      _this.state = _this.state === 'INITIAL' ? 'BADWEBVTT' : 'BADCUE';\n    }\n    return this;\n  }\n  flush() {\n    const _this = this;\n    try {\n      // Finish decoding the stream.\n      // _this.buffer += _this.decoder.decode();\n      // Synthesize the end of the current cue or region.\n      if (_this.cue || _this.state === 'HEADER') {\n        _this.buffer += '\\n\\n';\n        _this.parse();\n      }\n      // If we've flushed, parsed, and we're still on the INITIAL state then\n      // that means we don't have enough of the stream to parse the first\n      // line.\n      if (_this.state === 'INITIAL' || _this.state === 'BADWEBVTT') {\n        throw new Error('Malformed WebVTT signature.');\n      }\n    } catch (e) {\n      if (_this.onparsingerror) {\n        _this.onparsingerror(e);\n      }\n    }\n    if (_this.onflush) {\n      _this.onflush();\n    }\n    return this;\n  }\n}\n\nconst LINEBREAKS = /\\r\\n|\\n\\r|\\n|\\r/g;\n\n// String.prototype.startsWith is not supported in IE11\nconst startsWith = function startsWith(inputString, searchString, position = 0) {\n  return inputString.slice(position, position + searchString.length) === searchString;\n};\nconst cueString2millis = function cueString2millis(timeString) {\n  let ts = parseInt(timeString.slice(-3));\n  const secs = parseInt(timeString.slice(-6, -4));\n  const mins = parseInt(timeString.slice(-9, -7));\n  const hours = timeString.length > 9 ? parseInt(timeString.substring(0, timeString.indexOf(':'))) : 0;\n  if (!isFiniteNumber(ts) || !isFiniteNumber(secs) || !isFiniteNumber(mins) || !isFiniteNumber(hours)) {\n    throw Error(`Malformed X-TIMESTAMP-MAP: Local:${timeString}`);\n  }\n  ts += 1000 * secs;\n  ts += 60 * 1000 * mins;\n  ts += 60 * 60 * 1000 * hours;\n  return ts;\n};\n\n// From https://github.com/darkskyapp/string-hash\nconst hash = function hash(text) {\n  let _hash = 5381;\n  let i = text.length;\n  while (i) {\n    _hash = _hash * 33 ^ text.charCodeAt(--i);\n  }\n  return (_hash >>> 0).toString();\n};\n\n// Create a unique hash id for a cue based on start/end times and text.\n// This helps timeline-controller to avoid showing repeated captions.\nfunction generateCueId(startTime, endTime, text) {\n  return hash(startTime.toString()) + hash(endTime.toString()) + hash(text);\n}\nconst calculateOffset = function calculateOffset(vttCCs, cc, presentationTime) {\n  let currCC = vttCCs[cc];\n  let prevCC = vttCCs[currCC.prevCC];\n\n  // This is the first discontinuity or cues have been processed since the last discontinuity\n  // Offset = current discontinuity time\n  if (!prevCC || !prevCC.new && currCC.new) {\n    vttCCs.ccOffset = vttCCs.presentationOffset = currCC.start;\n    currCC.new = false;\n    return;\n  }\n\n  // There have been discontinuities since cues were last parsed.\n  // Offset = time elapsed\n  while ((_prevCC = prevCC) != null && _prevCC.new) {\n    var _prevCC;\n    vttCCs.ccOffset += currCC.start - prevCC.start;\n    currCC.new = false;\n    currCC = prevCC;\n    prevCC = vttCCs[currCC.prevCC];\n  }\n  vttCCs.presentationOffset = presentationTime;\n};\nfunction parseWebVTT(vttByteArray, initPTS, vttCCs, cc, timeOffset, callBack, errorCallBack) {\n  const parser = new VTTParser();\n  // Convert byteArray into string, replacing any somewhat exotic linefeeds with \"\\n\", then split on that character.\n  // Uint8Array.prototype.reduce is not implemented in IE11\n  const vttLines = utf8ArrayToStr(new Uint8Array(vttByteArray)).trim().replace(LINEBREAKS, '\\n').split('\\n');\n  const cues = [];\n  const init90kHz = initPTS ? toMpegTsClockFromTimescale(initPTS.baseTime, initPTS.timescale) : 0;\n  let cueTime = '00:00.000';\n  let timestampMapMPEGTS = 0;\n  let timestampMapLOCAL = 0;\n  let parsingError;\n  let inHeader = true;\n  parser.oncue = function (cue) {\n    // Adjust cue timing; clamp cues to start no earlier than - and drop cues that don't end after - 0 on timeline.\n    const currCC = vttCCs[cc];\n    let cueOffset = vttCCs.ccOffset;\n\n    // Calculate subtitle PTS offset\n    const webVttMpegTsMapOffset = (timestampMapMPEGTS - init90kHz) / 90000;\n\n    // Update offsets for new discontinuities\n    if (currCC != null && currCC.new) {\n      if (timestampMapLOCAL !== undefined) {\n        // When local time is provided, offset = discontinuity start time - local time\n        cueOffset = vttCCs.ccOffset = currCC.start;\n      } else {\n        calculateOffset(vttCCs, cc, webVttMpegTsMapOffset);\n      }\n    }\n    if (webVttMpegTsMapOffset) {\n      if (!initPTS) {\n        parsingError = new Error('Missing initPTS for VTT MPEGTS');\n        return;\n      }\n      // If we have MPEGTS, offset = presentation time + discontinuity offset\n      cueOffset = webVttMpegTsMapOffset - vttCCs.presentationOffset;\n    }\n    const duration = cue.endTime - cue.startTime;\n    const startTime = normalizePts((cue.startTime + cueOffset - timestampMapLOCAL) * 90000, timeOffset * 90000) / 90000;\n    cue.startTime = Math.max(startTime, 0);\n    cue.endTime = Math.max(startTime + duration, 0);\n\n    //trim trailing webvtt block whitespaces\n    const text = cue.text.trim();\n\n    // Fix encoding of special characters\n    cue.text = decodeURIComponent(encodeURIComponent(text));\n\n    // If the cue was not assigned an id from the VTT file (line above the content), create one.\n    if (!cue.id) {\n      cue.id = generateCueId(cue.startTime, cue.endTime, text);\n    }\n    if (cue.endTime > 0) {\n      cues.push(cue);\n    }\n  };\n  parser.onparsingerror = function (error) {\n    parsingError = error;\n  };\n  parser.onflush = function () {\n    if (parsingError) {\n      errorCallBack(parsingError);\n      return;\n    }\n    callBack(cues);\n  };\n\n  // Go through contents line by line.\n  vttLines.forEach(line => {\n    if (inHeader) {\n      // Look for X-TIMESTAMP-MAP in header.\n      if (startsWith(line, 'X-TIMESTAMP-MAP=')) {\n        // Once found, no more are allowed anyway, so stop searching.\n        inHeader = false;\n        // Extract LOCAL and MPEGTS.\n        line.slice(16).split(',').forEach(timestamp => {\n          if (startsWith(timestamp, 'LOCAL:')) {\n            cueTime = timestamp.slice(6);\n          } else if (startsWith(timestamp, 'MPEGTS:')) {\n            timestampMapMPEGTS = parseInt(timestamp.slice(7));\n          }\n        });\n        try {\n          // Convert cue time to seconds\n          timestampMapLOCAL = cueString2millis(cueTime) / 1000;\n        } catch (error) {\n          parsingError = error;\n        }\n        // Return without parsing X-TIMESTAMP-MAP line.\n        return;\n      } else if (line === '') {\n        inHeader = false;\n      }\n    }\n    // Parse line by default.\n    parser.parse(line + '\\n');\n  });\n  parser.flush();\n}\n\nconst IMSC1_CODEC = 'stpp.ttml.im1t';\n\n// Time format: h:m:s:frames(.subframes)\nconst HMSF_REGEX = /^(\\d{2,}):(\\d{2}):(\\d{2}):(\\d{2})\\.?(\\d+)?$/;\n\n// Time format: hours, minutes, seconds, milliseconds, frames, ticks\nconst TIME_UNIT_REGEX = /^(\\d*(?:\\.\\d*)?)(h|m|s|ms|f|t)$/;\nconst textAlignToLineAlign = {\n  left: 'start',\n  center: 'center',\n  right: 'end',\n  start: 'start',\n  end: 'end'\n};\nfunction parseIMSC1(payload, initPTS, callBack, errorCallBack) {\n  const results = findBox(new Uint8Array(payload), ['mdat']);\n  if (results.length === 0) {\n    errorCallBack(new Error('Could not parse IMSC1 mdat'));\n    return;\n  }\n  const ttmlList = results.map(mdat => utf8ArrayToStr(mdat));\n  const syncTime = toTimescaleFromScale(initPTS.baseTime, 1, initPTS.timescale);\n  try {\n    ttmlList.forEach(ttml => callBack(parseTTML(ttml, syncTime)));\n  } catch (error) {\n    errorCallBack(error);\n  }\n}\nfunction parseTTML(ttml, syncTime) {\n  const parser = new DOMParser();\n  const xmlDoc = parser.parseFromString(ttml, 'text/xml');\n  const tt = xmlDoc.getElementsByTagName('tt')[0];\n  if (!tt) {\n    throw new Error('Invalid ttml');\n  }\n  const defaultRateInfo = {\n    frameRate: 30,\n    subFrameRate: 1,\n    frameRateMultiplier: 0,\n    tickRate: 0\n  };\n  const rateInfo = Object.keys(defaultRateInfo).reduce((result, key) => {\n    result[key] = tt.getAttribute(`ttp:${key}`) || defaultRateInfo[key];\n    return result;\n  }, {});\n  const trim = tt.getAttribute('xml:space') !== 'preserve';\n  const styleElements = collectionToDictionary(getElementCollection(tt, 'styling', 'style'));\n  const regionElements = collectionToDictionary(getElementCollection(tt, 'layout', 'region'));\n  const cueElements = getElementCollection(tt, 'body', '[begin]');\n  return [].map.call(cueElements, cueElement => {\n    const cueText = getTextContent(cueElement, trim);\n    if (!cueText || !cueElement.hasAttribute('begin')) {\n      return null;\n    }\n    const startTime = parseTtmlTime(cueElement.getAttribute('begin'), rateInfo);\n    const duration = parseTtmlTime(cueElement.getAttribute('dur'), rateInfo);\n    let endTime = parseTtmlTime(cueElement.getAttribute('end'), rateInfo);\n    if (startTime === null) {\n      throw timestampParsingError(cueElement);\n    }\n    if (endTime === null) {\n      if (duration === null) {\n        throw timestampParsingError(cueElement);\n      }\n      endTime = startTime + duration;\n    }\n    const cue = new VTTCue(startTime - syncTime, endTime - syncTime, cueText);\n    cue.id = generateCueId(cue.startTime, cue.endTime, cue.text);\n    const region = regionElements[cueElement.getAttribute('region')];\n    const style = styleElements[cueElement.getAttribute('style')];\n\n    // Apply styles to cue\n    const styles = getTtmlStyles(region, style, styleElements);\n    const {\n      textAlign\n    } = styles;\n    if (textAlign) {\n      // cue.positionAlign not settable in FF~2016\n      const lineAlign = textAlignToLineAlign[textAlign];\n      if (lineAlign) {\n        cue.lineAlign = lineAlign;\n      }\n      cue.align = textAlign;\n    }\n    _extends(cue, styles);\n    return cue;\n  }).filter(cue => cue !== null);\n}\nfunction getElementCollection(fromElement, parentName, childName) {\n  const parent = fromElement.getElementsByTagName(parentName)[0];\n  if (parent) {\n    return [].slice.call(parent.querySelectorAll(childName));\n  }\n  return [];\n}\nfunction collectionToDictionary(elementsWithId) {\n  return elementsWithId.reduce((dict, element) => {\n    const id = element.getAttribute('xml:id');\n    if (id) {\n      dict[id] = element;\n    }\n    return dict;\n  }, {});\n}\nfunction getTextContent(element, trim) {\n  return [].slice.call(element.childNodes).reduce((str, node, i) => {\n    var _node$childNodes;\n    if (node.nodeName === 'br' && i) {\n      return str + '\\n';\n    }\n    if ((_node$childNodes = node.childNodes) != null && _node$childNodes.length) {\n      return getTextContent(node, trim);\n    } else if (trim) {\n      return str + node.textContent.trim().replace(/\\s+/g, ' ');\n    }\n    return str + node.textContent;\n  }, '');\n}\nfunction getTtmlStyles(region, style, styleElements) {\n  const ttsNs = 'http://www.w3.org/ns/ttml#styling';\n  let regionStyle = null;\n  const styleAttributes = ['displayAlign', 'textAlign', 'color', 'backgroundColor', 'fontSize', 'fontFamily'\n  // 'fontWeight',\n  // 'lineHeight',\n  // 'wrapOption',\n  // 'fontStyle',\n  // 'direction',\n  // 'writingMode'\n  ];\n  const regionStyleName = region != null && region.hasAttribute('style') ? region.getAttribute('style') : null;\n  if (regionStyleName && styleElements.hasOwnProperty(regionStyleName)) {\n    regionStyle = styleElements[regionStyleName];\n  }\n  return styleAttributes.reduce((styles, name) => {\n    const value = getAttributeNS(style, ttsNs, name) || getAttributeNS(region, ttsNs, name) || getAttributeNS(regionStyle, ttsNs, name);\n    if (value) {\n      styles[name] = value;\n    }\n    return styles;\n  }, {});\n}\nfunction getAttributeNS(element, ns, name) {\n  if (!element) {\n    return null;\n  }\n  return element.hasAttributeNS(ns, name) ? element.getAttributeNS(ns, name) : null;\n}\nfunction timestampParsingError(node) {\n  return new Error(`Could not parse ttml timestamp ${node}`);\n}\nfunction parseTtmlTime(timeAttributeValue, rateInfo) {\n  if (!timeAttributeValue) {\n    return null;\n  }\n  let seconds = parseTimeStamp(timeAttributeValue);\n  if (seconds === null) {\n    if (HMSF_REGEX.test(timeAttributeValue)) {\n      seconds = parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo);\n    } else if (TIME_UNIT_REGEX.test(timeAttributeValue)) {\n      seconds = parseTimeUnits(timeAttributeValue, rateInfo);\n    }\n  }\n  return seconds;\n}\nfunction parseHoursMinutesSecondsFrames(timeAttributeValue, rateInfo) {\n  const m = HMSF_REGEX.exec(timeAttributeValue);\n  const frames = (m[4] | 0) + (m[5] | 0) / rateInfo.subFrameRate;\n  return (m[1] | 0) * 3600 + (m[2] | 0) * 60 + (m[3] | 0) + frames / rateInfo.frameRate;\n}\nfunction parseTimeUnits(timeAttributeValue, rateInfo) {\n  const m = TIME_UNIT_REGEX.exec(timeAttributeValue);\n  const value = Number(m[1]);\n  const unit = m[2];\n  switch (unit) {\n    case 'h':\n      return value * 3600;\n    case 'm':\n      return value * 60;\n    case 'ms':\n      return value * 1000;\n    case 'f':\n      return value / rateInfo.frameRate;\n    case 't':\n      return value / rateInfo.tickRate;\n  }\n  return value;\n}\n\nclass TimelineController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.media = null;\n    this.config = void 0;\n    this.enabled = true;\n    this.Cues = void 0;\n    this.textTracks = [];\n    this.tracks = [];\n    this.initPTS = [];\n    this.unparsedVttFrags = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.cea608Parser1 = void 0;\n    this.cea608Parser2 = void 0;\n    this.lastCc = -1;\n    // Last video (CEA-608) fragment CC\n    this.lastSn = -1;\n    // Last video (CEA-608) fragment MSN\n    this.lastPartIndex = -1;\n    // Last video (CEA-608) fragment Part Index\n    this.prevCC = -1;\n    // Last subtitle fragment CC\n    this.vttCCs = newVTTCCs();\n    this.captionsProperties = void 0;\n    this.hls = hls;\n    this.config = hls.config;\n    this.Cues = hls.config.cueHandler;\n    this.captionsProperties = {\n      textTrack1: {\n        label: this.config.captionsTextTrack1Label,\n        languageCode: this.config.captionsTextTrack1LanguageCode\n      },\n      textTrack2: {\n        label: this.config.captionsTextTrack2Label,\n        languageCode: this.config.captionsTextTrack2LanguageCode\n      },\n      textTrack3: {\n        label: this.config.captionsTextTrack3Label,\n        languageCode: this.config.captionsTextTrack3LanguageCode\n      },\n      textTrack4: {\n        label: this.config.captionsTextTrack4Label,\n        languageCode: this.config.captionsTextTrack4LanguageCode\n      }\n    };\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.on(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.on(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.on(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.on(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.on(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.on(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.on(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n  }\n  destroy() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.SUBTITLE_TRACKS_UPDATED, this.onSubtitleTracksUpdated, this);\n    hls.off(Events.FRAG_LOADING, this.onFragLoading, this);\n    hls.off(Events.FRAG_LOADED, this.onFragLoaded, this);\n    hls.off(Events.FRAG_PARSING_USERDATA, this.onFragParsingUserdata, this);\n    hls.off(Events.FRAG_DECRYPTED, this.onFragDecrypted, this);\n    hls.off(Events.INIT_PTS_FOUND, this.onInitPtsFound, this);\n    hls.off(Events.SUBTITLE_TRACKS_CLEARED, this.onSubtitleTracksCleared, this);\n    hls.off(Events.BUFFER_FLUSHING, this.onBufferFlushing, this);\n    // @ts-ignore\n    this.hls = this.config = null;\n    this.cea608Parser1 = this.cea608Parser2 = undefined;\n  }\n  initCea608Parsers() {\n    if (this.config.enableCEA708Captions && (!this.cea608Parser1 || !this.cea608Parser2)) {\n      const channel1 = new OutputFilter(this, 'textTrack1');\n      const channel2 = new OutputFilter(this, 'textTrack2');\n      const channel3 = new OutputFilter(this, 'textTrack3');\n      const channel4 = new OutputFilter(this, 'textTrack4');\n      this.cea608Parser1 = new Cea608Parser(1, channel1, channel2);\n      this.cea608Parser2 = new Cea608Parser(3, channel3, channel4);\n    }\n  }\n  addCues(trackName, startTime, endTime, screen, cueRanges) {\n    // skip cues which overlap more than 50% with previously parsed time ranges\n    let merged = false;\n    for (let i = cueRanges.length; i--;) {\n      const cueRange = cueRanges[i];\n      const overlap = intersection(cueRange[0], cueRange[1], startTime, endTime);\n      if (overlap >= 0) {\n        cueRange[0] = Math.min(cueRange[0], startTime);\n        cueRange[1] = Math.max(cueRange[1], endTime);\n        merged = true;\n        if (overlap / (endTime - startTime) > 0.5) {\n          return;\n        }\n      }\n    }\n    if (!merged) {\n      cueRanges.push([startTime, endTime]);\n    }\n    if (this.config.renderTextTracksNatively) {\n      const track = this.captionsTracks[trackName];\n      this.Cues.newCue(track, startTime, endTime, screen);\n    } else {\n      const cues = this.Cues.newCue(null, startTime, endTime, screen);\n      this.hls.trigger(Events.CUES_PARSED, {\n        type: 'captions',\n        cues,\n        track: trackName\n      });\n    }\n  }\n\n  // Triggered when an initial PTS is found; used for synchronisation of WebVTT.\n  onInitPtsFound(event, {\n    frag,\n    id,\n    initPTS,\n    timescale\n  }) {\n    const {\n      unparsedVttFrags\n    } = this;\n    if (id === 'main') {\n      this.initPTS[frag.cc] = {\n        baseTime: initPTS,\n        timescale\n      };\n    }\n\n    // Due to asynchronous processing, initial PTS may arrive later than the first VTT fragments are loaded.\n    // Parse any unparsed fragments upon receiving the initial PTS.\n    if (unparsedVttFrags.length) {\n      this.unparsedVttFrags = [];\n      unparsedVttFrags.forEach(frag => {\n        this.onFragLoaded(Events.FRAG_LOADED, frag);\n      });\n    }\n  }\n  getExistingTrack(label, language) {\n    const {\n      media\n    } = this;\n    if (media) {\n      for (let i = 0; i < media.textTracks.length; i++) {\n        const textTrack = media.textTracks[i];\n        if (canReuseVttTextTrack(textTrack, {\n          name: label,\n          lang: language,\n          attrs: {}\n        })) {\n          return textTrack;\n        }\n      }\n    }\n    return null;\n  }\n  createCaptionsTrack(trackName) {\n    if (this.config.renderTextTracksNatively) {\n      this.createNativeTrack(trackName);\n    } else {\n      this.createNonNativeTrack(trackName);\n    }\n  }\n  createNativeTrack(trackName) {\n    if (this.captionsTracks[trackName]) {\n      return;\n    }\n    const {\n      captionsProperties,\n      captionsTracks,\n      media\n    } = this;\n    const {\n      label,\n      languageCode\n    } = captionsProperties[trackName];\n    // Enable reuse of existing text track.\n    const existingTrack = this.getExistingTrack(label, languageCode);\n    if (!existingTrack) {\n      const textTrack = this.createTextTrack('captions', label, languageCode);\n      if (textTrack) {\n        // Set a special property on the track so we know it's managed by Hls.js\n        textTrack[trackName] = true;\n        captionsTracks[trackName] = textTrack;\n      }\n    } else {\n      captionsTracks[trackName] = existingTrack;\n      clearCurrentCues(captionsTracks[trackName]);\n      sendAddTrackEvent(captionsTracks[trackName], media);\n    }\n  }\n  createNonNativeTrack(trackName) {\n    if (this.nonNativeCaptionsTracks[trackName]) {\n      return;\n    }\n    // Create a list of a single track for the provider to consume\n    const trackProperties = this.captionsProperties[trackName];\n    if (!trackProperties) {\n      return;\n    }\n    const label = trackProperties.label;\n    const track = {\n      _id: trackName,\n      label,\n      kind: 'captions',\n      default: trackProperties.media ? !!trackProperties.media.default : false,\n      closedCaptions: trackProperties.media\n    };\n    this.nonNativeCaptionsTracks[trackName] = track;\n    this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n      tracks: [track]\n    });\n  }\n  createTextTrack(kind, label, lang) {\n    const media = this.media;\n    if (!media) {\n      return;\n    }\n    return media.addTextTrack(kind, label, lang);\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media;\n    this._cleanTracks();\n  }\n  onMediaDetaching() {\n    const {\n      captionsTracks\n    } = this;\n    Object.keys(captionsTracks).forEach(trackName => {\n      clearCurrentCues(captionsTracks[trackName]);\n      delete captionsTracks[trackName];\n    });\n    this.nonNativeCaptionsTracks = {};\n  }\n  onManifestLoading() {\n    // Detect discontinuity in video fragment (CEA-608) parsing\n    this.lastCc = -1;\n    this.lastSn = -1;\n    this.lastPartIndex = -1;\n    // Detect discontinuity in subtitle manifests\n    this.prevCC = -1;\n    this.vttCCs = newVTTCCs();\n    // Reset tracks\n    this._cleanTracks();\n    this.tracks = [];\n    this.captionsTracks = {};\n    this.nonNativeCaptionsTracks = {};\n    this.textTracks = [];\n    this.unparsedVttFrags = [];\n    this.initPTS = [];\n    if (this.cea608Parser1 && this.cea608Parser2) {\n      this.cea608Parser1.reset();\n      this.cea608Parser2.reset();\n    }\n  }\n  _cleanTracks() {\n    // clear outdated subtitles\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const textTracks = media.textTracks;\n    if (textTracks) {\n      for (let i = 0; i < textTracks.length; i++) {\n        clearCurrentCues(textTracks[i]);\n      }\n    }\n  }\n  onSubtitleTracksUpdated(event, data) {\n    const tracks = data.subtitleTracks || [];\n    const hasIMSC1 = tracks.some(track => track.textCodec === IMSC1_CODEC);\n    if (this.config.enableWebVTT || hasIMSC1 && this.config.enableIMSC1) {\n      const listIsIdentical = subtitleOptionsIdentical(this.tracks, tracks);\n      if (listIsIdentical) {\n        this.tracks = tracks;\n        return;\n      }\n      this.textTracks = [];\n      this.tracks = tracks;\n      if (this.config.renderTextTracksNatively) {\n        const media = this.media;\n        const inUseTracks = media ? filterSubtitleTracks(media.textTracks) : null;\n        this.tracks.forEach((track, index) => {\n          // Reuse tracks with the same label and lang, but do not reuse 608/708 tracks\n          let textTrack;\n          if (inUseTracks) {\n            let inUseTrack = null;\n            for (let i = 0; i < inUseTracks.length; i++) {\n              if (inUseTracks[i] && canReuseVttTextTrack(inUseTracks[i], track)) {\n                inUseTrack = inUseTracks[i];\n                inUseTracks[i] = null;\n                break;\n              }\n            }\n            if (inUseTrack) {\n              textTrack = inUseTrack;\n            }\n          }\n          if (textTrack) {\n            clearCurrentCues(textTrack);\n          } else {\n            const textTrackKind = captionsOrSubtitlesFromCharacteristics(track);\n            textTrack = this.createTextTrack(textTrackKind, track.name, track.lang);\n            if (textTrack) {\n              textTrack.mode = 'disabled';\n            }\n          }\n          if (textTrack) {\n            this.textTracks.push(textTrack);\n          }\n        });\n        // Warn when video element has captions or subtitle TextTracks carried over from another source\n        if (inUseTracks != null && inUseTracks.length) {\n          const unusedTextTracks = inUseTracks.filter(t => t !== null).map(t => t.label);\n          if (unusedTextTracks.length) {\n            logger.warn(`Media element contains unused subtitle tracks: ${unusedTextTracks.join(', ')}. Replace media element for each source to clear TextTracks and captions menu.`);\n          }\n        }\n      } else if (this.tracks.length) {\n        // Create a list of tracks for the provider to consume\n        const tracksList = this.tracks.map(track => {\n          return {\n            label: track.name,\n            kind: track.type.toLowerCase(),\n            default: track.default,\n            subtitleTrack: track\n          };\n        });\n        this.hls.trigger(Events.NON_NATIVE_TEXT_TRACKS_FOUND, {\n          tracks: tracksList\n        });\n      }\n    }\n  }\n  onManifestLoaded(event, data) {\n    if (this.config.enableCEA708Captions && data.captions) {\n      data.captions.forEach(captionsTrack => {\n        const instreamIdMatch = /(?:CC|SERVICE)([1-4])/.exec(captionsTrack.instreamId);\n        if (!instreamIdMatch) {\n          return;\n        }\n        const trackName = `textTrack${instreamIdMatch[1]}`;\n        const trackProperties = this.captionsProperties[trackName];\n        if (!trackProperties) {\n          return;\n        }\n        trackProperties.label = captionsTrack.name;\n        if (captionsTrack.lang) {\n          // optional attribute\n          trackProperties.languageCode = captionsTrack.lang;\n        }\n        trackProperties.media = captionsTrack;\n      });\n    }\n  }\n  closedCaptionsForLevel(frag) {\n    const level = this.hls.levels[frag.level];\n    return level == null ? void 0 : level.attrs['CLOSED-CAPTIONS'];\n  }\n  onFragLoading(event, data) {\n    // if this frag isn't contiguous, clear the parser so cues with bad start/end times aren't added to the textTrack\n    if (this.enabled && data.frag.type === PlaylistLevelType.MAIN) {\n      var _data$part$index, _data$part;\n      const {\n        cea608Parser1,\n        cea608Parser2,\n        lastSn\n      } = this;\n      const {\n        cc,\n        sn\n      } = data.frag;\n      const partIndex = (_data$part$index = (_data$part = data.part) == null ? void 0 : _data$part.index) != null ? _data$part$index : -1;\n      if (cea608Parser1 && cea608Parser2) {\n        if (sn !== lastSn + 1 || sn === lastSn && partIndex !== this.lastPartIndex + 1 || cc !== this.lastCc) {\n          cea608Parser1.reset();\n          cea608Parser2.reset();\n        }\n      }\n      this.lastCc = cc;\n      this.lastSn = sn;\n      this.lastPartIndex = partIndex;\n    }\n  }\n  onFragLoaded(event, data) {\n    const {\n      frag,\n      payload\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      // If fragment is subtitle type, parse as WebVTT.\n      if (payload.byteLength) {\n        const decryptData = frag.decryptdata;\n        // fragment after decryption has a stats object\n        const decrypted = ('stats' in data);\n        // If the subtitles are not encrypted, parse VTTs now. Otherwise, we need to wait.\n        if (decryptData == null || !decryptData.encrypted || decrypted) {\n          const trackPlaylistMedia = this.tracks[frag.level];\n          const vttCCs = this.vttCCs;\n          if (!vttCCs[frag.cc]) {\n            vttCCs[frag.cc] = {\n              start: frag.start,\n              prevCC: this.prevCC,\n              new: true\n            };\n            this.prevCC = frag.cc;\n          }\n          if (trackPlaylistMedia && trackPlaylistMedia.textCodec === IMSC1_CODEC) {\n            this._parseIMSC1(frag, payload);\n          } else {\n            this._parseVTTs(data);\n          }\n        }\n      } else {\n        // In case there is no payload, finish unsuccessfully.\n        this.hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n          success: false,\n          frag,\n          error: new Error('Empty subtitle payload')\n        });\n      }\n    }\n  }\n  _parseIMSC1(frag, payload) {\n    const hls = this.hls;\n    parseIMSC1(payload, this.initPTS[frag.cc], cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      logger.log(`Failed to parse IMSC1: ${error}`);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _parseVTTs(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      payload\n    } = data;\n    // We need an initial synchronisation PTS. Store fragments as long as none has arrived\n    const {\n      initPTS,\n      unparsedVttFrags\n    } = this;\n    const maxAvCC = initPTS.length - 1;\n    if (!initPTS[frag.cc] && maxAvCC === -1) {\n      unparsedVttFrags.push(data);\n      return;\n    }\n    const hls = this.hls;\n    // Parse the WebVTT file contents.\n    const payloadWebVTT = (_frag$initSegment = frag.initSegment) != null && _frag$initSegment.data ? appendUint8Array(frag.initSegment.data, new Uint8Array(payload)) : payload;\n    parseWebVTT(payloadWebVTT, this.initPTS[frag.cc], this.vttCCs, frag.cc, frag.start, cues => {\n      this._appendCues(cues, frag.level);\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: true,\n        frag: frag\n      });\n    }, error => {\n      const missingInitPTS = error.message === 'Missing initPTS for VTT MPEGTS';\n      if (missingInitPTS) {\n        unparsedVttFrags.push(data);\n      } else {\n        this._fallbackToIMSC1(frag, payload);\n      }\n      // Something went wrong while parsing. Trigger event with success false.\n      logger.log(`Failed to parse VTT cue: ${error}`);\n      if (missingInitPTS && maxAvCC > frag.cc) {\n        return;\n      }\n      hls.trigger(Events.SUBTITLE_FRAG_PROCESSED, {\n        success: false,\n        frag: frag,\n        error\n      });\n    });\n  }\n  _fallbackToIMSC1(frag, payload) {\n    // If textCodec is unknown, try parsing as IMSC1. Set textCodec based on the result\n    const trackPlaylistMedia = this.tracks[frag.level];\n    if (!trackPlaylistMedia.textCodec) {\n      parseIMSC1(payload, this.initPTS[frag.cc], () => {\n        trackPlaylistMedia.textCodec = IMSC1_CODEC;\n        this._parseIMSC1(frag, payload);\n      }, () => {\n        trackPlaylistMedia.textCodec = 'wvtt';\n      });\n    }\n  }\n  _appendCues(cues, fragLevel) {\n    const hls = this.hls;\n    if (this.config.renderTextTracksNatively) {\n      const textTrack = this.textTracks[fragLevel];\n      // WebVTTParser.parse is an async method and if the currently selected text track mode is set to \"disabled\"\n      // before parsing is done then don't try to access currentTrack.cues.getCueById as cues will be null\n      // and trying to access getCueById method of cues will throw an exception\n      // Because we check if the mode is disabled, we can force check `cues` below. They can't be null.\n      if (!textTrack || textTrack.mode === 'disabled') {\n        return;\n      }\n      cues.forEach(cue => addCueToTrack(textTrack, cue));\n    } else {\n      const currentTrack = this.tracks[fragLevel];\n      if (!currentTrack) {\n        return;\n      }\n      const track = currentTrack.default ? 'default' : 'subtitles' + fragLevel;\n      hls.trigger(Events.CUES_PARSED, {\n        type: 'subtitles',\n        cues,\n        track\n      });\n    }\n  }\n  onFragDecrypted(event, data) {\n    const {\n      frag\n    } = data;\n    if (frag.type === PlaylistLevelType.SUBTITLE) {\n      this.onFragLoaded(Events.FRAG_LOADED, data);\n    }\n  }\n  onSubtitleTracksCleared() {\n    this.tracks = [];\n    this.captionsTracks = {};\n  }\n  onFragParsingUserdata(event, data) {\n    this.initCea608Parsers();\n    const {\n      cea608Parser1,\n      cea608Parser2\n    } = this;\n    if (!this.enabled || !cea608Parser1 || !cea608Parser2) {\n      return;\n    }\n    const {\n      frag,\n      samples\n    } = data;\n    if (frag.type === PlaylistLevelType.MAIN && this.closedCaptionsForLevel(frag) === 'NONE') {\n      return;\n    }\n    // If the event contains captions (found in the bytes property), push all bytes into the parser immediately\n    // It will create the proper timestamps based on the PTS value\n    for (let i = 0; i < samples.length; i++) {\n      const ccBytes = samples[i].bytes;\n      if (ccBytes) {\n        const ccdatas = this.extractCea608Data(ccBytes);\n        cea608Parser1.addData(samples[i].pts, ccdatas[0]);\n        cea608Parser2.addData(samples[i].pts, ccdatas[1]);\n      }\n    }\n  }\n  onBufferFlushing(event, {\n    startOffset,\n    endOffset,\n    endOffsetSubtitles,\n    type\n  }) {\n    const {\n      media\n    } = this;\n    if (!media || media.currentTime < endOffset) {\n      return;\n    }\n    // Clear 608 caption cues from the captions TextTracks when the video back buffer is flushed\n    // Forward cues are never removed because we can loose streamed 608 content from recent fragments\n    if (!type || type === 'video') {\n      const {\n        captionsTracks\n      } = this;\n      Object.keys(captionsTracks).forEach(trackName => removeCuesInRange(captionsTracks[trackName], startOffset, endOffset));\n    }\n    if (this.config.renderTextTracksNatively) {\n      // Clear VTT/IMSC1 subtitle cues from the subtitle TextTracks when the back buffer is flushed\n      if (startOffset === 0 && endOffsetSubtitles !== undefined) {\n        const {\n          textTracks\n        } = this;\n        Object.keys(textTracks).forEach(trackName => removeCuesInRange(textTracks[trackName], startOffset, endOffsetSubtitles));\n      }\n    }\n  }\n  extractCea608Data(byteArray) {\n    const actualCCBytes = [[], []];\n    const count = byteArray[0] & 0x1f;\n    let position = 2;\n    for (let j = 0; j < count; j++) {\n      const tmpByte = byteArray[position++];\n      const ccbyte1 = 0x7f & byteArray[position++];\n      const ccbyte2 = 0x7f & byteArray[position++];\n      if (ccbyte1 === 0 && ccbyte2 === 0) {\n        continue;\n      }\n      const ccValid = (0x04 & tmpByte) !== 0; // Support all four channels\n      if (ccValid) {\n        const ccType = 0x03 & tmpByte;\n        if (0x00 /* CEA608 field1*/ === ccType || 0x01 /* CEA608 field2*/ === ccType) {\n          // Exclude CEA708 CC data.\n          actualCCBytes[ccType].push(ccbyte1);\n          actualCCBytes[ccType].push(ccbyte2);\n        }\n      }\n    }\n    return actualCCBytes;\n  }\n}\nfunction captionsOrSubtitlesFromCharacteristics(track) {\n  if (track.characteristics) {\n    if (/transcribes-spoken-dialog/gi.test(track.characteristics) && /describes-music-and-sound/gi.test(track.characteristics)) {\n      return 'captions';\n    }\n  }\n  return 'subtitles';\n}\nfunction canReuseVttTextTrack(inUseTrack, manifestTrack) {\n  return !!inUseTrack && inUseTrack.kind === captionsOrSubtitlesFromCharacteristics(manifestTrack) && subtitleTrackMatchesTextTrack(manifestTrack, inUseTrack);\n}\nfunction intersection(x1, x2, y1, y2) {\n  return Math.min(x2, y2) - Math.max(x1, y1);\n}\nfunction newVTTCCs() {\n  return {\n    ccOffset: 0,\n    presentationOffset: 0,\n    0: {\n      start: 0,\n      prevCC: -1,\n      new: true\n    }\n  };\n}\n\nclass CapLevelController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.autoLevelCapping = void 0;\n    this.firstLevel = void 0;\n    this.media = void 0;\n    this.restrictedLevels = void 0;\n    this.timer = void 0;\n    this.clientRect = void 0;\n    this.streamController = void 0;\n    this.hls = hls;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    this.firstLevel = -1;\n    this.media = null;\n    this.restrictedLevels = [];\n    this.timer = undefined;\n    this.clientRect = null;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  destroy() {\n    if (this.hls) {\n      this.unregisterListener();\n    }\n    if (this.timer) {\n      this.stopCapping();\n    }\n    this.media = null;\n    this.clientRect = null;\n    // @ts-ignore\n    this.hls = this.streamController = null;\n  }\n  registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  unregisterListener() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.FPS_DROP_LEVEL_CAPPING, this.onFpsDropLevelCapping, this);\n    hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.BUFFER_CODECS, this.onBufferCodecs, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n  }\n  onFpsDropLevelCapping(event, data) {\n    // Don't add a restricted level more than once\n    const level = this.hls.levels[data.droppedLevel];\n    if (this.isLevelAllowed(level)) {\n      this.restrictedLevels.push({\n        bitrate: level.bitrate,\n        height: level.height,\n        width: level.width\n      });\n    }\n  }\n  onMediaAttaching(event, data) {\n    this.media = data.media instanceof HTMLVideoElement ? data.media : null;\n    this.clientRect = null;\n    if (this.timer && this.hls.levels.length) {\n      this.detectPlayerSize();\n    }\n  }\n  onManifestParsed(event, data) {\n    const hls = this.hls;\n    this.restrictedLevels = [];\n    this.firstLevel = data.firstLevel;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // Start capping immediately if the manifest has signaled video codecs\n      this.startCapping();\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.timer && isFiniteNumber(this.autoLevelCapping)) {\n      this.detectPlayerSize();\n    }\n  }\n\n  // Only activate capping when playing a video stream; otherwise, multi-bitrate audio-only streams will be restricted\n  // to the first level\n  onBufferCodecs(event, data) {\n    const hls = this.hls;\n    if (hls.config.capLevelToPlayerSize && data.video) {\n      // If the manifest did not signal a video codec capping has been deferred until we're certain video is present\n      this.startCapping();\n    }\n  }\n  onMediaDetaching() {\n    this.stopCapping();\n  }\n  detectPlayerSize() {\n    if (this.media) {\n      if (this.mediaHeight <= 0 || this.mediaWidth <= 0) {\n        this.clientRect = null;\n        return;\n      }\n      const levels = this.hls.levels;\n      if (levels.length) {\n        const hls = this.hls;\n        const maxLevel = this.getMaxLevel(levels.length - 1);\n        if (maxLevel !== this.autoLevelCapping) {\n          logger.log(`Setting autoLevelCapping to ${maxLevel}: ${levels[maxLevel].height}p@${levels[maxLevel].bitrate} for media ${this.mediaWidth}x${this.mediaHeight}`);\n        }\n        hls.autoLevelCapping = maxLevel;\n        if (hls.autoLevelCapping > this.autoLevelCapping && this.streamController) {\n          // if auto level capping has a higher value for the previous one, flush the buffer using nextLevelSwitch\n          // usually happen when the user go to the fullscreen mode.\n          this.streamController.nextLevelSwitch();\n        }\n        this.autoLevelCapping = hls.autoLevelCapping;\n      }\n    }\n  }\n\n  /*\n   * returns level should be the one with the dimensions equal or greater than the media (player) dimensions (so the video will be downscaled)\n   */\n  getMaxLevel(capLevelIndex) {\n    const levels = this.hls.levels;\n    if (!levels.length) {\n      return -1;\n    }\n    const validLevels = levels.filter((level, index) => this.isLevelAllowed(level) && index <= capLevelIndex);\n    this.clientRect = null;\n    return CapLevelController.getMaxLevelByMediaSize(validLevels, this.mediaWidth, this.mediaHeight);\n  }\n  startCapping() {\n    if (this.timer) {\n      // Don't reset capping if started twice; this can happen if the manifest signals a video codec\n      return;\n    }\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    self.clearInterval(this.timer);\n    this.timer = self.setInterval(this.detectPlayerSize.bind(this), 1000);\n    this.detectPlayerSize();\n  }\n  stopCapping() {\n    this.restrictedLevels = [];\n    this.firstLevel = -1;\n    this.autoLevelCapping = Number.POSITIVE_INFINITY;\n    if (this.timer) {\n      self.clearInterval(this.timer);\n      this.timer = undefined;\n    }\n  }\n  getDimensions() {\n    if (this.clientRect) {\n      return this.clientRect;\n    }\n    const media = this.media;\n    const boundsRect = {\n      width: 0,\n      height: 0\n    };\n    if (media) {\n      const clientRect = media.getBoundingClientRect();\n      boundsRect.width = clientRect.width;\n      boundsRect.height = clientRect.height;\n      if (!boundsRect.width && !boundsRect.height) {\n        // When the media element has no width or height (equivalent to not being in the DOM),\n        // then use its width and height attributes (media.width, media.height)\n        boundsRect.width = clientRect.right - clientRect.left || media.width || 0;\n        boundsRect.height = clientRect.bottom - clientRect.top || media.height || 0;\n      }\n    }\n    this.clientRect = boundsRect;\n    return boundsRect;\n  }\n  get mediaWidth() {\n    return this.getDimensions().width * this.contentScaleFactor;\n  }\n  get mediaHeight() {\n    return this.getDimensions().height * this.contentScaleFactor;\n  }\n  get contentScaleFactor() {\n    let pixelRatio = 1;\n    if (!this.hls.config.ignoreDevicePixelRatio) {\n      try {\n        pixelRatio = self.devicePixelRatio;\n      } catch (e) {\n        /* no-op */\n      }\n    }\n    return pixelRatio;\n  }\n  isLevelAllowed(level) {\n    const restrictedLevels = this.restrictedLevels;\n    return !restrictedLevels.some(restrictedLevel => {\n      return level.bitrate === restrictedLevel.bitrate && level.width === restrictedLevel.width && level.height === restrictedLevel.height;\n    });\n  }\n  static getMaxLevelByMediaSize(levels, width, height) {\n    if (!(levels != null && levels.length)) {\n      return -1;\n    }\n\n    // Levels can have the same dimensions but differing bandwidths - since levels are ordered, we can look to the next\n    // to determine whether we've chosen the greatest bandwidth for the media's dimensions\n    const atGreatestBandwidth = (curLevel, nextLevel) => {\n      if (!nextLevel) {\n        return true;\n      }\n      return curLevel.width !== nextLevel.width || curLevel.height !== nextLevel.height;\n    };\n\n    // If we run through the loop without breaking, the media's dimensions are greater than every level, so default to\n    // the max level\n    let maxLevelIndex = levels.length - 1;\n    // Prevent changes in aspect-ratio from causing capping to toggle back and forth\n    const squareSize = Math.max(width, height);\n    for (let i = 0; i < levels.length; i += 1) {\n      const level = levels[i];\n      if ((level.width >= squareSize || level.height >= squareSize) && atGreatestBandwidth(level, levels[i + 1])) {\n        maxLevelIndex = i;\n        break;\n      }\n    }\n    return maxLevelIndex;\n  }\n}\n\nclass FPSController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.isVideoPlaybackQualityAvailable = false;\n    this.timer = void 0;\n    this.media = null;\n    this.lastTime = void 0;\n    this.lastDroppedFrames = 0;\n    this.lastDecodedFrames = 0;\n    // stream controller must be provided as a dependency!\n    this.streamController = void 0;\n    this.hls = hls;\n    this.registerListeners();\n  }\n  setStreamController(streamController) {\n    this.streamController = streamController;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHING, this.onMediaAttaching, this);\n  }\n  destroy() {\n    if (this.timer) {\n      clearInterval(this.timer);\n    }\n    this.unregisterListeners();\n    this.isVideoPlaybackQualityAvailable = false;\n    this.media = null;\n  }\n  onMediaAttaching(event, data) {\n    const config = this.hls.config;\n    if (config.capLevelOnFPSDrop) {\n      const media = data.media instanceof self.HTMLVideoElement ? data.media : null;\n      this.media = media;\n      if (media && typeof media.getVideoPlaybackQuality === 'function') {\n        this.isVideoPlaybackQualityAvailable = true;\n      }\n      self.clearInterval(this.timer);\n      this.timer = self.setInterval(this.checkFPSInterval.bind(this), config.fpsDroppedMonitoringPeriod);\n    }\n  }\n  checkFPS(video, decodedFrames, droppedFrames) {\n    const currentTime = performance.now();\n    if (decodedFrames) {\n      if (this.lastTime) {\n        const currentPeriod = currentTime - this.lastTime;\n        const currentDropped = droppedFrames - this.lastDroppedFrames;\n        const currentDecoded = decodedFrames - this.lastDecodedFrames;\n        const droppedFPS = 1000 * currentDropped / currentPeriod;\n        const hls = this.hls;\n        hls.trigger(Events.FPS_DROP, {\n          currentDropped: currentDropped,\n          currentDecoded: currentDecoded,\n          totalDroppedFrames: droppedFrames\n        });\n        if (droppedFPS > 0) {\n          // logger.log('checkFPS : droppedFPS/decodedFPS:' + droppedFPS/(1000 * currentDecoded / currentPeriod));\n          if (currentDropped > hls.config.fpsDroppedMonitoringThreshold * currentDecoded) {\n            let currentLevel = hls.currentLevel;\n            logger.warn('drop FPS ratio greater than max allowed value for currentLevel: ' + currentLevel);\n            if (currentLevel > 0 && (hls.autoLevelCapping === -1 || hls.autoLevelCapping >= currentLevel)) {\n              currentLevel = currentLevel - 1;\n              hls.trigger(Events.FPS_DROP_LEVEL_CAPPING, {\n                level: currentLevel,\n                droppedLevel: hls.currentLevel\n              });\n              hls.autoLevelCapping = currentLevel;\n              this.streamController.nextLevelSwitch();\n            }\n          }\n        }\n      }\n      this.lastTime = currentTime;\n      this.lastDroppedFrames = droppedFrames;\n      this.lastDecodedFrames = decodedFrames;\n    }\n  }\n  checkFPSInterval() {\n    const video = this.media;\n    if (video) {\n      if (this.isVideoPlaybackQualityAvailable) {\n        const videoPlaybackQuality = video.getVideoPlaybackQuality();\n        this.checkFPS(video, videoPlaybackQuality.totalVideoFrames, videoPlaybackQuality.droppedVideoFrames);\n      } else {\n        // HTMLVideoElement doesn't include the webkit types\n        this.checkFPS(video, video.webkitDecodedFrameCount, video.webkitDroppedFrameCount);\n      }\n    }\n  }\n}\n\nconst LOGGER_PREFIX = '[eme]';\n/**\n * Controller to deal with encrypted media extensions (EME)\n * @see https://developer.mozilla.org/en-US/docs/Web/API/Encrypted_Media_Extensions_API\n *\n * @class\n * @constructor\n */\nclass EMEController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = null;\n    this.keyFormatPromise = null;\n    this.keySystemAccessPromises = {};\n    this._requestLicenseFailureCount = 0;\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    this.setMediaKeysQueue = EMEController.CDMCleanupPromise ? [EMEController.CDMCleanupPromise] : [];\n    this.onMediaEncrypted = this._onMediaEncrypted.bind(this);\n    this.onWaitingForKey = this._onWaitingForKey.bind(this);\n    this.debug = logger.debug.bind(logger, LOGGER_PREFIX);\n    this.log = logger.log.bind(logger, LOGGER_PREFIX);\n    this.warn = logger.warn.bind(logger, LOGGER_PREFIX);\n    this.error = logger.error.bind(logger, LOGGER_PREFIX);\n    this.hls = hls;\n    this.config = hls.config;\n    this.registerListeners();\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.requestMediaKeySystemAccessFunc = null;\n    config.licenseXhrSetup = config.licenseResponseCallback = undefined;\n    config.drmSystems = config.drmSystemOptions = {};\n    // @ts-ignore\n    this.hls = this.onMediaEncrypted = this.onWaitingForKey = this.keyIdToKeySessionPromise = null;\n    // @ts-ignore\n    this.config = null;\n  }\n  registerListeners() {\n    this.hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  unregisterListeners() {\n    this.hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    this.hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    this.hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    this.hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n  }\n  getLicenseServerUrl(keySystem) {\n    const {\n      drmSystems,\n      widevineLicenseUrl\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.licenseUrl;\n    }\n\n    // For backward compatibility\n    if (keySystem === KeySystems.WIDEVINE && widevineLicenseUrl) {\n      return widevineLicenseUrl;\n    }\n    throw new Error(`no license server URL configured for key-system \"${keySystem}\"`);\n  }\n  getServerCertificateUrl(keySystem) {\n    const {\n      drmSystems\n    } = this.config;\n    const keySystemConfiguration = drmSystems[keySystem];\n    if (keySystemConfiguration) {\n      return keySystemConfiguration.serverCertificateUrl;\n    } else {\n      this.log(`No Server Certificate in config.drmSystems[\"${keySystem}\"]`);\n    }\n  }\n  attemptKeySystemAccess(keySystemsToAttempt) {\n    const levels = this.hls.levels;\n    const uniqueCodec = (value, i, a) => !!value && a.indexOf(value) === i;\n    const audioCodecs = levels.map(level => level.audioCodec).filter(uniqueCodec);\n    const videoCodecs = levels.map(level => level.videoCodec).filter(uniqueCodec);\n    if (audioCodecs.length + videoCodecs.length === 0) {\n      videoCodecs.push('avc1.42e01e');\n    }\n    return new Promise((resolve, reject) => {\n      const attempt = keySystems => {\n        const keySystem = keySystems.shift();\n        this.getMediaKeysPromise(keySystem, audioCodecs, videoCodecs).then(mediaKeys => resolve({\n          keySystem,\n          mediaKeys\n        })).catch(error => {\n          if (keySystems.length) {\n            attempt(keySystems);\n          } else if (error instanceof EMEKeyError) {\n            reject(error);\n          } else {\n            reject(new EMEKeyError({\n              type: ErrorTypes.KEY_SYSTEM_ERROR,\n              details: ErrorDetails.KEY_SYSTEM_NO_ACCESS,\n              error,\n              fatal: true\n            }, error.message));\n          }\n        });\n      };\n      attempt(keySystemsToAttempt);\n    });\n  }\n  requestMediaKeySystemAccess(keySystem, supportedConfigurations) {\n    const {\n      requestMediaKeySystemAccessFunc\n    } = this.config;\n    if (!(typeof requestMediaKeySystemAccessFunc === 'function')) {\n      let errMessage = `Configured requestMediaKeySystemAccess is not a function ${requestMediaKeySystemAccessFunc}`;\n      if (requestMediaKeySystemAccess === null && self.location.protocol === 'http:') {\n        errMessage = `navigator.requestMediaKeySystemAccess is not available over insecure protocol ${location.protocol}`;\n      }\n      return Promise.reject(new Error(errMessage));\n    }\n    return requestMediaKeySystemAccessFunc(keySystem, supportedConfigurations);\n  }\n  getMediaKeysPromise(keySystem, audioCodecs, videoCodecs) {\n    // This can throw, but is caught in event handler callpath\n    const mediaKeySystemConfigs = getSupportedMediaKeySystemConfigurations(keySystem, audioCodecs, videoCodecs, this.config.drmSystemOptions);\n    const keySystemAccessPromises = this.keySystemAccessPromises[keySystem];\n    let keySystemAccess = keySystemAccessPromises == null ? void 0 : keySystemAccessPromises.keySystemAccess;\n    if (!keySystemAccess) {\n      this.log(`Requesting encrypted media \"${keySystem}\" key-system access with config: ${JSON.stringify(mediaKeySystemConfigs)}`);\n      keySystemAccess = this.requestMediaKeySystemAccess(keySystem, mediaKeySystemConfigs);\n      const _keySystemAccessPromises = this.keySystemAccessPromises[keySystem] = {\n        keySystemAccess\n      };\n      keySystemAccess.catch(error => {\n        this.log(`Failed to obtain access to key-system \"${keySystem}\": ${error}`);\n      });\n      return keySystemAccess.then(mediaKeySystemAccess => {\n        this.log(`Access for key-system \"${mediaKeySystemAccess.keySystem}\" obtained`);\n        const certificateRequest = this.fetchServerCertificate(keySystem);\n        this.log(`Create media-keys for \"${keySystem}\"`);\n        _keySystemAccessPromises.mediaKeys = mediaKeySystemAccess.createMediaKeys().then(mediaKeys => {\n          this.log(`Media-keys created for \"${keySystem}\"`);\n          return certificateRequest.then(certificate => {\n            if (certificate) {\n              return this.setMediaKeysServerCertificate(mediaKeys, keySystem, certificate);\n            }\n            return mediaKeys;\n          });\n        });\n        _keySystemAccessPromises.mediaKeys.catch(error => {\n          this.error(`Failed to create media-keys for \"${keySystem}\"}: ${error}`);\n        });\n        return _keySystemAccessPromises.mediaKeys;\n      });\n    }\n    return keySystemAccess.then(() => keySystemAccessPromises.mediaKeys);\n  }\n  createMediaKeySessionContext({\n    decryptdata,\n    keySystem,\n    mediaKeys\n  }) {\n    this.log(`Creating key-system session \"${keySystem}\" keyId: ${Hex.hexDump(decryptdata.keyId || [])}`);\n    const mediaKeysSession = mediaKeys.createSession();\n    const mediaKeySessionContext = {\n      decryptdata,\n      keySystem,\n      mediaKeys,\n      mediaKeysSession,\n      keyStatus: 'status-pending'\n    };\n    this.mediaKeySessions.push(mediaKeySessionContext);\n    return mediaKeySessionContext;\n  }\n  renewKeySession(mediaKeySessionContext) {\n    const decryptdata = mediaKeySessionContext.decryptdata;\n    if (decryptdata.pssh) {\n      const keySessionContext = this.createMediaKeySessionContext(mediaKeySessionContext);\n      const keyId = this.getKeyIdString(decryptdata);\n      const scheme = 'cenc';\n      this.keyIdToKeySessionPromise[keyId] = this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'expired');\n    } else {\n      this.warn(`Could not renew expired session. Missing pssh initData.`);\n    }\n    this.removeSession(mediaKeySessionContext);\n  }\n  getKeyIdString(decryptdata) {\n    if (!decryptdata) {\n      throw new Error('Could not read keyId of undefined decryptdata');\n    }\n    if (decryptdata.keyId === null) {\n      throw new Error('keyId is null');\n    }\n    return Hex.hexDump(decryptdata.keyId);\n  }\n  updateKeySession(mediaKeySessionContext, data) {\n    var _mediaKeySessionConte;\n    const keySession = mediaKeySessionContext.mediaKeysSession;\n    this.log(`Updating key-session \"${keySession.sessionId}\" for keyID ${Hex.hexDump(((_mediaKeySessionConte = mediaKeySessionContext.decryptdata) == null ? void 0 : _mediaKeySessionConte.keyId) || [])}\n      } (data length: ${data ? data.byteLength : data})`);\n    return keySession.update(data);\n  }\n  selectKeySystemFormat(frag) {\n    const keyFormats = Object.keys(frag.levelkeys || {});\n    if (!this.keyFormatPromise) {\n      this.log(`Selecting key-system from fragment (sn: ${frag.sn} ${frag.type}: ${frag.level}) key formats ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n    return this.keyFormatPromise;\n  }\n  getKeyFormatPromise(keyFormats) {\n    return new Promise((resolve, reject) => {\n      const keySystemsInConfig = getKeySystemsForConfig(this.config);\n      const keySystemsToAttempt = keyFormats.map(keySystemFormatToKeySystemDomain).filter(value => !!value && keySystemsInConfig.indexOf(value) !== -1);\n      return this.getKeySystemSelectionPromise(keySystemsToAttempt).then(({\n        keySystem\n      }) => {\n        const keySystemFormat = keySystemDomainToKeySystemFormat(keySystem);\n        if (keySystemFormat) {\n          resolve(keySystemFormat);\n        } else {\n          reject(new Error(`Unable to find format for key-system \"${keySystem}\"`));\n        }\n      }).catch(reject);\n    });\n  }\n  loadKey(data) {\n    const decryptdata = data.keyInfo.decryptdata;\n    const keyId = this.getKeyIdString(decryptdata);\n    const keyDetails = `(keyId: ${keyId} format: \"${decryptdata.keyFormat}\" method: ${decryptdata.method} uri: ${decryptdata.uri})`;\n    this.log(`Starting session for key ${keyDetails}`);\n    let keySessionContextPromise = this.keyIdToKeySessionPromise[keyId];\n    if (!keySessionContextPromise) {\n      keySessionContextPromise = this.keyIdToKeySessionPromise[keyId] = this.getKeySystemForKeyPromise(decryptdata).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        this.throwIfDestroyed();\n        this.log(`Handle encrypted media sn: ${data.frag.sn} ${data.frag.type}: ${data.frag.level} using key ${keyDetails}`);\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          const keySessionContext = this.createMediaKeySessionContext({\n            keySystem,\n            mediaKeys,\n            decryptdata\n          });\n          const scheme = 'cenc';\n          return this.generateRequestWithPreferredKeySession(keySessionContext, scheme, decryptdata.pssh, 'playlist-key');\n        });\n      });\n      keySessionContextPromise.catch(error => this.handleError(error));\n    }\n    return keySessionContextPromise;\n  }\n  throwIfDestroyed(message = 'Invalid state') {\n    if (!this.hls) {\n      throw new Error('invalid state');\n    }\n  }\n  handleError(error) {\n    if (!this.hls) {\n      return;\n    }\n    this.error(error.message);\n    if (error instanceof EMEKeyError) {\n      this.hls.trigger(Events.ERROR, error.data);\n    } else {\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_KEYS,\n        error,\n        fatal: true\n      });\n    }\n  }\n  getKeySystemForKeyPromise(decryptdata) {\n    const keyId = this.getKeyIdString(decryptdata);\n    const mediaKeySessionContext = this.keyIdToKeySessionPromise[keyId];\n    if (!mediaKeySessionContext) {\n      const keySystem = keySystemFormatToKeySystemDomain(decryptdata.keyFormat);\n      const keySystemsToAttempt = keySystem ? [keySystem] : getKeySystemsForConfig(this.config);\n      return this.attemptKeySystemAccess(keySystemsToAttempt);\n    }\n    return mediaKeySessionContext;\n  }\n  getKeySystemSelectionPromise(keySystemsToAttempt) {\n    if (!keySystemsToAttempt.length) {\n      keySystemsToAttempt = getKeySystemsForConfig(this.config);\n    }\n    if (keySystemsToAttempt.length === 0) {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_CONFIGURED_LICENSE,\n        fatal: true\n      }, `Missing key-system license configuration options ${JSON.stringify({\n        drmSystems: this.config.drmSystems\n      })}`);\n    }\n    return this.attemptKeySystemAccess(keySystemsToAttempt);\n  }\n  _onMediaEncrypted(event) {\n    const {\n      initDataType,\n      initData\n    } = event;\n    const logMessage = `\"${event.type}\" event: init data type: \"${initDataType}\"`;\n    this.debug(logMessage);\n\n    // Ignore event when initData is null\n    if (initData === null) {\n      return;\n    }\n    let keyId;\n    let keySystemDomain;\n    if (initDataType === 'sinf' && this.config.drmSystems[KeySystems.FAIRPLAY]) {\n      // Match sinf keyId to playlist skd://keyId=\n      const json = bin2str(new Uint8Array(initData));\n      try {\n        const sinf = base64Decode(JSON.parse(json).sinf);\n        const tenc = parseSinf(new Uint8Array(sinf));\n        if (!tenc) {\n          throw new Error(`'schm' box missing or not cbcs/cenc with schi > tenc`);\n        }\n        keyId = tenc.subarray(8, 24);\n        keySystemDomain = KeySystems.FAIRPLAY;\n      } catch (error) {\n        this.warn(`${logMessage} Failed to parse sinf: ${error}`);\n        return;\n      }\n    } else {\n      // Support Widevine clear-lead key-session creation (otherwise depend on playlist keys)\n      const psshResults = parseMultiPssh(initData);\n      const psshInfo = psshResults.filter(pssh => pssh.systemId === KeySystemIds.WIDEVINE)[0];\n      if (!psshInfo) {\n        if (psshResults.length === 0 || psshResults.some(pssh => !pssh.systemId)) {\n          this.warn(`${logMessage} contains incomplete or invalid pssh data`);\n        } else {\n          this.log(`ignoring ${logMessage} for ${psshResults.map(pssh => keySystemIdToKeySystemDomain(pssh.systemId)).join(',')} pssh data in favor of playlist keys`);\n        }\n        return;\n      }\n      keySystemDomain = keySystemIdToKeySystemDomain(psshInfo.systemId);\n      if (psshInfo.version === 0 && psshInfo.data) {\n        const offset = psshInfo.data.length - 22;\n        keyId = psshInfo.data.subarray(offset, offset + 16);\n      }\n    }\n    if (!keySystemDomain || !keyId) {\n      return;\n    }\n    const keyIdHex = Hex.hexDump(keyId);\n    const {\n      keyIdToKeySessionPromise,\n      mediaKeySessions\n    } = this;\n    let keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex];\n    for (let i = 0; i < mediaKeySessions.length; i++) {\n      // Match playlist key\n      const keyContext = mediaKeySessions[i];\n      const decryptdata = keyContext.decryptdata;\n      if (!decryptdata.keyId) {\n        continue;\n      }\n      const oldKeyIdHex = Hex.hexDump(decryptdata.keyId);\n      if (keyIdHex === oldKeyIdHex || decryptdata.uri.replace(/-/g, '').indexOf(keyIdHex) !== -1) {\n        keySessionContextPromise = keyIdToKeySessionPromise[oldKeyIdHex];\n        if (decryptdata.pssh) {\n          break;\n        }\n        delete keyIdToKeySessionPromise[oldKeyIdHex];\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = keySessionContextPromise.then(() => {\n          return this.generateRequestWithPreferredKeySession(keyContext, initDataType, initData, 'encrypted-event-key-match');\n        });\n        break;\n      }\n    }\n    if (!keySessionContextPromise) {\n      // Clear-lead key (not encountered in playlist)\n      keySessionContextPromise = keyIdToKeySessionPromise[keyIdHex] = this.getKeySystemSelectionPromise([keySystemDomain]).then(({\n        keySystem,\n        mediaKeys\n      }) => {\n        var _keySystemToKeySystem;\n        this.throwIfDestroyed();\n        const decryptdata = new LevelKey('ISO-23001-7', keyIdHex, (_keySystemToKeySystem = keySystemDomainToKeySystemFormat(keySystem)) != null ? _keySystemToKeySystem : '');\n        decryptdata.pssh = new Uint8Array(initData);\n        decryptdata.keyId = keyId;\n        return this.attemptSetMediaKeys(keySystem, mediaKeys).then(() => {\n          this.throwIfDestroyed();\n          const keySessionContext = this.createMediaKeySessionContext({\n            decryptdata,\n            keySystem,\n            mediaKeys\n          });\n          return this.generateRequestWithPreferredKeySession(keySessionContext, initDataType, initData, 'encrypted-event-no-match');\n        });\n      });\n    }\n    keySessionContextPromise.catch(error => this.handleError(error));\n  }\n  _onWaitingForKey(event) {\n    this.log(`\"${event.type}\" event`);\n  }\n  attemptSetMediaKeys(keySystem, mediaKeys) {\n    const queue = this.setMediaKeysQueue.slice();\n    this.log(`Setting media-keys for \"${keySystem}\"`);\n    // Only one setMediaKeys() can run at one time, and multiple setMediaKeys() operations\n    // can be queued for execution for multiple key sessions.\n    const setMediaKeysPromise = Promise.all(queue).then(() => {\n      if (!this.media) {\n        throw new Error('Attempted to set mediaKeys without media element attached');\n      }\n      return this.media.setMediaKeys(mediaKeys);\n    });\n    this.setMediaKeysQueue.push(setMediaKeysPromise);\n    return setMediaKeysPromise.then(() => {\n      this.log(`Media-keys set for \"${keySystem}\"`);\n      queue.push(setMediaKeysPromise);\n      this.setMediaKeysQueue = this.setMediaKeysQueue.filter(p => queue.indexOf(p) === -1);\n    });\n  }\n  generateRequestWithPreferredKeySession(context, initDataType, initData, reason) {\n    var _this$config$drmSyste, _this$config$drmSyste2;\n    const generateRequestFilter = (_this$config$drmSyste = this.config.drmSystems) == null ? void 0 : (_this$config$drmSyste2 = _this$config$drmSyste[context.keySystem]) == null ? void 0 : _this$config$drmSyste2.generateRequest;\n    if (generateRequestFilter) {\n      try {\n        const mappedInitData = generateRequestFilter.call(this.hls, initDataType, initData, context);\n        if (!mappedInitData) {\n          throw new Error('Invalid response from configured generateRequest filter');\n        }\n        initDataType = mappedInitData.initDataType;\n        initData = context.decryptdata.pssh = mappedInitData.initData ? new Uint8Array(mappedInitData.initData) : null;\n      } catch (error) {\n        var _this$hls;\n        this.warn(error.message);\n        if ((_this$hls = this.hls) != null && _this$hls.config.debug) {\n          throw error;\n        }\n      }\n    }\n    if (initData === null) {\n      this.log(`Skipping key-session request for \"${reason}\" (no initData)`);\n      return Promise.resolve(context);\n    }\n    const keyId = this.getKeyIdString(context.decryptdata);\n    this.log(`Generating key-session request for \"${reason}\": ${keyId} (init data type: ${initDataType} length: ${initData ? initData.byteLength : null})`);\n    const licenseStatus = new EventEmitter();\n    const onmessage = context._onmessage = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      const {\n        messageType,\n        message\n      } = event;\n      this.log(`\"${messageType}\" message event for session \"${keySession.sessionId}\" message size: ${message.byteLength}`);\n      if (messageType === 'license-request' || messageType === 'license-renewal') {\n        this.renewLicense(context, message).catch(error => {\n          this.handleError(error);\n          licenseStatus.emit('error', error);\n        });\n      } else if (messageType === 'license-release') {\n        if (context.keySystem === KeySystems.FAIRPLAY) {\n          this.updateKeySession(context, strToUtf8array('acknowledged'));\n          this.removeSession(context);\n        }\n      } else {\n        this.warn(`unhandled media key message type \"${messageType}\"`);\n      }\n    };\n    const onkeystatuseschange = context._onkeystatuseschange = event => {\n      const keySession = context.mediaKeysSession;\n      if (!keySession) {\n        licenseStatus.emit('error', new Error('invalid state'));\n        return;\n      }\n      this.onKeyStatusChange(context);\n      const keyStatus = context.keyStatus;\n      licenseStatus.emit('keyStatus', keyStatus);\n      if (keyStatus === 'expired') {\n        this.warn(`${context.keySystem} expired for key ${keyId}`);\n        this.renewKeySession(context);\n      }\n    };\n    context.mediaKeysSession.addEventListener('message', onmessage);\n    context.mediaKeysSession.addEventListener('keystatuseschange', onkeystatuseschange);\n    const keyUsablePromise = new Promise((resolve, reject) => {\n      licenseStatus.on('error', reject);\n      licenseStatus.on('keyStatus', keyStatus => {\n        if (keyStatus.startsWith('usable')) {\n          resolve();\n        } else if (keyStatus === 'output-restricted') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_OUTPUT_RESTRICTED,\n            fatal: false\n          }, 'HDCP level output restricted'));\n        } else if (keyStatus === 'internal-error') {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_STATUS_INTERNAL_ERROR,\n            fatal: true\n          }, `key status changed to \"${keyStatus}\"`));\n        } else if (keyStatus === 'expired') {\n          reject(new Error('key expired while generating request'));\n        } else {\n          this.warn(`unhandled key status change \"${keyStatus}\"`);\n        }\n      });\n    });\n    return context.mediaKeysSession.generateRequest(initDataType, initData).then(() => {\n      var _context$mediaKeysSes;\n      this.log(`Request generated for key-session \"${(_context$mediaKeysSes = context.mediaKeysSession) == null ? void 0 : _context$mediaKeysSes.sessionId}\" keyId: ${keyId}`);\n    }).catch(error => {\n      throw new EMEKeyError({\n        type: ErrorTypes.KEY_SYSTEM_ERROR,\n        details: ErrorDetails.KEY_SYSTEM_NO_SESSION,\n        error,\n        fatal: false\n      }, `Error generating key-session request: ${error}`);\n    }).then(() => keyUsablePromise).catch(error => {\n      licenseStatus.removeAllListeners();\n      this.removeSession(context);\n      throw error;\n    }).then(() => {\n      licenseStatus.removeAllListeners();\n      return context;\n    });\n  }\n  onKeyStatusChange(mediaKeySessionContext) {\n    mediaKeySessionContext.mediaKeysSession.keyStatuses.forEach((status, keyId) => {\n      this.log(`key status change \"${status}\" for keyStatuses keyId: ${Hex.hexDump('buffer' in keyId ? new Uint8Array(keyId.buffer, keyId.byteOffset, keyId.byteLength) : new Uint8Array(keyId))} session keyId: ${Hex.hexDump(new Uint8Array(mediaKeySessionContext.decryptdata.keyId || []))} uri: ${mediaKeySessionContext.decryptdata.uri}`);\n      mediaKeySessionContext.keyStatus = status;\n    });\n  }\n  fetchServerCertificate(keySystem) {\n    const config = this.config;\n    const Loader = config.loader;\n    const certLoader = new Loader(config);\n    const url = this.getServerCertificateUrl(keySystem);\n    if (!url) {\n      return Promise.resolve();\n    }\n    this.log(`Fetching server certificate for \"${keySystem}\"`);\n    return new Promise((resolve, reject) => {\n      const loaderContext = {\n        responseType: 'arraybuffer',\n        url\n      };\n      const loadPolicy = config.certLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          resolve(response.data);\n        },\n        onError: (response, contex, networkDetails, stats) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: _objectSpread2({\n              url: loaderContext.url,\n              data: undefined\n            }, response)\n          }, `\"${keySystem}\" certificate request failed (${url}). Status: ${response.code} (${response.text})`));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          reject(new EMEKeyError({\n            type: ErrorTypes.KEY_SYSTEM_ERROR,\n            details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_REQUEST_FAILED,\n            fatal: true,\n            networkDetails,\n            response: {\n              url: loaderContext.url,\n              data: undefined\n            }\n          }, `\"${keySystem}\" certificate request timed out (${url})`));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          reject(new Error('aborted'));\n        }\n      };\n      certLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  setMediaKeysServerCertificate(mediaKeys, keySystem, cert) {\n    return new Promise((resolve, reject) => {\n      mediaKeys.setServerCertificate(cert).then(success => {\n        this.log(`setServerCertificate ${success ? 'success' : 'not supported by CDM'} (${cert == null ? void 0 : cert.byteLength}) on \"${keySystem}\"`);\n        resolve(mediaKeys);\n      }).catch(error => {\n        reject(new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SERVER_CERTIFICATE_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message));\n      });\n    });\n  }\n  renewLicense(context, keyMessage) {\n    return this.requestLicense(context, new Uint8Array(keyMessage)).then(data => {\n      return this.updateKeySession(context, new Uint8Array(data)).catch(error => {\n        throw new EMEKeyError({\n          type: ErrorTypes.KEY_SYSTEM_ERROR,\n          details: ErrorDetails.KEY_SYSTEM_SESSION_UPDATE_FAILED,\n          error,\n          fatal: true\n        }, error.message);\n      });\n    });\n  }\n  unpackPlayReadyKeyMessage(xhr, licenseChallenge) {\n    // On Edge, the raw license message is UTF-16-encoded XML.  We need\n    // to unpack the Challenge element (base64-encoded string containing the\n    // actual license request) and any HttpHeader elements (sent as request\n    // headers).\n    // For PlayReady CDMs, we need to dig the Challenge out of the XML.\n    const xmlString = String.fromCharCode.apply(null, new Uint16Array(licenseChallenge.buffer));\n    if (!xmlString.includes('PlayReadyKeyMessage')) {\n      // This does not appear to be a wrapped message as on Edge.  Some\n      // clients do not need this unwrapping, so we will assume this is one of\n      // them.  Note that \"xml\" at this point probably looks like random\n      // garbage, since we interpreted UTF-8 as UTF-16.\n      xhr.setRequestHeader('Content-Type', 'text/xml; charset=utf-8');\n      return licenseChallenge;\n    }\n    const keyMessageXml = new DOMParser().parseFromString(xmlString, 'application/xml');\n    // Set request headers.\n    const headers = keyMessageXml.querySelectorAll('HttpHeader');\n    if (headers.length > 0) {\n      let header;\n      for (let i = 0, len = headers.length; i < len; i++) {\n        var _header$querySelector, _header$querySelector2;\n        header = headers[i];\n        const name = (_header$querySelector = header.querySelector('name')) == null ? void 0 : _header$querySelector.textContent;\n        const value = (_header$querySelector2 = header.querySelector('value')) == null ? void 0 : _header$querySelector2.textContent;\n        if (name && value) {\n          xhr.setRequestHeader(name, value);\n        }\n      }\n    }\n    const challengeElement = keyMessageXml.querySelector('Challenge');\n    const challengeText = challengeElement == null ? void 0 : challengeElement.textContent;\n    if (!challengeText) {\n      throw new Error(`Cannot find <Challenge> in key message`);\n    }\n    return strToUtf8array(atob(challengeText));\n  }\n  setupLicenseXHR(xhr, url, keysListItem, licenseChallenge) {\n    const licenseXhrSetup = this.config.licenseXhrSetup;\n    if (!licenseXhrSetup) {\n      xhr.open('POST', url, true);\n      return Promise.resolve({\n        xhr,\n        licenseChallenge\n      });\n    }\n    return Promise.resolve().then(() => {\n      if (!keysListItem.decryptdata) {\n        throw new Error('Key removed');\n      }\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).catch(error => {\n      if (!keysListItem.decryptdata) {\n        // Key session removed. Cancel license request.\n        throw error;\n      }\n      // let's try to open before running setup\n      xhr.open('POST', url, true);\n      return licenseXhrSetup.call(this.hls, xhr, url, keysListItem, licenseChallenge);\n    }).then(licenseXhrSetupResult => {\n      // if licenseXhrSetup did not yet call open, let's do it now\n      if (!xhr.readyState) {\n        xhr.open('POST', url, true);\n      }\n      const finalLicenseChallenge = licenseXhrSetupResult ? licenseXhrSetupResult : licenseChallenge;\n      return {\n        xhr,\n        licenseChallenge: finalLicenseChallenge\n      };\n    });\n  }\n  requestLicense(keySessionContext, licenseChallenge) {\n    const keyLoadPolicy = this.config.keyLoadPolicy.default;\n    return new Promise((resolve, reject) => {\n      const url = this.getLicenseServerUrl(keySessionContext.keySystem);\n      this.log(`Sending license request to URL: ${url}`);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'arraybuffer';\n      xhr.onreadystatechange = () => {\n        if (!this.hls || !keySessionContext.mediaKeysSession) {\n          return reject(new Error('invalid state'));\n        }\n        if (xhr.readyState === 4) {\n          if (xhr.status === 200) {\n            this._requestLicenseFailureCount = 0;\n            let data = xhr.response;\n            this.log(`License received ${data instanceof ArrayBuffer ? data.byteLength : data}`);\n            const licenseResponseCallback = this.config.licenseResponseCallback;\n            if (licenseResponseCallback) {\n              try {\n                data = licenseResponseCallback.call(this.hls, xhr, url, keySessionContext);\n              } catch (error) {\n                this.error(error);\n              }\n            }\n            resolve(data);\n          } else {\n            const retryConfig = keyLoadPolicy.errorRetry;\n            const maxNumRetry = retryConfig ? retryConfig.maxNumRetry : 0;\n            this._requestLicenseFailureCount++;\n            if (this._requestLicenseFailureCount > maxNumRetry || xhr.status >= 400 && xhr.status < 500) {\n              reject(new EMEKeyError({\n                type: ErrorTypes.KEY_SYSTEM_ERROR,\n                details: ErrorDetails.KEY_SYSTEM_LICENSE_REQUEST_FAILED,\n                fatal: true,\n                networkDetails: xhr,\n                response: {\n                  url,\n                  data: undefined,\n                  code: xhr.status,\n                  text: xhr.statusText\n                }\n              }, `License Request XHR failed (${url}). Status: ${xhr.status} (${xhr.statusText})`));\n            } else {\n              const attemptsLeft = maxNumRetry - this._requestLicenseFailureCount + 1;\n              this.warn(`Retrying license request, ${attemptsLeft} attempts left`);\n              this.requestLicense(keySessionContext, licenseChallenge).then(resolve, reject);\n            }\n          }\n        }\n      };\n      if (keySessionContext.licenseXhr && keySessionContext.licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        keySessionContext.licenseXhr.abort();\n      }\n      keySessionContext.licenseXhr = xhr;\n      this.setupLicenseXHR(xhr, url, keySessionContext, licenseChallenge).then(({\n        xhr,\n        licenseChallenge\n      }) => {\n        if (keySessionContext.keySystem == KeySystems.PLAYREADY) {\n          licenseChallenge = this.unpackPlayReadyKeyMessage(xhr, licenseChallenge);\n        }\n        xhr.send(licenseChallenge);\n      });\n    });\n  }\n  onMediaAttached(event, data) {\n    if (!this.config.emeEnabled) {\n      return;\n    }\n    const media = data.media;\n\n    // keep reference of media\n    this.media = media;\n    media.addEventListener('encrypted', this.onMediaEncrypted);\n    media.addEventListener('waitingforkey', this.onWaitingForKey);\n  }\n  onMediaDetached() {\n    const media = this.media;\n    const mediaKeysList = this.mediaKeySessions;\n    if (media) {\n      media.removeEventListener('encrypted', this.onMediaEncrypted);\n      media.removeEventListener('waitingforkey', this.onWaitingForKey);\n      this.media = null;\n    }\n    this._requestLicenseFailureCount = 0;\n    this.setMediaKeysQueue = [];\n    this.mediaKeySessions = [];\n    this.keyIdToKeySessionPromise = {};\n    LevelKey.clearKeyUriToKeyIdMap();\n\n    // Close all sessions and remove media keys from the video element.\n    const keySessionCount = mediaKeysList.length;\n    EMEController.CDMCleanupPromise = Promise.all(mediaKeysList.map(mediaKeySessionContext => this.removeSession(mediaKeySessionContext)).concat(media == null ? void 0 : media.setMediaKeys(null).catch(error => {\n      this.log(`Could not clear media keys: ${error}`);\n    }))).then(() => {\n      if (keySessionCount) {\n        this.log('finished closing key sessions and clearing media keys');\n        mediaKeysList.length = 0;\n      }\n    }).catch(error => {\n      this.log(`Could not close sessions and clear media keys: ${error}`);\n    });\n  }\n  onManifestLoading() {\n    this.keyFormatPromise = null;\n  }\n  onManifestLoaded(event, {\n    sessionKeys\n  }) {\n    if (!sessionKeys || !this.config.emeEnabled) {\n      return;\n    }\n    if (!this.keyFormatPromise) {\n      const keyFormats = sessionKeys.reduce((formats, sessionKey) => {\n        if (formats.indexOf(sessionKey.keyFormat) === -1) {\n          formats.push(sessionKey.keyFormat);\n        }\n        return formats;\n      }, []);\n      this.log(`Selecting key-system from session-keys ${keyFormats.join(', ')}`);\n      this.keyFormatPromise = this.getKeyFormatPromise(keyFormats);\n    }\n  }\n  removeSession(mediaKeySessionContext) {\n    const {\n      mediaKeysSession,\n      licenseXhr\n    } = mediaKeySessionContext;\n    if (mediaKeysSession) {\n      this.log(`Remove licenses and keys and close session ${mediaKeysSession.sessionId}`);\n      if (mediaKeySessionContext._onmessage) {\n        mediaKeysSession.removeEventListener('message', mediaKeySessionContext._onmessage);\n        mediaKeySessionContext._onmessage = undefined;\n      }\n      if (mediaKeySessionContext._onkeystatuseschange) {\n        mediaKeysSession.removeEventListener('keystatuseschange', mediaKeySessionContext._onkeystatuseschange);\n        mediaKeySessionContext._onkeystatuseschange = undefined;\n      }\n      if (licenseXhr && licenseXhr.readyState !== XMLHttpRequest.DONE) {\n        licenseXhr.abort();\n      }\n      mediaKeySessionContext.mediaKeysSession = mediaKeySessionContext.decryptdata = mediaKeySessionContext.licenseXhr = undefined;\n      const index = this.mediaKeySessions.indexOf(mediaKeySessionContext);\n      if (index > -1) {\n        this.mediaKeySessions.splice(index, 1);\n      }\n      return mediaKeysSession.remove().catch(error => {\n        this.log(`Could not remove session: ${error}`);\n      }).then(() => {\n        return mediaKeysSession.close();\n      }).catch(error => {\n        this.log(`Could not close session: ${error}`);\n      });\n    }\n  }\n}\nEMEController.CDMCleanupPromise = void 0;\nclass EMEKeyError extends Error {\n  constructor(data, message) {\n    super(message);\n    this.data = void 0;\n    data.error || (data.error = new Error(message));\n    this.data = data;\n    data.err = data.error;\n  }\n}\n\n/**\n * Common Media Object Type\n *\n * @group CMCD\n * @group CMSD\n *\n * @beta\n */\nvar CmObjectType;\n(function (CmObjectType) {\n  /**\n   * text file, such as a manifest or playlist\n   */\n  CmObjectType[\"MANIFEST\"] = \"m\";\n  /**\n   * audio only\n   */\n  CmObjectType[\"AUDIO\"] = \"a\";\n  /**\n   * video only\n   */\n  CmObjectType[\"VIDEO\"] = \"v\";\n  /**\n   * muxed audio and video\n   */\n  CmObjectType[\"MUXED\"] = \"av\";\n  /**\n   * init segment\n   */\n  CmObjectType[\"INIT\"] = \"i\";\n  /**\n   * caption or subtitle\n   */\n  CmObjectType[\"CAPTION\"] = \"c\";\n  /**\n   * ISOBMFF timed text track\n   */\n  CmObjectType[\"TIMED_TEXT\"] = \"tt\";\n  /**\n   * cryptographic key, license or certificate.\n   */\n  CmObjectType[\"KEY\"] = \"k\";\n  /**\n   * other\n   */\n  CmObjectType[\"OTHER\"] = \"o\";\n})(CmObjectType || (CmObjectType = {}));\n\n/**\n * Common Media Streaming Format\n *\n * @group CMCD\n * @group CMSD\n *\n * @beta\n */\nvar CmStreamingFormat;\n(function (CmStreamingFormat) {\n  /**\n   * MPEG DASH\n   */\n  CmStreamingFormat[\"DASH\"] = \"d\";\n  /**\n   * HTTP Live Streaming (HLS)\n   */\n  CmStreamingFormat[\"HLS\"] = \"h\";\n  /**\n   * Smooth Streaming\n   */\n  CmStreamingFormat[\"SMOOTH\"] = \"s\";\n  /**\n   * Other\n   */\n  CmStreamingFormat[\"OTHER\"] = \"o\";\n})(CmStreamingFormat || (CmStreamingFormat = {}));\n\n/**\n * CMCD header fields.\n *\n * @group CMCD\n *\n * @beta\n */\nvar CmcdHeaderField;\n(function (CmcdHeaderField) {\n  /**\n   * keys whose values vary with the object being requested.\n   */\n  CmcdHeaderField[\"OBJECT\"] = \"CMCD-Object\";\n  /**\n   * keys whose values vary with each request.\n   */\n  CmcdHeaderField[\"REQUEST\"] = \"CMCD-Request\";\n  /**\n   * keys whose values are expected to be invariant over the life of the session.\n   */\n  CmcdHeaderField[\"SESSION\"] = \"CMCD-Session\";\n  /**\n   * keys whose values do not vary with every request or object.\n   */\n  CmcdHeaderField[\"STATUS\"] = \"CMCD-Status\";\n})(CmcdHeaderField || (CmcdHeaderField = {}));\n\n/**\n * The map of CMCD header fields to official CMCD keys.\n *\n * @internal\n *\n * @group CMCD\n */\nconst CmcdHeaderMap = {\n  [CmcdHeaderField.OBJECT]: ['br', 'd', 'ot', 'tb'],\n  [CmcdHeaderField.REQUEST]: ['bl', 'dl', 'mtp', 'nor', 'nrr', 'su'],\n  [CmcdHeaderField.SESSION]: ['cid', 'pr', 'sf', 'sid', 'st', 'v'],\n  [CmcdHeaderField.STATUS]: ['bs', 'rtp']\n};\n\n/**\n * Structured Field Item\n *\n * @group Structured Field\n *\n * @beta\n */\nclass SfItem {\n  constructor(value, params) {\n    this.value = void 0;\n    this.params = void 0;\n    if (Array.isArray(value)) {\n      value = value.map(v => v instanceof SfItem ? v : new SfItem(v));\n    }\n    this.value = value;\n    this.params = params;\n  }\n}\n\n/**\n * A class to represent structured field tokens when `Symbol` is not available.\n *\n * @group Structured Field\n *\n * @beta\n */\nclass SfToken {\n  constructor(description) {\n    this.description = void 0;\n    this.description = description;\n  }\n}\n\nconst DICT = 'Dict';\n\nfunction format(value) {\n  if (Array.isArray(value)) {\n    return JSON.stringify(value);\n  }\n  if (value instanceof Map) {\n    return 'Map{}';\n  }\n  if (value instanceof Set) {\n    return 'Set{}';\n  }\n  if (typeof value === 'object') {\n    return JSON.stringify(value);\n  }\n  return String(value);\n}\nfunction throwError(action, src, type, cause) {\n  return new Error(`failed to ${action} \"${format(src)}\" as ${type}`, {\n    cause\n  });\n}\n\nconst BARE_ITEM = 'Bare Item';\n\nconst BOOLEAN = 'Boolean';\n\nconst BYTES = 'Byte Sequence';\n\nconst DECIMAL = 'Decimal';\n\nconst INTEGER = 'Integer';\n\nfunction isInvalidInt(value) {\n  return value < -999999999999999 || 999999999999999 < value;\n}\n\nconst STRING_REGEX = /[\\x00-\\x1f\\x7f]+/; // eslint-disable-line no-control-regex\n\nconst TOKEN = 'Token';\n\nconst KEY = 'Key';\n\nfunction serializeError(src, type, cause) {\n  return throwError('serialize', src, type, cause);\n}\n\n// 4.1.9.  Serializing a Boolean\n//\n// Given a Boolean as input_boolean, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  If input_boolean is not a boolean, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \"?\" to output.\n//\n// 4.  If input_boolean is true, append \"1\" to output.\n//\n// 5.  If input_boolean is false, append \"0\" to output.\n//\n// 6.  Return output.\nfunction serializeBoolean(value) {\n  if (typeof value !== 'boolean') {\n    throw serializeError(value, BOOLEAN);\n  }\n  return value ? '?1' : '?0';\n}\n\n/**\n * Encodes binary data to base64\n *\n * @param binary - The binary data to encode\n * @returns The base64 encoded string\n *\n * @group Utils\n *\n * @beta\n */\nfunction base64encode(binary) {\n  return btoa(String.fromCharCode(...binary));\n}\n\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\nfunction serializeByteSequence(value) {\n  if (ArrayBuffer.isView(value) === false) {\n    throw serializeError(value, BYTES);\n  }\n  return `:${base64encode(value)}:`;\n}\n\n// 4.1.4.  Serializing an Integer\n//\n// Given an Integer as input_integer, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_integer is not an integer in the range of\n//     -999,999,999,999,999 to 999,999,999,999,999 inclusive, fail\n//     serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  If input_integer is less than (but not equal to) 0, append \"-\" to\n//     output.\n//\n// 4.  Append input_integer's numeric value represented in base 10 using\n//     only decimal digits to output.\n//\n// 5.  Return output.\nfunction serializeInteger(value) {\n  if (isInvalidInt(value)) {\n    throw serializeError(value, INTEGER);\n  }\n  return value.toString();\n}\n\n// 4.1.10.  Serializing a Date\n//\n// Given a Date as input_integer, return an ASCII string suitable for\n// use in an HTTP field value.\n// 1.  Let output be \"@\".\n// 2.  Append to output the result of running Serializing an Integer\n//     with input_date (Section 4.1.4).\n// 3.  Return output.\nfunction serializeDate(value) {\n  return `@${serializeInteger(value.getTime() / 1000)}`;\n}\n\n/**\n * This implements the rounding procedure described in step 2 of the \"Serializing a Decimal\" specification.\n * This rounding style is known as \"even rounding\", \"banker's rounding\", or \"commercial rounding\".\n *\n * @param value - The value to round\n * @param precision - The number of decimal places to round to\n * @returns The rounded value\n *\n * @group Utils\n *\n * @beta\n */\nfunction roundToEven(value, precision) {\n  if (value < 0) {\n    return -roundToEven(-value, precision);\n  }\n  const decimalShift = Math.pow(10, precision);\n  const isEquidistant = Math.abs(value * decimalShift % 1 - 0.5) < Number.EPSILON;\n  if (isEquidistant) {\n    // If the tail of the decimal place is 'equidistant' we round to the nearest even value\n    const flooredValue = Math.floor(value * decimalShift);\n    return (flooredValue % 2 === 0 ? flooredValue : flooredValue + 1) / decimalShift;\n  } else {\n    // Otherwise, proceed as normal\n    return Math.round(value * decimalShift) / decimalShift;\n  }\n}\n\n// 4.1.5.  Serializing a Decimal\n//\n// Given a decimal number as input_decimal, return an ASCII string\n// suitable for use in a HTTP field value.\n//\n// 1.   If input_decimal is not a decimal number, fail serialization.\n//\n// 2.   If input_decimal has more than three significant digits to the\n//      right of the decimal point, round it to three decimal places,\n//      rounding the final digit to the nearest value, or to the even\n//      value if it is equidistant.\n//\n// 3.   If input_decimal has more than 12 significant digits to the left\n//      of the decimal point after rounding, fail serialization.\n//\n// 4.   Let output be an empty string.\n//\n// 5.   If input_decimal is less than (but not equal to) 0, append \"-\"\n//      to output.\n//\n// 6.   Append input_decimal's integer component represented in base 10\n//      (using only decimal digits) to output; if it is zero, append\n//      \"0\".\n//\n// 7.   Append \".\" to output.\n//\n// 8.   If input_decimal's fractional component is zero, append \"0\" to\n//      output.\n//\n// 9.   Otherwise, append the significant digits of input_decimal's\n//      fractional component represented in base 10 (using only decimal\n//      digits) to output.\n//\n// 10.  Return output.\nfunction serializeDecimal(value) {\n  const roundedValue = roundToEven(value, 3); // round to 3 decimal places\n  if (Math.floor(Math.abs(roundedValue)).toString().length > 12) {\n    throw serializeError(value, DECIMAL);\n  }\n  const stringValue = roundedValue.toString();\n  return stringValue.includes('.') ? stringValue : `${stringValue}.0`;\n}\n\nconst STRING = 'String';\n\n// 4.1.6.  Serializing a String\n//\n// Given a String as input_string, return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Convert input_string into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_string contains characters in the range %x00-1f or %x7f\n//     (i.e., not in VCHAR or SP), fail serialization.\n//\n// 3.  Let output be the string DQUOTE.\n//\n// 4.  For each character char in input_string:\n//\n//     1.  If char is \"\\\" or DQUOTE:\n//\n//         1.  Append \"\\\" to output.\n//\n//     2.  Append char to output.\n//\n// 5.  Append DQUOTE to output.\n//\n// 6.  Return output.\nfunction serializeString(value) {\n  if (STRING_REGEX.test(value)) {\n    throw serializeError(value, STRING);\n  }\n  return `\"${value.replace(/\\\\/g, `\\\\\\\\`).replace(/\"/g, `\\\\\"`)}\"`;\n}\n\nfunction symbolToStr(symbol) {\n  return symbol.description || symbol.toString().slice(7, -1);\n}\n\nfunction serializeToken(token) {\n  const value = symbolToStr(token);\n  if (/^([a-zA-Z*])([!#$%&'*+\\-.^_`|~\\w:/]*)$/.test(value) === false) {\n    throw serializeError(value, TOKEN);\n  }\n  return value;\n}\n\n// 4.1.3.1.  Serializing a Bare Item\n//\n// Given an Item as input_item, return an ASCII string suitable for use\n// in a HTTP field value.\n//\n// 1.  If input_item is an Integer, return the result of running\n//     Serializing an Integer (Section 4.1.4) with input_item.\n//\n// 2.  If input_item is a Decimal, return the result of running\n//     Serializing a Decimal (Section 4.1.5) with input_item.\n//\n// 3.  If input_item is a String, return the result of running\n//     Serializing a String (Section 4.1.6) with input_item.\n//\n// 4.  If input_item is a Token, return the result of running\n//     Serializing a Token (Section 4.1.7) with input_item.\n//\n// 5.  If input_item is a Boolean, return the result of running\n//     Serializing a Boolean (Section 4.1.9) with input_item.\n//\n// 6.  If input_item is a Byte Sequence, return the result of running\n//     Serializing a Byte Sequence (Section 4.1.8) with input_item.\n//\n// 7.  If input_item is a Date, return the result of running Serializing\n//     a Date (Section 4.1.10) with input_item.\n//\n// 8.  Otherwise, fail serialization.\nfunction serializeBareItem(value) {\n  switch (typeof value) {\n    case 'number':\n      if (!isFiniteNumber(value)) {\n        throw serializeError(value, BARE_ITEM);\n      }\n      if (Number.isInteger(value)) {\n        return serializeInteger(value);\n      }\n      return serializeDecimal(value);\n    case 'string':\n      return serializeString(value);\n    case 'symbol':\n      return serializeToken(value);\n    case 'boolean':\n      return serializeBoolean(value);\n    case 'object':\n      if (value instanceof Date) {\n        return serializeDate(value);\n      }\n      if (value instanceof Uint8Array) {\n        return serializeByteSequence(value);\n      }\n      if (value instanceof SfToken) {\n        return serializeToken(value);\n      }\n    default:\n      // fail\n      throw serializeError(value, BARE_ITEM);\n  }\n}\n\n// 4.1.1.3.  Serializing a Key\n//\n// Given a key as input_key, return an ASCII string suitable for use in\n// a HTTP field value.\n//\n// 1.  Convert input_key into a sequence of ASCII characters; if\n//     conversion fails, fail serialization.\n//\n// 2.  If input_key contains characters not in lcalpha, DIGIT, \"_\", \"-\",\n//     \".\", or \"*\" fail serialization.\n//\n// 3.  If the first character of input_key is not lcalpha or \"*\", fail\n//     serialization.\n//\n// 4.  Let output be an empty string.\n//\n// 5.  Append input_key to output.\n//\n// 6.  Return output.\nfunction serializeKey(value) {\n  if (/^[a-z*][a-z0-9\\-_.*]*$/.test(value) === false) {\n    throw serializeError(value, KEY);\n  }\n  return value;\n}\n\n// 4.1.1.2.  Serializing Parameters\n//\n// Given an ordered Dictionary as input_parameters (each member having a\n// param_name and a param_value), return an ASCII string suitable for\n// use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each param_name with a value of param_value in\n//     input_parameters:\n//\n//     1.  Append \";\" to output.\n//\n//     2.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with param_name to output.\n//\n//     3.  If param_value is not Boolean true:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  Append the result of running Serializing a bare Item\n//             (Section 4.1.3.1) with param_value to output.\n//\n// 3.  Return output.\nfunction serializeParams(params) {\n  if (params == null) {\n    return '';\n  }\n  return Object.entries(params).map(([key, value]) => {\n    if (value === true) {\n      return `;${serializeKey(key)}`; // omit true\n    }\n    return `;${serializeKey(key)}=${serializeBareItem(value)}`;\n  }).join('');\n}\n\n// 4.1.3.  Serializing an Item\n//\n// Given an Item as bare_item and Parameters as item_parameters, return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  Append the result of running Serializing a Bare Item\n//     Section 4.1.3.1 with bare_item to output.\n//\n// 3.  Append the result of running Serializing Parameters\n//     Section 4.1.1.2 with item_parameters to output.\n//\n// 4.  Return output.\nfunction serializeItem(value) {\n  if (value instanceof SfItem) {\n    return `${serializeBareItem(value.value)}${serializeParams(value.params)}`;\n  } else {\n    return serializeBareItem(value);\n  }\n}\n\n// 4.1.1.1.  Serializing an Inner List\n//\n// Given an array of (member_value, parameters) tuples as inner_list,\n// and parameters as list_parameters, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  Let output be the string \"(\".\n//\n// 2.  For each (member_value, parameters) of inner_list:\n//\n//     1.  Append the result of running Serializing an Item\n//         (Section 4.1.3) with (member_value, parameters) to output.\n//\n//     2.  If more values remain in inner_list, append a single SP to\n//         output.\n//\n// 3.  Append \")\" to output.\n//\n// 4.  Append the result of running Serializing Parameters\n//     (Section 4.1.1.2) with list_parameters to output.\n//\n// 5.  Return output.\nfunction serializeInnerList(value) {\n  return `(${value.value.map(serializeItem).join(' ')})${serializeParams(value.params)}`;\n}\n\n// 4.1.2.  Serializing a Dictionary\n//\n// Given an ordered Dictionary as input_dictionary (each member having a\n// member_name and a tuple value of (member_value, parameters)), return\n// an ASCII string suitable for use in a HTTP field value.\n//\n// 1.  Let output be an empty string.\n//\n// 2.  For each member_name with a value of (member_value, parameters)\n//     in input_dictionary:\n//\n//     1.  Append the result of running Serializing a Key\n//         (Section 4.1.1.3) with member's member_name to output.\n//\n//     2.  If member_value is Boolean true:\n//\n//         1.  Append the result of running Serializing Parameters\n//             (Section 4.1.1.2) with parameters to output.\n//\n//     3.  Otherwise:\n//\n//         1.  Append \"=\" to output.\n//\n//         2.  If member_value is an array, append the result of running\n//             Serializing an Inner List (Section 4.1.1.1) with\n//             (member_value, parameters) to output.\n//\n//         3.  Otherwise, append the result of running Serializing an\n//             Item (Section 4.1.3) with (member_value, parameters) to\n//             output.\n//\n//     4.  If more members remain in input_dictionary:\n//\n//         1.  Append \",\" to output.\n//\n//         2.  Append a single SP to output.\n//\n// 3.  Return output.\nfunction serializeDict(dict, options = {\n  whitespace: true\n}) {\n  if (typeof dict !== 'object') {\n    throw serializeError(dict, DICT);\n  }\n  const entries = dict instanceof Map ? dict.entries() : Object.entries(dict);\n  const optionalWhiteSpace = options != null && options.whitespace ? ' ' : '';\n  return Array.from(entries).map(([key, item]) => {\n    if (item instanceof SfItem === false) {\n      item = new SfItem(item);\n    }\n    let output = serializeKey(key);\n    if (item.value === true) {\n      output += serializeParams(item.params);\n    } else {\n      output += '=';\n      if (Array.isArray(item.value)) {\n        output += serializeInnerList(item);\n      } else {\n        output += serializeItem(item);\n      }\n    }\n    return output;\n  }).join(`,${optionalWhiteSpace}`);\n}\n\n/**\n * Encode an object into a structured field dictionary\n *\n * @param input - The structured field dictionary to encode\n * @returns The structured field string\n *\n * @group Structured Field\n *\n * @beta\n */\nfunction encodeSfDict(value, options) {\n  return serializeDict(value, options);\n}\n\n/**\n * Checks if the given key is a token field.\n *\n * @param key - The key to check.\n *\n * @returns `true` if the key is a token field.\n *\n * @internal\n *\n * @group CMCD\n */\nconst isTokenField = key => key === 'ot' || key === 'sf' || key === 'st';\n\nconst isValid = value => {\n  if (typeof value === 'number') {\n    return isFiniteNumber(value);\n  }\n  return value != null && value !== '' && value !== false;\n};\n\n/**\n * Constructs a relative path from a URL.\n *\n * @param url - The destination URL\n * @param base - The base URL\n * @returns The relative path\n *\n * @group Utils\n *\n * @beta\n */\nfunction urlToRelativePath(url, base) {\n  const to = new URL(url);\n  const from = new URL(base);\n  if (to.origin !== from.origin) {\n    return url;\n  }\n  const toPath = to.pathname.split('/').slice(1);\n  const fromPath = from.pathname.split('/').slice(1, -1);\n  // remove common parents\n  while (toPath[0] === fromPath[0]) {\n    toPath.shift();\n    fromPath.shift();\n  }\n  // add back paths\n  while (fromPath.length) {\n    fromPath.shift();\n    toPath.unshift('..');\n  }\n  return toPath.join('/');\n}\n\n/**\n * Generate a random v4 UUID\n *\n * @returns A random v4 UUID\n *\n * @group Utils\n *\n * @beta\n */\nfunction uuid() {\n  try {\n    return crypto.randomUUID();\n  } catch (error) {\n    try {\n      const url = URL.createObjectURL(new Blob());\n      const uuid = url.toString();\n      URL.revokeObjectURL(url);\n      return uuid.slice(uuid.lastIndexOf('/') + 1);\n    } catch (error) {\n      let dt = new Date().getTime();\n      const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n        const r = (dt + Math.random() * 16) % 16 | 0;\n        dt = Math.floor(dt / 16);\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n      });\n      return uuid;\n    }\n  }\n}\n\nconst toRounded = value => Math.round(value);\nconst toUrlSafe = (value, options) => {\n  if (options != null && options.baseUrl) {\n    value = urlToRelativePath(value, options.baseUrl);\n  }\n  return encodeURIComponent(value);\n};\nconst toHundred = value => toRounded(value / 100) * 100;\n/**\n * The default formatters for CMCD values.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CmcdFormatters = {\n  /**\n   * Bitrate (kbps) rounded integer\n   */\n  br: toRounded,\n  /**\n   * Duration (milliseconds) rounded integer\n   */\n  d: toRounded,\n  /**\n   * Buffer Length (milliseconds) rounded nearest 100ms\n   */\n  bl: toHundred,\n  /**\n   * Deadline (milliseconds) rounded nearest 100ms\n   */\n  dl: toHundred,\n  /**\n   * Measured Throughput (kbps) rounded nearest 100kbps\n   */\n  mtp: toHundred,\n  /**\n   * Next Object Request URL encoded\n   */\n  nor: toUrlSafe,\n  /**\n   * Requested maximum throughput (kbps) rounded nearest 100kbps\n   */\n  rtp: toHundred,\n  /**\n   * Top Bitrate (kbps) rounded integer\n   */\n  tb: toRounded\n};\n\n/**\n * Internal CMCD processing function.\n *\n * @param obj - The CMCD object to process.\n * @param map - The mapping function to use.\n * @param options - Options for encoding.\n *\n * @internal\n *\n * @group CMCD\n */\nfunction processCmcd(obj, options) {\n  const results = {};\n  if (obj == null || typeof obj !== 'object') {\n    return results;\n  }\n  const keys = Object.keys(obj).sort();\n  const formatters = _extends({}, CmcdFormatters, options == null ? void 0 : options.formatters);\n  const filter = options == null ? void 0 : options.filter;\n  keys.forEach(key => {\n    if (filter != null && filter(key)) {\n      return;\n    }\n    let value = obj[key];\n    const formatter = formatters[key];\n    if (formatter) {\n      value = formatter(value, options);\n    }\n    // Version should only be reported if not equal to 1.\n    if (key === 'v' && value === 1) {\n      return;\n    }\n    // Playback rate should only be sent if not equal to 1.\n    if (key == 'pr' && value === 1) {\n      return;\n    }\n    // ignore invalid values\n    if (!isValid(value)) {\n      return;\n    }\n    if (isTokenField(key) && typeof value === 'string') {\n      value = new SfToken(value);\n    }\n    results[key] = value;\n  });\n  return results;\n}\n\n/**\n * Encode a CMCD object to a string.\n *\n * @param cmcd - The CMCD object to encode.\n * @param options - Options for encoding.\n *\n * @returns The encoded CMCD string.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction encodeCmcd(cmcd, options = {}) {\n  if (!cmcd) {\n    return '';\n  }\n  return encodeSfDict(processCmcd(cmcd, options), _extends({\n    whitespace: false\n  }, options));\n}\n\n/**\n * Convert a CMCD data object to request headers\n *\n * @param cmcd - The CMCD data object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD header shards.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction toCmcdHeaders(cmcd, options = {}) {\n  if (!cmcd) {\n    return {};\n  }\n  const entries = Object.entries(cmcd);\n  const headerMap = Object.entries(CmcdHeaderMap).concat(Object.entries((options == null ? void 0 : options.customHeaderMap) || {}));\n  const shards = entries.reduce((acc, entry) => {\n    var _headerMap$find, _acc$field;\n    const [key, value] = entry;\n    const field = ((_headerMap$find = headerMap.find(entry => entry[1].includes(key))) == null ? void 0 : _headerMap$find[0]) || CmcdHeaderField.REQUEST;\n    (_acc$field = acc[field]) != null ? _acc$field : acc[field] = {};\n    acc[field][key] = value;\n    return acc;\n  }, {});\n  return Object.entries(shards).reduce((acc, [field, value]) => {\n    acc[field] = encodeCmcd(value, options);\n    return acc;\n  }, {});\n}\n\n/**\n * Append CMCD query args to a header object.\n *\n * @param headers - The headers to append to.\n * @param cmcd - The CMCD object to append.\n * @param customHeaderMap - A map of custom CMCD keys to header fields.\n *\n * @returns The headers with the CMCD header shards appended.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction appendCmcdHeaders(headers, cmcd, options) {\n  return _extends(headers, toCmcdHeaders(cmcd, options));\n}\n\n/**\n * CMCD parameter name.\n *\n * @group CMCD\n *\n * @beta\n */\nconst CMCD_PARAM = 'CMCD';\n\n/**\n * Convert a CMCD data object to a query arg.\n *\n * @param cmcd - The CMCD object to convert.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The CMCD query arg.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction toCmcdQuery(cmcd, options = {}) {\n  if (!cmcd) {\n    return '';\n  }\n  const params = encodeCmcd(cmcd, options);\n  return `${CMCD_PARAM}=${encodeURIComponent(params)}`;\n}\n\nconst REGEX = /CMCD=[^&#]+/;\n/**\n * Append CMCD query args to a URL.\n *\n * @param url - The URL to append to.\n * @param cmcd - The CMCD object to append.\n * @param options - Options for encoding the CMCD object.\n *\n * @returns The URL with the CMCD query args appended.\n *\n * @group CMCD\n *\n * @beta\n */\nfunction appendCmcdQuery(url, cmcd, options) {\n  // TODO: Replace with URLSearchParams once we drop Safari < 10.1 & Chrome < 49 support.\n  // https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams\n  const query = toCmcdQuery(cmcd, options);\n  if (!query) {\n    return url;\n  }\n  if (REGEX.test(url)) {\n    return url.replace(REGEX, query);\n  }\n  const separator = url.includes('?') ? '&' : '?';\n  return `${url}${separator}${query}`;\n}\n\n/**\n * Controller to deal with Common Media Client Data (CMCD)\n * @see https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5004-final.pdf\n */\nclass CMCDController {\n  // eslint-disable-line no-restricted-globals\n\n  constructor(hls) {\n    this.hls = void 0;\n    this.config = void 0;\n    this.media = void 0;\n    this.sid = void 0;\n    this.cid = void 0;\n    this.useHeaders = false;\n    this.includeKeys = void 0;\n    this.initialized = false;\n    this.starved = false;\n    this.buffering = true;\n    this.audioBuffer = void 0;\n    // eslint-disable-line no-restricted-globals\n    this.videoBuffer = void 0;\n    this.onWaiting = () => {\n      if (this.initialized) {\n        this.starved = true;\n      }\n      this.buffering = true;\n    };\n    this.onPlaying = () => {\n      if (!this.initialized) {\n        this.initialized = true;\n      }\n      this.buffering = false;\n    };\n    /**\n     * Apply CMCD data to a manifest request.\n     */\n    this.applyPlaylistData = context => {\n      try {\n        this.apply(context, {\n          ot: CmObjectType.MANIFEST,\n          su: !this.initialized\n        });\n      } catch (error) {\n        logger.warn('Could not generate manifest CMCD data.', error);\n      }\n    };\n    /**\n     * Apply CMCD data to a segment request\n     */\n    this.applyFragmentData = context => {\n      try {\n        const fragment = context.frag;\n        const level = this.hls.levels[fragment.level];\n        const ot = this.getObjectType(fragment);\n        const data = {\n          d: fragment.duration * 1000,\n          ot\n        };\n        if (ot === CmObjectType.VIDEO || ot === CmObjectType.AUDIO || ot == CmObjectType.MUXED) {\n          data.br = level.bitrate / 1000;\n          data.tb = this.getTopBandwidth(ot) / 1000;\n          data.bl = this.getBufferLength(ot);\n        }\n        this.apply(context, data);\n      } catch (error) {\n        logger.warn('Could not generate segment CMCD data.', error);\n      }\n    };\n    this.hls = hls;\n    const config = this.config = hls.config;\n    const {\n      cmcd\n    } = config;\n    if (cmcd != null) {\n      config.pLoader = this.createPlaylistLoader();\n      config.fLoader = this.createFragmentLoader();\n      this.sid = cmcd.sessionId || uuid();\n      this.cid = cmcd.contentId;\n      this.useHeaders = cmcd.useHeaders === true;\n      this.includeKeys = cmcd.includeKeys;\n      this.registerListeners();\n    }\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHED, this.onMediaDetached, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.onMediaDetached();\n\n    // @ts-ignore\n    this.hls = this.config = this.audioBuffer = this.videoBuffer = null;\n    // @ts-ignore\n    this.onWaiting = this.onPlaying = null;\n  }\n  onMediaAttached(event, data) {\n    this.media = data.media;\n    this.media.addEventListener('waiting', this.onWaiting);\n    this.media.addEventListener('playing', this.onPlaying);\n  }\n  onMediaDetached() {\n    if (!this.media) {\n      return;\n    }\n    this.media.removeEventListener('waiting', this.onWaiting);\n    this.media.removeEventListener('playing', this.onPlaying);\n\n    // @ts-ignore\n    this.media = null;\n  }\n  onBufferCreated(event, data) {\n    var _data$tracks$audio, _data$tracks$video;\n    this.audioBuffer = (_data$tracks$audio = data.tracks.audio) == null ? void 0 : _data$tracks$audio.buffer;\n    this.videoBuffer = (_data$tracks$video = data.tracks.video) == null ? void 0 : _data$tracks$video.buffer;\n  }\n  /**\n   * Create baseline CMCD data\n   */\n  createData() {\n    var _this$media;\n    return {\n      v: 1,\n      sf: CmStreamingFormat.HLS,\n      sid: this.sid,\n      cid: this.cid,\n      pr: (_this$media = this.media) == null ? void 0 : _this$media.playbackRate,\n      mtp: this.hls.bandwidthEstimate / 1000\n    };\n  }\n\n  /**\n   * Apply CMCD data to a request.\n   */\n  apply(context, data = {}) {\n    // apply baseline data\n    _extends(data, this.createData());\n    const isVideo = data.ot === CmObjectType.INIT || data.ot === CmObjectType.VIDEO || data.ot === CmObjectType.MUXED;\n    if (this.starved && isVideo) {\n      data.bs = true;\n      data.su = true;\n      this.starved = false;\n    }\n    if (data.su == null) {\n      data.su = this.buffering;\n    }\n\n    // TODO: Implement rtp, nrr, nor, dl\n\n    const {\n      includeKeys\n    } = this;\n    if (includeKeys) {\n      data = Object.keys(data).reduce((acc, key) => {\n        includeKeys.includes(key) && (acc[key] = data[key]);\n        return acc;\n      }, {});\n    }\n    if (this.useHeaders) {\n      if (!context.headers) {\n        context.headers = {};\n      }\n      appendCmcdHeaders(context.headers, data);\n    } else {\n      context.url = appendCmcdQuery(context.url, data);\n    }\n  }\n  /**\n   * The CMCD object type.\n   */\n  getObjectType(fragment) {\n    const {\n      type\n    } = fragment;\n    if (type === 'subtitle') {\n      return CmObjectType.TIMED_TEXT;\n    }\n    if (fragment.sn === 'initSegment') {\n      return CmObjectType.INIT;\n    }\n    if (type === 'audio') {\n      return CmObjectType.AUDIO;\n    }\n    if (type === 'main') {\n      if (!this.hls.audioTracks.length) {\n        return CmObjectType.MUXED;\n      }\n      return CmObjectType.VIDEO;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get the highest bitrate.\n   */\n  getTopBandwidth(type) {\n    let bitrate = 0;\n    let levels;\n    const hls = this.hls;\n    if (type === CmObjectType.AUDIO) {\n      levels = hls.audioTracks;\n    } else {\n      const max = hls.maxAutoLevel;\n      const len = max > -1 ? max + 1 : hls.levels.length;\n      levels = hls.levels.slice(0, len);\n    }\n    for (const level of levels) {\n      if (level.bitrate > bitrate) {\n        bitrate = level.bitrate;\n      }\n    }\n    return bitrate > 0 ? bitrate : NaN;\n  }\n\n  /**\n   * Get the buffer length for a media type in milliseconds\n   */\n  getBufferLength(type) {\n    const media = this.hls.media;\n    const buffer = type === CmObjectType.AUDIO ? this.audioBuffer : this.videoBuffer;\n    if (!buffer || !media) {\n      return NaN;\n    }\n    const info = BufferHelper.bufferInfo(buffer, media.currentTime, this.config.maxBufferHole);\n    return info.len * 1000;\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createPlaylistLoader() {\n    const {\n      pLoader\n    } = this.config;\n    const apply = this.applyPlaylistData;\n    const Ctor = pLoader || this.config.loader;\n    return class CmcdPlaylistLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n\n  /**\n   * Create a playlist loader\n   */\n  createFragmentLoader() {\n    const {\n      fLoader\n    } = this.config;\n    const apply = this.applyFragmentData;\n    const Ctor = fLoader || this.config.loader;\n    return class CmcdFragmentLoader {\n      constructor(config) {\n        this.loader = void 0;\n        this.loader = new Ctor(config);\n      }\n      get stats() {\n        return this.loader.stats;\n      }\n      get context() {\n        return this.loader.context;\n      }\n      destroy() {\n        this.loader.destroy();\n      }\n      abort() {\n        this.loader.abort();\n      }\n      load(context, config, callbacks) {\n        apply(context);\n        this.loader.load(context, config, callbacks);\n      }\n    };\n  }\n}\n\nconst PATHWAY_PENALTY_DURATION_MS = 300000;\nclass ContentSteeringController {\n  constructor(hls) {\n    this.hls = void 0;\n    this.log = void 0;\n    this.loader = null;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.pathwayPriority = null;\n    this.timeToLoad = 300;\n    this.reloadTimer = -1;\n    this.updated = 0;\n    this.started = false;\n    this.enabled = true;\n    this.levels = null;\n    this.audioTracks = null;\n    this.subtitleTracks = null;\n    this.penalizedPathways = {};\n    this.hls = hls;\n    this.log = logger.log.bind(logger, `[content-steering]:`);\n    this.registerListeners();\n  }\n  registerListeners() {\n    const hls = this.hls;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  unregisterListeners() {\n    const hls = this.hls;\n    if (!hls) {\n      return;\n    }\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  startLoad() {\n    this.started = true;\n    this.clearTimeout();\n    if (this.enabled && this.uri) {\n      if (this.updated) {\n        const ttl = this.timeToLoad * 1000 - (performance.now() - this.updated);\n        if (ttl > 0) {\n          this.scheduleRefresh(this.uri, ttl);\n          return;\n        }\n      }\n      this.loadSteeringManifest(this.uri);\n    }\n  }\n  stopLoad() {\n    this.started = false;\n    if (this.loader) {\n      this.loader.destroy();\n      this.loader = null;\n    }\n    this.clearTimeout();\n  }\n  clearTimeout() {\n    if (this.reloadTimer !== -1) {\n      self.clearTimeout(this.reloadTimer);\n      this.reloadTimer = -1;\n    }\n  }\n  destroy() {\n    this.unregisterListeners();\n    this.stopLoad();\n    // @ts-ignore\n    this.hls = null;\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  removeLevel(levelToRemove) {\n    const levels = this.levels;\n    if (levels) {\n      this.levels = levels.filter(level => level !== levelToRemove);\n    }\n  }\n  onManifestLoading() {\n    this.stopLoad();\n    this.enabled = true;\n    this.timeToLoad = 300;\n    this.updated = 0;\n    this.uri = null;\n    this.pathwayId = '.';\n    this.levels = this.audioTracks = this.subtitleTracks = null;\n  }\n  onManifestLoaded(event, data) {\n    const {\n      contentSteering\n    } = data;\n    if (contentSteering === null) {\n      return;\n    }\n    this.pathwayId = contentSteering.pathwayId;\n    this.uri = contentSteering.uri;\n    if (this.started) {\n      this.startLoad();\n    }\n  }\n  onManifestParsed(event, data) {\n    this.audioTracks = data.audioTracks;\n    this.subtitleTracks = data.subtitleTracks;\n  }\n  onError(event, data) {\n    const {\n      errorAction\n    } = data;\n    if ((errorAction == null ? void 0 : errorAction.action) === NetworkErrorAction.SendAlternateToPenaltyBox && errorAction.flags === ErrorActionFlags.MoveAllAlternatesMatchingHost) {\n      const levels = this.levels;\n      let pathwayPriority = this.pathwayPriority;\n      let errorPathway = this.pathwayId;\n      if (data.context) {\n        const {\n          groupId,\n          pathwayId,\n          type\n        } = data.context;\n        if (groupId && levels) {\n          errorPathway = this.getPathwayForGroupId(groupId, type, errorPathway);\n        } else if (pathwayId) {\n          errorPathway = pathwayId;\n        }\n      }\n      if (!(errorPathway in this.penalizedPathways)) {\n        this.penalizedPathways[errorPathway] = performance.now();\n      }\n      if (!pathwayPriority && levels) {\n        // If PATHWAY-PRIORITY was not provided, list pathways for error handling\n        pathwayPriority = levels.reduce((pathways, level) => {\n          if (pathways.indexOf(level.pathwayId) === -1) {\n            pathways.push(level.pathwayId);\n          }\n          return pathways;\n        }, []);\n      }\n      if (pathwayPriority && pathwayPriority.length > 1) {\n        this.updatePathwayPriority(pathwayPriority);\n        errorAction.resolved = this.pathwayId !== errorPathway;\n      }\n      if (!errorAction.resolved) {\n        logger.warn(`Could not resolve ${data.details} (\"${data.error.message}\") with content-steering for Pathway: ${errorPathway} levels: ${levels ? levels.length : levels} priorities: ${JSON.stringify(pathwayPriority)} penalized: ${JSON.stringify(this.penalizedPathways)}`);\n      }\n    }\n  }\n  filterParsedLevels(levels) {\n    // Filter levels to only include those that are in the initial pathway\n    this.levels = levels;\n    let pathwayLevels = this.getLevelsForPathway(this.pathwayId);\n    if (pathwayLevels.length === 0) {\n      const pathwayId = levels[0].pathwayId;\n      this.log(`No levels found in Pathway ${this.pathwayId}. Setting initial Pathway to \"${pathwayId}\"`);\n      pathwayLevels = this.getLevelsForPathway(pathwayId);\n      this.pathwayId = pathwayId;\n    }\n    if (pathwayLevels.length !== levels.length) {\n      this.log(`Found ${pathwayLevels.length}/${levels.length} levels in Pathway \"${this.pathwayId}\"`);\n      return pathwayLevels;\n    }\n    return levels;\n  }\n  getLevelsForPathway(pathwayId) {\n    if (this.levels === null) {\n      return [];\n    }\n    return this.levels.filter(level => pathwayId === level.pathwayId);\n  }\n  updatePathwayPriority(pathwayPriority) {\n    this.pathwayPriority = pathwayPriority;\n    let levels;\n\n    // Evaluate if we should remove the pathway from the penalized list\n    const penalizedPathways = this.penalizedPathways;\n    const now = performance.now();\n    Object.keys(penalizedPathways).forEach(pathwayId => {\n      if (now - penalizedPathways[pathwayId] > PATHWAY_PENALTY_DURATION_MS) {\n        delete penalizedPathways[pathwayId];\n      }\n    });\n    for (let i = 0; i < pathwayPriority.length; i++) {\n      const pathwayId = pathwayPriority[i];\n      if (pathwayId in penalizedPathways) {\n        continue;\n      }\n      if (pathwayId === this.pathwayId) {\n        return;\n      }\n      const selectedIndex = this.hls.nextLoadLevel;\n      const selectedLevel = this.hls.levels[selectedIndex];\n      levels = this.getLevelsForPathway(pathwayId);\n      if (levels.length > 0) {\n        this.log(`Setting Pathway to \"${pathwayId}\"`);\n        this.pathwayId = pathwayId;\n        reassignFragmentLevelIndexes(levels);\n        this.hls.trigger(Events.LEVELS_UPDATED, {\n          levels\n        });\n        // Set LevelController's level to trigger LEVEL_SWITCHING which loads playlist if needed\n        const levelAfterChange = this.hls.levels[selectedIndex];\n        if (selectedLevel && levelAfterChange && this.levels) {\n          if (levelAfterChange.attrs['STABLE-VARIANT-ID'] !== selectedLevel.attrs['STABLE-VARIANT-ID'] && levelAfterChange.bitrate !== selectedLevel.bitrate) {\n            this.log(`Unstable Pathways change from bitrate ${selectedLevel.bitrate} to ${levelAfterChange.bitrate}`);\n          }\n          this.hls.nextLoadLevel = selectedIndex;\n        }\n        break;\n      }\n    }\n  }\n  getPathwayForGroupId(groupId, type, defaultPathway) {\n    const levels = this.getLevelsForPathway(defaultPathway).concat(this.levels || []);\n    for (let i = 0; i < levels.length; i++) {\n      if (type === PlaylistContextType.AUDIO_TRACK && levels[i].hasAudioGroup(groupId) || type === PlaylistContextType.SUBTITLE_TRACK && levels[i].hasSubtitleGroup(groupId)) {\n        return levels[i].pathwayId;\n      }\n    }\n    return defaultPathway;\n  }\n  clonePathways(pathwayClones) {\n    const levels = this.levels;\n    if (!levels) {\n      return;\n    }\n    const audioGroupCloneMap = {};\n    const subtitleGroupCloneMap = {};\n    pathwayClones.forEach(pathwayClone => {\n      const {\n        ID: cloneId,\n        'BASE-ID': baseId,\n        'URI-REPLACEMENT': uriReplacement\n      } = pathwayClone;\n      if (levels.some(level => level.pathwayId === cloneId)) {\n        return;\n      }\n      const clonedVariants = this.getLevelsForPathway(baseId).map(baseLevel => {\n        const attributes = new AttrList(baseLevel.attrs);\n        attributes['PATHWAY-ID'] = cloneId;\n        const clonedAudioGroupId = attributes.AUDIO && `${attributes.AUDIO}_clone_${cloneId}`;\n        const clonedSubtitleGroupId = attributes.SUBTITLES && `${attributes.SUBTITLES}_clone_${cloneId}`;\n        if (clonedAudioGroupId) {\n          audioGroupCloneMap[attributes.AUDIO] = clonedAudioGroupId;\n          attributes.AUDIO = clonedAudioGroupId;\n        }\n        if (clonedSubtitleGroupId) {\n          subtitleGroupCloneMap[attributes.SUBTITLES] = clonedSubtitleGroupId;\n          attributes.SUBTITLES = clonedSubtitleGroupId;\n        }\n        const url = performUriReplacement(baseLevel.uri, attributes['STABLE-VARIANT-ID'], 'PER-VARIANT-URIS', uriReplacement);\n        const clonedLevel = new Level({\n          attrs: attributes,\n          audioCodec: baseLevel.audioCodec,\n          bitrate: baseLevel.bitrate,\n          height: baseLevel.height,\n          name: baseLevel.name,\n          url,\n          videoCodec: baseLevel.videoCodec,\n          width: baseLevel.width\n        });\n        if (baseLevel.audioGroups) {\n          for (let i = 1; i < baseLevel.audioGroups.length; i++) {\n            clonedLevel.addGroupId('audio', `${baseLevel.audioGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        if (baseLevel.subtitleGroups) {\n          for (let i = 1; i < baseLevel.subtitleGroups.length; i++) {\n            clonedLevel.addGroupId('text', `${baseLevel.subtitleGroups[i]}_clone_${cloneId}`);\n          }\n        }\n        return clonedLevel;\n      });\n      levels.push(...clonedVariants);\n      cloneRenditionGroups(this.audioTracks, audioGroupCloneMap, uriReplacement, cloneId);\n      cloneRenditionGroups(this.subtitleTracks, subtitleGroupCloneMap, uriReplacement, cloneId);\n    });\n  }\n  loadSteeringManifest(uri) {\n    const config = this.hls.config;\n    const Loader = config.loader;\n    if (this.loader) {\n      this.loader.destroy();\n    }\n    this.loader = new Loader(config);\n    let url;\n    try {\n      url = new self.URL(uri);\n    } catch (error) {\n      this.enabled = false;\n      this.log(`Failed to parse Steering Manifest URI: ${uri}`);\n      return;\n    }\n    if (url.protocol !== 'data:') {\n      const throughput = (this.hls.bandwidthEstimate || config.abrEwmaDefaultEstimate) | 0;\n      url.searchParams.set('_HLS_pathway', this.pathwayId);\n      url.searchParams.set('_HLS_throughput', '' + throughput);\n    }\n    const context = {\n      responseType: 'json',\n      url: url.href\n    };\n    const loadPolicy = config.steeringManifestLoadPolicy.default;\n    const legacyRetryCompatibility = loadPolicy.errorRetry || loadPolicy.timeoutRetry || {};\n    const loaderConfig = {\n      loadPolicy,\n      timeout: loadPolicy.maxLoadTimeMs,\n      maxRetry: legacyRetryCompatibility.maxNumRetry || 0,\n      retryDelay: legacyRetryCompatibility.retryDelayMs || 0,\n      maxRetryDelay: legacyRetryCompatibility.maxRetryDelayMs || 0\n    };\n    const callbacks = {\n      onSuccess: (response, stats, context, networkDetails) => {\n        this.log(`Loaded steering manifest: \"${url}\"`);\n        const steeringData = response.data;\n        if (steeringData.VERSION !== 1) {\n          this.log(`Steering VERSION ${steeringData.VERSION} not supported!`);\n          return;\n        }\n        this.updated = performance.now();\n        this.timeToLoad = steeringData.TTL;\n        const {\n          'RELOAD-URI': reloadUri,\n          'PATHWAY-CLONES': pathwayClones,\n          'PATHWAY-PRIORITY': pathwayPriority\n        } = steeringData;\n        if (reloadUri) {\n          try {\n            this.uri = new self.URL(reloadUri, url).href;\n          } catch (error) {\n            this.enabled = false;\n            this.log(`Failed to parse Steering Manifest RELOAD-URI: ${reloadUri}`);\n            return;\n          }\n        }\n        this.scheduleRefresh(this.uri || context.url);\n        if (pathwayClones) {\n          this.clonePathways(pathwayClones);\n        }\n        const loadedSteeringData = {\n          steeringManifest: steeringData,\n          url: url.toString()\n        };\n        this.hls.trigger(Events.STEERING_MANIFEST_LOADED, loadedSteeringData);\n        if (pathwayPriority) {\n          this.updatePathwayPriority(pathwayPriority);\n        }\n      },\n      onError: (error, context, networkDetails, stats) => {\n        this.log(`Error loading steering manifest: ${error.code} ${error.text} (${context.url})`);\n        this.stopLoad();\n        if (error.code === 410) {\n          this.enabled = false;\n          this.log(`Steering manifest ${context.url} no longer available`);\n          return;\n        }\n        let ttl = this.timeToLoad * 1000;\n        if (error.code === 429) {\n          const loader = this.loader;\n          if (typeof (loader == null ? void 0 : loader.getResponseHeader) === 'function') {\n            const retryAfter = loader.getResponseHeader('Retry-After');\n            if (retryAfter) {\n              ttl = parseFloat(retryAfter) * 1000;\n            }\n          }\n          this.log(`Steering manifest ${context.url} rate limited`);\n          return;\n        }\n        this.scheduleRefresh(this.uri || context.url, ttl);\n      },\n      onTimeout: (stats, context, networkDetails) => {\n        this.log(`Timeout loading steering manifest (${context.url})`);\n        this.scheduleRefresh(this.uri || context.url);\n      }\n    };\n    this.log(`Requesting steering manifest: ${url}`);\n    this.loader.load(context, loaderConfig, callbacks);\n  }\n  scheduleRefresh(uri, ttlMs = this.timeToLoad * 1000) {\n    this.clearTimeout();\n    this.reloadTimer = self.setTimeout(() => {\n      var _this$hls;\n      const media = (_this$hls = this.hls) == null ? void 0 : _this$hls.media;\n      if (media && !media.ended) {\n        this.loadSteeringManifest(uri);\n        return;\n      }\n      this.scheduleRefresh(uri, this.timeToLoad * 1000);\n    }, ttlMs);\n  }\n}\nfunction cloneRenditionGroups(tracks, groupCloneMap, uriReplacement, cloneId) {\n  if (!tracks) {\n    return;\n  }\n  Object.keys(groupCloneMap).forEach(audioGroupId => {\n    const clonedTracks = tracks.filter(track => track.groupId === audioGroupId).map(track => {\n      const clonedTrack = _extends({}, track);\n      clonedTrack.details = undefined;\n      clonedTrack.attrs = new AttrList(clonedTrack.attrs);\n      clonedTrack.url = clonedTrack.attrs.URI = performUriReplacement(track.url, track.attrs['STABLE-RENDITION-ID'], 'PER-RENDITION-URIS', uriReplacement);\n      clonedTrack.groupId = clonedTrack.attrs['GROUP-ID'] = groupCloneMap[audioGroupId];\n      clonedTrack.attrs['PATHWAY-ID'] = cloneId;\n      return clonedTrack;\n    });\n    tracks.push(...clonedTracks);\n  });\n}\nfunction performUriReplacement(uri, stableId, perOptionKey, uriReplacement) {\n  const {\n    HOST: host,\n    PARAMS: params,\n    [perOptionKey]: perOptionUris\n  } = uriReplacement;\n  let perVariantUri;\n  if (stableId) {\n    perVariantUri = perOptionUris == null ? void 0 : perOptionUris[stableId];\n    if (perVariantUri) {\n      uri = perVariantUri;\n    }\n  }\n  const url = new self.URL(uri);\n  if (host && !perVariantUri) {\n    url.host = host;\n  }\n  if (params) {\n    Object.keys(params).sort().forEach(key => {\n      if (key) {\n        url.searchParams.set(key, params[key]);\n      }\n    });\n  }\n  return url.href;\n}\n\nconst AGE_HEADER_LINE_REGEX = /^age:\\s*[\\d.]+\\s*$/im;\nclass XhrLoader {\n  constructor(config) {\n    this.xhrSetup = void 0;\n    this.requestTimeout = void 0;\n    this.retryTimeout = void 0;\n    this.retryDelay = void 0;\n    this.config = null;\n    this.callbacks = null;\n    this.context = null;\n    this.loader = null;\n    this.stats = void 0;\n    this.xhrSetup = config ? config.xhrSetup || null : null;\n    this.stats = new LoadStats();\n    this.retryDelay = 0;\n  }\n  destroy() {\n    this.callbacks = null;\n    this.abortInternal();\n    this.loader = null;\n    this.config = null;\n    this.context = null;\n    this.xhrSetup = null;\n  }\n  abortInternal() {\n    const loader = this.loader;\n    self.clearTimeout(this.requestTimeout);\n    self.clearTimeout(this.retryTimeout);\n    if (loader) {\n      loader.onreadystatechange = null;\n      loader.onprogress = null;\n      if (loader.readyState !== 4) {\n        this.stats.aborted = true;\n        loader.abort();\n      }\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.loader);\n    }\n  }\n  load(context, config, callbacks) {\n    if (this.stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    this.stats.loading.start = self.performance.now();\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.loadInternal();\n  }\n  loadInternal() {\n    const {\n      config,\n      context\n    } = this;\n    if (!config || !context) {\n      return;\n    }\n    const xhr = this.loader = new self.XMLHttpRequest();\n    const stats = this.stats;\n    stats.loading.first = 0;\n    stats.loaded = 0;\n    stats.aborted = false;\n    const xhrSetup = this.xhrSetup;\n    if (xhrSetup) {\n      Promise.resolve().then(() => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        return xhrSetup(xhr, context.url);\n      }).catch(error => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        xhr.open('GET', context.url, true);\n        return xhrSetup(xhr, context.url);\n      }).then(() => {\n        if (this.loader !== xhr || this.stats.aborted) return;\n        this.openAndSendXhr(xhr, context, config);\n      }).catch(error => {\n        // IE11 throws an exception on xhr.open if attempting to access an HTTP resource over HTTPS\n        this.callbacks.onError({\n          code: xhr.status,\n          text: error.message\n        }, context, xhr, stats);\n        return;\n      });\n    } else {\n      this.openAndSendXhr(xhr, context, config);\n    }\n  }\n  openAndSendXhr(xhr, context, config) {\n    if (!xhr.readyState) {\n      xhr.open('GET', context.url, true);\n    }\n    const headers = context.headers;\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    if (headers) {\n      for (const header in headers) {\n        xhr.setRequestHeader(header, headers[header]);\n      }\n    }\n    if (context.rangeEnd) {\n      xhr.setRequestHeader('Range', 'bytes=' + context.rangeStart + '-' + (context.rangeEnd - 1));\n    }\n    xhr.onreadystatechange = this.readystatechange.bind(this);\n    xhr.onprogress = this.loadprogress.bind(this);\n    xhr.responseType = context.responseType;\n    // setup timeout before we perform request\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.timeout);\n    xhr.send();\n  }\n  readystatechange() {\n    const {\n      context,\n      loader: xhr,\n      stats\n    } = this;\n    if (!context || !xhr) {\n      return;\n    }\n    const readyState = xhr.readyState;\n    const config = this.config;\n\n    // don't proceed if xhr has been aborted\n    if (stats.aborted) {\n      return;\n    }\n\n    // >= HEADERS_RECEIVED\n    if (readyState >= 2) {\n      if (stats.loading.first === 0) {\n        stats.loading.first = Math.max(self.performance.now(), stats.loading.start);\n        // readyState >= 2 AND readyState !==4 (readyState = HEADERS_RECEIVED || LOADING) rearm timeout as xhr not finished yet\n        if (config.timeout !== config.loadPolicy.maxLoadTimeMs) {\n          self.clearTimeout(this.requestTimeout);\n          config.timeout = config.loadPolicy.maxLoadTimeMs;\n          this.requestTimeout = self.setTimeout(this.loadtimeout.bind(this), config.loadPolicy.maxLoadTimeMs - (stats.loading.first - stats.loading.start));\n        }\n      }\n      if (readyState === 4) {\n        self.clearTimeout(this.requestTimeout);\n        xhr.onreadystatechange = null;\n        xhr.onprogress = null;\n        const status = xhr.status;\n        // http status between 200 to 299 are all successful\n        const useResponse = xhr.responseType !== 'text';\n        if (status >= 200 && status < 300 && (useResponse && xhr.response || xhr.responseText !== null)) {\n          stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n          const data = useResponse ? xhr.response : xhr.responseText;\n          const len = xhr.responseType === 'arraybuffer' ? data.byteLength : data.length;\n          stats.loaded = stats.total = len;\n          stats.bwEstimate = stats.total * 8000 / (stats.loading.end - stats.loading.first);\n          if (!this.callbacks) {\n            return;\n          }\n          const onProgress = this.callbacks.onProgress;\n          if (onProgress) {\n            onProgress(stats, context, data, xhr);\n          }\n          if (!this.callbacks) {\n            return;\n          }\n          const response = {\n            url: xhr.responseURL,\n            data: data,\n            code: status\n          };\n          this.callbacks.onSuccess(response, stats, context, xhr);\n        } else {\n          const retryConfig = config.loadPolicy.errorRetry;\n          const retryCount = stats.retry;\n          // if max nb of retries reached or if http status between 400 and 499 (such error cannot be recovered, retrying is useless), return error\n          const response = {\n            url: context.url,\n            data: undefined,\n            code: status\n          };\n          if (shouldRetry(retryConfig, retryCount, false, response)) {\n            this.retry(retryConfig);\n          } else {\n            logger.error(`${status} while loading ${context.url}`);\n            this.callbacks.onError({\n              code: status,\n              text: xhr.statusText\n            }, context, xhr, stats);\n          }\n        }\n      }\n    }\n  }\n  loadtimeout() {\n    if (!this.config) return;\n    const retryConfig = this.config.loadPolicy.timeoutRetry;\n    const retryCount = this.stats.retry;\n    if (shouldRetry(retryConfig, retryCount, true)) {\n      this.retry(retryConfig);\n    } else {\n      var _this$context;\n      logger.warn(`timeout while loading ${(_this$context = this.context) == null ? void 0 : _this$context.url}`);\n      const callbacks = this.callbacks;\n      if (callbacks) {\n        this.abortInternal();\n        callbacks.onTimeout(this.stats, this.context, this.loader);\n      }\n    }\n  }\n  retry(retryConfig) {\n    const {\n      context,\n      stats\n    } = this;\n    this.retryDelay = getRetryDelay(retryConfig, stats.retry);\n    stats.retry++;\n    logger.warn(`${status ? 'HTTP Status ' + status : 'Timeout'} while loading ${context == null ? void 0 : context.url}, retrying ${stats.retry}/${retryConfig.maxNumRetry} in ${this.retryDelay}ms`);\n    // abort and reset internal state\n    this.abortInternal();\n    this.loader = null;\n    // schedule retry\n    self.clearTimeout(this.retryTimeout);\n    this.retryTimeout = self.setTimeout(this.loadInternal.bind(this), this.retryDelay);\n  }\n  loadprogress(event) {\n    const stats = this.stats;\n    stats.loaded = event.loaded;\n    if (event.lengthComputable) {\n      stats.total = event.total;\n    }\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.loader && AGE_HEADER_LINE_REGEX.test(this.loader.getAllResponseHeaders())) {\n      const ageHeader = this.loader.getResponseHeader('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    if (this.loader && new RegExp(`^${name}:\\\\s*[\\\\d.]+\\\\s*$`, 'im').test(this.loader.getAllResponseHeaders())) {\n      return this.loader.getResponseHeader(name);\n    }\n    return null;\n  }\n}\n\nfunction fetchSupported() {\n  if (\n  // @ts-ignore\n  self.fetch && self.AbortController && self.ReadableStream && self.Request) {\n    try {\n      new self.ReadableStream({}); // eslint-disable-line no-new\n      return true;\n    } catch (e) {\n      /* noop */\n    }\n  }\n  return false;\n}\nconst BYTERANGE = /(\\d+)-(\\d+)\\/(\\d+)/;\nclass FetchLoader {\n  constructor(config /* HlsConfig */) {\n    this.fetchSetup = void 0;\n    this.requestTimeout = void 0;\n    this.request = null;\n    this.response = null;\n    this.controller = void 0;\n    this.context = null;\n    this.config = null;\n    this.callbacks = null;\n    this.stats = void 0;\n    this.loader = null;\n    this.fetchSetup = config.fetchSetup || getRequest;\n    this.controller = new self.AbortController();\n    this.stats = new LoadStats();\n  }\n  destroy() {\n    this.loader = this.callbacks = this.context = this.config = this.request = null;\n    this.abortInternal();\n    this.response = null;\n    // @ts-ignore\n    this.fetchSetup = this.controller = this.stats = null;\n  }\n  abortInternal() {\n    if (this.controller && !this.stats.loading.end) {\n      this.stats.aborted = true;\n      this.controller.abort();\n    }\n  }\n  abort() {\n    var _this$callbacks;\n    this.abortInternal();\n    if ((_this$callbacks = this.callbacks) != null && _this$callbacks.onAbort) {\n      this.callbacks.onAbort(this.stats, this.context, this.response);\n    }\n  }\n  load(context, config, callbacks) {\n    const stats = this.stats;\n    if (stats.loading.start) {\n      throw new Error('Loader can only be used once.');\n    }\n    stats.loading.start = self.performance.now();\n    const initParams = getRequestParameters(context, this.controller.signal);\n    const onProgress = callbacks.onProgress;\n    const isArrayBuffer = context.responseType === 'arraybuffer';\n    const LENGTH = isArrayBuffer ? 'byteLength' : 'length';\n    const {\n      maxTimeToFirstByteMs,\n      maxLoadTimeMs\n    } = config.loadPolicy;\n    this.context = context;\n    this.config = config;\n    this.callbacks = callbacks;\n    this.request = this.fetchSetup(context, initParams);\n    self.clearTimeout(this.requestTimeout);\n    config.timeout = maxTimeToFirstByteMs && isFiniteNumber(maxTimeToFirstByteMs) ? maxTimeToFirstByteMs : maxLoadTimeMs;\n    this.requestTimeout = self.setTimeout(() => {\n      this.abortInternal();\n      callbacks.onTimeout(stats, context, this.response);\n    }, config.timeout);\n    self.fetch(this.request).then(response => {\n      this.response = this.loader = response;\n      const first = Math.max(self.performance.now(), stats.loading.start);\n      self.clearTimeout(this.requestTimeout);\n      config.timeout = maxLoadTimeMs;\n      this.requestTimeout = self.setTimeout(() => {\n        this.abortInternal();\n        callbacks.onTimeout(stats, context, this.response);\n      }, maxLoadTimeMs - (first - stats.loading.start));\n      if (!response.ok) {\n        const {\n          status,\n          statusText\n        } = response;\n        throw new FetchError(statusText || 'fetch, bad network response', status, response);\n      }\n      stats.loading.first = first;\n      stats.total = getContentLength(response.headers) || stats.total;\n      if (onProgress && isFiniteNumber(config.highWaterMark)) {\n        return this.loadProgressively(response, stats, context, config.highWaterMark, onProgress);\n      }\n      if (isArrayBuffer) {\n        return response.arrayBuffer();\n      }\n      if (context.responseType === 'json') {\n        return response.json();\n      }\n      return response.text();\n    }).then(responseData => {\n      const response = this.response;\n      if (!response) {\n        throw new Error('loader destroyed');\n      }\n      self.clearTimeout(this.requestTimeout);\n      stats.loading.end = Math.max(self.performance.now(), stats.loading.first);\n      const total = responseData[LENGTH];\n      if (total) {\n        stats.loaded = stats.total = total;\n      }\n      const loaderResponse = {\n        url: response.url,\n        data: responseData,\n        code: response.status\n      };\n      if (onProgress && !isFiniteNumber(config.highWaterMark)) {\n        onProgress(stats, context, responseData, response);\n      }\n      callbacks.onSuccess(loaderResponse, stats, context, response);\n    }).catch(error => {\n      self.clearTimeout(this.requestTimeout);\n      if (stats.aborted) {\n        return;\n      }\n      // CORS errors result in an undefined code. Set it to 0 here to align with XHR's behavior\n      // when destroying, 'error' itself can be undefined\n      const code = !error ? 0 : error.code || 0;\n      const text = !error ? null : error.message;\n      callbacks.onError({\n        code,\n        text\n      }, context, error ? error.details : null, stats);\n    });\n  }\n  getCacheAge() {\n    let result = null;\n    if (this.response) {\n      const ageHeader = this.response.headers.get('age');\n      result = ageHeader ? parseFloat(ageHeader) : null;\n    }\n    return result;\n  }\n  getResponseHeader(name) {\n    return this.response ? this.response.headers.get(name) : null;\n  }\n  loadProgressively(response, stats, context, highWaterMark = 0, onProgress) {\n    const chunkCache = new ChunkCache();\n    const reader = response.body.getReader();\n    const pump = () => {\n      return reader.read().then(data => {\n        if (data.done) {\n          if (chunkCache.dataLength) {\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n          return Promise.resolve(new ArrayBuffer(0));\n        }\n        const chunk = data.value;\n        const len = chunk.length;\n        stats.loaded += len;\n        if (len < highWaterMark || chunkCache.dataLength) {\n          // The current chunk is too small to to be emitted or the cache already has data\n          // Push it to the cache\n          chunkCache.push(chunk);\n          if (chunkCache.dataLength >= highWaterMark) {\n            // flush in order to join the typed arrays\n            onProgress(stats, context, chunkCache.flush(), response);\n          }\n        } else {\n          // If there's nothing cached already, and the chache is large enough\n          // just emit the progress event\n          onProgress(stats, context, chunk, response);\n        }\n        return pump();\n      }).catch(() => {\n        /* aborted */\n        return Promise.reject();\n      });\n    };\n    return pump();\n  }\n}\nfunction getRequestParameters(context, signal) {\n  const initParams = {\n    method: 'GET',\n    mode: 'cors',\n    credentials: 'same-origin',\n    signal,\n    headers: new self.Headers(_extends({}, context.headers))\n  };\n  if (context.rangeEnd) {\n    initParams.headers.set('Range', 'bytes=' + context.rangeStart + '-' + String(context.rangeEnd - 1));\n  }\n  return initParams;\n}\nfunction getByteRangeLength(byteRangeHeader) {\n  const result = BYTERANGE.exec(byteRangeHeader);\n  if (result) {\n    return parseInt(result[2]) - parseInt(result[1]) + 1;\n  }\n}\nfunction getContentLength(headers) {\n  const contentRange = headers.get('Content-Range');\n  if (contentRange) {\n    const byteRangeLength = getByteRangeLength(contentRange);\n    if (isFiniteNumber(byteRangeLength)) {\n      return byteRangeLength;\n    }\n  }\n  const contentLength = headers.get('Content-Length');\n  if (contentLength) {\n    return parseInt(contentLength);\n  }\n}\nfunction getRequest(context, initParams) {\n  return new self.Request(context.url, initParams);\n}\nclass FetchError extends Error {\n  constructor(message, code, details) {\n    super(message);\n    this.code = void 0;\n    this.details = void 0;\n    this.code = code;\n    this.details = details;\n  }\n}\n\nconst WHITESPACE_CHAR = /\\s/;\nconst Cues = {\n  newCue(track, startTime, endTime, captionScreen) {\n    const result = [];\n    let row;\n    // the type data states this is VTTCue, but it can potentially be a TextTrackCue on old browsers\n    let cue;\n    let indenting;\n    let indent;\n    let text;\n    const Cue = self.VTTCue || self.TextTrackCue;\n    for (let r = 0; r < captionScreen.rows.length; r++) {\n      row = captionScreen.rows[r];\n      indenting = true;\n      indent = 0;\n      text = '';\n      if (!row.isEmpty()) {\n        var _track$cues;\n        for (let c = 0; c < row.chars.length; c++) {\n          if (WHITESPACE_CHAR.test(row.chars[c].uchar) && indenting) {\n            indent++;\n          } else {\n            text += row.chars[c].uchar;\n            indenting = false;\n          }\n        }\n        // To be used for cleaning-up orphaned roll-up captions\n        row.cueStartTime = startTime;\n\n        // Give a slight bump to the endTime if it's equal to startTime to avoid a SyntaxError in IE\n        if (startTime === endTime) {\n          endTime += 0.0001;\n        }\n        if (indent >= 16) {\n          indent--;\n        } else {\n          indent++;\n        }\n        const cueText = fixLineBreaks(text.trim());\n        const id = generateCueId(startTime, endTime, cueText);\n\n        // If this cue already exists in the track do not push it\n        if (!(track != null && (_track$cues = track.cues) != null && _track$cues.getCueById(id))) {\n          cue = new Cue(startTime, endTime, cueText);\n          cue.id = id;\n          cue.line = r + 1;\n          cue.align = 'left';\n          // Clamp the position between 10 and 80 percent (CEA-608 PAC indent code)\n          // https://dvcs.w3.org/hg/text-tracks/raw-file/default/608toVTT/608toVTT.html#positioning-in-cea-608\n          // Firefox throws an exception and captions break with out of bounds 0-100 values\n          cue.position = 10 + Math.min(80, Math.floor(indent * 8 / 32) * 10);\n          result.push(cue);\n        }\n      }\n    }\n    if (track && result.length) {\n      // Sort bottom cues in reverse order so that they render in line order when overlapping in Chrome\n      result.sort((cueA, cueB) => {\n        if (cueA.line === 'auto' || cueB.line === 'auto') {\n          return 0;\n        }\n        if (cueA.line > 8 && cueB.line > 8) {\n          return cueB.line - cueA.line;\n        }\n        return cueA.line - cueB.line;\n      });\n      result.forEach(cue => addCueToTrack(track, cue));\n    }\n    return result;\n  }\n};\n\n/**\n * @deprecated use fragLoadPolicy.default\n */\n\n/**\n * @deprecated use manifestLoadPolicy.default and playlistLoadPolicy.default\n */\n\nconst defaultLoadPolicy = {\n  maxTimeToFirstByteMs: 8000,\n  maxLoadTimeMs: 20000,\n  timeoutRetry: null,\n  errorRetry: null\n};\n\n/**\n * @ignore\n * If possible, keep hlsDefaultConfig shallow\n * It is cloned whenever a new Hls instance is created, by keeping the config\n * shallow the properties are cloned, and we don't end up manipulating the default\n */\nconst hlsDefaultConfig = _objectSpread2(_objectSpread2({\n  autoStartLoad: true,\n  // used by stream-controller\n  startPosition: -1,\n  // used by stream-controller\n  defaultAudioCodec: undefined,\n  // used by stream-controller\n  debug: false,\n  // used by logger\n  capLevelOnFPSDrop: false,\n  // used by fps-controller\n  capLevelToPlayerSize: false,\n  // used by cap-level-controller\n  ignoreDevicePixelRatio: false,\n  // used by cap-level-controller\n  preferManagedMediaSource: true,\n  initialLiveManifestSize: 1,\n  // used by stream-controller\n  maxBufferLength: 30,\n  // used by stream-controller\n  backBufferLength: Infinity,\n  // used by buffer-controller\n  frontBufferFlushThreshold: Infinity,\n  maxBufferSize: 60 * 1000 * 1000,\n  // used by stream-controller\n  maxBufferHole: 0.1,\n  // used by stream-controller\n  highBufferWatchdogPeriod: 2,\n  // used by stream-controller\n  nudgeOffset: 0.1,\n  // used by stream-controller\n  nudgeMaxRetry: 3,\n  // used by stream-controller\n  maxFragLookUpTolerance: 0.25,\n  // used by stream-controller\n  liveSyncDurationCount: 3,\n  // used by latency-controller\n  liveMaxLatencyDurationCount: Infinity,\n  // used by latency-controller\n  liveSyncDuration: undefined,\n  // used by latency-controller\n  liveMaxLatencyDuration: undefined,\n  // used by latency-controller\n  maxLiveSyncPlaybackRate: 1,\n  // used by latency-controller\n  liveDurationInfinity: false,\n  // used by buffer-controller\n  /**\n   * @deprecated use backBufferLength\n   */\n  liveBackBufferLength: null,\n  // used by buffer-controller\n  maxMaxBufferLength: 600,\n  // used by stream-controller\n  enableWorker: true,\n  // used by transmuxer\n  workerPath: null,\n  // used by transmuxer\n  enableSoftwareAES: true,\n  // used by decrypter\n  startLevel: undefined,\n  // used by level-controller\n  startFragPrefetch: false,\n  // used by stream-controller\n  fpsDroppedMonitoringPeriod: 5000,\n  // used by fps-controller\n  fpsDroppedMonitoringThreshold: 0.2,\n  // used by fps-controller\n  appendErrorMaxRetry: 3,\n  // used by buffer-controller\n  loader: XhrLoader,\n  // loader: FetchLoader,\n  fLoader: undefined,\n  // used by fragment-loader\n  pLoader: undefined,\n  // used by playlist-loader\n  xhrSetup: undefined,\n  // used by xhr-loader\n  licenseXhrSetup: undefined,\n  // used by eme-controller\n  licenseResponseCallback: undefined,\n  // used by eme-controller\n  abrController: AbrController,\n  bufferController: BufferController,\n  capLevelController: CapLevelController,\n  errorController: ErrorController,\n  fpsController: FPSController,\n  stretchShortVideoTrack: false,\n  // used by mp4-remuxer\n  maxAudioFramesDrift: 1,\n  // used by mp4-remuxer\n  forceKeyFrameOnDiscontinuity: true,\n  // used by ts-demuxer\n  abrEwmaFastLive: 3,\n  // used by abr-controller\n  abrEwmaSlowLive: 9,\n  // used by abr-controller\n  abrEwmaFastVoD: 3,\n  // used by abr-controller\n  abrEwmaSlowVoD: 9,\n  // used by abr-controller\n  abrEwmaDefaultEstimate: 5e5,\n  // 500 kbps  // used by abr-controller\n  abrEwmaDefaultEstimateMax: 5e6,\n  // 5 mbps\n  abrBandWidthFactor: 0.95,\n  // used by abr-controller\n  abrBandWidthUpFactor: 0.7,\n  // used by abr-controller\n  abrMaxWithRealBitrate: false,\n  // used by abr-controller\n  maxStarvationDelay: 4,\n  // used by abr-controller\n  maxLoadingDelay: 4,\n  // used by abr-controller\n  minAutoBitrate: 0,\n  // used by hls\n  emeEnabled: false,\n  // used by eme-controller\n  widevineLicenseUrl: undefined,\n  // used by eme-controller\n  drmSystems: {},\n  // used by eme-controller\n  drmSystemOptions: {},\n  // used by eme-controller\n  requestMediaKeySystemAccessFunc: requestMediaKeySystemAccess ,\n  // used by eme-controller\n  testBandwidth: true,\n  progressive: false,\n  lowLatencyMode: true,\n  cmcd: undefined,\n  enableDateRangeMetadataCues: true,\n  enableEmsgMetadataCues: true,\n  enableID3MetadataCues: true,\n  useMediaCapabilities: true,\n  certLoadPolicy: {\n    default: defaultLoadPolicy\n  },\n  keyLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 8000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      },\n      errorRetry: {\n        maxNumRetry: 8,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 20000,\n        backoff: 'linear'\n      }\n    }\n  },\n  manifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: Infinity,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  playlistLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  fragLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 120000,\n      timeoutRetry: {\n        maxNumRetry: 4,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 6,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    }\n  },\n  steeringManifestLoadPolicy: {\n    default: {\n      maxTimeToFirstByteMs: 10000,\n      maxLoadTimeMs: 20000,\n      timeoutRetry: {\n        maxNumRetry: 2,\n        retryDelayMs: 0,\n        maxRetryDelayMs: 0\n      },\n      errorRetry: {\n        maxNumRetry: 1,\n        retryDelayMs: 1000,\n        maxRetryDelayMs: 8000\n      }\n    } \n  },\n  // These default settings are deprecated in favor of the above policies\n  // and are maintained for backwards compatibility\n  manifestLoadingTimeOut: 10000,\n  manifestLoadingMaxRetry: 1,\n  manifestLoadingRetryDelay: 1000,\n  manifestLoadingMaxRetryTimeout: 64000,\n  levelLoadingTimeOut: 10000,\n  levelLoadingMaxRetry: 4,\n  levelLoadingRetryDelay: 1000,\n  levelLoadingMaxRetryTimeout: 64000,\n  fragLoadingTimeOut: 20000,\n  fragLoadingMaxRetry: 6,\n  fragLoadingRetryDelay: 1000,\n  fragLoadingMaxRetryTimeout: 64000\n}, timelineConfig()), {}, {\n  subtitleStreamController: SubtitleStreamController ,\n  subtitleTrackController: SubtitleTrackController ,\n  timelineController: TimelineController ,\n  audioStreamController: AudioStreamController ,\n  audioTrackController: AudioTrackController ,\n  emeController: EMEController ,\n  cmcdController: CMCDController ,\n  contentSteeringController: ContentSteeringController \n});\nfunction timelineConfig() {\n  return {\n    cueHandler: Cues,\n    // used by timeline-controller\n    enableWebVTT: true,\n    // used by timeline-controller\n    enableIMSC1: true,\n    // used by timeline-controller\n    enableCEA708Captions: true,\n    // used by timeline-controller\n    captionsTextTrack1Label: 'English',\n    // used by timeline-controller\n    captionsTextTrack1LanguageCode: 'en',\n    // used by timeline-controller\n    captionsTextTrack2Label: 'Spanish',\n    // used by timeline-controller\n    captionsTextTrack2LanguageCode: 'es',\n    // used by timeline-controller\n    captionsTextTrack3Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack3LanguageCode: '',\n    // used by timeline-controller\n    captionsTextTrack4Label: 'Unknown CC',\n    // used by timeline-controller\n    captionsTextTrack4LanguageCode: '',\n    // used by timeline-controller\n    renderTextTracksNatively: true\n  };\n}\n\n/**\n * @ignore\n */\nfunction mergeConfig(defaultConfig, userConfig) {\n  if ((userConfig.liveSyncDurationCount || userConfig.liveMaxLatencyDurationCount) && (userConfig.liveSyncDuration || userConfig.liveMaxLatencyDuration)) {\n    throw new Error(\"Illegal hls.js config: don't mix up liveSyncDurationCount/liveMaxLatencyDurationCount and liveSyncDuration/liveMaxLatencyDuration\");\n  }\n  if (userConfig.liveMaxLatencyDurationCount !== undefined && (userConfig.liveSyncDurationCount === undefined || userConfig.liveMaxLatencyDurationCount <= userConfig.liveSyncDurationCount)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDurationCount\" must be greater than \"liveSyncDurationCount\"');\n  }\n  if (userConfig.liveMaxLatencyDuration !== undefined && (userConfig.liveSyncDuration === undefined || userConfig.liveMaxLatencyDuration <= userConfig.liveSyncDuration)) {\n    throw new Error('Illegal hls.js config: \"liveMaxLatencyDuration\" must be greater than \"liveSyncDuration\"');\n  }\n  const defaultsCopy = deepCpy(defaultConfig);\n\n  // Backwards compatibility with deprecated config values\n  const deprecatedSettingTypes = ['manifest', 'level', 'frag'];\n  const deprecatedSettings = ['TimeOut', 'MaxRetry', 'RetryDelay', 'MaxRetryTimeout'];\n  deprecatedSettingTypes.forEach(type => {\n    const policyName = `${type === 'level' ? 'playlist' : type}LoadPolicy`;\n    const policyNotSet = userConfig[policyName] === undefined;\n    const report = [];\n    deprecatedSettings.forEach(setting => {\n      const deprecatedSetting = `${type}Loading${setting}`;\n      const value = userConfig[deprecatedSetting];\n      if (value !== undefined && policyNotSet) {\n        report.push(deprecatedSetting);\n        const settings = defaultsCopy[policyName].default;\n        userConfig[policyName] = {\n          default: settings\n        };\n        switch (setting) {\n          case 'TimeOut':\n            settings.maxLoadTimeMs = value;\n            settings.maxTimeToFirstByteMs = value;\n            break;\n          case 'MaxRetry':\n            settings.errorRetry.maxNumRetry = value;\n            settings.timeoutRetry.maxNumRetry = value;\n            break;\n          case 'RetryDelay':\n            settings.errorRetry.retryDelayMs = value;\n            settings.timeoutRetry.retryDelayMs = value;\n            break;\n          case 'MaxRetryTimeout':\n            settings.errorRetry.maxRetryDelayMs = value;\n            settings.timeoutRetry.maxRetryDelayMs = value;\n            break;\n        }\n      }\n    });\n    if (report.length) {\n      logger.warn(`hls.js config: \"${report.join('\", \"')}\" setting(s) are deprecated, use \"${policyName}\": ${JSON.stringify(userConfig[policyName])}`);\n    }\n  });\n  return _objectSpread2(_objectSpread2({}, defaultsCopy), userConfig);\n}\nfunction deepCpy(obj) {\n  if (obj && typeof obj === 'object') {\n    if (Array.isArray(obj)) {\n      return obj.map(deepCpy);\n    }\n    return Object.keys(obj).reduce((result, key) => {\n      result[key] = deepCpy(obj[key]);\n      return result;\n    }, {});\n  }\n  return obj;\n}\n\n/**\n * @ignore\n */\nfunction enableStreamingMode(config) {\n  const currentLoader = config.loader;\n  if (currentLoader !== FetchLoader && currentLoader !== XhrLoader) {\n    // If a developer has configured their own loader, respect that choice\n    logger.log('[config]: Custom loader detected, cannot enable progressive streaming');\n    config.progressive = false;\n  } else {\n    const canStreamProgressively = fetchSupported();\n    if (canStreamProgressively) {\n      config.loader = FetchLoader;\n      config.progressive = true;\n      config.enableSoftwareAES = true;\n      logger.log('[config]: Progressive streaming enabled, using FetchLoader');\n    }\n  }\n}\n\nlet chromeOrFirefox;\nclass LevelController extends BasePlaylistController {\n  constructor(hls, contentSteeringController) {\n    super(hls, '[level-controller]');\n    this._levels = [];\n    this._firstLevel = -1;\n    this._maxAutoLevel = -1;\n    this._startLevel = void 0;\n    this.currentLevel = null;\n    this.currentLevelIndex = -1;\n    this.manualLevelIndex = -1;\n    this.steering = void 0;\n    this.onParsedComplete = void 0;\n    this.steering = contentSteeringController;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.on(Events.ERROR, this.onError, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_LOADED, this.onManifestLoaded, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n    hls.off(Events.ERROR, this.onError, this);\n  }\n  destroy() {\n    this._unregisterListeners();\n    this.steering = null;\n    this.resetLevels();\n    super.destroy();\n  }\n  stopLoad() {\n    const levels = this._levels;\n\n    // clean up live level details to force reload them, and reset load errors\n    levels.forEach(level => {\n      level.loadError = 0;\n      level.fragmentError = 0;\n    });\n    super.stopLoad();\n  }\n  resetLevels() {\n    this._startLevel = undefined;\n    this.manualLevelIndex = -1;\n    this.currentLevelIndex = -1;\n    this.currentLevel = null;\n    this._levels = [];\n    this._maxAutoLevel = -1;\n  }\n  onManifestLoading(event, data) {\n    this.resetLevels();\n  }\n  onManifestLoaded(event, data) {\n    const preferManagedMediaSource = this.hls.config.preferManagedMediaSource;\n    const levels = [];\n    const redundantSet = {};\n    const generatePathwaySet = {};\n    let resolutionFound = false;\n    let videoCodecFound = false;\n    let audioCodecFound = false;\n    data.levels.forEach(levelParsed => {\n      var _audioCodec, _videoCodec;\n      const attributes = levelParsed.attrs;\n\n      // erase audio codec info if browser does not support mp4a.40.34.\n      // demuxer will autodetect codec and fallback to mpeg/audio\n      let {\n        audioCodec,\n        videoCodec\n      } = levelParsed;\n      if (((_audioCodec = audioCodec) == null ? void 0 : _audioCodec.indexOf('mp4a.40.34')) !== -1) {\n        chromeOrFirefox || (chromeOrFirefox = /chrome|firefox/i.test(navigator.userAgent));\n        if (chromeOrFirefox) {\n          levelParsed.audioCodec = audioCodec = undefined;\n        }\n      }\n      if (audioCodec) {\n        levelParsed.audioCodec = audioCodec = getCodecCompatibleName(audioCodec, preferManagedMediaSource);\n      }\n      if (((_videoCodec = videoCodec) == null ? void 0 : _videoCodec.indexOf('avc1')) === 0) {\n        videoCodec = levelParsed.videoCodec = convertAVC1ToAVCOTI(videoCodec);\n      }\n\n      // only keep levels with supported audio/video codecs\n      const {\n        width,\n        height,\n        unknownCodecs\n      } = levelParsed;\n      resolutionFound || (resolutionFound = !!(width && height));\n      videoCodecFound || (videoCodecFound = !!videoCodec);\n      audioCodecFound || (audioCodecFound = !!audioCodec);\n      if (unknownCodecs != null && unknownCodecs.length || audioCodec && !areCodecsMediaSourceSupported(audioCodec, 'audio', preferManagedMediaSource) || videoCodec && !areCodecsMediaSourceSupported(videoCodec, 'video', preferManagedMediaSource)) {\n        return;\n      }\n      const {\n        CODECS,\n        'FRAME-RATE': FRAMERATE,\n        'HDCP-LEVEL': HDCP,\n        'PATHWAY-ID': PATHWAY,\n        RESOLUTION,\n        'VIDEO-RANGE': VIDEO_RANGE\n      } = attributes;\n      const contentSteeringPrefix = `${PATHWAY || '.'}-`;\n      const levelKey = `${contentSteeringPrefix}${levelParsed.bitrate}-${RESOLUTION}-${FRAMERATE}-${CODECS}-${VIDEO_RANGE}-${HDCP}`;\n      if (!redundantSet[levelKey]) {\n        const level = new Level(levelParsed);\n        redundantSet[levelKey] = level;\n        generatePathwaySet[levelKey] = 1;\n        levels.push(level);\n      } else if (redundantSet[levelKey].uri !== levelParsed.url && !levelParsed.attrs['PATHWAY-ID']) {\n        // Assign Pathway IDs to Redundant Streams (default Pathways is \".\". Redundant Streams \"..\", \"...\", and so on.)\n        // Content Steering controller to handles Pathway fallback on error\n        const pathwayCount = generatePathwaySet[levelKey] += 1;\n        levelParsed.attrs['PATHWAY-ID'] = new Array(pathwayCount + 1).join('.');\n        const level = new Level(levelParsed);\n        redundantSet[levelKey] = level;\n        levels.push(level);\n      } else {\n        redundantSet[levelKey].addGroupId('audio', attributes.AUDIO);\n        redundantSet[levelKey].addGroupId('text', attributes.SUBTITLES);\n      }\n    });\n    this.filterAndSortMediaOptions(levels, data, resolutionFound, videoCodecFound, audioCodecFound);\n  }\n  filterAndSortMediaOptions(filteredLevels, data, resolutionFound, videoCodecFound, audioCodecFound) {\n    let audioTracks = [];\n    let subtitleTracks = [];\n    let levels = filteredLevels;\n\n    // remove audio-only and invalid video-range levels if we also have levels with video codecs or RESOLUTION signalled\n    if ((resolutionFound || videoCodecFound) && audioCodecFound) {\n      levels = levels.filter(({\n        videoCodec,\n        videoRange,\n        width,\n        height\n      }) => (!!videoCodec || !!(width && height)) && isVideoRange(videoRange));\n    }\n    if (levels.length === 0) {\n      // Dispatch error after MANIFEST_LOADED is done propagating\n      Promise.resolve().then(() => {\n        if (this.hls) {\n          if (data.levels.length) {\n            this.warn(`One or more CODECS in variant not supported: ${JSON.stringify(data.levels[0].attrs)}`);\n          }\n          const error = new Error('no level with compatible codecs found in manifest');\n          this.hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.MANIFEST_INCOMPATIBLE_CODECS_ERROR,\n            fatal: true,\n            url: data.url,\n            error,\n            reason: error.message\n          });\n        }\n      });\n      return;\n    }\n    if (data.audioTracks) {\n      const {\n        preferManagedMediaSource\n      } = this.hls.config;\n      audioTracks = data.audioTracks.filter(track => !track.audioCodec || areCodecsMediaSourceSupported(track.audioCodec, 'audio', preferManagedMediaSource));\n      // Assign ids after filtering as array indices by group-id\n      assignTrackIdsByGroup(audioTracks);\n    }\n    if (data.subtitles) {\n      subtitleTracks = data.subtitles;\n      assignTrackIdsByGroup(subtitleTracks);\n    }\n    // start bitrate is the first bitrate of the manifest\n    const unsortedLevels = levels.slice(0);\n    // sort levels from lowest to highest\n    levels.sort((a, b) => {\n      if (a.attrs['HDCP-LEVEL'] !== b.attrs['HDCP-LEVEL']) {\n        return (a.attrs['HDCP-LEVEL'] || '') > (b.attrs['HDCP-LEVEL'] || '') ? 1 : -1;\n      }\n      // sort on height before bitrate for cap-level-controller\n      if (resolutionFound && a.height !== b.height) {\n        return a.height - b.height;\n      }\n      if (a.frameRate !== b.frameRate) {\n        return a.frameRate - b.frameRate;\n      }\n      if (a.videoRange !== b.videoRange) {\n        return VideoRangeValues.indexOf(a.videoRange) - VideoRangeValues.indexOf(b.videoRange);\n      }\n      if (a.videoCodec !== b.videoCodec) {\n        const valueA = videoCodecPreferenceValue(a.videoCodec);\n        const valueB = videoCodecPreferenceValue(b.videoCodec);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.uri === b.uri && a.codecSet !== b.codecSet) {\n        const valueA = codecsSetSelectionPreferenceValue(a.codecSet);\n        const valueB = codecsSetSelectionPreferenceValue(b.codecSet);\n        if (valueA !== valueB) {\n          return valueB - valueA;\n        }\n      }\n      if (a.averageBitrate !== b.averageBitrate) {\n        return a.averageBitrate - b.averageBitrate;\n      }\n      return 0;\n    });\n    let firstLevelInPlaylist = unsortedLevels[0];\n    if (this.steering) {\n      levels = this.steering.filterParsedLevels(levels);\n      if (levels.length !== unsortedLevels.length) {\n        for (let i = 0; i < unsortedLevels.length; i++) {\n          if (unsortedLevels[i].pathwayId === levels[0].pathwayId) {\n            firstLevelInPlaylist = unsortedLevels[i];\n            break;\n          }\n        }\n      }\n    }\n    this._levels = levels;\n\n    // find index of first level in sorted levels\n    for (let i = 0; i < levels.length; i++) {\n      if (levels[i] === firstLevelInPlaylist) {\n        var _this$hls$userConfig;\n        this._firstLevel = i;\n        const firstLevelBitrate = firstLevelInPlaylist.bitrate;\n        const bandwidthEstimate = this.hls.bandwidthEstimate;\n        this.log(`manifest loaded, ${levels.length} level(s) found, first bitrate: ${firstLevelBitrate}`);\n        // Update default bwe to first variant bitrate as long it has not been configured or set\n        if (((_this$hls$userConfig = this.hls.userConfig) == null ? void 0 : _this$hls$userConfig.abrEwmaDefaultEstimate) === undefined) {\n          const startingBwEstimate = Math.min(firstLevelBitrate, this.hls.config.abrEwmaDefaultEstimateMax);\n          if (startingBwEstimate > bandwidthEstimate && bandwidthEstimate === hlsDefaultConfig.abrEwmaDefaultEstimate) {\n            this.hls.bandwidthEstimate = startingBwEstimate;\n          }\n        }\n        break;\n      }\n    }\n\n    // Audio is only alternate if manifest include a URI along with the audio group tag,\n    // and this is not an audio-only stream where levels contain audio-only\n    const audioOnly = audioCodecFound && !videoCodecFound;\n    const edata = {\n      levels,\n      audioTracks,\n      subtitleTracks,\n      sessionData: data.sessionData,\n      sessionKeys: data.sessionKeys,\n      firstLevel: this._firstLevel,\n      stats: data.stats,\n      audio: audioCodecFound,\n      video: videoCodecFound,\n      altAudio: !audioOnly && audioTracks.some(t => !!t.url)\n    };\n    this.hls.trigger(Events.MANIFEST_PARSED, edata);\n\n    // Initiate loading after all controllers have received MANIFEST_PARSED\n    if (this.hls.config.autoStartLoad || this.hls.forceStartLoad) {\n      this.hls.startLoad(this.hls.config.startPosition);\n    }\n  }\n  get levels() {\n    if (this._levels.length === 0) {\n      return null;\n    }\n    return this._levels;\n  }\n  get level() {\n    return this.currentLevelIndex;\n  }\n  set level(newLevel) {\n    const levels = this._levels;\n    if (levels.length === 0) {\n      return;\n    }\n    // check if level idx is valid\n    if (newLevel < 0 || newLevel >= levels.length) {\n      // invalid level id given, trigger error\n      const error = new Error('invalid level idx');\n      const fatal = newLevel < 0;\n      this.hls.trigger(Events.ERROR, {\n        type: ErrorTypes.OTHER_ERROR,\n        details: ErrorDetails.LEVEL_SWITCH_ERROR,\n        level: newLevel,\n        fatal,\n        error,\n        reason: error.message\n      });\n      if (fatal) {\n        return;\n      }\n      newLevel = Math.min(newLevel, levels.length - 1);\n    }\n    const lastLevelIndex = this.currentLevelIndex;\n    const lastLevel = this.currentLevel;\n    const lastPathwayId = lastLevel ? lastLevel.attrs['PATHWAY-ID'] : undefined;\n    const level = levels[newLevel];\n    const pathwayId = level.attrs['PATHWAY-ID'];\n    this.currentLevelIndex = newLevel;\n    this.currentLevel = level;\n    if (lastLevelIndex === newLevel && level.details && lastLevel && lastPathwayId === pathwayId) {\n      return;\n    }\n    this.log(`Switching to level ${newLevel} (${level.height ? level.height + 'p ' : ''}${level.videoRange ? level.videoRange + ' ' : ''}${level.codecSet ? level.codecSet + ' ' : ''}@${level.bitrate})${pathwayId ? ' with Pathway ' + pathwayId : ''} from level ${lastLevelIndex}${lastPathwayId ? ' with Pathway ' + lastPathwayId : ''}`);\n    const levelSwitchingData = {\n      level: newLevel,\n      attrs: level.attrs,\n      details: level.details,\n      bitrate: level.bitrate,\n      averageBitrate: level.averageBitrate,\n      maxBitrate: level.maxBitrate,\n      realBitrate: level.realBitrate,\n      width: level.width,\n      height: level.height,\n      codecSet: level.codecSet,\n      audioCodec: level.audioCodec,\n      videoCodec: level.videoCodec,\n      audioGroups: level.audioGroups,\n      subtitleGroups: level.subtitleGroups,\n      loaded: level.loaded,\n      loadError: level.loadError,\n      fragmentError: level.fragmentError,\n      name: level.name,\n      id: level.id,\n      uri: level.uri,\n      url: level.url,\n      urlId: 0,\n      audioGroupIds: level.audioGroupIds,\n      textGroupIds: level.textGroupIds\n    };\n    this.hls.trigger(Events.LEVEL_SWITCHING, levelSwitchingData);\n    // check if we need to load playlist for this level\n    const levelDetails = level.details;\n    if (!levelDetails || levelDetails.live) {\n      // level not retrieved yet, or live playlist we need to (re)load it\n      const hlsUrlParameters = this.switchParams(level.uri, lastLevel == null ? void 0 : lastLevel.details, levelDetails);\n      this.loadPlaylist(hlsUrlParameters);\n    }\n  }\n  get manualLevel() {\n    return this.manualLevelIndex;\n  }\n  set manualLevel(newLevel) {\n    this.manualLevelIndex = newLevel;\n    if (this._startLevel === undefined) {\n      this._startLevel = newLevel;\n    }\n    if (newLevel !== -1) {\n      this.level = newLevel;\n    }\n  }\n  get firstLevel() {\n    return this._firstLevel;\n  }\n  set firstLevel(newLevel) {\n    this._firstLevel = newLevel;\n  }\n  get startLevel() {\n    // Setting hls.startLevel (this._startLevel) overrides config.startLevel\n    if (this._startLevel === undefined) {\n      const configStartLevel = this.hls.config.startLevel;\n      if (configStartLevel !== undefined) {\n        return configStartLevel;\n      }\n      return this.hls.firstAutoLevel;\n    }\n    return this._startLevel;\n  }\n  set startLevel(newLevel) {\n    this._startLevel = newLevel;\n  }\n  onError(event, data) {\n    if (data.fatal || !data.context) {\n      return;\n    }\n    if (data.context.type === PlaylistContextType.LEVEL && data.context.level === this.level) {\n      this.checkRetry(data);\n    }\n  }\n\n  // reset errors on the successful load of a fragment\n  onFragBuffered(event, {\n    frag\n  }) {\n    if (frag !== undefined && frag.type === PlaylistLevelType.MAIN) {\n      const el = frag.elementaryStreams;\n      if (!Object.keys(el).some(type => !!el[type])) {\n        return;\n      }\n      const level = this._levels[frag.level];\n      if (level != null && level.loadError) {\n        this.log(`Resetting level error count of ${level.loadError} on frag buffered`);\n        level.loadError = 0;\n      }\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _data$deliveryDirecti2;\n    const {\n      level,\n      details\n    } = data;\n    const curLevel = this._levels[level];\n    if (!curLevel) {\n      var _data$deliveryDirecti;\n      this.warn(`Invalid level index ${level}`);\n      if ((_data$deliveryDirecti = data.deliveryDirectives) != null && _data$deliveryDirecti.skip) {\n        details.deltaUpdateFailed = true;\n      }\n      return;\n    }\n\n    // only process level loaded events matching with expected level\n    if (level === this.currentLevelIndex) {\n      // reset level load error counter on successful level loaded only if there is no issues with fragments\n      if (curLevel.fragmentError === 0) {\n        curLevel.loadError = 0;\n      }\n      this.playlistLoaded(level, data, curLevel.details);\n    } else if ((_data$deliveryDirecti2 = data.deliveryDirectives) != null && _data$deliveryDirecti2.skip) {\n      // received a delta playlist update that cannot be merged\n      details.deltaUpdateFailed = true;\n    }\n  }\n  loadPlaylist(hlsUrlParameters) {\n    super.loadPlaylist();\n    const currentLevelIndex = this.currentLevelIndex;\n    const currentLevel = this.currentLevel;\n    if (currentLevel && this.shouldLoadPlaylist(currentLevel)) {\n      let url = currentLevel.uri;\n      if (hlsUrlParameters) {\n        try {\n          url = hlsUrlParameters.addDirectives(url);\n        } catch (error) {\n          this.warn(`Could not construct new URL with HLS Delivery Directives: ${error}`);\n        }\n      }\n      const pathwayId = currentLevel.attrs['PATHWAY-ID'];\n      this.log(`Loading level index ${currentLevelIndex}${(hlsUrlParameters == null ? void 0 : hlsUrlParameters.msn) !== undefined ? ' at sn ' + hlsUrlParameters.msn + ' part ' + hlsUrlParameters.part : ''} with${pathwayId ? ' Pathway ' + pathwayId : ''} ${url}`);\n\n      // console.log('Current audio track group ID:', this.hls.audioTracks[this.hls.audioTrack].groupId);\n      // console.log('New video quality level audio group id:', levelObject.attrs.AUDIO, level);\n      this.clearTimer();\n      this.hls.trigger(Events.LEVEL_LOADING, {\n        url,\n        level: currentLevelIndex,\n        pathwayId: currentLevel.attrs['PATHWAY-ID'],\n        id: 0,\n        // Deprecated Level urlId\n        deliveryDirectives: hlsUrlParameters || null\n      });\n    }\n  }\n  get nextLoadLevel() {\n    if (this.manualLevelIndex !== -1) {\n      return this.manualLevelIndex;\n    } else {\n      return this.hls.nextAutoLevel;\n    }\n  }\n  set nextLoadLevel(nextLevel) {\n    this.level = nextLevel;\n    if (this.manualLevelIndex === -1) {\n      this.hls.nextAutoLevel = nextLevel;\n    }\n  }\n  removeLevel(levelIndex) {\n    var _this$currentLevel;\n    const levels = this._levels.filter((level, index) => {\n      if (index !== levelIndex) {\n        return true;\n      }\n      if (this.steering) {\n        this.steering.removeLevel(level);\n      }\n      if (level === this.currentLevel) {\n        this.currentLevel = null;\n        this.currentLevelIndex = -1;\n        if (level.details) {\n          level.details.fragments.forEach(f => f.level = -1);\n        }\n      }\n      return false;\n    });\n    reassignFragmentLevelIndexes(levels);\n    this._levels = levels;\n    if (this.currentLevelIndex > -1 && (_this$currentLevel = this.currentLevel) != null && _this$currentLevel.details) {\n      this.currentLevelIndex = this.currentLevel.details.fragments[0].level;\n    }\n    this.hls.trigger(Events.LEVELS_UPDATED, {\n      levels\n    });\n  }\n  onLevelsUpdated(event, {\n    levels\n  }) {\n    this._levels = levels;\n  }\n  checkMaxAutoUpdated() {\n    const {\n      autoLevelCapping,\n      maxAutoLevel,\n      maxHdcpLevel\n    } = this.hls;\n    if (this._maxAutoLevel !== maxAutoLevel) {\n      this._maxAutoLevel = maxAutoLevel;\n      this.hls.trigger(Events.MAX_AUTO_LEVEL_UPDATED, {\n        autoLevelCapping,\n        levels: this.levels,\n        maxAutoLevel,\n        minAutoLevel: this.hls.minAutoLevel,\n        maxHdcpLevel\n      });\n    }\n  }\n}\nfunction assignTrackIdsByGroup(tracks) {\n  const groups = {};\n  tracks.forEach(track => {\n    const groupId = track.groupId || '';\n    track.id = groups[groupId] = groups[groupId] || 0;\n    groups[groupId]++;\n  });\n}\n\nclass KeyLoader {\n  constructor(config) {\n    this.config = void 0;\n    this.keyUriToKeyInfo = {};\n    this.emeController = null;\n    this.config = config;\n  }\n  abort(type) {\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        var _loader$context;\n        if (type && type !== ((_loader$context = loader.context) == null ? void 0 : _loader$context.frag.type)) {\n          return;\n        }\n        loader.abort();\n      }\n    }\n  }\n  detach() {\n    for (const uri in this.keyUriToKeyInfo) {\n      const keyInfo = this.keyUriToKeyInfo[uri];\n      // Remove cached EME keys on detach\n      if (keyInfo.mediaKeySessionContext || keyInfo.decryptdata.isCommonEncryption) {\n        delete this.keyUriToKeyInfo[uri];\n      }\n    }\n  }\n  destroy() {\n    this.detach();\n    for (const uri in this.keyUriToKeyInfo) {\n      const loader = this.keyUriToKeyInfo[uri].loader;\n      if (loader) {\n        loader.destroy();\n      }\n    }\n    this.keyUriToKeyInfo = {};\n  }\n  createKeyLoadError(frag, details = ErrorDetails.KEY_LOAD_ERROR, error, networkDetails, response) {\n    return new LoadError({\n      type: ErrorTypes.NETWORK_ERROR,\n      details,\n      fatal: false,\n      frag,\n      response,\n      error,\n      networkDetails\n    });\n  }\n  loadClear(loadingFrag, encryptedFragments) {\n    if (this.emeController && this.config.emeEnabled) {\n      // access key-system with nearest key on start (loaidng frag is unencrypted)\n      const {\n        sn,\n        cc\n      } = loadingFrag;\n      for (let i = 0; i < encryptedFragments.length; i++) {\n        const frag = encryptedFragments[i];\n        if (cc <= frag.cc && (sn === 'initSegment' || frag.sn === 'initSegment' || sn < frag.sn)) {\n          this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n            frag.setKeyFormat(keySystemFormat);\n          });\n          break;\n        }\n      }\n    }\n  }\n  load(frag) {\n    if (!frag.decryptdata && frag.encrypted && this.emeController) {\n      // Multiple keys, but none selected, resolve in eme-controller\n      return this.emeController.selectKeySystemFormat(frag).then(keySystemFormat => {\n        return this.loadInternal(frag, keySystemFormat);\n      });\n    }\n    return this.loadInternal(frag);\n  }\n  loadInternal(frag, keySystemFormat) {\n    var _keyInfo, _keyInfo2;\n    if (keySystemFormat) {\n      frag.setKeyFormat(keySystemFormat);\n    }\n    const decryptdata = frag.decryptdata;\n    if (!decryptdata) {\n      const error = new Error(keySystemFormat ? `Expected frag.decryptdata to be defined after setting format ${keySystemFormat}` : 'Missing decryption data on fragment in onKeyLoading');\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, error));\n    }\n    const uri = decryptdata.uri;\n    if (!uri) {\n      return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Invalid key URI: \"${uri}\"`)));\n    }\n    let keyInfo = this.keyUriToKeyInfo[uri];\n    if ((_keyInfo = keyInfo) != null && _keyInfo.decryptdata.key) {\n      decryptdata.key = keyInfo.decryptdata.key;\n      return Promise.resolve({\n        frag,\n        keyInfo\n      });\n    }\n    // Return key load promise as long as it does not have a mediakey session with an unusable key status\n    if ((_keyInfo2 = keyInfo) != null && _keyInfo2.keyLoadPromise) {\n      var _keyInfo$mediaKeySess;\n      switch ((_keyInfo$mediaKeySess = keyInfo.mediaKeySessionContext) == null ? void 0 : _keyInfo$mediaKeySess.keyStatus) {\n        case undefined:\n        case 'status-pending':\n        case 'usable':\n        case 'usable-in-future':\n          return keyInfo.keyLoadPromise.then(keyLoadedData => {\n            // Return the correct fragment with updated decryptdata key and loaded keyInfo\n            decryptdata.key = keyLoadedData.keyInfo.decryptdata.key;\n            return {\n              frag,\n              keyInfo\n            };\n          });\n      }\n      // If we have a key session and status and it is not pending or usable, continue\n      // This will go back to the eme-controller for expired keys to get a new keyLoadPromise\n    }\n\n    // Load the key or return the loading promise\n    keyInfo = this.keyUriToKeyInfo[uri] = {\n      decryptdata,\n      keyLoadPromise: null,\n      loader: null,\n      mediaKeySessionContext: null\n    };\n    switch (decryptdata.method) {\n      case 'ISO-23001-7':\n      case 'SAMPLE-AES':\n      case 'SAMPLE-AES-CENC':\n      case 'SAMPLE-AES-CTR':\n        if (decryptdata.keyFormat === 'identity') {\n          // loadKeyHTTP handles http(s) and data URLs\n          return this.loadKeyHTTP(keyInfo, frag);\n        }\n        return this.loadKeyEME(keyInfo, frag);\n      case 'AES-128':\n        return this.loadKeyHTTP(keyInfo, frag);\n      default:\n        return Promise.reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`Key supplied with unsupported METHOD: \"${decryptdata.method}\"`)));\n    }\n  }\n  loadKeyEME(keyInfo, frag) {\n    const keyLoadedData = {\n      frag,\n      keyInfo\n    };\n    if (this.emeController && this.config.emeEnabled) {\n      const keySessionContextPromise = this.emeController.loadKey(keyLoadedData);\n      if (keySessionContextPromise) {\n        return (keyInfo.keyLoadPromise = keySessionContextPromise.then(keySessionContext => {\n          keyInfo.mediaKeySessionContext = keySessionContext;\n          return keyLoadedData;\n        })).catch(error => {\n          // Remove promise for license renewal or retry\n          keyInfo.keyLoadPromise = null;\n          throw error;\n        });\n      }\n    }\n    return Promise.resolve(keyLoadedData);\n  }\n  loadKeyHTTP(keyInfo, frag) {\n    const config = this.config;\n    const Loader = config.loader;\n    const keyLoader = new Loader(config);\n    frag.keyLoader = keyInfo.loader = keyLoader;\n    return keyInfo.keyLoadPromise = new Promise((resolve, reject) => {\n      const loaderContext = {\n        keyInfo,\n        frag,\n        responseType: 'arraybuffer',\n        url: keyInfo.decryptdata.uri\n      };\n\n      // maxRetry is 0 so that instead of retrying the same key on the same variant multiple times,\n      // key-loader will trigger an error and rely on stream-controller to handle retry logic.\n      // this will also align retry logic with fragment-loader\n      const loadPolicy = config.keyLoadPolicy.default;\n      const loaderConfig = {\n        loadPolicy,\n        timeout: loadPolicy.maxLoadTimeMs,\n        maxRetry: 0,\n        retryDelay: 0,\n        maxRetryDelay: 0\n      };\n      const loaderCallbacks = {\n        onSuccess: (response, stats, context, networkDetails) => {\n          const {\n            frag,\n            keyInfo,\n            url: uri\n          } = context;\n          if (!frag.decryptdata || keyInfo !== this.keyUriToKeyInfo[uri]) {\n            return reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error('after key load, decryptdata unset or changed'), networkDetails));\n          }\n          keyInfo.decryptdata.key = frag.decryptdata.key = new Uint8Array(response.data);\n\n          // detach fragment key loader on load success\n          frag.keyLoader = null;\n          keyInfo.loader = null;\n          resolve({\n            frag,\n            keyInfo\n          });\n        },\n        onError: (response, context, networkDetails, stats) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_ERROR, new Error(`HTTP Error ${response.code} loading key ${response.text}`), networkDetails, _objectSpread2({\n            url: loaderContext.url,\n            data: undefined\n          }, response)));\n        },\n        onTimeout: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.KEY_LOAD_TIMEOUT, new Error('key loading timed out'), networkDetails));\n        },\n        onAbort: (stats, context, networkDetails) => {\n          this.resetLoader(context);\n          reject(this.createKeyLoadError(frag, ErrorDetails.INTERNAL_ABORTED, new Error('key loading aborted'), networkDetails));\n        }\n      };\n      keyLoader.load(loaderContext, loaderConfig, loaderCallbacks);\n    });\n  }\n  resetLoader(context) {\n    const {\n      frag,\n      keyInfo,\n      url: uri\n    } = context;\n    const loader = keyInfo.loader;\n    if (frag.keyLoader === loader) {\n      frag.keyLoader = null;\n      keyInfo.loader = null;\n    }\n    delete this.keyUriToKeyInfo[uri];\n    if (loader) {\n      loader.destroy();\n    }\n  }\n}\n\nfunction getSourceBuffer() {\n  return self.SourceBuffer || self.WebKitSourceBuffer;\n}\nfunction isMSESupported() {\n  const mediaSource = getMediaSource();\n  if (!mediaSource) {\n    return false;\n  }\n\n  // if SourceBuffer is exposed ensure its API is valid\n  // Older browsers do not expose SourceBuffer globally so checking SourceBuffer.prototype is impossible\n  const sourceBuffer = getSourceBuffer();\n  return !sourceBuffer || sourceBuffer.prototype && typeof sourceBuffer.prototype.appendBuffer === 'function' && typeof sourceBuffer.prototype.remove === 'function';\n}\nfunction isSupported() {\n  if (!isMSESupported()) {\n    return false;\n  }\n  const mediaSource = getMediaSource();\n  return typeof (mediaSource == null ? void 0 : mediaSource.isTypeSupported) === 'function' && (['avc1.42E01E,mp4a.40.2', 'av01.0.01M.08', 'vp09.00.50.08'].some(codecsForVideoContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecsForVideoContainer, 'video'))) || ['mp4a.40.2', 'fLaC'].some(codecForAudioContainer => mediaSource.isTypeSupported(mimeTypeForCodec(codecForAudioContainer, 'audio'))));\n}\nfunction changeTypeSupported() {\n  var _sourceBuffer$prototy;\n  const sourceBuffer = getSourceBuffer();\n  return typeof (sourceBuffer == null ? void 0 : (_sourceBuffer$prototy = sourceBuffer.prototype) == null ? void 0 : _sourceBuffer$prototy.changeType) === 'function';\n}\n\nconst STALL_MINIMUM_DURATION_MS = 250;\nconst MAX_START_GAP_JUMP = 2.0;\nconst SKIP_BUFFER_HOLE_STEP_SECONDS = 0.1;\nconst SKIP_BUFFER_RANGE_START = 0.05;\nclass GapController {\n  constructor(config, media, fragmentTracker, hls) {\n    this.config = void 0;\n    this.media = null;\n    this.fragmentTracker = void 0;\n    this.hls = void 0;\n    this.nudgeRetry = 0;\n    this.stallReported = false;\n    this.stalled = null;\n    this.moved = false;\n    this.seeking = false;\n    this.config = config;\n    this.media = media;\n    this.fragmentTracker = fragmentTracker;\n    this.hls = hls;\n  }\n  destroy() {\n    this.media = null;\n    // @ts-ignore\n    this.hls = this.fragmentTracker = null;\n  }\n\n  /**\n   * Checks if the playhead is stuck within a gap, and if so, attempts to free it.\n   * A gap is an unbuffered range between two buffered ranges (or the start and the first buffered range).\n   *\n   * @param lastCurrentTime - Previously read playhead position\n   */\n  poll(lastCurrentTime, activeFrag) {\n    const {\n      config,\n      media,\n      stalled\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const {\n      currentTime,\n      seeking\n    } = media;\n    const seeked = this.seeking && !seeking;\n    const beginSeek = !this.seeking && seeking;\n    this.seeking = seeking;\n\n    // The playhead is moving, no-op\n    if (currentTime !== lastCurrentTime) {\n      this.moved = true;\n      if (!seeking) {\n        this.nudgeRetry = 0;\n      }\n      if (stalled !== null) {\n        // The playhead is now moving, but was previously stalled\n        if (this.stallReported) {\n          const _stalledDuration = self.performance.now() - stalled;\n          logger.warn(`playback not stuck anymore @${currentTime}, after ${Math.round(_stalledDuration)}ms`);\n          this.stallReported = false;\n        }\n        this.stalled = null;\n      }\n      return;\n    }\n\n    // Clear stalled state when beginning or finishing seeking so that we don't report stalls coming out of a seek\n    if (beginSeek || seeked) {\n      this.stalled = null;\n      return;\n    }\n\n    // The playhead should not be moving\n    if (media.paused && !seeking || media.ended || media.playbackRate === 0 || !BufferHelper.getBuffered(media).length) {\n      this.nudgeRetry = 0;\n      return;\n    }\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const nextStart = bufferInfo.nextStart || 0;\n    if (seeking) {\n      // Waiting for seeking in a buffered range to complete\n      const hasEnoughBuffer = bufferInfo.len > MAX_START_GAP_JUMP;\n      // Next buffered range is too far ahead to jump to while still seeking\n      const noBufferGap = !nextStart || activeFrag && activeFrag.start <= currentTime || nextStart - currentTime > MAX_START_GAP_JUMP && !this.fragmentTracker.getPartialFragment(currentTime);\n      if (hasEnoughBuffer || noBufferGap) {\n        return;\n      }\n      // Reset moved state when seeking to a point in or before a gap\n      this.moved = false;\n    }\n\n    // Skip start gaps if we haven't played, but the last poll detected the start of a stall\n    // The addition poll gives the browser a chance to jump the gap for us\n    if (!this.moved && this.stalled !== null) {\n      var _level$details;\n      // There is no playable buffer (seeked, waiting for buffer)\n      const isBuffered = bufferInfo.len > 0;\n      if (!isBuffered && !nextStart) {\n        return;\n      }\n      // Jump start gaps within jump threshold\n      const startJump = Math.max(nextStart, bufferInfo.start || 0) - currentTime;\n\n      // When joining a live stream with audio tracks, account for live playlist window sliding by allowing\n      // a larger jump over start gaps caused by the audio-stream-controller buffering a start fragment\n      // that begins over 1 target duration after the video start position.\n      const level = this.hls.levels ? this.hls.levels[this.hls.currentLevel] : null;\n      const isLive = level == null ? void 0 : (_level$details = level.details) == null ? void 0 : _level$details.live;\n      const maxStartGapJump = isLive ? level.details.targetduration * 2 : MAX_START_GAP_JUMP;\n      const partialOrGap = this.fragmentTracker.getPartialFragment(currentTime);\n      if (startJump > 0 && (startJump <= maxStartGapJump || partialOrGap)) {\n        if (!media.paused) {\n          this._trySkipBufferHole(partialOrGap);\n        }\n        return;\n      }\n    }\n\n    // Start tracking stall time\n    const tnow = self.performance.now();\n    if (stalled === null) {\n      this.stalled = tnow;\n      return;\n    }\n    const stalledDuration = tnow - stalled;\n    if (!seeking && stalledDuration >= STALL_MINIMUM_DURATION_MS) {\n      // Report stalling after trying to fix\n      this._reportStall(bufferInfo);\n      if (!this.media) {\n        return;\n      }\n    }\n    const bufferedWithHoles = BufferHelper.bufferInfo(media, currentTime, config.maxBufferHole);\n    this._tryFixBufferStall(bufferedWithHoles, stalledDuration);\n  }\n\n  /**\n   * Detects and attempts to fix known buffer stalling issues.\n   * @param bufferInfo - The properties of the current buffer.\n   * @param stalledDurationMs - The amount of time Hls.js has been stalling for.\n   * @private\n   */\n  _tryFixBufferStall(bufferInfo, stalledDurationMs) {\n    const {\n      config,\n      fragmentTracker,\n      media\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    const partial = fragmentTracker.getPartialFragment(currentTime);\n    if (partial) {\n      // Try to skip over the buffer hole caused by a partial fragment\n      // This method isn't limited by the size of the gap between buffered ranges\n      const targetTime = this._trySkipBufferHole(partial);\n      // we return here in this case, meaning\n      // the branch below only executes when we haven't seeked to a new position\n      if (targetTime || !this.media) {\n        return;\n      }\n    }\n\n    // if we haven't had to skip over a buffer hole of a partial fragment\n    // we may just have to \"nudge\" the playlist as the browser decoding/rendering engine\n    // needs to cross some sort of threshold covering all source-buffers content\n    // to start playing properly.\n    if ((bufferInfo.len > config.maxBufferHole || bufferInfo.nextStart && bufferInfo.nextStart - currentTime < config.maxBufferHole) && stalledDurationMs > config.highBufferWatchdogPeriod * 1000) {\n      logger.warn('Trying to nudge playhead over buffer-hole');\n      // Try to nudge currentTime over a buffer hole if we've been stalling for the configured amount of seconds\n      // We only try to jump the hole if it's under the configured size\n      // Reset stalled so to rearm watchdog timer\n      this.stalled = null;\n      this._tryNudgeBuffer();\n    }\n  }\n\n  /**\n   * Triggers a BUFFER_STALLED_ERROR event, but only once per stall period.\n   * @param bufferLen - The playhead distance from the end of the current buffer segment.\n   * @private\n   */\n  _reportStall(bufferInfo) {\n    const {\n      hls,\n      media,\n      stallReported\n    } = this;\n    if (!stallReported && media) {\n      // Report stalled error once\n      this.stallReported = true;\n      const error = new Error(`Playback stalling at @${media.currentTime} due to low buffer (${JSON.stringify(bufferInfo)})`);\n      logger.warn(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        fatal: false,\n        error,\n        buffer: bufferInfo.len\n      });\n    }\n  }\n\n  /**\n   * Attempts to fix buffer stalls by jumping over known gaps caused by partial fragments\n   * @param partial - The partial fragment found at the current time (where playback is stalling).\n   * @private\n   */\n  _trySkipBufferHole(partial) {\n    const {\n      config,\n      hls,\n      media\n    } = this;\n    if (media === null) {\n      return 0;\n    }\n\n    // Check if currentTime is between unbuffered regions of partial fragments\n    const currentTime = media.currentTime;\n    const bufferInfo = BufferHelper.bufferInfo(media, currentTime, 0);\n    const startTime = currentTime < bufferInfo.start ? bufferInfo.start : bufferInfo.nextStart;\n    if (startTime) {\n      const bufferStarved = bufferInfo.len <= config.maxBufferHole;\n      const waiting = bufferInfo.len > 0 && bufferInfo.len < 1 && media.readyState < 3;\n      const gapLength = startTime - currentTime;\n      if (gapLength > 0 && (bufferStarved || waiting)) {\n        // Only allow large gaps to be skipped if it is a start gap, or all fragments in skip range are partial\n        if (gapLength > config.maxBufferHole) {\n          const {\n            fragmentTracker\n          } = this;\n          let startGap = false;\n          if (currentTime === 0) {\n            const startFrag = fragmentTracker.getAppendedFrag(0, PlaylistLevelType.MAIN);\n            if (startFrag && startTime < startFrag.end) {\n              startGap = true;\n            }\n          }\n          if (!startGap) {\n            const startProvisioned = partial || fragmentTracker.getAppendedFrag(currentTime, PlaylistLevelType.MAIN);\n            if (startProvisioned) {\n              let moreToLoad = false;\n              let pos = startProvisioned.end;\n              while (pos < startTime) {\n                const provisioned = fragmentTracker.getPartialFragment(pos);\n                if (provisioned) {\n                  pos += provisioned.duration;\n                } else {\n                  moreToLoad = true;\n                  break;\n                }\n              }\n              if (moreToLoad) {\n                return 0;\n              }\n            }\n          }\n        }\n        const targetTime = Math.max(startTime + SKIP_BUFFER_RANGE_START, currentTime + SKIP_BUFFER_HOLE_STEP_SECONDS);\n        logger.warn(`skipping hole, adjusting currentTime from ${currentTime} to ${targetTime}`);\n        this.moved = true;\n        this.stalled = null;\n        media.currentTime = targetTime;\n        if (partial && !partial.gap) {\n          const error = new Error(`fragment loaded with buffer holes, seeking from ${currentTime} to ${targetTime}`);\n          hls.trigger(Events.ERROR, {\n            type: ErrorTypes.MEDIA_ERROR,\n            details: ErrorDetails.BUFFER_SEEK_OVER_HOLE,\n            fatal: false,\n            error,\n            reason: error.message,\n            frag: partial\n          });\n        }\n        return targetTime;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Attempts to fix buffer stalls by advancing the mediaElement's current time by a small amount.\n   * @private\n   */\n  _tryNudgeBuffer() {\n    const {\n      config,\n      hls,\n      media,\n      nudgeRetry\n    } = this;\n    if (media === null) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    this.nudgeRetry++;\n    if (nudgeRetry < config.nudgeMaxRetry) {\n      const targetTime = currentTime + (nudgeRetry + 1) * config.nudgeOffset;\n      // playback stalled in buffered area ... let's nudge currentTime to try to overcome this\n      const error = new Error(`Nudging 'currentTime' from ${currentTime} to ${targetTime}`);\n      logger.warn(error.message);\n      media.currentTime = targetTime;\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_NUDGE_ON_STALL,\n        error,\n        fatal: false\n      });\n    } else {\n      const error = new Error(`Playhead still not moving while enough data buffered @${currentTime} after ${config.nudgeMaxRetry} nudges`);\n      logger.error(error.message);\n      hls.trigger(Events.ERROR, {\n        type: ErrorTypes.MEDIA_ERROR,\n        details: ErrorDetails.BUFFER_STALLED_ERROR,\n        error,\n        fatal: true\n      });\n    }\n  }\n}\n\nconst TICK_INTERVAL = 100; // how often to tick in ms\n\nclass StreamController extends BaseStreamController {\n  constructor(hls, fragmentTracker, keyLoader) {\n    super(hls, fragmentTracker, keyLoader, '[stream-controller]', PlaylistLevelType.MAIN);\n    this.audioCodecSwap = false;\n    this.gapController = null;\n    this.level = -1;\n    this._forceStartLoad = false;\n    this.altAudio = false;\n    this.audioOnly = false;\n    this.fragPlaying = null;\n    this.onvplaying = null;\n    this.onvseeked = null;\n    this.fragLastKbps = 0;\n    this.couldBacktrack = false;\n    this.backtrackFragment = null;\n    this.audioCodecSwitch = false;\n    this.videoBuffer = null;\n    this._registerListeners();\n  }\n  _registerListeners() {\n    const {\n      hls\n    } = this;\n    hls.on(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.on(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.on(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.on(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.on(Events.LEVEL_LOADING, this.onLevelLoading, this);\n    hls.on(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.on(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.on(Events.ERROR, this.onError, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.on(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.on(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.on(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.on(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.on(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  _unregisterListeners() {\n    const {\n      hls\n    } = this;\n    hls.off(Events.MEDIA_ATTACHED, this.onMediaAttached, this);\n    hls.off(Events.MEDIA_DETACHING, this.onMediaDetaching, this);\n    hls.off(Events.MANIFEST_LOADING, this.onManifestLoading, this);\n    hls.off(Events.MANIFEST_PARSED, this.onManifestParsed, this);\n    hls.off(Events.LEVEL_LOADED, this.onLevelLoaded, this);\n    hls.off(Events.FRAG_LOAD_EMERGENCY_ABORTED, this.onFragLoadEmergencyAborted, this);\n    hls.off(Events.ERROR, this.onError, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHING, this.onAudioTrackSwitching, this);\n    hls.off(Events.AUDIO_TRACK_SWITCHED, this.onAudioTrackSwitched, this);\n    hls.off(Events.BUFFER_CREATED, this.onBufferCreated, this);\n    hls.off(Events.BUFFER_FLUSHED, this.onBufferFlushed, this);\n    hls.off(Events.LEVELS_UPDATED, this.onLevelsUpdated, this);\n    hls.off(Events.FRAG_BUFFERED, this.onFragBuffered, this);\n  }\n  onHandlerDestroying() {\n    this._unregisterListeners();\n    super.onHandlerDestroying();\n  }\n  startLoad(startPosition) {\n    if (this.levels) {\n      const {\n        lastCurrentTime,\n        hls\n      } = this;\n      this.stopLoad();\n      this.setInterval(TICK_INTERVAL);\n      this.level = -1;\n      if (!this.startFragRequested) {\n        // determine load level\n        let startLevel = hls.startLevel;\n        if (startLevel === -1) {\n          if (hls.config.testBandwidth && this.levels.length > 1) {\n            // -1 : guess start Level by doing a bitrate test by loading first fragment of lowest quality level\n            startLevel = 0;\n            this.bitrateTest = true;\n          } else {\n            startLevel = hls.firstAutoLevel;\n          }\n        }\n        // set new level to playlist loader : this will trigger start level load\n        // hls.nextLoadLevel remains until it is set to a new value or until a new frag is successfully loaded\n        hls.nextLoadLevel = startLevel;\n        this.level = hls.loadLevel;\n        this.loadedmetadata = false;\n      }\n      // if startPosition undefined but lastCurrentTime set, set startPosition to last currentTime\n      if (lastCurrentTime > 0 && startPosition === -1) {\n        this.log(`Override startPosition with lastCurrentTime @${lastCurrentTime.toFixed(3)}`);\n        startPosition = lastCurrentTime;\n      }\n      this.state = State.IDLE;\n      this.nextLoadPosition = this.startPosition = this.lastCurrentTime = startPosition;\n      this.tick();\n    } else {\n      this._forceStartLoad = true;\n      this.state = State.STOPPED;\n    }\n  }\n  stopLoad() {\n    this._forceStartLoad = false;\n    super.stopLoad();\n  }\n  doTick() {\n    switch (this.state) {\n      case State.WAITING_LEVEL:\n        {\n          const {\n            levels,\n            level\n          } = this;\n          const currentLevel = levels == null ? void 0 : levels[level];\n          const details = currentLevel == null ? void 0 : currentLevel.details;\n          if (details && (!details.live || this.levelLastLoaded === currentLevel)) {\n            if (this.waitForCdnTuneIn(details)) {\n              break;\n            }\n            this.state = State.IDLE;\n            break;\n          } else if (this.hls.nextLoadLevel !== this.level) {\n            this.state = State.IDLE;\n            break;\n          }\n          break;\n        }\n      case State.FRAG_LOADING_WAITING_RETRY:\n        {\n          var _this$media;\n          const now = self.performance.now();\n          const retryDate = this.retryDate;\n          // if current time is gt than retryDate, or if media seeking let's switch to IDLE state to retry loading\n          if (!retryDate || now >= retryDate || (_this$media = this.media) != null && _this$media.seeking) {\n            const {\n              levels,\n              level\n            } = this;\n            const currentLevel = levels == null ? void 0 : levels[level];\n            this.resetStartWhenNotLoaded(currentLevel || null);\n            this.state = State.IDLE;\n          }\n        }\n        break;\n    }\n    if (this.state === State.IDLE) {\n      this.doTickIdle();\n    }\n    this.onTickEnd();\n  }\n  onTickEnd() {\n    super.onTickEnd();\n    this.checkBuffer();\n    this.checkFragmentChanged();\n  }\n  doTickIdle() {\n    const {\n      hls,\n      levelLastLoaded,\n      levels,\n      media\n    } = this;\n\n    // if start level not parsed yet OR\n    // if video not attached AND start fragment already requested OR start frag prefetch not enabled\n    // exit loop, as we either need more info (level not parsed) or we need media to be attached to load new fragment\n    if (levelLastLoaded === null || !media && (this.startFragRequested || !hls.config.startFragPrefetch)) {\n      return;\n    }\n\n    // If the \"main\" level is audio-only but we are loading an alternate track in the same group, do not load anything\n    if (this.altAudio && this.audioOnly) {\n      return;\n    }\n    const level = hls.nextLoadLevel;\n    if (!(levels != null && levels[level])) {\n      return;\n    }\n    const levelInfo = levels[level];\n\n    // if buffer length is less than maxBufLen try to load a new fragment\n\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null) {\n      return;\n    }\n    const lastDetails = this.getLevelDetails();\n    if (lastDetails && this._streamEnded(bufferInfo, lastDetails)) {\n      const data = {};\n      if (this.altAudio) {\n        data.type = 'video';\n      }\n      this.hls.trigger(Events.BUFFER_EOS, data);\n      this.state = State.ENDED;\n      return;\n    }\n\n    // set next load level : this will trigger a playlist load if needed\n    if (hls.loadLevel !== level && hls.manualLevel === -1) {\n      this.log(`Adapting to level ${level} from level ${this.level}`);\n    }\n    this.level = hls.nextLoadLevel = level;\n    const levelDetails = levelInfo.details;\n    // if level info not retrieved yet, switch state and wait for level retrieval\n    // if live playlist, ensure that new playlist has been refreshed to avoid loading/try to load\n    // a useless and outdated fragment (that might even introduce load error if it is already out of the live playlist)\n    if (!levelDetails || this.state === State.WAITING_LEVEL || levelDetails.live && this.levelLastLoaded !== levelInfo) {\n      this.level = level;\n      this.state = State.WAITING_LEVEL;\n      return;\n    }\n    const bufferLen = bufferInfo.len;\n\n    // compute max Buffer Length that we could get from this load level, based on level bitrate. don't buffer more than 60 MB and more than 30s\n    const maxBufLen = this.getMaxBufferLength(levelInfo.maxBitrate);\n\n    // Stay idle if we are still with buffer margins\n    if (bufferLen >= maxBufLen) {\n      return;\n    }\n    if (this.backtrackFragment && this.backtrackFragment.start > bufferInfo.end) {\n      this.backtrackFragment = null;\n    }\n    const targetBufferTime = this.backtrackFragment ? this.backtrackFragment.start : bufferInfo.end;\n    let frag = this.getNextFragment(targetBufferTime, levelDetails);\n    // Avoid backtracking by loading an earlier segment in streams with segments that do not start with a key frame (flagged by `couldBacktrack`)\n    if (this.couldBacktrack && !this.fragPrevious && frag && frag.sn !== 'initSegment' && this.fragmentTracker.getState(frag) !== FragmentState.OK) {\n      var _this$backtrackFragme;\n      const backtrackSn = ((_this$backtrackFragme = this.backtrackFragment) != null ? _this$backtrackFragme : frag).sn;\n      const fragIdx = backtrackSn - levelDetails.startSN;\n      const backtrackFrag = levelDetails.fragments[fragIdx - 1];\n      if (backtrackFrag && frag.cc === backtrackFrag.cc) {\n        frag = backtrackFrag;\n        this.fragmentTracker.removeFragment(backtrackFrag);\n      }\n    } else if (this.backtrackFragment && bufferInfo.len) {\n      this.backtrackFragment = null;\n    }\n    // Avoid loop loading by using nextLoadPosition set for backtracking and skipping consecutive GAP tags\n    if (frag && this.isLoopLoading(frag, targetBufferTime)) {\n      const gapStart = frag.gap;\n      if (!gapStart) {\n        // Cleanup the fragment tracker before trying to find the next unbuffered fragment\n        const type = this.audioOnly && !this.altAudio ? ElementaryStreamTypes.AUDIO : ElementaryStreamTypes.VIDEO;\n        const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n        if (mediaBuffer) {\n          this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n        }\n      }\n      frag = this.getNextFragmentLoopLoading(frag, levelDetails, bufferInfo, PlaylistLevelType.MAIN, maxBufLen);\n    }\n    if (!frag) {\n      return;\n    }\n    if (frag.initSegment && !frag.initSegment.data && !this.bitrateTest) {\n      frag = frag.initSegment;\n    }\n    this.loadFragment(frag, levelInfo, targetBufferTime);\n  }\n  loadFragment(frag, level, targetBufferTime) {\n    // Check if fragment is not loaded\n    const fragState = this.fragmentTracker.getState(frag);\n    this.fragCurrent = frag;\n    if (fragState === FragmentState.NOT_LOADED || fragState === FragmentState.PARTIAL) {\n      if (frag.sn === 'initSegment') {\n        this._loadInitSegment(frag, level);\n      } else if (this.bitrateTest) {\n        this.log(`Fragment ${frag.sn} of level ${frag.level} is being downloaded to test bitrate and will not be buffered`);\n        this._loadBitrateTestFrag(frag, level);\n      } else {\n        this.startFragRequested = true;\n        super.loadFragment(frag, level, targetBufferTime);\n      }\n    } else {\n      this.clearTrackerIfNeeded(frag);\n    }\n  }\n  getBufferedFrag(position) {\n    return this.fragmentTracker.getBufferedFrag(position, PlaylistLevelType.MAIN);\n  }\n  followingBufferedFrag(frag) {\n    if (frag) {\n      // try to get range of next fragment (500ms after this range)\n      return this.getBufferedFrag(frag.end + 0.5);\n    }\n    return null;\n  }\n\n  /*\n    on immediate level switch :\n     - pause playback if playing\n     - cancel any pending load request\n     - and trigger a buffer flush\n  */\n  immediateLevelSwitch() {\n    this.abortCurrentFrag();\n    this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n  }\n\n  /**\n   * try to switch ASAP without breaking video playback:\n   * in order to ensure smooth but quick level switching,\n   * we need to find the next flushable buffer range\n   * we should take into account new segment fetch time\n   */\n  nextLevelSwitch() {\n    const {\n      levels,\n      media\n    } = this;\n    // ensure that media is defined and that metadata are available (to retrieve currentTime)\n    if (media != null && media.readyState) {\n      let fetchdelay;\n      const fragPlayingCurrent = this.getAppendedFrag(media.currentTime);\n      if (fragPlayingCurrent && fragPlayingCurrent.start > 1) {\n        // flush buffer preceding current fragment (flush until current fragment start offset)\n        // minus 1s to avoid video freezing, that could happen if we flush keyframe of current video ...\n        this.flushMainBuffer(0, fragPlayingCurrent.start - 1);\n      }\n      const levelDetails = this.getLevelDetails();\n      if (levelDetails != null && levelDetails.live) {\n        const bufferInfo = this.getMainFwdBufferInfo();\n        // Do not flush in live stream with low buffer\n        if (!bufferInfo || bufferInfo.len < levelDetails.targetduration * 2) {\n          return;\n        }\n      }\n      if (!media.paused && levels) {\n        // add a safety delay of 1s\n        const nextLevelId = this.hls.nextLoadLevel;\n        const nextLevel = levels[nextLevelId];\n        const fragLastKbps = this.fragLastKbps;\n        if (fragLastKbps && this.fragCurrent) {\n          fetchdelay = this.fragCurrent.duration * nextLevel.maxBitrate / (1000 * fragLastKbps) + 1;\n        } else {\n          fetchdelay = 0;\n        }\n      } else {\n        fetchdelay = 0;\n      }\n      // this.log('fetchdelay:'+fetchdelay);\n      // find buffer range that will be reached once new fragment will be fetched\n      const bufferedFrag = this.getBufferedFrag(media.currentTime + fetchdelay);\n      if (bufferedFrag) {\n        // we can flush buffer range following this one without stalling playback\n        const nextBufferedFrag = this.followingBufferedFrag(bufferedFrag);\n        if (nextBufferedFrag) {\n          // if we are here, we can also cancel any loading/demuxing in progress, as they are useless\n          this.abortCurrentFrag();\n          // start flush position is in next buffered frag. Leave some padding for non-independent segments and smoother playback.\n          const maxStart = nextBufferedFrag.maxStartPTS ? nextBufferedFrag.maxStartPTS : nextBufferedFrag.start;\n          const fragDuration = nextBufferedFrag.duration;\n          const startPts = Math.max(bufferedFrag.end, maxStart + Math.min(Math.max(fragDuration - this.config.maxFragLookUpTolerance, fragDuration * (this.couldBacktrack ? 0.5 : 0.125)), fragDuration * (this.couldBacktrack ? 0.75 : 0.25)));\n          this.flushMainBuffer(startPts, Number.POSITIVE_INFINITY);\n        }\n      }\n    }\n  }\n  abortCurrentFrag() {\n    const fragCurrent = this.fragCurrent;\n    this.fragCurrent = null;\n    this.backtrackFragment = null;\n    if (fragCurrent) {\n      fragCurrent.abortRequests();\n      this.fragmentTracker.removeFragment(fragCurrent);\n    }\n    switch (this.state) {\n      case State.KEY_LOADING:\n      case State.FRAG_LOADING:\n      case State.FRAG_LOADING_WAITING_RETRY:\n      case State.PARSING:\n      case State.PARSED:\n        this.state = State.IDLE;\n        break;\n    }\n    this.nextLoadPosition = this.getLoadPosition();\n  }\n  flushMainBuffer(startOffset, endOffset) {\n    super.flushMainBuffer(startOffset, endOffset, this.altAudio ? 'video' : null);\n  }\n  onMediaAttached(event, data) {\n    super.onMediaAttached(event, data);\n    const media = data.media;\n    this.onvplaying = this.onMediaPlaying.bind(this);\n    this.onvseeked = this.onMediaSeeked.bind(this);\n    media.addEventListener('playing', this.onvplaying);\n    media.addEventListener('seeked', this.onvseeked);\n    this.gapController = new GapController(this.config, media, this.fragmentTracker, this.hls);\n  }\n  onMediaDetaching() {\n    const {\n      media\n    } = this;\n    if (media && this.onvplaying && this.onvseeked) {\n      media.removeEventListener('playing', this.onvplaying);\n      media.removeEventListener('seeked', this.onvseeked);\n      this.onvplaying = this.onvseeked = null;\n      this.videoBuffer = null;\n    }\n    this.fragPlaying = null;\n    if (this.gapController) {\n      this.gapController.destroy();\n      this.gapController = null;\n    }\n    super.onMediaDetaching();\n  }\n  onMediaPlaying() {\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onMediaSeeked() {\n    const media = this.media;\n    const currentTime = media ? media.currentTime : null;\n    if (isFiniteNumber(currentTime)) {\n      this.log(`Media seeked to ${currentTime.toFixed(3)}`);\n    }\n\n    // If seeked was issued before buffer was appended do not tick immediately\n    const bufferInfo = this.getMainFwdBufferInfo();\n    if (bufferInfo === null || bufferInfo.len === 0) {\n      this.warn(`Main forward buffer length on \"seeked\" event ${bufferInfo ? bufferInfo.len : 'empty'})`);\n      return;\n    }\n\n    // tick to speed up FRAG_CHANGED triggering\n    this.tick();\n  }\n  onManifestLoading() {\n    // reset buffer on manifest loading\n    this.log('Trigger BUFFER_RESET');\n    this.hls.trigger(Events.BUFFER_RESET, undefined);\n    this.fragmentTracker.removeAllFragments();\n    this.couldBacktrack = false;\n    this.startPosition = this.lastCurrentTime = this.fragLastKbps = 0;\n    this.levels = this.fragPlaying = this.backtrackFragment = this.levelLastLoaded = null;\n    this.altAudio = this.audioOnly = this.startFragRequested = false;\n  }\n  onManifestParsed(event, data) {\n    // detect if we have different kind of audio codecs used amongst playlists\n    let aac = false;\n    let heaac = false;\n    data.levels.forEach(level => {\n      const codec = level.audioCodec;\n      if (codec) {\n        aac = aac || codec.indexOf('mp4a.40.2') !== -1;\n        heaac = heaac || codec.indexOf('mp4a.40.5') !== -1;\n      }\n    });\n    this.audioCodecSwitch = aac && heaac && !changeTypeSupported();\n    if (this.audioCodecSwitch) {\n      this.log('Both AAC/HE-AAC audio found in levels; declaring level codec as HE-AAC');\n    }\n    this.levels = data.levels;\n    this.startFragRequested = false;\n  }\n  onLevelLoading(event, data) {\n    const {\n      levels\n    } = this;\n    if (!levels || this.state !== State.IDLE) {\n      return;\n    }\n    const level = levels[data.level];\n    if (!level.details || level.details.live && this.levelLastLoaded !== level || this.waitForCdnTuneIn(level.details)) {\n      this.state = State.WAITING_LEVEL;\n    }\n  }\n  onLevelLoaded(event, data) {\n    var _curLevel$details;\n    const {\n      levels\n    } = this;\n    const newLevelId = data.level;\n    const newDetails = data.details;\n    const duration = newDetails.totalduration;\n    if (!levels) {\n      this.warn(`Levels were reset while loading level ${newLevelId}`);\n      return;\n    }\n    this.log(`Level ${newLevelId} loaded [${newDetails.startSN},${newDetails.endSN}]${newDetails.lastPartSn ? `[part-${newDetails.lastPartSn}-${newDetails.lastPartIndex}]` : ''}, cc [${newDetails.startCC}, ${newDetails.endCC}] duration:${duration}`);\n    const curLevel = levels[newLevelId];\n    const fragCurrent = this.fragCurrent;\n    if (fragCurrent && (this.state === State.FRAG_LOADING || this.state === State.FRAG_LOADING_WAITING_RETRY)) {\n      if (fragCurrent.level !== data.level && fragCurrent.loader) {\n        this.abortCurrentFrag();\n      }\n    }\n    let sliding = 0;\n    if (newDetails.live || (_curLevel$details = curLevel.details) != null && _curLevel$details.live) {\n      var _this$levelLastLoaded;\n      this.checkLiveUpdate(newDetails);\n      if (newDetails.deltaUpdateFailed) {\n        return;\n      }\n      sliding = this.alignPlaylists(newDetails, curLevel.details, (_this$levelLastLoaded = this.levelLastLoaded) == null ? void 0 : _this$levelLastLoaded.details);\n    }\n    // override level info\n    curLevel.details = newDetails;\n    this.levelLastLoaded = curLevel;\n    this.hls.trigger(Events.LEVEL_UPDATED, {\n      details: newDetails,\n      level: newLevelId\n    });\n\n    // only switch back to IDLE state if we were waiting for level to start downloading a new fragment\n    if (this.state === State.WAITING_LEVEL) {\n      if (this.waitForCdnTuneIn(newDetails)) {\n        // Wait for Low-Latency CDN Tune-in\n        return;\n      }\n      this.state = State.IDLE;\n    }\n    if (!this.startFragRequested) {\n      this.setStartPosition(newDetails, sliding);\n    } else if (newDetails.live) {\n      this.synchronizeToLiveEdge(newDetails);\n    }\n\n    // trigger handler right now\n    this.tick();\n  }\n  _handleFragmentLoadProgress(data) {\n    var _frag$initSegment;\n    const {\n      frag,\n      part,\n      payload\n    } = data;\n    const {\n      levels\n    } = this;\n    if (!levels) {\n      this.warn(`Levels were reset while fragment load was in progress. Fragment ${frag.sn} of level ${frag.level} will not be buffered`);\n      return;\n    }\n    const currentLevel = levels[frag.level];\n    const details = currentLevel.details;\n    if (!details) {\n      this.warn(`Dropping fragment ${frag.sn} of level ${frag.level} after level details were reset`);\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    const videoCodec = currentLevel.videoCodec;\n\n    // time Offset is accurate if level PTS is known, or if playlist is not sliding (not live)\n    const accurateTimeOffset = details.PTSKnown || !details.live;\n    const initSegmentData = (_frag$initSegment = frag.initSegment) == null ? void 0 : _frag$initSegment.data;\n    const audioCodec = this._getAudioCodec(currentLevel);\n\n    // transmux the MPEG-TS data to ISO-BMFF segments\n    // this.log(`Transmuxing ${frag.sn} of [${details.startSN} ,${details.endSN}],level ${frag.level}, cc ${frag.cc}`);\n    const transmuxer = this.transmuxer = this.transmuxer || new TransmuxerInterface(this.hls, PlaylistLevelType.MAIN, this._handleTransmuxComplete.bind(this), this._handleTransmuxerFlush.bind(this));\n    const partIndex = part ? part.index : -1;\n    const partial = partIndex !== -1;\n    const chunkMeta = new ChunkMetadata(frag.level, frag.sn, frag.stats.chunkCount, payload.byteLength, partIndex, partial);\n    const initPTS = this.initPTS[frag.cc];\n    transmuxer.push(payload, initSegmentData, audioCodec, videoCodec, frag, part, details.totalduration, accurateTimeOffset, chunkMeta, initPTS);\n  }\n  onAudioTrackSwitching(event, data) {\n    // if any URL found on new audio track, it is an alternate audio track\n    const fromAltAudio = this.altAudio;\n    const altAudio = !!data.url;\n    // if we switch on main audio, ensure that main fragment scheduling is synced with media.buffered\n    // don't do anything if we switch to alt audio: audio stream controller is handling it.\n    // we will just have to change buffer scheduling on audioTrackSwitched\n    if (!altAudio) {\n      if (this.mediaBuffer !== this.media) {\n        this.log('Switching on main audio, use media.buffered to schedule main fragment loading');\n        this.mediaBuffer = this.media;\n        const fragCurrent = this.fragCurrent;\n        // we need to refill audio buffer from main: cancel any frag loading to speed up audio switch\n        if (fragCurrent) {\n          this.log('Switching to main audio track, cancel main fragment load');\n          fragCurrent.abortRequests();\n          this.fragmentTracker.removeFragment(fragCurrent);\n        }\n        // destroy transmuxer to force init segment generation (following audio switch)\n        this.resetTransmuxer();\n        // switch to IDLE state to load new fragment\n        this.resetLoadingState();\n      } else if (this.audioOnly) {\n        // Reset audio transmuxer so when switching back to main audio we're not still appending where we left off\n        this.resetTransmuxer();\n      }\n      const hls = this.hls;\n      // If switching from alt to main audio, flush all audio and trigger track switched\n      if (fromAltAudio) {\n        hls.trigger(Events.BUFFER_FLUSHING, {\n          startOffset: 0,\n          endOffset: Number.POSITIVE_INFINITY,\n          type: null\n        });\n        this.fragmentTracker.removeAllFragments();\n      }\n      hls.trigger(Events.AUDIO_TRACK_SWITCHED, data);\n    }\n  }\n  onAudioTrackSwitched(event, data) {\n    const trackId = data.id;\n    const altAudio = !!this.hls.audioTracks[trackId].url;\n    if (altAudio) {\n      const videoBuffer = this.videoBuffer;\n      // if we switched on alternate audio, ensure that main fragment scheduling is synced with video sourcebuffer buffered\n      if (videoBuffer && this.mediaBuffer !== videoBuffer) {\n        this.log('Switching on alternate audio, use video.buffered to schedule main fragment loading');\n        this.mediaBuffer = videoBuffer;\n      }\n    }\n    this.altAudio = altAudio;\n    this.tick();\n  }\n  onBufferCreated(event, data) {\n    const tracks = data.tracks;\n    let mediaTrack;\n    let name;\n    let alternate = false;\n    for (const type in tracks) {\n      const track = tracks[type];\n      if (track.id === 'main') {\n        name = type;\n        mediaTrack = track;\n        // keep video source buffer reference\n        if (type === 'video') {\n          const videoTrack = tracks[type];\n          if (videoTrack) {\n            this.videoBuffer = videoTrack.buffer;\n          }\n        }\n      } else {\n        alternate = true;\n      }\n    }\n    if (alternate && mediaTrack) {\n      this.log(`Alternate track found, use ${name}.buffered to schedule main fragment loading`);\n      this.mediaBuffer = mediaTrack.buffer;\n    } else {\n      this.mediaBuffer = this.media;\n    }\n  }\n  onFragBuffered(event, data) {\n    const {\n      frag,\n      part\n    } = data;\n    if (frag && frag.type !== PlaylistLevelType.MAIN) {\n      return;\n    }\n    if (this.fragContextChanged(frag)) {\n      // If a level switch was requested while a fragment was buffering, it will emit the FRAG_BUFFERED event upon completion\n      // Avoid setting state back to IDLE, since that will interfere with a level switch\n      this.warn(`Fragment ${frag.sn}${part ? ' p: ' + part.index : ''} of level ${frag.level} finished buffering, but was aborted. state: ${this.state}`);\n      if (this.state === State.PARSED) {\n        this.state = State.IDLE;\n      }\n      return;\n    }\n    const stats = part ? part.stats : frag.stats;\n    this.fragLastKbps = Math.round(8 * stats.total / (stats.buffering.end - stats.loading.first));\n    if (frag.sn !== 'initSegment') {\n      this.fragPrevious = frag;\n    }\n    this.fragBufferedComplete(frag, part);\n  }\n  onError(event, data) {\n    var _data$context;\n    if (data.fatal) {\n      this.state = State.ERROR;\n      return;\n    }\n    switch (data.details) {\n      case ErrorDetails.FRAG_GAP:\n      case ErrorDetails.FRAG_PARSING_ERROR:\n      case ErrorDetails.FRAG_DECRYPT_ERROR:\n      case ErrorDetails.FRAG_LOAD_ERROR:\n      case ErrorDetails.FRAG_LOAD_TIMEOUT:\n      case ErrorDetails.KEY_LOAD_ERROR:\n      case ErrorDetails.KEY_LOAD_TIMEOUT:\n        this.onFragmentOrKeyLoadError(PlaylistLevelType.MAIN, data);\n        break;\n      case ErrorDetails.LEVEL_LOAD_ERROR:\n      case ErrorDetails.LEVEL_LOAD_TIMEOUT:\n      case ErrorDetails.LEVEL_PARSING_ERROR:\n        // in case of non fatal error while loading level, if level controller is not retrying to load level, switch back to IDLE\n        if (!data.levelRetry && this.state === State.WAITING_LEVEL && ((_data$context = data.context) == null ? void 0 : _data$context.type) === PlaylistContextType.LEVEL) {\n          this.state = State.IDLE;\n        }\n        break;\n      case ErrorDetails.BUFFER_APPEND_ERROR:\n      case ErrorDetails.BUFFER_FULL_ERROR:\n        if (!data.parent || data.parent !== 'main') {\n          return;\n        }\n        if (data.details === ErrorDetails.BUFFER_APPEND_ERROR) {\n          this.resetLoadingState();\n          return;\n        }\n        if (this.reduceLengthAndFlushBuffer(data)) {\n          this.flushMainBuffer(0, Number.POSITIVE_INFINITY);\n        }\n        break;\n      case ErrorDetails.INTERNAL_EXCEPTION:\n        this.recoverWorkerError(data);\n        break;\n    }\n  }\n\n  // Checks the health of the buffer and attempts to resolve playback stalls.\n  checkBuffer() {\n    const {\n      media,\n      gapController\n    } = this;\n    if (!media || !gapController || !media.readyState) {\n      // Exit early if we don't have media or if the media hasn't buffered anything yet (readyState 0)\n      return;\n    }\n    if (this.loadedmetadata || !BufferHelper.getBuffered(media).length) {\n      // Resolve gaps using the main buffer, whose ranges are the intersections of the A/V sourcebuffers\n      const activeFrag = this.state !== State.IDLE ? this.fragCurrent : null;\n      gapController.poll(this.lastCurrentTime, activeFrag);\n    }\n    this.lastCurrentTime = media.currentTime;\n  }\n  onFragLoadEmergencyAborted() {\n    this.state = State.IDLE;\n    // if loadedmetadata is not set, it means that we are emergency switch down on first frag\n    // in that case, reset startFragRequested flag\n    if (!this.loadedmetadata) {\n      this.startFragRequested = false;\n      this.nextLoadPosition = this.startPosition;\n    }\n    this.tickImmediate();\n  }\n  onBufferFlushed(event, {\n    type\n  }) {\n    if (type !== ElementaryStreamTypes.AUDIO || this.audioOnly && !this.altAudio) {\n      const mediaBuffer = (type === ElementaryStreamTypes.VIDEO ? this.videoBuffer : this.mediaBuffer) || this.media;\n      this.afterBufferFlushed(mediaBuffer, type, PlaylistLevelType.MAIN);\n      this.tick();\n    }\n  }\n  onLevelsUpdated(event, data) {\n    if (this.level > -1 && this.fragCurrent) {\n      this.level = this.fragCurrent.level;\n    }\n    this.levels = data.levels;\n  }\n  swapAudioCodec() {\n    this.audioCodecSwap = !this.audioCodecSwap;\n  }\n\n  /**\n   * Seeks to the set startPosition if not equal to the mediaElement's current time.\n   */\n  seekToStartPos() {\n    const {\n      media\n    } = this;\n    if (!media) {\n      return;\n    }\n    const currentTime = media.currentTime;\n    let startPosition = this.startPosition;\n    // only adjust currentTime if different from startPosition or if startPosition not buffered\n    // at that stage, there should be only one buffered range, as we reach that code after first fragment has been buffered\n    if (startPosition >= 0 && currentTime < startPosition) {\n      if (media.seeking) {\n        this.log(`could not seek to ${startPosition}, already seeking at ${currentTime}`);\n        return;\n      }\n      const buffered = BufferHelper.getBuffered(media);\n      const bufferStart = buffered.length ? buffered.start(0) : 0;\n      const delta = bufferStart - startPosition;\n      if (delta > 0 && (delta < this.config.maxBufferHole || delta < this.config.maxFragLookUpTolerance)) {\n        this.log(`adjusting start position by ${delta} to match buffer start`);\n        startPosition += delta;\n        this.startPosition = startPosition;\n      }\n      this.log(`seek to target start position ${startPosition} from current time ${currentTime}`);\n      media.currentTime = startPosition;\n    }\n  }\n  _getAudioCodec(currentLevel) {\n    let audioCodec = this.config.defaultAudioCodec || currentLevel.audioCodec;\n    if (this.audioCodecSwap && audioCodec) {\n      this.log('Swapping audio codec');\n      if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n        audioCodec = 'mp4a.40.2';\n      } else {\n        audioCodec = 'mp4a.40.5';\n      }\n    }\n    return audioCodec;\n  }\n  _loadBitrateTestFrag(frag, level) {\n    frag.bitrateTest = true;\n    this._doFragLoad(frag, level).then(data => {\n      const {\n        hls\n      } = this;\n      if (!data || this.fragContextChanged(frag)) {\n        return;\n      }\n      level.fragmentError = 0;\n      this.state = State.IDLE;\n      this.startFragRequested = false;\n      this.bitrateTest = false;\n      const stats = frag.stats;\n      // Bitrate tests fragments are neither parsed nor buffered\n      stats.parsing.start = stats.parsing.end = stats.buffering.start = stats.buffering.end = self.performance.now();\n      hls.trigger(Events.FRAG_LOADED, data);\n      frag.bitrateTest = false;\n    });\n  }\n  _handleTransmuxComplete(transmuxResult) {\n    var _id3$samples;\n    const id = 'main';\n    const {\n      hls\n    } = this;\n    const {\n      remuxResult,\n      chunkMeta\n    } = transmuxResult;\n    const context = this.getCurrentContext(chunkMeta);\n    if (!context) {\n      this.resetWhenMissingContext(chunkMeta);\n      return;\n    }\n    const {\n      frag,\n      part,\n      level\n    } = context;\n    const {\n      video,\n      text,\n      id3,\n      initSegment\n    } = remuxResult;\n    const {\n      details\n    } = level;\n    // The audio-stream-controller handles audio buffering if Hls.js is playing an alternate audio track\n    const audio = this.altAudio ? undefined : remuxResult.audio;\n\n    // Check if the current fragment has been aborted. We check this by first seeing if we're still playing the current level.\n    // If we are, subsequently check if the currently loading fragment (fragCurrent) has changed.\n    if (this.fragContextChanged(frag)) {\n      this.fragmentTracker.removeFragment(frag);\n      return;\n    }\n    this.state = State.PARSING;\n    if (initSegment) {\n      if (initSegment != null && initSegment.tracks) {\n        const mapFragment = frag.initSegment || frag;\n        this._bufferInitSegment(level, initSegment.tracks, mapFragment, chunkMeta);\n        hls.trigger(Events.FRAG_PARSING_INIT_SEGMENT, {\n          frag: mapFragment,\n          id,\n          tracks: initSegment.tracks\n        });\n      }\n\n      // This would be nice if Number.isFinite acted as a typeguard, but it doesn't. See: https://github.com/Microsoft/TypeScript/issues/10038\n      const initPTS = initSegment.initPTS;\n      const timescale = initSegment.timescale;\n      if (isFiniteNumber(initPTS)) {\n        this.initPTS[frag.cc] = {\n          baseTime: initPTS,\n          timescale\n        };\n        hls.trigger(Events.INIT_PTS_FOUND, {\n          frag,\n          id,\n          initPTS,\n          timescale\n        });\n      }\n    }\n\n    // Avoid buffering if backtracking this fragment\n    if (video && details && frag.sn !== 'initSegment') {\n      const prevFrag = details.fragments[frag.sn - 1 - details.startSN];\n      const isFirstFragment = frag.sn === details.startSN;\n      const isFirstInDiscontinuity = !prevFrag || frag.cc > prevFrag.cc;\n      if (remuxResult.independent !== false) {\n        const {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        } = video;\n        if (part) {\n          part.elementaryStreams[video.type] = {\n            startPTS,\n            endPTS,\n            startDTS,\n            endDTS\n          };\n        } else {\n          if (video.firstKeyFrame && video.independent && chunkMeta.id === 1 && !isFirstInDiscontinuity) {\n            this.couldBacktrack = true;\n          }\n          if (video.dropped && video.independent) {\n            // Backtrack if dropped frames create a gap after currentTime\n\n            const bufferInfo = this.getMainFwdBufferInfo();\n            const targetBufferTime = (bufferInfo ? bufferInfo.end : this.getLoadPosition()) + this.config.maxBufferHole;\n            const startTime = video.firstKeyFramePTS ? video.firstKeyFramePTS : startPTS;\n            if (!isFirstFragment && targetBufferTime < startTime - this.config.maxBufferHole && !isFirstInDiscontinuity) {\n              this.backtrack(frag);\n              return;\n            } else if (isFirstInDiscontinuity) {\n              // Mark segment with a gap to avoid loop loading\n              frag.gap = true;\n            }\n            // Set video stream start to fragment start so that truncated samples do not distort the timeline, and mark it partial\n            frag.setElementaryStreamInfo(video.type, frag.start, endPTS, frag.start, endDTS, true);\n          } else if (isFirstFragment && startPTS > MAX_START_GAP_JUMP) {\n            // Mark segment with a gap to skip large start gap\n            frag.gap = true;\n          }\n        }\n        frag.setElementaryStreamInfo(video.type, startPTS, endPTS, startDTS, endDTS);\n        if (this.backtrackFragment) {\n          this.backtrackFragment = frag;\n        }\n        this.bufferFragmentData(video, frag, part, chunkMeta, isFirstFragment || isFirstInDiscontinuity);\n      } else if (isFirstFragment || isFirstInDiscontinuity) {\n        // Mark segment with a gap to avoid loop loading\n        frag.gap = true;\n      } else {\n        this.backtrack(frag);\n        return;\n      }\n    }\n    if (audio) {\n      const {\n        startPTS,\n        endPTS,\n        startDTS,\n        endDTS\n      } = audio;\n      if (part) {\n        part.elementaryStreams[ElementaryStreamTypes.AUDIO] = {\n          startPTS,\n          endPTS,\n          startDTS,\n          endDTS\n        };\n      }\n      frag.setElementaryStreamInfo(ElementaryStreamTypes.AUDIO, startPTS, endPTS, startDTS, endDTS);\n      this.bufferFragmentData(audio, frag, part, chunkMeta);\n    }\n    if (details && id3 != null && (_id3$samples = id3.samples) != null && _id3$samples.length) {\n      const emittedID3 = {\n        id,\n        frag,\n        details,\n        samples: id3.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_METADATA, emittedID3);\n    }\n    if (details && text) {\n      const emittedText = {\n        id,\n        frag,\n        details,\n        samples: text.samples\n      };\n      hls.trigger(Events.FRAG_PARSING_USERDATA, emittedText);\n    }\n  }\n  _bufferInitSegment(currentLevel, tracks, frag, chunkMeta) {\n    if (this.state !== State.PARSING) {\n      return;\n    }\n    this.audioOnly = !!tracks.audio && !tracks.video;\n\n    // if audio track is expected to come from audio stream controller, discard any coming from main\n    if (this.altAudio && !this.audioOnly) {\n      delete tracks.audio;\n    }\n    // include levelCodec in audio and video tracks\n    const {\n      audio,\n      video,\n      audiovideo\n    } = tracks;\n    if (audio) {\n      let audioCodec = currentLevel.audioCodec;\n      const ua = navigator.userAgent.toLowerCase();\n      if (this.audioCodecSwitch) {\n        if (audioCodec) {\n          if (audioCodec.indexOf('mp4a.40.5') !== -1) {\n            audioCodec = 'mp4a.40.2';\n          } else {\n            audioCodec = 'mp4a.40.5';\n          }\n        }\n        // In the case that AAC and HE-AAC audio codecs are signalled in manifest,\n        // force HE-AAC, as it seems that most browsers prefers it.\n        // don't force HE-AAC if mono stream, or in Firefox\n        const audioMetadata = audio.metadata;\n        if (audioMetadata && 'channelCount' in audioMetadata && (audioMetadata.channelCount || 1) !== 1 && ua.indexOf('firefox') === -1) {\n          audioCodec = 'mp4a.40.5';\n        }\n      }\n      // HE-AAC is broken on Android, always signal audio codec as AAC even if variant manifest states otherwise\n      if (audioCodec && audioCodec.indexOf('mp4a.40.5') !== -1 && ua.indexOf('android') !== -1 && audio.container !== 'audio/mpeg') {\n        // Exclude mpeg audio\n        audioCodec = 'mp4a.40.2';\n        this.log(`Android: force audio codec to ${audioCodec}`);\n      }\n      if (currentLevel.audioCodec && currentLevel.audioCodec !== audioCodec) {\n        this.log(`Swapping manifest audio codec \"${currentLevel.audioCodec}\" for \"${audioCodec}\"`);\n      }\n      audio.levelCodec = audioCodec;\n      audio.id = 'main';\n      this.log(`Init audio buffer, container:${audio.container}, codecs[selected/level/parsed]=[${audioCodec || ''}/${currentLevel.audioCodec || ''}/${audio.codec}]`);\n    }\n    if (video) {\n      video.levelCodec = currentLevel.videoCodec;\n      video.id = 'main';\n      this.log(`Init video buffer, container:${video.container}, codecs[level/parsed]=[${currentLevel.videoCodec || ''}/${video.codec}]`);\n    }\n    if (audiovideo) {\n      this.log(`Init audiovideo buffer, container:${audiovideo.container}, codecs[level/parsed]=[${currentLevel.codecs}/${audiovideo.codec}]`);\n    }\n    this.hls.trigger(Events.BUFFER_CODECS, tracks);\n    // loop through tracks that are going to be provided to bufferController\n    Object.keys(tracks).forEach(trackName => {\n      const track = tracks[trackName];\n      const initSegment = track.initSegment;\n      if (initSegment != null && initSegment.byteLength) {\n        this.hls.trigger(Events.BUFFER_APPENDING, {\n          type: trackName,\n          data: initSegment,\n          frag,\n          part: null,\n          chunkMeta,\n          parent: frag.type\n        });\n      }\n    });\n    // trigger handler right now\n    this.tickImmediate();\n  }\n  getMainFwdBufferInfo() {\n    return this.getFwdBufferInfo(this.mediaBuffer ? this.mediaBuffer : this.media, PlaylistLevelType.MAIN);\n  }\n  backtrack(frag) {\n    this.couldBacktrack = true;\n    // Causes findFragments to backtrack through fragments to find the keyframe\n    this.backtrackFragment = frag;\n    this.resetTransmuxer();\n    this.flushBufferGap(frag);\n    this.fragmentTracker.removeFragment(frag);\n    this.fragPrevious = null;\n    this.nextLoadPosition = frag.start;\n    this.state = State.IDLE;\n  }\n  checkFragmentChanged() {\n    const video = this.media;\n    let fragPlayingCurrent = null;\n    if (video && video.readyState > 1 && video.seeking === false) {\n      const currentTime = video.currentTime;\n      /* if video element is in seeked state, currentTime can only increase.\n        (assuming that playback rate is positive ...)\n        As sometimes currentTime jumps back to zero after a\n        media decode error, check this, to avoid seeking back to\n        wrong position after a media decode error\n      */\n\n      if (BufferHelper.isBuffered(video, currentTime)) {\n        fragPlayingCurrent = this.getAppendedFrag(currentTime);\n      } else if (BufferHelper.isBuffered(video, currentTime + 0.1)) {\n        /* ensure that FRAG_CHANGED event is triggered at startup,\n          when first video frame is displayed and playback is paused.\n          add a tolerance of 100ms, in case current position is not buffered,\n          check if current pos+100ms is buffered and use that buffer range\n          for FRAG_CHANGED event reporting */\n        fragPlayingCurrent = this.getAppendedFrag(currentTime + 0.1);\n      }\n      if (fragPlayingCurrent) {\n        this.backtrackFragment = null;\n        const fragPlaying = this.fragPlaying;\n        const fragCurrentLevel = fragPlayingCurrent.level;\n        if (!fragPlaying || fragPlayingCurrent.sn !== fragPlaying.sn || fragPlaying.level !== fragCurrentLevel) {\n          this.fragPlaying = fragPlayingCurrent;\n          this.hls.trigger(Events.FRAG_CHANGED, {\n            frag: fragPlayingCurrent\n          });\n          if (!fragPlaying || fragPlaying.level !== fragCurrentLevel) {\n            this.hls.trigger(Events.LEVEL_SWITCHED, {\n              level: fragCurrentLevel\n            });\n          }\n        }\n      }\n    }\n  }\n  get nextLevel() {\n    const frag = this.nextBufferedFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get currentFrag() {\n    const media = this.media;\n    if (media) {\n      return this.fragPlaying || this.getAppendedFrag(media.currentTime);\n    }\n    return null;\n  }\n  get currentProgramDateTime() {\n    const media = this.media;\n    if (media) {\n      const currentTime = media.currentTime;\n      const frag = this.currentFrag;\n      if (frag && isFiniteNumber(currentTime) && isFiniteNumber(frag.programDateTime)) {\n        const epocMs = frag.programDateTime + (currentTime - frag.start) * 1000;\n        return new Date(epocMs);\n      }\n    }\n    return null;\n  }\n  get currentLevel() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return frag.level;\n    }\n    return -1;\n  }\n  get nextBufferedFrag() {\n    const frag = this.currentFrag;\n    if (frag) {\n      return this.followingBufferedFrag(frag);\n    }\n    return null;\n  }\n  get forceStartLoad() {\n    return this._forceStartLoad;\n  }\n}\n\n/**\n * The `Hls` class is the core of the HLS.js library used to instantiate player instances.\n * @public\n */\nclass Hls {\n  /**\n   * Get the video-dev/hls.js package version.\n   */\n  static get version() {\n    return \"1.5.15\";\n  }\n\n  /**\n   * Check if the required MediaSource Extensions are available.\n   */\n  static isMSESupported() {\n    return isMSESupported();\n  }\n\n  /**\n   * Check if MediaSource Extensions are available and isTypeSupported checks pass for any baseline codecs.\n   */\n  static isSupported() {\n    return isSupported();\n  }\n\n  /**\n   * Get the MediaSource global used for MSE playback (ManagedMediaSource, MediaSource, or WebKitMediaSource).\n   */\n  static getMediaSource() {\n    return getMediaSource();\n  }\n  static get Events() {\n    return Events;\n  }\n  static get ErrorTypes() {\n    return ErrorTypes;\n  }\n  static get ErrorDetails() {\n    return ErrorDetails;\n  }\n\n  /**\n   * Get the default configuration applied to new instances.\n   */\n  static get DefaultConfig() {\n    if (!Hls.defaultConfig) {\n      return hlsDefaultConfig;\n    }\n    return Hls.defaultConfig;\n  }\n\n  /**\n   * Replace the default configuration applied to new instances.\n   */\n  static set DefaultConfig(defaultConfig) {\n    Hls.defaultConfig = defaultConfig;\n  }\n\n  /**\n   * Creates an instance of an HLS client that can attach to exactly one `HTMLMediaElement`.\n   * @param userConfig - Configuration options applied over `Hls.DefaultConfig`\n   */\n  constructor(userConfig = {}) {\n    /**\n     * The runtime configuration used by the player. At instantiation this is combination of `hls.userConfig` merged over `Hls.DefaultConfig`.\n     */\n    this.config = void 0;\n    /**\n     * The configuration object provided on player instantiation.\n     */\n    this.userConfig = void 0;\n    this.coreComponents = void 0;\n    this.networkControllers = void 0;\n    this.started = false;\n    this._emitter = new EventEmitter();\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    this.abrController = void 0;\n    this.bufferController = void 0;\n    this.capLevelController = void 0;\n    this.latencyController = void 0;\n    this.levelController = void 0;\n    this.streamController = void 0;\n    this.audioTrackController = void 0;\n    this.subtitleTrackController = void 0;\n    this.emeController = void 0;\n    this.cmcdController = void 0;\n    this._media = null;\n    this.url = null;\n    this.triggeringException = void 0;\n    enableLogs(userConfig.debug || false, 'Hls instance');\n    const config = this.config = mergeConfig(Hls.DefaultConfig, userConfig);\n    this.userConfig = userConfig;\n    if (config.progressive) {\n      enableStreamingMode(config);\n    }\n\n    // core controllers and network loaders\n    const {\n      abrController: ConfigAbrController,\n      bufferController: ConfigBufferController,\n      capLevelController: ConfigCapLevelController,\n      errorController: ConfigErrorController,\n      fpsController: ConfigFpsController\n    } = config;\n    const errorController = new ConfigErrorController(this);\n    const abrController = this.abrController = new ConfigAbrController(this);\n    const bufferController = this.bufferController = new ConfigBufferController(this);\n    const capLevelController = this.capLevelController = new ConfigCapLevelController(this);\n    const fpsController = new ConfigFpsController(this);\n    const playListLoader = new PlaylistLoader(this);\n    const id3TrackController = new ID3TrackController(this);\n    const ConfigContentSteeringController = config.contentSteeringController;\n    // ConentSteeringController is defined before LevelController to receive Multivariant Playlist events first\n    const contentSteering = ConfigContentSteeringController ? new ConfigContentSteeringController(this) : null;\n    const levelController = this.levelController = new LevelController(this, contentSteering);\n    // FragmentTracker must be defined before StreamController because the order of event handling is important\n    const fragmentTracker = new FragmentTracker(this);\n    const keyLoader = new KeyLoader(this.config);\n    const streamController = this.streamController = new StreamController(this, fragmentTracker, keyLoader);\n\n    // Cap level controller uses streamController to flush the buffer\n    capLevelController.setStreamController(streamController);\n    // fpsController uses streamController to switch when frames are being dropped\n    fpsController.setStreamController(streamController);\n    const networkControllers = [playListLoader, levelController, streamController];\n    if (contentSteering) {\n      networkControllers.splice(1, 0, contentSteering);\n    }\n    this.networkControllers = networkControllers;\n    const coreComponents = [abrController, bufferController, capLevelController, fpsController, id3TrackController, fragmentTracker];\n    this.audioTrackController = this.createController(config.audioTrackController, networkControllers);\n    const AudioStreamControllerClass = config.audioStreamController;\n    if (AudioStreamControllerClass) {\n      networkControllers.push(new AudioStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    // subtitleTrackController must be defined before subtitleStreamController because the order of event handling is important\n    this.subtitleTrackController = this.createController(config.subtitleTrackController, networkControllers);\n    const SubtitleStreamControllerClass = config.subtitleStreamController;\n    if (SubtitleStreamControllerClass) {\n      networkControllers.push(new SubtitleStreamControllerClass(this, fragmentTracker, keyLoader));\n    }\n    this.createController(config.timelineController, coreComponents);\n    keyLoader.emeController = this.emeController = this.createController(config.emeController, coreComponents);\n    this.cmcdController = this.createController(config.cmcdController, coreComponents);\n    this.latencyController = this.createController(LatencyController, coreComponents);\n    this.coreComponents = coreComponents;\n\n    // Error controller handles errors before and after all other controllers\n    // This listener will be invoked after all other controllers error listeners\n    networkControllers.push(errorController);\n    const onErrorOut = errorController.onErrorOut;\n    if (typeof onErrorOut === 'function') {\n      this.on(Events.ERROR, onErrorOut, errorController);\n    }\n  }\n  createController(ControllerClass, components) {\n    if (ControllerClass) {\n      const controllerInstance = new ControllerClass(this);\n      if (components) {\n        components.push(controllerInstance);\n      }\n      return controllerInstance;\n    }\n    return null;\n  }\n\n  // Delegate the EventEmitter through the public API of Hls.js\n  on(event, listener, context = this) {\n    this._emitter.on(event, listener, context);\n  }\n  once(event, listener, context = this) {\n    this._emitter.once(event, listener, context);\n  }\n  removeAllListeners(event) {\n    this._emitter.removeAllListeners(event);\n  }\n  off(event, listener, context = this, once) {\n    this._emitter.off(event, listener, context, once);\n  }\n  listeners(event) {\n    return this._emitter.listeners(event);\n  }\n  emit(event, name, eventObject) {\n    return this._emitter.emit(event, name, eventObject);\n  }\n  trigger(event, eventObject) {\n    if (this.config.debug) {\n      return this.emit(event, event, eventObject);\n    } else {\n      try {\n        return this.emit(event, event, eventObject);\n      } catch (error) {\n        logger.error('An internal error happened while handling event ' + event + '. Error message: \"' + error.message + '\". Here is a stacktrace:', error);\n        // Prevent recursion in error event handlers that throw #5497\n        if (!this.triggeringException) {\n          this.triggeringException = true;\n          const fatal = event === Events.ERROR;\n          this.trigger(Events.ERROR, {\n            type: ErrorTypes.OTHER_ERROR,\n            details: ErrorDetails.INTERNAL_EXCEPTION,\n            fatal,\n            event,\n            error\n          });\n          this.triggeringException = false;\n        }\n      }\n    }\n    return false;\n  }\n  listenerCount(event) {\n    return this._emitter.listenerCount(event);\n  }\n\n  /**\n   * Dispose of the instance\n   */\n  destroy() {\n    logger.log('destroy');\n    this.trigger(Events.DESTROYING, undefined);\n    this.detachMedia();\n    this.removeAllListeners();\n    this._autoLevelCapping = -1;\n    this.url = null;\n    this.networkControllers.forEach(component => component.destroy());\n    this.networkControllers.length = 0;\n    this.coreComponents.forEach(component => component.destroy());\n    this.coreComponents.length = 0;\n    // Remove any references that could be held in config options or callbacks\n    const config = this.config;\n    config.xhrSetup = config.fetchSetup = undefined;\n    // @ts-ignore\n    this.userConfig = null;\n  }\n\n  /**\n   * Attaches Hls.js to a media element\n   */\n  attachMedia(media) {\n    logger.log('attachMedia');\n    this._media = media;\n    this.trigger(Events.MEDIA_ATTACHING, {\n      media: media\n    });\n  }\n\n  /**\n   * Detach Hls.js from the media\n   */\n  detachMedia() {\n    logger.log('detachMedia');\n    this.trigger(Events.MEDIA_DETACHING, undefined);\n    this._media = null;\n  }\n\n  /**\n   * Set the source URL. Can be relative or absolute.\n   */\n  loadSource(url) {\n    this.stopLoad();\n    const media = this.media;\n    const loadedSource = this.url;\n    const loadingSource = this.url = urlToolkitExports.buildAbsoluteURL(self.location.href, url, {\n      alwaysNormalize: true\n    });\n    this._autoLevelCapping = -1;\n    this._maxHdcpLevel = null;\n    logger.log(`loadSource:${loadingSource}`);\n    if (media && loadedSource && (loadedSource !== loadingSource || this.bufferController.hasSourceTypes())) {\n      this.detachMedia();\n      this.attachMedia(media);\n    }\n    // when attaching to a source URL, trigger a playlist load\n    this.trigger(Events.MANIFEST_LOADING, {\n      url: url\n    });\n  }\n\n  /**\n   * Start loading data from the stream source.\n   * Depending on default config, client starts loading automatically when a source is set.\n   *\n   * @param startPosition - Set the start position to stream from.\n   * Defaults to -1 (None: starts from earliest point)\n   */\n  startLoad(startPosition = -1) {\n    logger.log(`startLoad(${startPosition})`);\n    this.started = true;\n    this.networkControllers.forEach(controller => {\n      controller.startLoad(startPosition);\n    });\n  }\n\n  /**\n   * Stop loading of any stream data.\n   */\n  stopLoad() {\n    logger.log('stopLoad');\n    this.started = false;\n    this.networkControllers.forEach(controller => {\n      controller.stopLoad();\n    });\n  }\n\n  /**\n   * Resumes stream controller segment loading if previously started.\n   */\n  resumeBuffering() {\n    if (this.started) {\n      this.networkControllers.forEach(controller => {\n        if ('fragmentLoader' in controller) {\n          controller.startLoad(-1);\n        }\n      });\n    }\n  }\n\n  /**\n   * Stops stream controller segment loading without changing 'started' state like stopLoad().\n   * This allows for media buffering to be paused without interupting playlist loading.\n   */\n  pauseBuffering() {\n    this.networkControllers.forEach(controller => {\n      if ('fragmentLoader' in controller) {\n        controller.stopLoad();\n      }\n    });\n  }\n\n  /**\n   * Swap through possible audio codecs in the stream (for example to switch from stereo to 5.1)\n   */\n  swapAudioCodec() {\n    logger.log('swapAudioCodec');\n    this.streamController.swapAudioCodec();\n  }\n\n  /**\n   * When the media-element fails, this allows to detach and then re-attach it\n   * as one call (convenience method).\n   *\n   * Automatic recovery of media-errors by this process is configurable.\n   */\n  recoverMediaError() {\n    logger.log('recoverMediaError');\n    const media = this._media;\n    this.detachMedia();\n    if (media) {\n      this.attachMedia(media);\n    }\n  }\n  removeLevel(levelIndex) {\n    this.levelController.removeLevel(levelIndex);\n  }\n\n  /**\n   * @returns an array of levels (variants) sorted by HDCP-LEVEL, RESOLUTION (height), FRAME-RATE, CODECS, VIDEO-RANGE, and BANDWIDTH\n   */\n  get levels() {\n    const levels = this.levelController.levels;\n    return levels ? levels : [];\n  }\n\n  /**\n   * Index of quality level (variant) currently played\n   */\n  get currentLevel() {\n    return this.streamController.currentLevel;\n  }\n\n  /**\n   * Set quality level index immediately. This will flush the current buffer to replace the quality asap. That means playback will interrupt at least shortly to re-buffer and re-sync eventually. Set to -1 for automatic level selection.\n   */\n  set currentLevel(newLevel) {\n    logger.log(`set currentLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.immediateLevelSwitch();\n  }\n\n  /**\n   * Index of next quality level loaded as scheduled by stream controller.\n   */\n  get nextLevel() {\n    return this.streamController.nextLevel;\n  }\n\n  /**\n   * Set quality level index for next loaded data.\n   * This will switch the video quality asap, without interrupting playback.\n   * May abort current loading of data, and flush parts of buffer (outside currently played fragment region).\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set nextLevel(newLevel) {\n    logger.log(`set nextLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n    this.streamController.nextLevelSwitch();\n  }\n\n  /**\n   * Return the quality level of the currently or last (of none is loaded currently) segment\n   */\n  get loadLevel() {\n    return this.levelController.level;\n  }\n\n  /**\n   * Set quality level index for next loaded data in a conservative way.\n   * This will switch the quality without flushing, but interrupt current loading.\n   * Thus the moment when the quality switch will appear in effect will only be after the already existing buffer.\n   * @param newLevel - Pass -1 for automatic level selection\n   */\n  set loadLevel(newLevel) {\n    logger.log(`set loadLevel:${newLevel}`);\n    this.levelController.manualLevel = newLevel;\n  }\n\n  /**\n   * get next quality level loaded\n   */\n  get nextLoadLevel() {\n    return this.levelController.nextLoadLevel;\n  }\n\n  /**\n   * Set quality level of next loaded segment in a fully \"non-destructive\" way.\n   * Same as `loadLevel` but will wait for next switch (until current loading is done).\n   */\n  set nextLoadLevel(level) {\n    this.levelController.nextLoadLevel = level;\n  }\n\n  /**\n   * Return \"first level\": like a default level, if not set,\n   * falls back to index of first level referenced in manifest\n   */\n  get firstLevel() {\n    return Math.max(this.levelController.firstLevel, this.minAutoLevel);\n  }\n\n  /**\n   * Sets \"first-level\", see getter.\n   */\n  set firstLevel(newLevel) {\n    logger.log(`set firstLevel:${newLevel}`);\n    this.levelController.firstLevel = newLevel;\n  }\n\n  /**\n   * Return the desired start level for the first fragment that will be loaded.\n   * The default value of -1 indicates automatic start level selection.\n   * Setting hls.nextAutoLevel without setting a startLevel will result in\n   * the nextAutoLevel value being used for one fragment load.\n   */\n  get startLevel() {\n    const startLevel = this.levelController.startLevel;\n    if (startLevel === -1 && this.abrController.forcedAutoLevel > -1) {\n      return this.abrController.forcedAutoLevel;\n    }\n    return startLevel;\n  }\n\n  /**\n   * set  start level (level of first fragment that will be played back)\n   * if not overrided by user, first level appearing in manifest will be used as start level\n   * if -1 : automatic start level selection, playback will start from level matching download bandwidth\n   * (determined from download of first segment)\n   */\n  set startLevel(newLevel) {\n    logger.log(`set startLevel:${newLevel}`);\n    // if not in automatic start level detection, ensure startLevel is greater than minAutoLevel\n    if (newLevel !== -1) {\n      newLevel = Math.max(newLevel, this.minAutoLevel);\n    }\n    this.levelController.startLevel = newLevel;\n  }\n\n  /**\n   * Whether level capping is enabled.\n   * Default value is set via `config.capLevelToPlayerSize`.\n   */\n  get capLevelToPlayerSize() {\n    return this.config.capLevelToPlayerSize;\n  }\n\n  /**\n   * Enables or disables level capping. If disabled after previously enabled, `nextLevelSwitch` will be immediately called.\n   */\n  set capLevelToPlayerSize(shouldStartCapping) {\n    const newCapLevelToPlayerSize = !!shouldStartCapping;\n    if (newCapLevelToPlayerSize !== this.config.capLevelToPlayerSize) {\n      if (newCapLevelToPlayerSize) {\n        this.capLevelController.startCapping(); // If capping occurs, nextLevelSwitch will happen based on size.\n      } else {\n        this.capLevelController.stopCapping();\n        this.autoLevelCapping = -1;\n        this.streamController.nextLevelSwitch(); // Now we're uncapped, get the next level asap.\n      }\n      this.config.capLevelToPlayerSize = newCapLevelToPlayerSize;\n    }\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  get autoLevelCapping() {\n    return this._autoLevelCapping;\n  }\n\n  /**\n   * Returns the current bandwidth estimate in bits per second, when available. Otherwise, `NaN` is returned.\n   */\n  get bandwidthEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimate();\n  }\n  set bandwidthEstimate(abrEwmaDefaultEstimate) {\n    this.abrController.resetEstimator(abrEwmaDefaultEstimate);\n  }\n\n  /**\n   * get time to first byte estimate\n   * @type {number}\n   */\n  get ttfbEstimate() {\n    const {\n      bwEstimator\n    } = this.abrController;\n    if (!bwEstimator) {\n      return NaN;\n    }\n    return bwEstimator.getEstimateTTFB();\n  }\n\n  /**\n   * Capping/max level value that should be used by automatic level selection algorithm (`ABRController`)\n   */\n  set autoLevelCapping(newLevel) {\n    if (this._autoLevelCapping !== newLevel) {\n      logger.log(`set autoLevelCapping:${newLevel}`);\n      this._autoLevelCapping = newLevel;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n  get maxHdcpLevel() {\n    return this._maxHdcpLevel;\n  }\n  set maxHdcpLevel(value) {\n    if (isHdcpLevel(value) && this._maxHdcpLevel !== value) {\n      this._maxHdcpLevel = value;\n      this.levelController.checkMaxAutoUpdated();\n    }\n  }\n\n  /**\n   * True when automatic level selection enabled\n   */\n  get autoLevelEnabled() {\n    return this.levelController.manualLevel === -1;\n  }\n\n  /**\n   * Level set manually (if any)\n   */\n  get manualLevel() {\n    return this.levelController.manualLevel;\n  }\n\n  /**\n   * min level selectable in auto mode according to config.minAutoBitrate\n   */\n  get minAutoLevel() {\n    const {\n      levels,\n      config: {\n        minAutoBitrate\n      }\n    } = this;\n    if (!levels) return 0;\n    const len = levels.length;\n    for (let i = 0; i < len; i++) {\n      if (levels[i].maxBitrate >= minAutoBitrate) {\n        return i;\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * max level selectable in auto mode according to autoLevelCapping\n   */\n  get maxAutoLevel() {\n    const {\n      levels,\n      autoLevelCapping,\n      maxHdcpLevel\n    } = this;\n    let maxAutoLevel;\n    if (autoLevelCapping === -1 && levels != null && levels.length) {\n      maxAutoLevel = levels.length - 1;\n    } else {\n      maxAutoLevel = autoLevelCapping;\n    }\n    if (maxHdcpLevel) {\n      for (let i = maxAutoLevel; i--;) {\n        const hdcpLevel = levels[i].attrs['HDCP-LEVEL'];\n        if (hdcpLevel && hdcpLevel <= maxHdcpLevel) {\n          return i;\n        }\n      }\n    }\n    return maxAutoLevel;\n  }\n  get firstAutoLevel() {\n    return this.abrController.firstAutoLevel;\n  }\n\n  /**\n   * next automatically selected quality level\n   */\n  get nextAutoLevel() {\n    return this.abrController.nextAutoLevel;\n  }\n\n  /**\n   * this setter is used to force next auto level.\n   * this is useful to force a switch down in auto mode:\n   * in case of load error on level N, hls.js can set nextAutoLevel to N-1 for example)\n   * forced value is valid for one fragment. upon successful frag loading at forced level,\n   * this value will be resetted to -1 by ABR controller.\n   */\n  set nextAutoLevel(nextLevel) {\n    this.abrController.nextAutoLevel = nextLevel;\n  }\n\n  /**\n   * get the datetime value relative to media.currentTime for the active level Program Date Time if present\n   */\n  get playingDate() {\n    return this.streamController.currentProgramDateTime;\n  }\n  get mainForwardBufferInfo() {\n    return this.streamController.getMainFwdBufferInfo();\n  }\n\n  /**\n   * Find and select the best matching audio track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.audioPreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setAudioOption(audioOption) {\n    var _this$audioTrackContr;\n    return (_this$audioTrackContr = this.audioTrackController) == null ? void 0 : _this$audioTrackContr.setAudioOption(audioOption);\n  }\n  /**\n   * Find and select the best matching subtitle track, making a level switch when a Group change is necessary.\n   * Updates `hls.config.subtitlePreference`. Returns the selected track, or null when no matching track is found.\n   */\n  setSubtitleOption(subtitleOption) {\n    var _this$subtitleTrackCo;\n    (_this$subtitleTrackCo = this.subtitleTrackController) == null ? void 0 : _this$subtitleTrackCo.setSubtitleOption(subtitleOption);\n    return null;\n  }\n\n  /**\n   * Get the complete list of audio tracks across all media groups\n   */\n  get allAudioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.allAudioTracks : [];\n  }\n\n  /**\n   * Get the list of selectable audio tracks\n   */\n  get audioTracks() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTracks : [];\n  }\n\n  /**\n   * index of the selected audio track (index in audio track lists)\n   */\n  get audioTrack() {\n    const audioTrackController = this.audioTrackController;\n    return audioTrackController ? audioTrackController.audioTrack : -1;\n  }\n\n  /**\n   * selects an audio track, based on its index in audio track lists\n   */\n  set audioTrack(audioTrackId) {\n    const audioTrackController = this.audioTrackController;\n    if (audioTrackController) {\n      audioTrackController.audioTrack = audioTrackId;\n    }\n  }\n\n  /**\n   * get the complete list of subtitle tracks across all media groups\n   */\n  get allSubtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.allSubtitleTracks : [];\n  }\n\n  /**\n   * get alternate subtitle tracks list from playlist\n   */\n  get subtitleTracks() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTracks : [];\n  }\n\n  /**\n   * index of the selected subtitle track (index in subtitle track lists)\n   */\n  get subtitleTrack() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleTrack : -1;\n  }\n  get media() {\n    return this._media;\n  }\n\n  /**\n   * select an subtitle track, based on its index in subtitle track lists\n   */\n  set subtitleTrack(subtitleTrackId) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleTrack = subtitleTrackId;\n    }\n  }\n\n  /**\n   * Whether subtitle display is enabled or not\n   */\n  get subtitleDisplay() {\n    const subtitleTrackController = this.subtitleTrackController;\n    return subtitleTrackController ? subtitleTrackController.subtitleDisplay : false;\n  }\n\n  /**\n   * Enable/disable subtitle display rendering\n   */\n  set subtitleDisplay(value) {\n    const subtitleTrackController = this.subtitleTrackController;\n    if (subtitleTrackController) {\n      subtitleTrackController.subtitleDisplay = value;\n    }\n  }\n\n  /**\n   * get mode for Low-Latency HLS loading\n   */\n  get lowLatencyMode() {\n    return this.config.lowLatencyMode;\n  }\n\n  /**\n   * Enable/disable Low-Latency HLS part playlist and segment loading, and start live streams at playlist PART-HOLD-BACK rather than HOLD-BACK.\n   */\n  set lowLatencyMode(mode) {\n    this.config.lowLatencyMode = mode;\n  }\n\n  /**\n   * Position (in seconds) of live sync point (ie edge of live position minus safety delay defined by ```hls.config.liveSyncDuration```)\n   * @returns null prior to loading live Playlist\n   */\n  get liveSyncPosition() {\n    return this.latencyController.liveSyncPosition;\n  }\n\n  /**\n   * Estimated position (in seconds) of live edge (ie edge of live playlist plus time sync playlist advanced)\n   * @returns 0 before first playlist is loaded\n   */\n  get latency() {\n    return this.latencyController.latency;\n  }\n\n  /**\n   * maximum distance from the edge before the player seeks forward to ```hls.liveSyncPosition```\n   * configured using ```liveMaxLatencyDurationCount``` (multiple of target duration) or ```liveMaxLatencyDuration```\n   * @returns 0 before first playlist is loaded\n   */\n  get maxLatency() {\n    return this.latencyController.maxLatency;\n  }\n\n  /**\n   * target distance from the edge as calculated by the latency controller\n   */\n  get targetLatency() {\n    return this.latencyController.targetLatency;\n  }\n\n  /**\n   * the rate at which the edge of the current live playlist is advancing or 1 if there is none\n   */\n  get drift() {\n    return this.latencyController.drift;\n  }\n\n  /**\n   * set to true when startLoad is called before MANIFEST_PARSED event\n   */\n  get forceStartLoad() {\n    return this.streamController.forceStartLoad;\n  }\n}\nHls.defaultConfig = void 0;\n\nexport { AbrController, AttrList, AudioStreamController, AudioTrackController, BasePlaylistController, BaseSegment, BaseStreamController, BufferController, CMCDController, CapLevelController, ChunkMetadata, ContentSteeringController, DateRange, EMEController, ErrorActionFlags, ErrorController, ErrorDetails, ErrorTypes, Events, FPSController, Fragment, Hls, HlsSkip, HlsUrlParameters, KeySystemFormats, KeySystems, Level, LevelDetails, LevelKey, LoadStats, MetadataSchema, NetworkErrorAction, Part, PlaylistLevelType, SubtitleStreamController, SubtitleTrackController, TimelineController, Hls as default, getMediaSource, isMSESupported, isSupported };\n//# sourceMappingURL=hls.mjs.map\n","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { isSingleExpression } from './directive-helpers.js';\nimport { Directive, PartType } from './directive.js';\nexport * from './directive.js';\nconst DEV_MODE = true;\n/**\n * Recursively walks down the tree of Parts/TemplateInstances/Directives to set\n * the connected state of directives and run `disconnected`/ `reconnected`\n * callbacks.\n *\n * @return True if there were children to disconnect; false otherwise\n */\nconst notifyChildrenConnectedChanged = (parent, isConnected) => {\n    var _a, _b;\n    const children = parent._$disconnectableChildren;\n    if (children === undefined) {\n        return false;\n    }\n    for (const obj of children) {\n        // The existence of `_$notifyDirectiveConnectionChanged` is used as a \"brand\" to\n        // disambiguate AsyncDirectives from other DisconnectableChildren\n        // (as opposed to using an instanceof check to know when to call it); the\n        // redundancy of \"Directive\" in the API name is to avoid conflicting with\n        // `_$notifyConnectionChanged`, which exists `ChildParts` which are also in\n        // this list\n        // Disconnect Directive (and any nested directives contained within)\n        // This property needs to remain unminified.\n        (_b = (_a = obj)['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(_a, isConnected, false);\n        // Disconnect Part/TemplateInstance\n        notifyChildrenConnectedChanged(obj, isConnected);\n    }\n    return true;\n};\n/**\n * Removes the given child from its parent list of disconnectable children, and\n * if the parent list becomes empty as a result, removes the parent from its\n * parent, and so forth up the tree when that causes subsequent parent lists to\n * become empty.\n */\nconst removeDisconnectableFromParent = (obj) => {\n    let parent, children;\n    do {\n        if ((parent = obj._$parent) === undefined) {\n            break;\n        }\n        children = parent._$disconnectableChildren;\n        children.delete(obj);\n        obj = parent;\n    } while ((children === null || children === void 0 ? void 0 : children.size) === 0);\n};\nconst addDisconnectableToParent = (obj) => {\n    // Climb the parent tree, creating a sparse tree of children needing\n    // disconnection\n    for (let parent; (parent = obj._$parent); obj = parent) {\n        let children = parent._$disconnectableChildren;\n        if (children === undefined) {\n            parent._$disconnectableChildren = children = new Set();\n        }\n        else if (children.has(obj)) {\n            // Once we've reached a parent that already contains this child, we\n            // can short-circuit\n            break;\n        }\n        children.add(obj);\n        installDisconnectAPI(parent);\n    }\n};\n/**\n * Changes the parent reference of the ChildPart, and updates the sparse tree of\n * Disconnectable children accordingly.\n *\n * Note, this method will be patched onto ChildPart instances and called from\n * the core code when parts are moved between different parents.\n */\nfunction reparentDisconnectables(newParent) {\n    if (this._$disconnectableChildren !== undefined) {\n        removeDisconnectableFromParent(this);\n        this._$parent = newParent;\n        addDisconnectableToParent(this);\n    }\n    else {\n        this._$parent = newParent;\n    }\n}\n/**\n * Sets the connected state on any directives contained within the committed\n * value of this part (i.e. within a TemplateInstance or iterable of\n * ChildParts) and runs their `disconnected`/`reconnected`s, as well as within\n * any directives stored on the ChildPart (when `valueOnly` is false).\n *\n * `isClearingValue` should be passed as `true` on a top-level part that is\n * clearing itself, and not as a result of recursively disconnecting directives\n * as part of a `clear` operation higher up the tree. This both ensures that any\n * directive on this ChildPart that produced a value that caused the clear\n * operation is not disconnected, and also serves as a performance optimization\n * to avoid needless bookkeeping when a subtree is going away; when clearing a\n * subtree, only the top-most part need to remove itself from the parent.\n *\n * `fromPartIndex` is passed only in the case of a partial `_clear` running as a\n * result of truncating an iterable.\n *\n * Note, this method will be patched onto ChildPart instances and called from the\n * core code when parts are cleared or the connection state is changed by the\n * user.\n */\nfunction notifyChildPartConnectedChanged(isConnected, isClearingValue = false, fromPartIndex = 0) {\n    const value = this._$committedValue;\n    const children = this._$disconnectableChildren;\n    if (children === undefined || children.size === 0) {\n        return;\n    }\n    if (isClearingValue) {\n        if (Array.isArray(value)) {\n            // Iterable case: Any ChildParts created by the iterable should be\n            // disconnected and removed from this ChildPart's disconnectable\n            // children (starting at `fromPartIndex` in the case of truncation)\n            for (let i = fromPartIndex; i < value.length; i++) {\n                notifyChildrenConnectedChanged(value[i], false);\n                removeDisconnectableFromParent(value[i]);\n            }\n        }\n        else if (value != null) {\n            // TemplateInstance case: If the value has disconnectable children (will\n            // only be in the case that it is a TemplateInstance), we disconnect it\n            // and remove it from this ChildPart's disconnectable children\n            notifyChildrenConnectedChanged(value, false);\n            removeDisconnectableFromParent(value);\n        }\n    }\n    else {\n        notifyChildrenConnectedChanged(this, isConnected);\n    }\n}\n/**\n * Patches disconnection API onto ChildParts.\n */\nconst installDisconnectAPI = (obj) => {\n    var _a, _b;\n    var _c, _d;\n    if (obj.type == PartType.CHILD) {\n        (_a = (_c = obj)._$notifyConnectionChanged) !== null && _a !== void 0 ? _a : (_c._$notifyConnectionChanged = notifyChildPartConnectedChanged);\n        (_b = (_d = obj)._$reparentDisconnectables) !== null && _b !== void 0 ? _b : (_d._$reparentDisconnectables = reparentDisconnectables);\n    }\n};\n/**\n * An abstract `Directive` base class whose `disconnected` method will be\n * called when the part containing the directive is cleared as a result of\n * re-rendering, or when the user calls `part.setConnected(false)` on\n * a part that was previously rendered containing the directive (as happens\n * when e.g. a LitElement disconnects from the DOM).\n *\n * If `part.setConnected(true)` is subsequently called on a\n * containing part, the directive's `reconnected` method will be called prior\n * to its next `update`/`render` callbacks. When implementing `disconnected`,\n * `reconnected` should also be implemented to be compatible with reconnection.\n *\n * Note that updates may occur while the directive is disconnected. As such,\n * directives should generally check the `this.isConnected` flag during\n * render/update to determine whether it is safe to subscribe to resources\n * that may prevent garbage collection.\n */\nexport class AsyncDirective extends Directive {\n    constructor() {\n        super(...arguments);\n        // @internal\n        this._$disconnectableChildren = undefined;\n    }\n    /**\n     * Initialize the part with internal fields\n     * @param part\n     * @param parent\n     * @param attributeIndex\n     */\n    _$initialize(part, parent, attributeIndex) {\n        super._$initialize(part, parent, attributeIndex);\n        addDisconnectableToParent(this);\n        this.isConnected = part._$isConnected;\n    }\n    // This property needs to remain unminified.\n    /**\n     * Called from the core code when a directive is going away from a part (in\n     * which case `shouldRemoveFromParent` should be true), and from the\n     * `setChildrenConnected` helper function when recursively changing the\n     * connection state of a tree (in which case `shouldRemoveFromParent` should\n     * be false).\n     *\n     * @param isConnected\n     * @param isClearingDirective - True when the directive itself is being\n     *     removed; false when the tree is being disconnected\n     * @internal\n     */\n    ['_$notifyDirectiveConnectionChanged'](isConnected, isClearingDirective = true) {\n        var _a, _b;\n        if (isConnected !== this.isConnected) {\n            this.isConnected = isConnected;\n            if (isConnected) {\n                (_a = this.reconnected) === null || _a === void 0 ? void 0 : _a.call(this);\n            }\n            else {\n                (_b = this.disconnected) === null || _b === void 0 ? void 0 : _b.call(this);\n            }\n        }\n        if (isClearingDirective) {\n            notifyChildrenConnectedChanged(this, isConnected);\n            removeDisconnectableFromParent(this);\n        }\n    }\n    /**\n     * Sets the value of the directive's Part outside the normal `update`/`render`\n     * lifecycle of a directive.\n     *\n     * This method should not be called synchronously from a directive's `update`\n     * or `render`.\n     *\n     * @param directive The directive to update\n     * @param value The value to set\n     */\n    setValue(value) {\n        if (isSingleExpression(this.__part)) {\n            this.__part._$setValue(value, this);\n        }\n        else {\n            // this.__attributeIndex will be defined in this case, but\n            // assert it in dev mode\n            if (DEV_MODE && this.__attributeIndex === undefined) {\n                throw new Error(`Expected this.__attributeIndex to be a number`);\n            }\n            const newValues = [...this.__part._$committedValue];\n            newValues[this.__attributeIndex] = value;\n            this.__part._$setValue(newValues, this, 0);\n        }\n    }\n    /**\n     * User callbacks for implementing logic to release any resources/subscriptions\n     * that may have been retained by this directive. Since directives may also be\n     * re-connected, `reconnected` should also be implemented to restore the\n     * working state of the directive prior to the next render.\n     */\n    disconnected() { }\n    reconnected() { }\n}\n//# sourceMappingURL=async-directive.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b;\nimport { _$LH, } from './lit-html.js';\nconst { _ChildPart: ChildPart } = _$LH;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nconst wrap = ENABLE_SHADYDOM_NOPATCH &&\n    ((_a = window.ShadyDOM) === null || _a === void 0 ? void 0 : _a.inUse) &&\n    ((_b = window.ShadyDOM) === null || _b === void 0 ? void 0 : _b.noPatch) === true\n    ? window.ShadyDOM.wrap\n    : (node) => node;\n/**\n * Tests if a value is a primitive value.\n *\n * See https://tc39.github.io/ecma262/#sec-typeof-operator\n */\nexport const isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');\nexport const TemplateResultType = {\n    HTML: 1,\n    SVG: 2,\n};\n/**\n * Tests if a value is a TemplateResult or a CompiledTemplateResult.\n */\nexport const isTemplateResult = (value, type) => type === undefined\n    ? // This property needs to remain unminified.\n        (value === null || value === void 0 ? void 0 : value['_$litType$']) !== undefined\n    : (value === null || value === void 0 ? void 0 : value['_$litType$']) === type;\n/**\n * Tests if a value is a CompiledTemplateResult.\n */\nexport const isCompiledTemplateResult = (value) => {\n    var _a;\n    return ((_a = value === null || value === void 0 ? void 0 : value['_$litType$']) === null || _a === void 0 ? void 0 : _a.h) != null;\n};\n/**\n * Tests if a value is a DirectiveResult.\n */\nexport const isDirectiveResult = (value) => \n// This property needs to remain unminified.\n(value === null || value === void 0 ? void 0 : value['_$litDirective$']) !== undefined;\n/**\n * Retrieves the Directive class for a DirectiveResult\n */\nexport const getDirectiveClass = (value) => \n// This property needs to remain unminified.\nvalue === null || value === void 0 ? void 0 : value['_$litDirective$'];\n/**\n * Tests whether a part has only a single-expression with no strings to\n * interpolate between.\n *\n * Only AttributePart and PropertyPart can have multiple expressions.\n * Multi-expression parts have a `strings` property and single-expression\n * parts do not.\n */\nexport const isSingleExpression = (part) => part.strings === undefined;\nconst createMarker = () => document.createComment('');\n/**\n * Inserts a ChildPart into the given container ChildPart's DOM, either at the\n * end of the container ChildPart, or before the optional `refPart`.\n *\n * This does not add the part to the containerPart's committed value. That must\n * be done by callers.\n *\n * @param containerPart Part within which to add the new ChildPart\n * @param refPart Part before which to add the new ChildPart; when omitted the\n *     part added to the end of the `containerPart`\n * @param part Part to insert, or undefined to create a new part\n */\nexport const insertPart = (containerPart, refPart, part) => {\n    var _a;\n    const container = wrap(containerPart._$startNode).parentNode;\n    const refNode = refPart === undefined ? containerPart._$endNode : refPart._$startNode;\n    if (part === undefined) {\n        const startNode = wrap(container).insertBefore(createMarker(), refNode);\n        const endNode = wrap(container).insertBefore(createMarker(), refNode);\n        part = new ChildPart(startNode, endNode, containerPart, containerPart.options);\n    }\n    else {\n        const endNode = wrap(part._$endNode).nextSibling;\n        const oldParent = part._$parent;\n        const parentChanged = oldParent !== containerPart;\n        if (parentChanged) {\n            (_a = part._$reparentDisconnectables) === null || _a === void 0 ? void 0 : _a.call(part, containerPart);\n            // Note that although `_$reparentDisconnectables` updates the part's\n            // `_$parent` reference after unlinking from its current parent, that\n            // method only exists if Disconnectables are present, so we need to\n            // unconditionally set it here\n            part._$parent = containerPart;\n            // Since the _$isConnected getter is somewhat costly, only\n            // read it once we know the subtree has directives that need\n            // to be notified\n            let newConnectionState;\n            if (part._$notifyConnectionChanged !== undefined &&\n                (newConnectionState = containerPart._$isConnected) !==\n                    oldParent._$isConnected) {\n                part._$notifyConnectionChanged(newConnectionState);\n            }\n        }\n        if (endNode !== refNode || parentChanged) {\n            let start = part._$startNode;\n            while (start !== endNode) {\n                const n = wrap(start).nextSibling;\n                wrap(container).insertBefore(start, refNode);\n                start = n;\n            }\n        }\n    }\n    return part;\n};\n/**\n * Sets the value of a Part.\n *\n * Note that this should only be used to set/update the value of user-created\n * parts (i.e. those created using `insertPart`); it should not be used\n * by directives to set the value of the directive's container part. Directives\n * should return a value from `update`/`render` to update their part state.\n *\n * For directives that require setting their part value asynchronously, they\n * should extend `AsyncDirective` and call `this.setValue()`.\n *\n * @param part Part to set\n * @param value Value to set\n * @param index For `AttributePart`s, the index to set\n * @param directiveParent Used internally; should not be set by user\n */\nexport const setChildPartValue = (part, value, directiveParent = part) => {\n    part._$setValue(value, directiveParent);\n    return part;\n};\n// A sentinel value that can never appear as a part value except when set by\n// live(). Used to force a dirty-check to fail and cause a re-render.\nconst RESET_VALUE = {};\n/**\n * Sets the committed value of a ChildPart directly without triggering the\n * commit stage of the part.\n *\n * This is useful in cases where a directive needs to update the part such\n * that the next update detects a value change or not. When value is omitted,\n * the next update will be guaranteed to be detected as a change.\n *\n * @param part\n * @param value\n */\nexport const setCommittedValue = (part, value = RESET_VALUE) => (part._$committedValue = value);\n/**\n * Returns the committed value of a ChildPart.\n *\n * The committed value is used for change detection and efficient updates of\n * the part. It can differ from the value set by the template or directive in\n * cases where the template value is transformed before being committed.\n *\n * - `TemplateResult`s are committed as a `TemplateInstance`\n * - Iterables are committed as `Array<ChildPart>`\n * - All other types are committed as the template value or value returned or\n *   set by a directive.\n *\n * @param part\n */\nexport const getCommittedValue = (part) => part._$committedValue;\n/**\n * Removes a ChildPart from the DOM, including any of its content.\n *\n * @param part The Part to remove\n */\nexport const removePart = (part) => {\n    var _a;\n    (_a = part._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(part, false, true);\n    let start = part._$startNode;\n    const end = wrap(part._$endNode).nextSibling;\n    while (start !== end) {\n        const n = wrap(start).nextSibling;\n        wrap(start).remove();\n        start = n;\n    }\n};\nexport const clearPart = (part) => {\n    part._$clear();\n};\n//# sourceMappingURL=directive-helpers.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nexport const PartType = {\n    ATTRIBUTE: 1,\n    CHILD: 2,\n    PROPERTY: 3,\n    BOOLEAN_ATTRIBUTE: 4,\n    EVENT: 5,\n    ELEMENT: 6,\n};\n/**\n * Creates a user-facing directive function from a Directive class. This\n * function has the same parameters as the directive's render() method.\n */\nexport const directive = (c) => (...values) => ({\n    // This property needs to remain unminified.\n    ['_$litDirective$']: c,\n    values,\n});\n/**\n * Base class for creating custom directives. Users should extend this class,\n * implement `render` and/or `update`, and then pass their subclass to\n * `directive`.\n */\nexport class Directive {\n    constructor(_partInfo) { }\n    // See comment in Disconnectable interface for why this is a getter\n    get _$isConnected() {\n        return this._$parent._$isConnected;\n    }\n    /** @internal */\n    _$initialize(part, parent, attributeIndex) {\n        this.__part = part;\n        this._$parent = parent;\n        this.__attributeIndex = attributeIndex;\n    }\n    /** @internal */\n    _$resolve(part, props) {\n        return this.update(part, props);\n    }\n    update(_part, props) {\n        return this.render(...props);\n    }\n}\n//# sourceMappingURL=directive.js.map","/**\n * @license\n * Copyright 2018 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { nothing } from '../lit-html.js';\n/**\n * For AttributeParts, sets the attribute if the value is defined and removes\n * the attribute if the value is undefined.\n *\n * For other part types, this directive is a no-op.\n */\nexport const ifDefined = (value) => value !== null && value !== void 0 ? value : nothing;\n//# sourceMappingURL=if-defined.js.map","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { nothing } from '../lit-html.js';\nimport { directive, Directive, } from '../directive.js';\nimport { setCommittedValue } from '../directive-helpers.js';\nclass Keyed extends Directive {\n    constructor() {\n        super(...arguments);\n        this.key = nothing;\n    }\n    render(k, v) {\n        this.key = k;\n        return v;\n    }\n    update(part, [k, v]) {\n        if (k !== this.key) {\n            // Clear the part before returning a value. The one-arg form of\n            // setCommittedValue sets the value to a sentinel which forces a\n            // commit the next render.\n            setCommittedValue(part);\n            this.key = k;\n        }\n        return v;\n    }\n}\n/**\n * Associates a renderable value with a unique key. When the key changes, the\n * previous DOM is removed and disposed before rendering the next value, even\n * if the value - such as a template - is the same.\n *\n * This is useful for forcing re-renders of stateful components, or working\n * with code that expects new data to generate new HTML elements, such as some\n * animation techniques.\n */\nexport const keyed = directive(Keyed);\n//# sourceMappingURL=keyed.js.map","/**\n * @license\n * Copyright 2020 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { nothing } from '../lit-html.js';\nimport { directive, AsyncDirective } from '../async-directive.js';\n/**\n * Creates a new Ref object, which is container for a reference to an element.\n */\nexport const createRef = () => new Ref();\n/**\n * An object that holds a ref value.\n */\nclass Ref {\n}\n// When callbacks are used for refs, this map tracks the last value the callback\n// was called with, for ensuring a directive doesn't clear the ref if the ref\n// has already been rendered to a new spot. It is double-keyed on both the\n// context (`options.host`) and the callback, since we auto-bind class methods\n// to `options.host`.\nconst lastElementForContextAndCallback = new WeakMap();\nclass RefDirective extends AsyncDirective {\n    render(_ref) {\n        return nothing;\n    }\n    update(part, [ref]) {\n        var _a;\n        const refChanged = ref !== this._ref;\n        if (refChanged && this._ref !== undefined) {\n            // The ref passed to the directive has changed;\n            // unset the previous ref's value\n            this._updateRefValue(undefined);\n        }\n        if (refChanged || this._lastElementForRef !== this._element) {\n            // We either got a new ref or this is the first render;\n            // store the ref/element & update the ref value\n            this._ref = ref;\n            this._context = (_a = part.options) === null || _a === void 0 ? void 0 : _a.host;\n            this._updateRefValue((this._element = part.element));\n        }\n        return nothing;\n    }\n    _updateRefValue(element) {\n        var _a;\n        if (typeof this._ref === 'function') {\n            // If the current ref was called with a previous value, call with\n            // `undefined`; We do this to ensure callbacks are called in a consistent\n            // way regardless of whether a ref might be moving up in the tree (in\n            // which case it would otherwise be called with the new value before the\n            // previous one unsets it) and down in the tree (where it would be unset\n            // before being set). Note that element lookup is keyed by\n            // both the context and the callback, since we allow passing unbound\n            // functions that are called on options.host, and we want to treat\n            // these as unique \"instances\" of a function.\n            const context = (_a = this._context) !== null && _a !== void 0 ? _a : globalThis;\n            let lastElementForCallback = lastElementForContextAndCallback.get(context);\n            if (lastElementForCallback === undefined) {\n                lastElementForCallback = new WeakMap();\n                lastElementForContextAndCallback.set(context, lastElementForCallback);\n            }\n            if (lastElementForCallback.get(this._ref) !== undefined) {\n                this._ref.call(this._context, undefined);\n            }\n            lastElementForCallback.set(this._ref, element);\n            // Call the ref with the new element value\n            if (element !== undefined) {\n                this._ref.call(this._context, element);\n            }\n        }\n        else {\n            this._ref.value = element;\n        }\n    }\n    get _lastElementForRef() {\n        var _a, _b, _c;\n        return typeof this._ref === 'function'\n            ? (_b = lastElementForContextAndCallback\n                .get((_a = this._context) !== null && _a !== void 0 ? _a : globalThis)) === null || _b === void 0 ? void 0 : _b.get(this._ref)\n            : (_c = this._ref) === null || _c === void 0 ? void 0 : _c.value;\n    }\n    disconnected() {\n        // Only clear the box if our element is still the one in it (i.e. another\n        // directive instance hasn't rendered its element to it before us); that\n        // only happens in the event of the directive being cleared (not via manual\n        // disconnection)\n        if (this._lastElementForRef === this._element) {\n            this._updateRefValue(undefined);\n        }\n    }\n    reconnected() {\n        // If we were manually disconnected, we can safely put our element back in\n        // the box, since no rendering could have occurred to change its state\n        this._updateRefValue(this._element);\n    }\n}\n/**\n * Sets the value of a Ref object or calls a ref callback with the element it's\n * bound to.\n *\n * A Ref object acts as a container for a reference to an element. A ref\n * callback is a function that takes an element as its only argument.\n *\n * The ref directive sets the value of the Ref object or calls the ref callback\n * during rendering, if the referenced element changed.\n *\n * Note: If a ref callback is rendered to a different element position or is\n * removed in a subsequent render, it will first be called with `undefined`,\n * followed by another call with the new element it was rendered to (if any).\n *\n * ```js\n * // Using Ref object\n * const inputRef = createRef();\n * render(html`<input ${ref(inputRef)}>`, container);\n * inputRef.value.focus();\n *\n * // Using callback\n * const callback = (inputElement) => inputElement.focus();\n * render(html`<input ${ref(callback)}>`, container);\n * ```\n */\nexport const ref = directive(RefDirective);\n//# sourceMappingURL=ref.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { nothing, noChange } from '../lit-html.js';\nimport { directive, Directive, PartType } from '../directive.js';\nconst HTML_RESULT = 1;\nexport class UnsafeHTMLDirective extends Directive {\n    constructor(partInfo) {\n        super(partInfo);\n        this._value = nothing;\n        if (partInfo.type !== PartType.CHILD) {\n            throw new Error(`${this.constructor.directiveName}() can only be used in child bindings`);\n        }\n    }\n    render(value) {\n        if (value === nothing || value == null) {\n            this._templateResult = undefined;\n            return (this._value = value);\n        }\n        if (value === noChange) {\n            return value;\n        }\n        if (typeof value != 'string') {\n            throw new Error(`${this.constructor.directiveName}() called with a non-string value`);\n        }\n        if (value === this._value) {\n            return this._templateResult;\n        }\n        this._value = value;\n        const strings = [value];\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        strings.raw = strings;\n        // WARNING: impersonating a TemplateResult like this is extremely\n        // dangerous. Third-party directives should not do this.\n        return (this._templateResult = {\n            // Cast to a known set of integers that satisfy ResultType so that we\n            // don't have to export ResultType and possibly encourage this pattern.\n            // This property needs to remain unminified.\n            ['_$litType$']: this.constructor\n                .resultType,\n            strings,\n            values: [],\n        });\n    }\n}\nUnsafeHTMLDirective.directiveName = 'unsafeHTML';\nUnsafeHTMLDirective.resultType = HTML_RESULT;\n/**\n * Renders the result as HTML, rather than text.\n *\n * The values `undefined`, `null`, and `nothing`, will all result in no content\n * (empty string) being rendered.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeHTML = directive(UnsafeHTMLDirective);\n//# sourceMappingURL=unsafe-html.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nimport { directive } from '../directive.js';\nimport { UnsafeHTMLDirective } from './unsafe-html.js';\nconst SVG_RESULT = 2;\nclass UnsafeSVGDirective extends UnsafeHTMLDirective {\n}\nUnsafeSVGDirective.directiveName = 'unsafeSVG';\nUnsafeSVGDirective.resultType = SVG_RESULT;\n/**\n * Renders the result as SVG, rather than text.\n *\n * The values `undefined`, `null`, and `nothing`, will all result in no content\n * (empty string) being rendered.\n *\n * Note, this is unsafe to use with any user-provided input that hasn't been\n * sanitized or escaped, as it may lead to cross-site-scripting\n * vulnerabilities.\n */\nexport const unsafeSVG = directive(UnsafeSVGDirective);\n//# sourceMappingURL=unsafe-svg.js.map","/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\nvar _a, _b, _c, _d;\nconst DEV_MODE = true;\nconst ENABLE_EXTRA_SECURITY_HOOKS = true;\nconst ENABLE_SHADYDOM_NOPATCH = true;\nconst NODE_MODE = false;\n// Use window for browser builds because IE11 doesn't have globalThis.\nconst global = NODE_MODE ? globalThis : window;\n/**\n * Useful for visualizing and logging insights into what the Lit template system is doing.\n *\n * Compiled out of prod mode builds.\n */\nconst debugLogEvent = DEV_MODE\n    ? (event) => {\n        const shouldEmit = global\n            .emitLitDebugLogEvents;\n        if (!shouldEmit) {\n            return;\n        }\n        global.dispatchEvent(new CustomEvent('lit-debug', {\n            detail: event,\n        }));\n    }\n    : undefined;\n// Used for connecting beginRender and endRender events when there are nested\n// renders when errors are thrown preventing an endRender event from being\n// called.\nlet debugLogRenderId = 0;\nlet issueWarning;\nif (DEV_MODE) {\n    (_a = global.litIssuedWarnings) !== null && _a !== void 0 ? _a : (global.litIssuedWarnings = new Set());\n    // Issue a warning, if we haven't already.\n    issueWarning = (code, warning) => {\n        warning += code\n            ? ` See https://lit.dev/msg/${code} for more information.`\n            : '';\n        if (!global.litIssuedWarnings.has(warning)) {\n            console.warn(warning);\n            global.litIssuedWarnings.add(warning);\n        }\n    };\n    issueWarning('dev-mode', `Lit is in dev mode. Not recommended for production!`);\n}\nconst wrap = ENABLE_SHADYDOM_NOPATCH &&\n    ((_b = global.ShadyDOM) === null || _b === void 0 ? void 0 : _b.inUse) &&\n    ((_c = global.ShadyDOM) === null || _c === void 0 ? void 0 : _c.noPatch) === true\n    ? global.ShadyDOM.wrap\n    : (node) => node;\nconst trustedTypes = global.trustedTypes;\n/**\n * Our TrustedTypePolicy for HTML which is declared using the html template\n * tag function.\n *\n * That HTML is a developer-authored constant, and is parsed with innerHTML\n * before any untrusted expressions have been mixed in. Therefor it is\n * considered safe by construction.\n */\nconst policy = trustedTypes\n    ? trustedTypes.createPolicy('lit-html', {\n        createHTML: (s) => s,\n    })\n    : undefined;\nconst identityFunction = (value) => value;\nconst noopSanitizer = (_node, _name, _type) => identityFunction;\n/** Sets the global sanitizer factory. */\nconst setSanitizer = (newSanitizer) => {\n    if (!ENABLE_EXTRA_SECURITY_HOOKS) {\n        return;\n    }\n    if (sanitizerFactoryInternal !== noopSanitizer) {\n        throw new Error(`Attempted to overwrite existing lit-html security policy.` +\n            ` setSanitizeDOMValueFactory should be called at most once.`);\n    }\n    sanitizerFactoryInternal = newSanitizer;\n};\n/**\n * Only used in internal tests, not a part of the public API.\n */\nconst _testOnlyClearSanitizerFactoryDoNotCallOrElse = () => {\n    sanitizerFactoryInternal = noopSanitizer;\n};\nconst createSanitizer = (node, name, type) => {\n    return sanitizerFactoryInternal(node, name, type);\n};\n// Added to an attribute name to mark the attribute as bound so we can find\n// it easily.\nconst boundAttributeSuffix = '$lit$';\n// This marker is used in many syntactic positions in HTML, so it must be\n// a valid element name and attribute name. We don't support dynamic names (yet)\n// but this at least ensures that the parse tree is closer to the template\n// intention.\nconst marker = `lit$${String(Math.random()).slice(9)}$`;\n// String used to tell if a comment is a marker comment\nconst markerMatch = '?' + marker;\n// Text used to insert a comment marker node. We use processing instruction\n// syntax because it's slightly smaller, but parses as a comment node.\nconst nodeMarker = `<${markerMatch}>`;\nconst d = NODE_MODE && global.document === undefined\n    ? {\n        createTreeWalker() {\n            return {};\n        },\n    }\n    : document;\n// Creates a dynamic marker. We never have to search for these in the DOM.\nconst createMarker = () => d.createComment('');\nconst isPrimitive = (value) => value === null || (typeof value != 'object' && typeof value != 'function');\nconst isArray = Array.isArray;\nconst isIterable = (value) => isArray(value) ||\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    typeof (value === null || value === void 0 ? void 0 : value[Symbol.iterator]) === 'function';\nconst SPACE_CHAR = `[ \\t\\n\\f\\r]`;\nconst ATTR_VALUE_CHAR = `[^ \\t\\n\\f\\r\"'\\`<>=]`;\nconst NAME_CHAR = `[^\\\\s\"'>=/]`;\n// These regexes represent the five parsing states that we care about in the\n// Template's HTML scanner. They match the *end* of the state they're named\n// after.\n// Depending on the match, we transition to a new state. If there's no match,\n// we stay in the same state.\n// Note that the regexes are stateful. We utilize lastIndex and sync it\n// across the multiple regexes used. In addition to the five regexes below\n// we also dynamically create a regex to find the matching end tags for raw\n// text elements.\n/**\n * End of text is: `<` followed by:\n *   (comment start) or (tag) or (dynamic tag binding)\n */\nconst textEndRegex = /<(?:(!--|\\/[^a-zA-Z])|(\\/?[a-zA-Z][^>\\s]*)|(\\/?$))/g;\nconst COMMENT_START = 1;\nconst TAG_NAME = 2;\nconst DYNAMIC_TAG_NAME = 3;\nconst commentEndRegex = /-->/g;\n/**\n * Comments not started with <!--, like </{, can be ended by a single `>`\n */\nconst comment2EndRegex = />/g;\n/**\n * The tagEnd regex matches the end of the \"inside an opening\" tag syntax\n * position. It either matches a `>`, an attribute-like sequence, or the end\n * of the string after a space (attribute-name position ending).\n *\n * See attributes in the HTML spec:\n * https://www.w3.org/TR/html5/syntax.html#elements-attributes\n *\n * \" \\t\\n\\f\\r\" are HTML space characters:\n * https://infra.spec.whatwg.org/#ascii-whitespace\n *\n * So an attribute is:\n *  * The name: any character except a whitespace character, (\"), ('), \">\",\n *    \"=\", or \"/\". Note: this is different from the HTML spec which also excludes control characters.\n *  * Followed by zero or more space characters\n *  * Followed by \"=\"\n *  * Followed by zero or more space characters\n *  * Followed by:\n *    * Any character except space, ('), (\"), \"<\", \">\", \"=\", (`), or\n *    * (\") then any non-(\"), or\n *    * (') then any non-(')\n */\nconst tagEndRegex = new RegExp(`>|${SPACE_CHAR}(?:(${NAME_CHAR}+)(${SPACE_CHAR}*=${SPACE_CHAR}*(?:${ATTR_VALUE_CHAR}|(\"|')|))|$)`, 'g');\nconst ENTIRE_MATCH = 0;\nconst ATTRIBUTE_NAME = 1;\nconst SPACES_AND_EQUALS = 2;\nconst QUOTE_CHAR = 3;\nconst singleQuoteAttrEndRegex = /'/g;\nconst doubleQuoteAttrEndRegex = /\"/g;\n/**\n * Matches the raw text elements.\n *\n * Comments are not parsed within raw text elements, so we need to search their\n * text content for marker strings.\n */\nconst rawTextElement = /^(?:script|style|textarea|title)$/i;\n/** TemplateResult types */\nconst HTML_RESULT = 1;\nconst SVG_RESULT = 2;\n// TemplatePart types\n// IMPORTANT: these must match the values in PartType\nconst ATTRIBUTE_PART = 1;\nconst CHILD_PART = 2;\nconst PROPERTY_PART = 3;\nconst BOOLEAN_ATTRIBUTE_PART = 4;\nconst EVENT_PART = 5;\nconst ELEMENT_PART = 6;\nconst COMMENT_PART = 7;\n/**\n * Generates a template literal tag function that returns a TemplateResult with\n * the given result type.\n */\nconst tag = (type) => (strings, ...values) => {\n    // Warn against templates octal escape sequences\n    // We do this here rather than in render so that the warning is closer to the\n    // template definition.\n    if (DEV_MODE && strings.some((s) => s === undefined)) {\n        console.warn('Some template strings are undefined.\\n' +\n            'This is probably caused by illegal octal escape sequences.');\n    }\n    return {\n        // This property needs to remain unminified.\n        ['_$litType$']: type,\n        strings,\n        values,\n    };\n};\n/**\n * Interprets a template literal as an HTML template that can efficiently\n * render to and update a container.\n *\n * ```ts\n * const header = (title: string) => html`<h1>${title}</h1>`;\n * ```\n *\n * The `html` tag returns a description of the DOM to render as a value. It is\n * lazy, meaning no work is done until the template is rendered. When rendering,\n * if a template comes from the same expression as a previously rendered result,\n * it's efficiently updated instead of replaced.\n */\nexport const html = tag(HTML_RESULT);\n/**\n * Interprets a template literal as an SVG fragment that can efficiently\n * render to and update a container.\n *\n * ```ts\n * const rect = svg`<rect width=\"10\" height=\"10\"></rect>`;\n *\n * const myImage = html`\n *   <svg viewBox=\"0 0 10 10\" xmlns=\"http://www.w3.org/2000/svg\">\n *     ${rect}\n *   </svg>`;\n * ```\n *\n * The `svg` *tag function* should only be used for SVG fragments, or elements\n * that would be contained **inside** an `<svg>` HTML element. A common error is\n * placing an `<svg>` *element* in a template tagged with the `svg` tag\n * function. The `<svg>` element is an HTML element and should be used within a\n * template tagged with the {@linkcode html} tag function.\n *\n * In LitElement usage, it's invalid to return an SVG fragment from the\n * `render()` method, as the SVG fragment will be contained within the element's\n * shadow root and thus cannot be used within an `<svg>` HTML element.\n */\nexport const svg = tag(SVG_RESULT);\n/**\n * A sentinel value that signals that a value was handled by a directive and\n * should not be written to the DOM.\n */\nexport const noChange = Symbol.for('lit-noChange');\n/**\n * A sentinel value that signals a ChildPart to fully clear its content.\n *\n * ```ts\n * const button = html`${\n *  user.isAdmin\n *    ? html`<button>DELETE</button>`\n *    : nothing\n * }`;\n * ```\n *\n * Prefer using `nothing` over other falsy values as it provides a consistent\n * behavior between various expression binding contexts.\n *\n * In child expressions, `undefined`, `null`, `''`, and `nothing` all behave the\n * same and render no nodes. In attribute expressions, `nothing` _removes_ the\n * attribute, while `undefined` and `null` will render an empty string. In\n * property expressions `nothing` becomes `undefined`.\n */\nexport const nothing = Symbol.for('lit-nothing');\n/**\n * The cache of prepared templates, keyed by the tagged TemplateStringsArray\n * and _not_ accounting for the specific template tag used. This means that\n * template tags cannot be dynamic - the must statically be one of html, svg,\n * or attr. This restriction simplifies the cache lookup, which is on the hot\n * path for rendering.\n */\nconst templateCache = new WeakMap();\nconst walker = d.createTreeWalker(d, 129 /* NodeFilter.SHOW_{ELEMENT|COMMENT} */, null, false);\nlet sanitizerFactoryInternal = noopSanitizer;\nfunction trustFromTemplateString(tsa, stringFromTSA) {\n    // A security check to prevent spoofing of Lit template results.\n    // In the future, we may be able to replace this with Array.isTemplateObject,\n    // though we might need to make that check inside of the html and svg\n    // functions, because precompiled templates don't come in as\n    // TemplateStringArray objects.\n    if (!Array.isArray(tsa) || !tsa.hasOwnProperty('raw')) {\n        let message = 'invalid template strings array';\n        if (DEV_MODE) {\n            message = `\n          Internal Error: expected template strings to be an array\n          with a 'raw' field. Faking a template strings array by\n          calling html or svg like an ordinary function is effectively\n          the same as calling unsafeHtml and can lead to major security\n          issues, e.g. opening your code up to XSS attacks.\n          If you're using the html or svg tagged template functions normally\n          and still seeing this error, please file a bug at\n          https://github.com/lit/lit/issues/new?template=bug_report.md\n          and include information about your build tooling, if any.\n        `\n                .trim()\n                .replace(/\\n */g, '\\n');\n        }\n        throw new Error(message);\n    }\n    return policy !== undefined\n        ? policy.createHTML(stringFromTSA)\n        : stringFromTSA;\n}\n/**\n * Returns an HTML string for the given TemplateStringsArray and result type\n * (HTML or SVG), along with the case-sensitive bound attribute names in\n * template order. The HTML contains comment markers denoting the `ChildPart`s\n * and suffixes on bound attributes denoting the `AttributeParts`.\n *\n * @param strings template strings array\n * @param type HTML or SVG\n * @return Array containing `[html, attrNames]` (array returned for terseness,\n *     to avoid object fields since this code is shared with non-minified SSR\n *     code)\n */\nconst getTemplateHtml = (strings, type) => {\n    // Insert makers into the template HTML to represent the position of\n    // bindings. The following code scans the template strings to determine the\n    // syntactic position of the bindings. They can be in text position, where\n    // we insert an HTML comment, attribute value position, where we insert a\n    // sentinel string and re-write the attribute name, or inside a tag where\n    // we insert the sentinel string.\n    const l = strings.length - 1;\n    // Stores the case-sensitive bound attribute names in the order of their\n    // parts. ElementParts are also reflected in this array as undefined\n    // rather than a string, to disambiguate from attribute bindings.\n    const attrNames = [];\n    let html = type === SVG_RESULT ? '<svg>' : '';\n    // When we're inside a raw text tag (not it's text content), the regex\n    // will still be tagRegex so we can find attributes, but will switch to\n    // this regex when the tag ends.\n    let rawTextEndRegex;\n    // The current parsing state, represented as a reference to one of the\n    // regexes\n    let regex = textEndRegex;\n    for (let i = 0; i < l; i++) {\n        const s = strings[i];\n        // The index of the end of the last attribute name. When this is\n        // positive at end of a string, it means we're in an attribute value\n        // position and need to rewrite the attribute name.\n        // We also use a special value of -2 to indicate that we encountered\n        // the end of a string in attribute name position.\n        let attrNameEndIndex = -1;\n        let attrName;\n        let lastIndex = 0;\n        let match;\n        // The conditions in this loop handle the current parse state, and the\n        // assignments to the `regex` variable are the state transitions.\n        while (lastIndex < s.length) {\n            // Make sure we start searching from where we previously left off\n            regex.lastIndex = lastIndex;\n            match = regex.exec(s);\n            if (match === null) {\n                break;\n            }\n            lastIndex = regex.lastIndex;\n            if (regex === textEndRegex) {\n                if (match[COMMENT_START] === '!--') {\n                    regex = commentEndRegex;\n                }\n                else if (match[COMMENT_START] !== undefined) {\n                    // We started a weird comment, like </{\n                    regex = comment2EndRegex;\n                }\n                else if (match[TAG_NAME] !== undefined) {\n                    if (rawTextElement.test(match[TAG_NAME])) {\n                        // Record if we encounter a raw-text element. We'll switch to\n                        // this regex at the end of the tag.\n                        rawTextEndRegex = new RegExp(`</${match[TAG_NAME]}`, 'g');\n                    }\n                    regex = tagEndRegex;\n                }\n                else if (match[DYNAMIC_TAG_NAME] !== undefined) {\n                    if (DEV_MODE) {\n                        throw new Error('Bindings in tag names are not supported. Please use static templates instead. ' +\n                            'See https://lit.dev/docs/templates/expressions/#static-expressions');\n                    }\n                    regex = tagEndRegex;\n                }\n            }\n            else if (regex === tagEndRegex) {\n                if (match[ENTIRE_MATCH] === '>') {\n                    // End of a tag. If we had started a raw-text element, use that\n                    // regex\n                    regex = rawTextEndRegex !== null && rawTextEndRegex !== void 0 ? rawTextEndRegex : textEndRegex;\n                    // We may be ending an unquoted attribute value, so make sure we\n                    // clear any pending attrNameEndIndex\n                    attrNameEndIndex = -1;\n                }\n                else if (match[ATTRIBUTE_NAME] === undefined) {\n                    // Attribute name position\n                    attrNameEndIndex = -2;\n                }\n                else {\n                    attrNameEndIndex = regex.lastIndex - match[SPACES_AND_EQUALS].length;\n                    attrName = match[ATTRIBUTE_NAME];\n                    regex =\n                        match[QUOTE_CHAR] === undefined\n                            ? tagEndRegex\n                            : match[QUOTE_CHAR] === '\"'\n                                ? doubleQuoteAttrEndRegex\n                                : singleQuoteAttrEndRegex;\n                }\n            }\n            else if (regex === doubleQuoteAttrEndRegex ||\n                regex === singleQuoteAttrEndRegex) {\n                regex = tagEndRegex;\n            }\n            else if (regex === commentEndRegex || regex === comment2EndRegex) {\n                regex = textEndRegex;\n            }\n            else {\n                // Not one of the five state regexes, so it must be the dynamically\n                // created raw text regex and we're at the close of that element.\n                regex = tagEndRegex;\n                rawTextEndRegex = undefined;\n            }\n        }\n        if (DEV_MODE) {\n            // If we have a attrNameEndIndex, which indicates that we should\n            // rewrite the attribute name, assert that we're in a valid attribute\n            // position - either in a tag, or a quoted attribute value.\n            console.assert(attrNameEndIndex === -1 ||\n                regex === tagEndRegex ||\n                regex === singleQuoteAttrEndRegex ||\n                regex === doubleQuoteAttrEndRegex, 'unexpected parse state B');\n        }\n        // We have four cases:\n        //  1. We're in text position, and not in a raw text element\n        //     (regex === textEndRegex): insert a comment marker.\n        //  2. We have a non-negative attrNameEndIndex which means we need to\n        //     rewrite the attribute name to add a bound attribute suffix.\n        //  3. We're at the non-first binding in a multi-binding attribute, use a\n        //     plain marker.\n        //  4. We're somewhere else inside the tag. If we're in attribute name\n        //     position (attrNameEndIndex === -2), add a sequential suffix to\n        //     generate a unique attribute name.\n        // Detect a binding next to self-closing tag end and insert a space to\n        // separate the marker from the tag end:\n        const end = regex === tagEndRegex && strings[i + 1].startsWith('/>') ? ' ' : '';\n        html +=\n            regex === textEndRegex\n                ? s + nodeMarker\n                : attrNameEndIndex >= 0\n                    ? (attrNames.push(attrName),\n                        s.slice(0, attrNameEndIndex) +\n                            boundAttributeSuffix +\n                            s.slice(attrNameEndIndex)) +\n                        marker +\n                        end\n                    : s +\n                        marker +\n                        (attrNameEndIndex === -2 ? (attrNames.push(undefined), i) : end);\n    }\n    const htmlResult = html + (strings[l] || '<?>') + (type === SVG_RESULT ? '</svg>' : '');\n    // Returned as an array for terseness\n    return [trustFromTemplateString(strings, htmlResult), attrNames];\n};\nclass Template {\n    constructor(\n    // This property needs to remain unminified.\n    { strings, ['_$litType$']: type }, options) {\n        this.parts = [];\n        let node;\n        let nodeIndex = 0;\n        let attrNameIndex = 0;\n        const partCount = strings.length - 1;\n        const parts = this.parts;\n        // Create template element\n        const [html, attrNames] = getTemplateHtml(strings, type);\n        this.el = Template.createElement(html, options);\n        walker.currentNode = this.el.content;\n        // Reparent SVG nodes into template root\n        if (type === SVG_RESULT) {\n            const content = this.el.content;\n            const svgElement = content.firstChild;\n            svgElement.remove();\n            content.append(...svgElement.childNodes);\n        }\n        // Walk the template to find binding markers and create TemplateParts\n        while ((node = walker.nextNode()) !== null && parts.length < partCount) {\n            if (node.nodeType === 1) {\n                if (DEV_MODE) {\n                    const tag = node.localName;\n                    // Warn if `textarea` includes an expression and throw if `template`\n                    // does since these are not supported. We do this by checking\n                    // innerHTML for anything that looks like a marker. This catches\n                    // cases like bindings in textarea there markers turn into text nodes.\n                    if (/^(?:textarea|template)$/i.test(tag) &&\n                        node.innerHTML.includes(marker)) {\n                        const m = `Expressions are not supported inside \\`${tag}\\` ` +\n                            `elements. See https://lit.dev/msg/expression-in-${tag} for more ` +\n                            `information.`;\n                        if (tag === 'template') {\n                            throw new Error(m);\n                        }\n                        else\n                            issueWarning('', m);\n                    }\n                }\n                // TODO (justinfagnani): for attempted dynamic tag names, we don't\n                // increment the bindingIndex, and it'll be off by 1 in the element\n                // and off by two after it.\n                if (node.hasAttributes()) {\n                    // We defer removing bound attributes because on IE we might not be\n                    // iterating attributes in their template order, and would sometimes\n                    // remove an attribute that we still need to create a part for.\n                    const attrsToRemove = [];\n                    for (const name of node.getAttributeNames()) {\n                        // `name` is the name of the attribute we're iterating over, but not\n                        // _necessarily_ the name of the attribute we will create a part\n                        // for. They can be different in browsers that don't iterate on\n                        // attributes in source order. In that case the attrNames array\n                        // contains the attribute name we'll process next. We only need the\n                        // attribute name here to know if we should process a bound attribute\n                        // on this element.\n                        if (name.endsWith(boundAttributeSuffix) ||\n                            name.startsWith(marker)) {\n                            const realName = attrNames[attrNameIndex++];\n                            attrsToRemove.push(name);\n                            if (realName !== undefined) {\n                                // Lowercase for case-sensitive SVG attributes like viewBox\n                                const value = node.getAttribute(realName.toLowerCase() + boundAttributeSuffix);\n                                const statics = value.split(marker);\n                                const m = /([.?@])?(.*)/.exec(realName);\n                                parts.push({\n                                    type: ATTRIBUTE_PART,\n                                    index: nodeIndex,\n                                    name: m[2],\n                                    strings: statics,\n                                    ctor: m[1] === '.'\n                                        ? PropertyPart\n                                        : m[1] === '?'\n                                            ? BooleanAttributePart\n                                            : m[1] === '@'\n                                                ? EventPart\n                                                : AttributePart,\n                                });\n                            }\n                            else {\n                                parts.push({\n                                    type: ELEMENT_PART,\n                                    index: nodeIndex,\n                                });\n                            }\n                        }\n                    }\n                    for (const name of attrsToRemove) {\n                        node.removeAttribute(name);\n                    }\n                }\n                // TODO (justinfagnani): benchmark the regex against testing for each\n                // of the 3 raw text element names.\n                if (rawTextElement.test(node.tagName)) {\n                    // For raw text elements we need to split the text content on\n                    // markers, create a Text node for each segment, and create\n                    // a TemplatePart for each marker.\n                    const strings = node.textContent.split(marker);\n                    const lastIndex = strings.length - 1;\n                    if (lastIndex > 0) {\n                        node.textContent = trustedTypes\n                            ? trustedTypes.emptyScript\n                            : '';\n                        // Generate a new text node for each literal section\n                        // These nodes are also used as the markers for node parts\n                        // We can't use empty text nodes as markers because they're\n                        // normalized when cloning in IE (could simplify when\n                        // IE is no longer supported)\n                        for (let i = 0; i < lastIndex; i++) {\n                            node.append(strings[i], createMarker());\n                            // Walk past the marker node we just added\n                            walker.nextNode();\n                            parts.push({ type: CHILD_PART, index: ++nodeIndex });\n                        }\n                        // Note because this marker is added after the walker's current\n                        // node, it will be walked to in the outer loop (and ignored), so\n                        // we don't need to adjust nodeIndex here\n                        node.append(strings[lastIndex], createMarker());\n                    }\n                }\n            }\n            else if (node.nodeType === 8) {\n                const data = node.data;\n                if (data === markerMatch) {\n                    parts.push({ type: CHILD_PART, index: nodeIndex });\n                }\n                else {\n                    let i = -1;\n                    while ((i = node.data.indexOf(marker, i + 1)) !== -1) {\n                        // Comment node has a binding marker inside, make an inactive part\n                        // The binding won't work, but subsequent bindings will\n                        parts.push({ type: COMMENT_PART, index: nodeIndex });\n                        // Move to the end of the match\n                        i += marker.length - 1;\n                    }\n                }\n            }\n            nodeIndex++;\n        }\n        // We could set walker.currentNode to another node here to prevent a memory\n        // leak, but every time we prepare a template, we immediately render it\n        // and re-use the walker in new TemplateInstance._clone().\n        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n            kind: 'template prep',\n            template: this,\n            clonableTemplate: this.el,\n            parts: this.parts,\n            strings,\n        });\n    }\n    // Overridden via `litHtmlPolyfillSupport` to provide platform support.\n    /** @nocollapse */\n    static createElement(html, _options) {\n        const el = d.createElement('template');\n        el.innerHTML = html;\n        return el;\n    }\n}\nfunction resolveDirective(part, value, parent = part, attributeIndex) {\n    var _a, _b, _c;\n    var _d;\n    // Bail early if the value is explicitly noChange. Note, this means any\n    // nested directive is still attached and is not run.\n    if (value === noChange) {\n        return value;\n    }\n    let currentDirective = attributeIndex !== undefined\n        ? (_a = parent.__directives) === null || _a === void 0 ? void 0 : _a[attributeIndex]\n        : parent.__directive;\n    const nextDirectiveConstructor = isPrimitive(value)\n        ? undefined\n        : // This property needs to remain unminified.\n            value['_$litDirective$'];\n    if ((currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective.constructor) !== nextDirectiveConstructor) {\n        // This property needs to remain unminified.\n        (_b = currentDirective === null || currentDirective === void 0 ? void 0 : currentDirective['_$notifyDirectiveConnectionChanged']) === null || _b === void 0 ? void 0 : _b.call(currentDirective, false);\n        if (nextDirectiveConstructor === undefined) {\n            currentDirective = undefined;\n        }\n        else {\n            currentDirective = new nextDirectiveConstructor(part);\n            currentDirective._$initialize(part, parent, attributeIndex);\n        }\n        if (attributeIndex !== undefined) {\n            ((_c = (_d = parent).__directives) !== null && _c !== void 0 ? _c : (_d.__directives = []))[attributeIndex] =\n                currentDirective;\n        }\n        else {\n            parent.__directive = currentDirective;\n        }\n    }\n    if (currentDirective !== undefined) {\n        value = resolveDirective(part, currentDirective._$resolve(part, value.values), currentDirective, attributeIndex);\n    }\n    return value;\n}\n/**\n * An updateable instance of a Template. Holds references to the Parts used to\n * update the template instance.\n */\nclass TemplateInstance {\n    constructor(template, parent) {\n        this._$parts = [];\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$template = template;\n        this._$parent = parent;\n    }\n    // Called by ChildPart parentNode getter\n    get parentNode() {\n        return this._$parent.parentNode;\n    }\n    // See comment in Disconnectable interface for why this is a getter\n    get _$isConnected() {\n        return this._$parent._$isConnected;\n    }\n    // This method is separate from the constructor because we need to return a\n    // DocumentFragment and we don't want to hold onto it with an instance field.\n    _clone(options) {\n        var _a;\n        const { el: { content }, parts: parts, } = this._$template;\n        const fragment = ((_a = options === null || options === void 0 ? void 0 : options.creationScope) !== null && _a !== void 0 ? _a : d).importNode(content, true);\n        walker.currentNode = fragment;\n        let node = walker.nextNode();\n        let nodeIndex = 0;\n        let partIndex = 0;\n        let templatePart = parts[0];\n        while (templatePart !== undefined) {\n            if (nodeIndex === templatePart.index) {\n                let part;\n                if (templatePart.type === CHILD_PART) {\n                    part = new ChildPart(node, node.nextSibling, this, options);\n                }\n                else if (templatePart.type === ATTRIBUTE_PART) {\n                    part = new templatePart.ctor(node, templatePart.name, templatePart.strings, this, options);\n                }\n                else if (templatePart.type === ELEMENT_PART) {\n                    part = new ElementPart(node, this, options);\n                }\n                this._$parts.push(part);\n                templatePart = parts[++partIndex];\n            }\n            if (nodeIndex !== (templatePart === null || templatePart === void 0 ? void 0 : templatePart.index)) {\n                node = walker.nextNode();\n                nodeIndex++;\n            }\n        }\n        // We need to set the currentNode away from the cloned tree so that we\n        // don't hold onto the tree even if the tree is detached and should be\n        // freed.\n        walker.currentNode = d;\n        return fragment;\n    }\n    _update(values) {\n        let i = 0;\n        for (const part of this._$parts) {\n            if (part !== undefined) {\n                debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                    kind: 'set part',\n                    part,\n                    value: values[i],\n                    valueIndex: i,\n                    values,\n                    templateInstance: this,\n                });\n                if (part.strings !== undefined) {\n                    part._$setValue(values, part, i);\n                    // The number of values the part consumes is part.strings.length - 1\n                    // since values are in between template spans. We increment i by 1\n                    // later in the loop, so increment it by part.strings.length - 2 here\n                    i += part.strings.length - 2;\n                }\n                else {\n                    part._$setValue(values[i]);\n                }\n            }\n            i++;\n        }\n    }\n}\nclass ChildPart {\n    constructor(startNode, endNode, parent, options) {\n        var _a;\n        this.type = CHILD_PART;\n        this._$committedValue = nothing;\n        // The following fields will be patched onto ChildParts when required by\n        // AsyncDirective\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$startNode = startNode;\n        this._$endNode = endNode;\n        this._$parent = parent;\n        this.options = options;\n        // Note __isConnected is only ever accessed on RootParts (i.e. when there is\n        // no _$parent); the value on a non-root-part is \"don't care\", but checking\n        // for parent would be more code\n        this.__isConnected = (_a = options === null || options === void 0 ? void 0 : options.isConnected) !== null && _a !== void 0 ? _a : true;\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            // Explicitly initialize for consistent class shape.\n            this._textSanitizer = undefined;\n        }\n    }\n    // See comment in Disconnectable interface for why this is a getter\n    get _$isConnected() {\n        var _a, _b;\n        // ChildParts that are not at the root should always be created with a\n        // parent; only RootChildNode's won't, so they return the local isConnected\n        // state\n        return (_b = (_a = this._$parent) === null || _a === void 0 ? void 0 : _a._$isConnected) !== null && _b !== void 0 ? _b : this.__isConnected;\n    }\n    /**\n     * The parent node into which the part renders its content.\n     *\n     * A ChildPart's content consists of a range of adjacent child nodes of\n     * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and\n     * `.endNode`).\n     *\n     * - If both `.startNode` and `.endNode` are non-null, then the part's content\n     * consists of all siblings between `.startNode` and `.endNode`, exclusively.\n     *\n     * - If `.startNode` is non-null but `.endNode` is null, then the part's\n     * content consists of all siblings following `.startNode`, up to and\n     * including the last child of `.parentNode`. If `.endNode` is non-null, then\n     * `.startNode` will always be non-null.\n     *\n     * - If both `.endNode` and `.startNode` are null, then the part's content\n     * consists of all child nodes of `.parentNode`.\n     */\n    get parentNode() {\n        let parentNode = wrap(this._$startNode).parentNode;\n        const parent = this._$parent;\n        if (parent !== undefined &&\n            (parentNode === null || parentNode === void 0 ? void 0 : parentNode.nodeType) === 11 /* Node.DOCUMENT_FRAGMENT */) {\n            // If the parentNode is a DocumentFragment, it may be because the DOM is\n            // still in the cloned fragment during initial render; if so, get the real\n            // parentNode the part will be committed into by asking the parent.\n            parentNode = parent.parentNode;\n        }\n        return parentNode;\n    }\n    /**\n     * The part's leading marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get startNode() {\n        return this._$startNode;\n    }\n    /**\n     * The part's trailing marker node, if any. See `.parentNode` for more\n     * information.\n     */\n    get endNode() {\n        return this._$endNode;\n    }\n    _$setValue(value, directiveParent = this) {\n        var _a;\n        if (DEV_MODE && this.parentNode === null) {\n            throw new Error(`This \\`ChildPart\\` has no \\`parentNode\\` and therefore cannot accept a value. This likely means the element containing the part was manipulated in an unsupported way outside of Lit's control such that the part's marker nodes were ejected from DOM. For example, setting the element's \\`innerHTML\\` or \\`textContent\\` can do this.`);\n        }\n        value = resolveDirective(this, value, directiveParent);\n        if (isPrimitive(value)) {\n            // Non-rendering child values. It's important that these do not render\n            // empty text nodes to avoid issues with preventing default <slot>\n            // fallback content.\n            if (value === nothing || value == null || value === '') {\n                if (this._$committedValue !== nothing) {\n                    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                        kind: 'commit nothing to child',\n                        start: this._$startNode,\n                        end: this._$endNode,\n                        parent: this._$parent,\n                        options: this.options,\n                    });\n                    this._$clear();\n                }\n                this._$committedValue = nothing;\n            }\n            else if (value !== this._$committedValue && value !== noChange) {\n                this._commitText(value);\n            }\n            // This property needs to remain unminified.\n        }\n        else if (value['_$litType$'] !== undefined) {\n            this._commitTemplateResult(value);\n        }\n        else if (value.nodeType !== undefined) {\n            if (DEV_MODE && ((_a = this.options) === null || _a === void 0 ? void 0 : _a.host) === value) {\n                this._commitText(`[probable mistake: rendered a template's host in itself ` +\n                    `(commonly caused by writing \\${this} in a template]`);\n                console.warn(`Attempted to render the template host`, value, `inside itself. This is almost always a mistake, and in dev mode `, `we render some warning text. In production however, we'll `, `render it, which will usually result in an error, and sometimes `, `in the element disappearing from the DOM.`);\n                return;\n            }\n            this._commitNode(value);\n        }\n        else if (isIterable(value)) {\n            this._commitIterable(value);\n        }\n        else {\n            // Fallback, will render the string representation\n            this._commitText(value);\n        }\n    }\n    _insert(node) {\n        return wrap(wrap(this._$startNode).parentNode).insertBefore(node, this._$endNode);\n    }\n    _commitNode(value) {\n        var _a;\n        if (this._$committedValue !== value) {\n            this._$clear();\n            if (ENABLE_EXTRA_SECURITY_HOOKS &&\n                sanitizerFactoryInternal !== noopSanitizer) {\n                const parentNodeName = (_a = this._$startNode.parentNode) === null || _a === void 0 ? void 0 : _a.nodeName;\n                if (parentNodeName === 'STYLE' || parentNodeName === 'SCRIPT') {\n                    let message = 'Forbidden';\n                    if (DEV_MODE) {\n                        if (parentNodeName === 'STYLE') {\n                            message =\n                                `Lit does not support binding inside style nodes. ` +\n                                    `This is a security risk, as style injection attacks can ` +\n                                    `exfiltrate data and spoof UIs. ` +\n                                    `Consider instead using css\\`...\\` literals ` +\n                                    `to compose styles, and make do dynamic styling with ` +\n                                    `css custom properties, ::parts, <slot>s, ` +\n                                    `and by mutating the DOM rather than stylesheets.`;\n                        }\n                        else {\n                            message =\n                                `Lit does not support binding inside script nodes. ` +\n                                    `This is a security risk, as it could allow arbitrary ` +\n                                    `code execution.`;\n                        }\n                    }\n                    throw new Error(message);\n                }\n            }\n            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                kind: 'commit node',\n                start: this._$startNode,\n                parent: this._$parent,\n                value: value,\n                options: this.options,\n            });\n            this._$committedValue = this._insert(value);\n        }\n    }\n    _commitText(value) {\n        // If the committed value is a primitive it means we called _commitText on\n        // the previous render, and we know that this._$startNode.nextSibling is a\n        // Text node. We can now just replace the text content (.data) of the node.\n        if (this._$committedValue !== nothing &&\n            isPrimitive(this._$committedValue)) {\n            const node = wrap(this._$startNode).nextSibling;\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(node, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n            }\n            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                kind: 'commit text',\n                node,\n                value,\n                options: this.options,\n            });\n            node.data = value;\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                const textNode = d.createTextNode('');\n                this._commitNode(textNode);\n                // When setting text content, for security purposes it matters a lot\n                // what the parent is. For example, <style> and <script> need to be\n                // handled with care, while <span> does not. So first we need to put a\n                // text node into the document, then we can sanitize its content.\n                if (this._textSanitizer === undefined) {\n                    this._textSanitizer = createSanitizer(textNode, 'data', 'property');\n                }\n                value = this._textSanitizer(value);\n                debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                    kind: 'commit text',\n                    node: textNode,\n                    value,\n                    options: this.options,\n                });\n                textNode.data = value;\n            }\n            else {\n                this._commitNode(d.createTextNode(value));\n                debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                    kind: 'commit text',\n                    node: wrap(this._$startNode).nextSibling,\n                    value,\n                    options: this.options,\n                });\n            }\n        }\n        this._$committedValue = value;\n    }\n    _commitTemplateResult(result) {\n        var _a;\n        // This property needs to remain unminified.\n        const { values, ['_$litType$']: type } = result;\n        // If $litType$ is a number, result is a plain TemplateResult and we get\n        // the template from the template cache. If not, result is a\n        // CompiledTemplateResult and _$litType$ is a CompiledTemplate and we need\n        // to create the <template> element the first time we see it.\n        const template = typeof type === 'number'\n            ? this._$getTemplate(result)\n            : (type.el === undefined &&\n                (type.el = Template.createElement(trustFromTemplateString(type.h, type.h[0]), this.options)),\n                type);\n        if (((_a = this._$committedValue) === null || _a === void 0 ? void 0 : _a._$template) === template) {\n            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                kind: 'template updating',\n                template,\n                instance: this._$committedValue,\n                parts: this._$committedValue._$parts,\n                options: this.options,\n                values,\n            });\n            this._$committedValue._update(values);\n        }\n        else {\n            const instance = new TemplateInstance(template, this);\n            const fragment = instance._clone(this.options);\n            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                kind: 'template instantiated',\n                template,\n                instance,\n                parts: instance._$parts,\n                options: this.options,\n                fragment,\n                values,\n            });\n            instance._update(values);\n            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                kind: 'template instantiated and updated',\n                template,\n                instance,\n                parts: instance._$parts,\n                options: this.options,\n                fragment,\n                values,\n            });\n            this._commitNode(fragment);\n            this._$committedValue = instance;\n        }\n    }\n    // Overridden via `litHtmlPolyfillSupport` to provide platform support.\n    /** @internal */\n    _$getTemplate(result) {\n        let template = templateCache.get(result.strings);\n        if (template === undefined) {\n            templateCache.set(result.strings, (template = new Template(result)));\n        }\n        return template;\n    }\n    _commitIterable(value) {\n        // For an Iterable, we create a new InstancePart per item, then set its\n        // value to the item. This is a little bit of overhead for every item in\n        // an Iterable, but it lets us recurse easily and efficiently update Arrays\n        // of TemplateResults that will be commonly returned from expressions like:\n        // array.map((i) => html`${i}`), by reusing existing TemplateInstances.\n        // If value is an array, then the previous render was of an\n        // iterable and value will contain the ChildParts from the previous\n        // render. If value is not an array, clear this part and make a new\n        // array for ChildParts.\n        if (!isArray(this._$committedValue)) {\n            this._$committedValue = [];\n            this._$clear();\n        }\n        // Lets us keep track of how many items we stamped so we can clear leftover\n        // items from a previous render\n        const itemParts = this._$committedValue;\n        let partIndex = 0;\n        let itemPart;\n        for (const item of value) {\n            if (partIndex === itemParts.length) {\n                // If no existing part, create a new one\n                // TODO (justinfagnani): test perf impact of always creating two parts\n                // instead of sharing parts between nodes\n                // https://github.com/lit/lit/issues/1266\n                itemParts.push((itemPart = new ChildPart(this._insert(createMarker()), this._insert(createMarker()), this, this.options)));\n            }\n            else {\n                // Reuse an existing part\n                itemPart = itemParts[partIndex];\n            }\n            itemPart._$setValue(item);\n            partIndex++;\n        }\n        if (partIndex < itemParts.length) {\n            // itemParts always have end nodes\n            this._$clear(itemPart && wrap(itemPart._$endNode).nextSibling, partIndex);\n            // Truncate the parts array so _value reflects the current state\n            itemParts.length = partIndex;\n        }\n    }\n    /**\n     * Removes the nodes contained within this Part from the DOM.\n     *\n     * @param start Start node to clear from, for clearing a subset of the part's\n     *     DOM (used when truncating iterables)\n     * @param from  When `start` is specified, the index within the iterable from\n     *     which ChildParts are being removed, used for disconnecting directives in\n     *     those Parts.\n     *\n     * @internal\n     */\n    _$clear(start = wrap(this._$startNode).nextSibling, from) {\n        var _a;\n        (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, false, true, from);\n        while (start && start !== this._$endNode) {\n            const n = wrap(start).nextSibling;\n            wrap(start).remove();\n            start = n;\n        }\n    }\n    /**\n     * Implementation of RootPart's `isConnected`. Note that this metod\n     * should only be called on `RootPart`s (the `ChildPart` returned from a\n     * top-level `render()` call). It has no effect on non-root ChildParts.\n     * @param isConnected Whether to set\n     * @internal\n     */\n    setConnected(isConnected) {\n        var _a;\n        if (this._$parent === undefined) {\n            this.__isConnected = isConnected;\n            (_a = this._$notifyConnectionChanged) === null || _a === void 0 ? void 0 : _a.call(this, isConnected);\n        }\n        else if (DEV_MODE) {\n            throw new Error('part.setConnected() may only be called on a ' +\n                'RootPart returned from render().');\n        }\n    }\n}\nclass AttributePart {\n    constructor(element, name, strings, parent, options) {\n        this.type = ATTRIBUTE_PART;\n        /** @internal */\n        this._$committedValue = nothing;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this.element = element;\n        this.name = name;\n        this._$parent = parent;\n        this.options = options;\n        if (strings.length > 2 || strings[0] !== '' || strings[1] !== '') {\n            this._$committedValue = new Array(strings.length - 1).fill(new String());\n            this.strings = strings;\n        }\n        else {\n            this._$committedValue = nothing;\n        }\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            this._sanitizer = undefined;\n        }\n    }\n    get tagName() {\n        return this.element.tagName;\n    }\n    // See comment in Disconnectable interface for why this is a getter\n    get _$isConnected() {\n        return this._$parent._$isConnected;\n    }\n    /**\n     * Sets the value of this part by resolving the value from possibly multiple\n     * values and static strings and committing it to the DOM.\n     * If this part is single-valued, `this._strings` will be undefined, and the\n     * method will be called with a single value argument. If this part is\n     * multi-value, `this._strings` will be defined, and the method is called\n     * with the value array of the part's owning TemplateInstance, and an offset\n     * into the value array from which the values should be read.\n     * This method is overloaded this way to eliminate short-lived array slices\n     * of the template instance values, and allow a fast-path for single-valued\n     * parts.\n     *\n     * @param value The part value, or an array of values for multi-valued parts\n     * @param valueIndex the index to start reading values from. `undefined` for\n     *   single-valued parts\n     * @param noCommit causes the part to not commit its value to the DOM. Used\n     *   in hydration to prime attribute parts with their first-rendered value,\n     *   but not set the attribute, and in SSR to no-op the DOM operation and\n     *   capture the value for serialization.\n     *\n     * @internal\n     */\n    _$setValue(value, directiveParent = this, valueIndex, noCommit) {\n        const strings = this.strings;\n        // Whether any of the values has changed, for dirty-checking\n        let change = false;\n        if (strings === undefined) {\n            // Single-value binding case\n            value = resolveDirective(this, value, directiveParent, 0);\n            change =\n                !isPrimitive(value) ||\n                    (value !== this._$committedValue && value !== noChange);\n            if (change) {\n                this._$committedValue = value;\n            }\n        }\n        else {\n            // Interpolation case\n            const values = value;\n            value = strings[0];\n            let i, v;\n            for (i = 0; i < strings.length - 1; i++) {\n                v = resolveDirective(this, values[valueIndex + i], directiveParent, i);\n                if (v === noChange) {\n                    // If the user-provided value is `noChange`, use the previous value\n                    v = this._$committedValue[i];\n                }\n                change || (change = !isPrimitive(v) || v !== this._$committedValue[i]);\n                if (v === nothing) {\n                    value = nothing;\n                }\n                else if (value !== nothing) {\n                    value += (v !== null && v !== void 0 ? v : '') + strings[i + 1];\n                }\n                // We always record each value, even if one is `nothing`, for future\n                // change detection.\n                this._$committedValue[i] = v;\n            }\n        }\n        if (change && !noCommit) {\n            this._commitValue(value);\n        }\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (value === nothing) {\n            wrap(this.element).removeAttribute(this.name);\n        }\n        else {\n            if (ENABLE_EXTRA_SECURITY_HOOKS) {\n                if (this._sanitizer === undefined) {\n                    this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'attribute');\n                }\n                value = this._sanitizer(value !== null && value !== void 0 ? value : '');\n            }\n            debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n                kind: 'commit attribute',\n                element: this.element,\n                name: this.name,\n                value,\n                options: this.options,\n            });\n            wrap(this.element).setAttribute(this.name, (value !== null && value !== void 0 ? value : ''));\n        }\n    }\n}\nclass PropertyPart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = PROPERTY_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        if (ENABLE_EXTRA_SECURITY_HOOKS) {\n            if (this._sanitizer === undefined) {\n                this._sanitizer = sanitizerFactoryInternal(this.element, this.name, 'property');\n            }\n            value = this._sanitizer(value);\n        }\n        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n            kind: 'commit property',\n            element: this.element,\n            name: this.name,\n            value,\n            options: this.options,\n        });\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        this.element[this.name] = value === nothing ? undefined : value;\n    }\n}\n// Temporary workaround for https://crbug.com/993268\n// Currently, any attribute starting with \"on\" is considered to be a\n// TrustedScript source. Such boolean attributes must be set to the equivalent\n// trusted emptyScript value.\nconst emptyStringForBooleanAttribute = trustedTypes\n    ? trustedTypes.emptyScript\n    : '';\nclass BooleanAttributePart extends AttributePart {\n    constructor() {\n        super(...arguments);\n        this.type = BOOLEAN_ATTRIBUTE_PART;\n    }\n    /** @internal */\n    _commitValue(value) {\n        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n            kind: 'commit boolean attribute',\n            element: this.element,\n            name: this.name,\n            value: !!(value && value !== nothing),\n            options: this.options,\n        });\n        if (value && value !== nothing) {\n            wrap(this.element).setAttribute(this.name, emptyStringForBooleanAttribute);\n        }\n        else {\n            wrap(this.element).removeAttribute(this.name);\n        }\n    }\n}\nclass EventPart extends AttributePart {\n    constructor(element, name, strings, parent, options) {\n        super(element, name, strings, parent, options);\n        this.type = EVENT_PART;\n        if (DEV_MODE && this.strings !== undefined) {\n            throw new Error(`A \\`<${element.localName}>\\` has a \\`@${name}=...\\` listener with ` +\n                'invalid content. Event listeners in templates must have exactly ' +\n                'one expression and no surrounding text.');\n        }\n    }\n    // EventPart does not use the base _$setValue/_resolveValue implementation\n    // since the dirty checking is more complex\n    /** @internal */\n    _$setValue(newListener, directiveParent = this) {\n        var _a;\n        newListener =\n            (_a = resolveDirective(this, newListener, directiveParent, 0)) !== null && _a !== void 0 ? _a : nothing;\n        if (newListener === noChange) {\n            return;\n        }\n        const oldListener = this._$committedValue;\n        // If the new value is nothing or any options change we have to remove the\n        // part as a listener.\n        const shouldRemoveListener = (newListener === nothing && oldListener !== nothing) ||\n            newListener.capture !==\n                oldListener.capture ||\n            newListener.once !==\n                oldListener.once ||\n            newListener.passive !==\n                oldListener.passive;\n        // If the new value is not nothing and we removed the listener, we have\n        // to add the part as a listener.\n        const shouldAddListener = newListener !== nothing &&\n            (oldListener === nothing || shouldRemoveListener);\n        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n            kind: 'commit event listener',\n            element: this.element,\n            name: this.name,\n            value: newListener,\n            options: this.options,\n            removeListener: shouldRemoveListener,\n            addListener: shouldAddListener,\n            oldListener,\n        });\n        if (shouldRemoveListener) {\n            this.element.removeEventListener(this.name, this, oldListener);\n        }\n        if (shouldAddListener) {\n            // Beware: IE11 and Chrome 41 don't like using the listener as the\n            // options object. Figure out how to deal w/ this in IE11 - maybe\n            // patch addEventListener?\n            this.element.addEventListener(this.name, this, newListener);\n        }\n        this._$committedValue = newListener;\n    }\n    handleEvent(event) {\n        var _a, _b;\n        if (typeof this._$committedValue === 'function') {\n            this._$committedValue.call((_b = (_a = this.options) === null || _a === void 0 ? void 0 : _a.host) !== null && _b !== void 0 ? _b : this.element, event);\n        }\n        else {\n            this._$committedValue.handleEvent(event);\n        }\n    }\n}\nclass ElementPart {\n    constructor(element, parent, options) {\n        this.element = element;\n        this.type = ELEMENT_PART;\n        /** @internal */\n        this._$disconnectableChildren = undefined;\n        this._$parent = parent;\n        this.options = options;\n    }\n    // See comment in Disconnectable interface for why this is a getter\n    get _$isConnected() {\n        return this._$parent._$isConnected;\n    }\n    _$setValue(value) {\n        debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n            kind: 'commit to element binding',\n            element: this.element,\n            value,\n            options: this.options,\n        });\n        resolveDirective(this, value);\n    }\n}\n/**\n * END USERS SHOULD NOT RELY ON THIS OBJECT.\n *\n * Private exports for use by other Lit packages, not intended for use by\n * external users.\n *\n * We currently do not make a mangled rollup build of the lit-ssr code. In order\n * to keep a number of (otherwise private) top-level exports  mangled in the\n * client side code, we export a _$LH object containing those members (or\n * helper methods for accessing private fields of those members), and then\n * re-export them for use in lit-ssr. This keeps lit-ssr agnostic to whether the\n * client-side code is being used in `dev` mode or `prod` mode.\n *\n * This has a unique name, to disambiguate it from private exports in\n * lit-element, which re-exports all of lit-html.\n *\n * @private\n */\nexport const _$LH = {\n    // Used in lit-ssr\n    _boundAttributeSuffix: boundAttributeSuffix,\n    _marker: marker,\n    _markerMatch: markerMatch,\n    _HTML_RESULT: HTML_RESULT,\n    _getTemplateHtml: getTemplateHtml,\n    // Used in tests and private-ssr-support\n    _TemplateInstance: TemplateInstance,\n    _isIterable: isIterable,\n    _resolveDirective: resolveDirective,\n    _ChildPart: ChildPart,\n    _AttributePart: AttributePart,\n    _BooleanAttributePart: BooleanAttributePart,\n    _EventPart: EventPart,\n    _PropertyPart: PropertyPart,\n    _ElementPart: ElementPart,\n};\n// Apply polyfills if available\nconst polyfillSupport = DEV_MODE\n    ? global.litHtmlPolyfillSupportDevMode\n    : global.litHtmlPolyfillSupport;\npolyfillSupport === null || polyfillSupport === void 0 ? void 0 : polyfillSupport(Template, ChildPart);\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for lit-html usage.\n((_d = global.litHtmlVersions) !== null && _d !== void 0 ? _d : (global.litHtmlVersions = [])).push('2.8.0');\nif (DEV_MODE && global.litHtmlVersions.length > 1) {\n    issueWarning('multiple-versions', `Multiple versions of Lit loaded. ` +\n        `Loading multiple versions is not recommended.`);\n}\n/**\n * Renders a value, usually a lit-html TemplateResult, to the container.\n *\n * This example renders the text \"Hello, Zoe!\" inside a paragraph tag, appending\n * it to the container `document.body`.\n *\n * ```js\n * import {html, render} from 'lit';\n *\n * const name = \"Zoe\";\n * render(html`<p>Hello, ${name}!</p>`, document.body);\n * ```\n *\n * @param value Any [renderable\n *   value](https://lit.dev/docs/templates/expressions/#child-expressions),\n *   typically a {@linkcode TemplateResult} created by evaluating a template tag\n *   like {@linkcode html} or {@linkcode svg}.\n * @param container A DOM container to render to. The first render will append\n *   the rendered value to the container, and subsequent renders will\n *   efficiently update the rendered value if the same result type was\n *   previously rendered there.\n * @param options See {@linkcode RenderOptions} for options documentation.\n * @see\n * {@link https://lit.dev/docs/libraries/standalone-templates/#rendering-lit-html-templates| Rendering Lit HTML Templates}\n */\nexport const render = (value, container, options) => {\n    var _a, _b;\n    if (DEV_MODE && container == null) {\n        // Give a clearer error message than\n        //     Uncaught TypeError: Cannot read properties of null (reading\n        //     '_$litPart$')\n        // which reads like an internal Lit error.\n        throw new TypeError(`The container to render into may not be ${container}`);\n    }\n    const renderId = DEV_MODE ? debugLogRenderId++ : 0;\n    const partOwnerNode = (_a = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _a !== void 0 ? _a : container;\n    // This property needs to remain unminified.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let part = partOwnerNode['_$litPart$'];\n    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n        kind: 'begin render',\n        id: renderId,\n        value,\n        container,\n        options,\n        part,\n    });\n    if (part === undefined) {\n        const endNode = (_b = options === null || options === void 0 ? void 0 : options.renderBefore) !== null && _b !== void 0 ? _b : null;\n        // This property needs to remain unminified.\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        partOwnerNode['_$litPart$'] = part = new ChildPart(container.insertBefore(createMarker(), endNode), endNode, undefined, options !== null && options !== void 0 ? options : {});\n    }\n    part._$setValue(value);\n    debugLogEvent === null || debugLogEvent === void 0 ? void 0 : debugLogEvent({\n        kind: 'end render',\n        id: renderId,\n        value,\n        container,\n        options,\n        part,\n    });\n    return part;\n};\nif (ENABLE_EXTRA_SECURITY_HOOKS) {\n    render.setSanitizer = setSanitizer;\n    render.createSanitizer = createSanitizer;\n    if (DEV_MODE) {\n        render._testOnlyClearSanitizerFactoryDoNotCallOrElse =\n            _testOnlyClearSanitizerFactoryDoNotCallOrElse;\n    }\n}\n//# sourceMappingURL=lit-html.js.map","import { Host, effect, computed, setAttribute } from './vidstack-DVpy0IqK.js';\nimport { MediaProvider, MediaPlayer } from './vidstack-Dn9nMoEW.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\n\nclass MediaProviderElement extends Host(HTMLElement, MediaProvider) {\n  static tagName = \"media-provider\";\n  #media;\n  #target = null;\n  #blocker = null;\n  onSetup() {\n    this.#media = useMediaContext();\n    this.setAttribute(\"keep-alive\", \"\");\n  }\n  onDestroy() {\n    this.#blocker?.remove();\n    this.#blocker = null;\n    this.#target?.remove();\n    this.#target = null;\n  }\n  onConnect() {\n    effect(() => {\n      const loader = this.$state.loader(), isYouTubeEmbed = loader?.name === \"youtube\", isVimeoEmbed = loader?.name === \"vimeo\", isEmbed = isYouTubeEmbed || isVimeoEmbed, isGoogleCast = loader?.name === \"google-cast\";\n      const target = loader ? isGoogleCast ? this.#createGoogleCastContainer() : isEmbed ? this.#createIFrame() : loader.mediaType() === \"audio\" ? this.#createAudio() : this.#createVideo() : null;\n      if (this.#target !== target) {\n        const parent = this.#target?.parentElement ?? this;\n        this.#target?.remove();\n        this.#target = target;\n        if (target) parent.prepend(target);\n        if (isEmbed && target) {\n          effect(() => {\n            const { nativeControls, viewType } = this.#media.$state, showNativeControls = nativeControls(), isAudioView = viewType() === \"audio\", showBlocker = !showNativeControls && !isAudioView;\n            if (showBlocker) {\n              this.#blocker = this.querySelector(\".vds-blocker\");\n              if (!this.#blocker) {\n                this.#blocker = document.createElement(\"div\");\n                this.#blocker.classList.add(\"vds-blocker\");\n                target.after(this.#blocker);\n              }\n            } else {\n              this.#blocker?.remove();\n              this.#blocker = null;\n            }\n            setAttribute(target, \"data-no-controls\", !showNativeControls);\n          });\n        }\n      }\n      if (isYouTubeEmbed) target?.classList.add(\"vds-youtube\");\n      else if (isVimeoEmbed) target?.classList.add(\"vds-vimeo\");\n      if (!isEmbed) {\n        this.#blocker?.remove();\n        this.#blocker = null;\n      }\n      this.load(target);\n    });\n  }\n  #createAudio() {\n    const audio = this.#target instanceof HTMLAudioElement ? this.#target : document.createElement(\"audio\");\n    const { controls, crossOrigin } = this.#media.$state;\n    effect(() => {\n      setAttribute(audio, \"controls\", controls());\n      setAttribute(audio, \"crossorigin\", crossOrigin());\n    });\n    return audio;\n  }\n  #createVideo() {\n    const video = this.#target instanceof HTMLVideoElement ? this.#target : document.createElement(\"video\");\n    const { crossOrigin, poster, nativeControls } = this.#media.$state, $controls = computed(() => nativeControls() ? \"true\" : null), $poster = computed(() => poster() && nativeControls() ? poster() : null);\n    effect(() => {\n      setAttribute(video, \"controls\", $controls());\n      setAttribute(video, \"crossorigin\", crossOrigin());\n      setAttribute(video, \"poster\", $poster());\n    });\n    return video;\n  }\n  #createIFrame() {\n    const iframe = this.#target instanceof HTMLIFrameElement ? this.#target : document.createElement(\"iframe\"), { nativeControls } = this.#media.$state;\n    effect(() => setAttribute(iframe, \"tabindex\", !nativeControls() ? -1 : null));\n    return iframe;\n  }\n  #createGoogleCastContainer() {\n    if (this.#target?.classList.contains(\"vds-google-cast\")) {\n      return this.#target;\n    }\n    const container = document.createElement(\"div\");\n    container.classList.add(\"vds-google-cast\");\n    import('./vidstack-Ds5tKO58.js').then(({ insertContent }) => {\n      insertContent(container, this.#media.$state);\n    });\n    return container;\n  }\n}\n\nclass MediaPlayerElement extends Host(HTMLElement, MediaPlayer) {\n  static tagName = \"media-player\";\n  static attrs = {\n    autoPlay: \"autoplay\",\n    crossOrigin: \"crossorigin\",\n    playsInline: \"playsinline\",\n    preferNativeHLS: \"prefer-native-hls\",\n    minLiveDVRWindow: \"min-live-dvr-window\"\n  };\n}\n\nexport { MediaPlayerElement, MediaProviderElement };\n","import { signal, listenEvent, ViewController, effect, EventsController, setAttribute } from './vidstack-DVpy0IqK.js';\n\nlet $keyboard = signal(false);\n{\n  listenEvent(document, \"pointerdown\", () => {\n    $keyboard.set(false);\n  });\n  listenEvent(document, \"keydown\", (e) => {\n    if (e.metaKey || e.altKey || e.ctrlKey) return;\n    $keyboard.set(true);\n  });\n}\nclass FocusVisibleController extends ViewController {\n  #focused = signal(false);\n  onConnect(el) {\n    effect(() => {\n      const events = new EventsController(el);\n      if (!$keyboard()) {\n        this.#focused.set(false);\n        updateFocusAttr(el, false);\n        events.add(\"pointerenter\", this.#onPointerEnter.bind(this)).add(\"pointerleave\", this.#onPointerLeave.bind(this));\n        return;\n      }\n      const active = document.activeElement === el;\n      this.#focused.set(active);\n      updateFocusAttr(el, active);\n      events.add(\"focus\", this.#onFocus.bind(this)).add(\"blur\", this.#onBlur.bind(this));\n    });\n  }\n  focused() {\n    return this.#focused();\n  }\n  #onFocus() {\n    this.#focused.set(true);\n    updateFocusAttr(this.el, true);\n  }\n  #onBlur() {\n    this.#focused.set(false);\n    updateFocusAttr(this.el, false);\n  }\n  #onPointerEnter() {\n    updateHoverAttr(this.el, true);\n  }\n  #onPointerLeave() {\n    updateHoverAttr(this.el, false);\n  }\n}\nfunction updateFocusAttr(el, isFocused) {\n  setAttribute(el, \"data-focus\", isFocused);\n  setAttribute(el, \"data-hocus\", isFocused);\n}\nfunction updateHoverAttr(el, isHovering) {\n  setAttribute(el, \"data-hocus\", isHovering);\n  setAttribute(el, \"data-hover\", isHovering);\n}\n\nexport { $keyboard, FocusVisibleController };\n","import { isArray, isUndefined, isNumber } from './vidstack-DVpy0IqK.js';\n\nclass TimeRange {\n  #ranges;\n  get length() {\n    return this.#ranges.length;\n  }\n  constructor(start, end) {\n    if (isArray(start)) {\n      this.#ranges = start;\n    } else if (!isUndefined(start) && !isUndefined(end)) {\n      this.#ranges = [[start, end]];\n    } else {\n      this.#ranges = [];\n    }\n  }\n  start(index) {\n    throwIfEmpty(this.#ranges.length);\n    throwIfOutOfRange(\"start\", index, this.#ranges.length - 1);\n    return this.#ranges[index][0] ?? Infinity;\n  }\n  end(index) {\n    throwIfEmpty(this.#ranges.length);\n    throwIfOutOfRange(\"end\", index, this.#ranges.length - 1);\n    return this.#ranges[index][1] ?? Infinity;\n  }\n}\nfunction getTimeRangesStart(range) {\n  if (!range.length) return null;\n  let min = range.start(0);\n  for (let i = 1; i < range.length; i++) {\n    const value = range.start(i);\n    if (value < min) min = value;\n  }\n  return min;\n}\nfunction getTimeRangesEnd(range) {\n  if (!range.length) return null;\n  let max = range.end(0);\n  for (let i = 1; i < range.length; i++) {\n    const value = range.end(i);\n    if (value > max) max = value;\n  }\n  return max;\n}\nfunction throwIfEmpty(length) {\n  if (!length) throw new Error(\"`TimeRanges` object is empty.\" );\n}\nfunction throwIfOutOfRange(fnName, index, end) {\n  if (!isNumber(index) || index < 0 || index > end) {\n    throw new Error(\n      `Failed to execute '${fnName}' on 'TimeRanges': The index provided (${index}) is non-numeric or out of bounds (0-${end}).`\n    );\n  }\n}\nfunction normalizeTimeIntervals(intervals) {\n  if (intervals.length <= 1) {\n    return intervals;\n  }\n  intervals.sort((a, b) => a[0] - b[0]);\n  let normalized = [], current = intervals[0];\n  for (let i = 1; i < intervals.length; i++) {\n    const next = intervals[i];\n    if (current[1] >= next[0] - 1) {\n      current = [current[0], Math.max(current[1], next[1])];\n    } else {\n      normalized.push(current);\n      current = next;\n    }\n  }\n  normalized.push(current);\n  return normalized;\n}\nfunction updateTimeIntervals(intervals, interval, value) {\n  let start = interval[0], end = interval[1];\n  if (value < start) {\n    return [value, -1];\n  } else if (value === start) {\n    return interval;\n  } else if (start === -1) {\n    interval[0] = value;\n    return interval;\n  } else if (value > start) {\n    interval[1] = value;\n    if (end === -1) intervals.push(interval);\n  }\n  normalizeTimeIntervals(intervals);\n  return interval;\n}\n\nexport { TimeRange, getTimeRangesEnd, getTimeRangesStart, normalizeTimeIntervals, updateTimeIntervals };\n","function sortVideoQualities(qualities, desc) {\n  return [...qualities].sort(desc ? compareVideoQualityDesc : compareVideoQualityAsc);\n}\nfunction compareVideoQualityAsc(a, b) {\n  return a.height === b.height ? (a.bitrate ?? 0) - (b.bitrate ?? 0) : a.height - b.height;\n}\nfunction compareVideoQualityDesc(a, b) {\n  return b.height === a.height ? (b.bitrate ?? 0) - (a.bitrate ?? 0) : b.height - a.height;\n}\n\nfunction ariaBool(value) {\n  return value ? \"true\" : \"false\";\n}\nfunction $ariaBool(signal) {\n  return () => ariaBool(signal());\n}\n\nexport { $ariaBool, sortVideoQualities };\n","import { isNull, isBoolean, isString, deferredPromise } from './vidstack-DVpy0IqK.js';\nimport { isAudioSrc, isVideoSrc } from './vidstack-CrZuJYaH.js';\n\nfunction appendParamsToURL(baseUrl, params) {\n  const searchParams = new URLSearchParams();\n  for (const key of Object.keys(params)) {\n    searchParams.set(key, params[key] + \"\");\n  }\n  return baseUrl + \"?\" + searchParams.toString();\n}\nfunction preconnect(url, rel = \"preconnect\") {\n  const exists = document.querySelector(`link[href=\"${url}\"]`);\n  if (!isNull(exists)) return true;\n  const link = document.createElement(\"link\");\n  link.rel = rel;\n  link.href = url;\n  link.crossOrigin = \"true\";\n  document.head.append(link);\n  return true;\n}\nconst pendingRequests = {};\nfunction loadScript(src) {\n  if (pendingRequests[src]) return pendingRequests[src].promise;\n  const promise = deferredPromise(), exists = document.querySelector(`script[src=\"${src}\"]`);\n  if (!isNull(exists)) {\n    promise.resolve();\n    return promise.promise;\n  }\n  const script = document.createElement(\"script\");\n  script.src = src;\n  script.onload = () => {\n    promise.resolve();\n    delete pendingRequests[src];\n  };\n  script.onerror = () => {\n    promise.reject();\n    delete pendingRequests[src];\n  };\n  setTimeout(() => document.head.append(script), 0);\n  return promise.promise;\n}\nfunction getRequestCredentials(crossOrigin) {\n  return crossOrigin === \"use-credentials\" ? \"include\" : isString(crossOrigin) ? \"same-origin\" : void 0;\n}\nfunction getDownloadFile({\n  title,\n  src,\n  download\n}) {\n  const url = isBoolean(download) || download === \"\" ? src.src : isString(download) ? download : download?.url;\n  if (!isValidFileDownload({ url, src, download })) return null;\n  return {\n    url,\n    name: !isBoolean(download) && !isString(download) && download?.filename || title.toLowerCase() || \"media\"\n  };\n}\nfunction isValidFileDownload({\n  url,\n  src,\n  download\n}) {\n  return isString(url) && (download && download !== true || isAudioSrc(src) || isVideoSrc(src));\n}\n\nexport { appendParamsToURL, getDownloadFile, getRequestCredentials, loadScript, preconnect };\n","const SET_AUTO = Symbol(\"SET_AUTO_QUALITY\" ), ENABLE_AUTO = Symbol(\"ENABLE_AUTO_QUALITY\" );\nconst QualitySymbol = {\n  setAuto: SET_AUTO,\n  enableAuto: ENABLE_AUTO\n};\n\nexport { QualitySymbol };\n","import { Host, effect, setAttribute } from './vidstack-DVpy0IqK.js';\nimport { Poster } from './vidstack-DB2Hlarx.js';\nimport './vidstack-CUYciP40.js';\nimport './vidstack-BgIVvpNy.js';\nimport './vidstack-CrZuJYaH.js';\n\nclass MediaPosterElement extends Host(HTMLElement, Poster) {\n  static tagName = \"media-poster\";\n  static attrs = {\n    crossOrigin: \"crossorigin\"\n  };\n  #img = document.createElement(\"img\");\n  onSetup() {\n    this.$state.img.set(this.#img);\n  }\n  onConnect() {\n    const { src, alt, crossOrigin } = this.$state;\n    effect(() => {\n      const { loading, hidden } = this.$state;\n      this.#img.style.display = loading() || hidden() ? \"none\" : \"\";\n    });\n    effect(() => {\n      setAttribute(this.#img, \"alt\", alt());\n      setAttribute(this.#img, \"crossorigin\", crossOrigin());\n      setAttribute(this.#img, \"src\", src());\n    });\n    if (this.#img.parentNode !== this) {\n      this.prepend(this.#img);\n    }\n  }\n}\n\nexport { MediaPosterElement };\n","import { getScope, listenEvent, scoped, isString } from './vidstack-DVpy0IqK.js';\n\nfunction findActiveCue(cues, time) {\n  for (let i = 0, len = cues.length; i < len; i++) {\n    if (isCueActive(cues[i], time)) return cues[i];\n  }\n  return null;\n}\nfunction isCueActive(cue, time) {\n  return time >= cue.startTime && time < cue.endTime;\n}\nfunction watchActiveTextTrack(tracks, kind, onChange) {\n  let currentTrack = null, scope = getScope();\n  function onModeChange() {\n    const kinds = isString(kind) ? [kind] : kind, track = tracks.toArray().find((track2) => kinds.includes(track2.kind) && track2.mode === \"showing\");\n    if (track === currentTrack) return;\n    if (!track) {\n      onChange(null);\n      currentTrack = null;\n      return;\n    }\n    if (track.readyState == 2) {\n      onChange(track);\n    } else {\n      onChange(null);\n      scoped(() => {\n        const off = listenEvent(\n          track,\n          \"load\",\n          () => {\n            onChange(track);\n            off();\n          },\n          { once: true }\n        );\n      }, scope);\n    }\n    currentTrack = track;\n  }\n  onModeChange();\n  return listenEvent(tracks, \"mode-change\", onModeChange);\n}\nfunction watchCueTextChange(tracks, kind, callback) {\n  watchActiveTextTrack(tracks, kind, (track) => {\n    if (!track) {\n      callback(\"\");\n      return;\n    }\n    const onCueChange = () => {\n      const activeCue = track?.activeCues[0];\n      callback(activeCue?.text || \"\");\n    };\n    onCueChange();\n    listenEvent(track, \"cue-change\", onCueChange);\n  });\n}\n\nexport { findActiveCue, isCueActive, watchActiveTextTrack, watchCueTextChange };\n","import { autoUpdate, computePosition, flip, shift } from '@floating-ui/dom';\nimport { getScope, scoped, onDispose, isDOMNode, isFunction, setAttribute, effect, EventsController, isKeyboardClick, isTouchEvent, setStyle, toggleClass, signal, listenEvent, animationFrameThrottle, computed } from './vidstack-DVpy0IqK.js';\n\nfunction isEventInside(el, event) {\n  const target = event.composedPath()[0];\n  return isDOMNode(target) && el.contains(target);\n}\nconst rafJobs = /* @__PURE__ */ new Set();\n{\n  let processJobs = function() {\n    for (const job of rafJobs) {\n      try {\n        job();\n      } catch (e) {\n        console.error(`[vidstack] failed job:\n\n${e}`);\n      }\n    }\n    window.requestAnimationFrame(processJobs);\n  };\n  processJobs();\n}\nfunction scheduleRafJob(job) {\n  rafJobs.add(job);\n  return () => rafJobs.delete(job);\n}\nfunction setAttributeIfEmpty(target, name, value) {\n  if (!target.hasAttribute(name)) target.setAttribute(name, value);\n}\nfunction setARIALabel(target, $label) {\n  if (target.hasAttribute(\"aria-label\") || target.hasAttribute(\"data-no-label\")) return;\n  if (!isFunction($label)) {\n    setAttribute(target, \"aria-label\", $label);\n    return;\n  }\n  function updateAriaDescription() {\n    setAttribute(target, \"aria-label\", $label());\n  }\n  effect(updateAriaDescription);\n}\nfunction isElementVisible(el) {\n  const style = getComputedStyle(el);\n  return style.display !== \"none\" && parseInt(style.opacity) > 0;\n}\nfunction checkVisibility(el) {\n  return !!el && (\"checkVisibility\" in el ? el.checkVisibility({ checkOpacity: true, checkVisibilityCSS: true }) : isElementVisible(el));\n}\nfunction observeVisibility(el, callback) {\n  return scheduleRafJob(() => callback(checkVisibility(el)));\n}\nfunction isElementParent(owner, node, test) {\n  while (node) {\n    if (node === owner) {\n      return true;\n    } else if (test?.(node)) {\n      break;\n    } else {\n      node = node.parentElement;\n    }\n  }\n  return false;\n}\nfunction onPress(target, handler) {\n  return new EventsController(target).add(\"pointerup\", (event) => {\n    if (event.button === 0 && !event.defaultPrevented) handler(event);\n  }).add(\"keydown\", (event) => {\n    if (isKeyboardClick(event)) handler(event);\n  });\n}\nfunction isTouchPinchEvent(event) {\n  return isTouchEvent(event) && (event.touches.length > 1 || event.changedTouches.length > 1);\n}\nfunction requestScopedAnimationFrame(callback) {\n  let scope = getScope(), id = window.requestAnimationFrame(() => {\n    scoped(callback, scope);\n    id = -1;\n  });\n  return () => void window.cancelAnimationFrame(id);\n}\nfunction cloneTemplate(template, length, onCreate) {\n  let current, prev = template, parent = template.parentElement, content = template.content.firstElementChild, elements = [];\n  if (!content && template.firstElementChild) {\n    template.innerHTML = template.firstElementChild.outerHTML;\n    template.firstElementChild.remove();\n    content = template.content.firstElementChild;\n  }\n  if (content?.nodeType !== 1) {\n    throw Error(\"[vidstack] template must contain root element\");\n  }\n  for (let i = 0; i < length; i++) {\n    current = document.importNode(content, true);\n    onCreate?.(current, i);\n    parent.insertBefore(current, prev.nextSibling);\n    elements.push(current);\n    prev = current;\n  }\n  onDispose(() => {\n    for (let i = 0; i < elements.length; i++) elements[i].remove();\n  });\n  return elements;\n}\nfunction createTemplate(content) {\n  const template = document.createElement(\"template\");\n  template.innerHTML = content;\n  return template.content;\n}\nfunction cloneTemplateContent(content) {\n  const fragment = content.cloneNode(true);\n  return fragment.firstElementChild;\n}\nfunction autoPlacement(el, trigger, placement, {\n  offsetVarName,\n  xOffset,\n  yOffset,\n  ...options\n}) {\n  if (!el) return;\n  const floatingPlacement = placement.replace(\" \", \"-\").replace(\"-center\", \"\");\n  setStyle(el, \"visibility\", !trigger ? \"hidden\" : null);\n  if (!trigger) return;\n  let isTop = placement.includes(\"top\");\n  const negateX = (x) => placement.includes(\"left\") ? `calc(-1 * ${x})` : x, negateY = (y) => isTop ? `calc(-1 * ${y})` : y;\n  return autoUpdate(trigger, el, () => {\n    computePosition(trigger, el, {\n      placement: floatingPlacement,\n      middleware: [\n        ...options.middleware ?? [],\n        flip({ fallbackAxisSideDirection: \"start\", crossAxis: false }),\n        shift()\n      ],\n      ...options\n    }).then(({ x, y, middlewareData }) => {\n      const hasFlipped = !!middlewareData.flip?.index;\n      isTop = placement.includes(hasFlipped ? \"bottom\" : \"top\");\n      el.setAttribute(\n        \"data-placement\",\n        hasFlipped ? placement.startsWith(\"top\") ? placement.replace(\"top\", \"bottom\") : placement.replace(\"bottom\", \"top\") : placement\n      );\n      Object.assign(el.style, {\n        top: `calc(${y + \"px\"} + ${negateY(\n          yOffset ? yOffset + \"px\" : `var(--${offsetVarName}-y-offset, 0px)`\n        )})`,\n        left: `calc(${x + \"px\"} + ${negateX(\n          xOffset ? xOffset + \"px\" : `var(--${offsetVarName}-x-offset, 0px)`\n        )})`\n      });\n    });\n  });\n}\nfunction hasAnimation(el) {\n  const styles = getComputedStyle(el);\n  return styles.animationName !== \"none\";\n}\nfunction createSlot(name) {\n  const slot = document.createElement(\"slot\");\n  slot.name = name;\n  return slot;\n}\nfunction useTransitionActive($el) {\n  const $active = signal(false);\n  effect(() => {\n    const el = $el();\n    if (!el) return;\n    new EventsController(el).add(\"transitionstart\", () => $active.set(true)).add(\"transitionend\", () => $active.set(false));\n  });\n  return $active;\n}\nfunction useResizeObserver($el, onResize) {\n  function onElementChange() {\n    const el = $el();\n    if (!el) return;\n    onResize();\n    const observer = new ResizeObserver(animationFrameThrottle(onResize));\n    observer.observe(el);\n    return () => observer.disconnect();\n  }\n  effect(onElementChange);\n}\nfunction useActive($el) {\n  const $isMouseEnter = useMouseEnter($el), $isFocusedIn = useFocusIn($el);\n  let prevMouseEnter = false;\n  return computed(() => {\n    const isMouseEnter = $isMouseEnter();\n    if (prevMouseEnter && !isMouseEnter) return false;\n    prevMouseEnter = isMouseEnter;\n    return isMouseEnter || $isFocusedIn();\n  });\n}\nfunction useMouseEnter($el) {\n  const $isMouseEnter = signal(false);\n  effect(() => {\n    const el = $el();\n    if (!el) {\n      $isMouseEnter.set(false);\n      return;\n    }\n    new EventsController(el).add(\"mouseenter\", () => $isMouseEnter.set(true)).add(\"mouseleave\", () => $isMouseEnter.set(false));\n  });\n  return $isMouseEnter;\n}\nfunction useFocusIn($el) {\n  const $isFocusIn = signal(false);\n  effect(() => {\n    const el = $el();\n    if (!el) {\n      $isFocusIn.set(false);\n      return;\n    }\n    new EventsController(el).add(\"focusin\", () => $isFocusIn.set(true)).add(\"focusout\", () => $isFocusIn.set(false));\n  });\n  return $isFocusIn;\n}\nfunction isHTMLElement(el) {\n  return el instanceof HTMLElement;\n}\nfunction useColorSchemePreference() {\n  const colorScheme = signal(\"dark\");\n  const media = window.matchMedia(\"(prefers-color-scheme: light)\");\n  function onChange() {\n    colorScheme.set(media.matches ? \"light\" : \"dark\");\n  }\n  onChange();\n  listenEvent(media, \"change\", onChange);\n  return colorScheme;\n}\nfunction watchColorScheme(el, colorScheme) {\n  effect(() => {\n    const scheme = colorScheme();\n    if (scheme === \"system\") {\n      const preference = useColorSchemePreference();\n      effect(() => updateColorScheme(preference()));\n      return;\n    }\n    updateColorScheme(scheme);\n  });\n  function updateColorScheme(scheme) {\n    toggleClass(el, \"light\", scheme === \"light\");\n    toggleClass(el, \"dark\", scheme === \"dark\");\n  }\n}\n\nexport { autoPlacement, cloneTemplate, cloneTemplateContent, createSlot, createTemplate, hasAnimation, isElementParent, isElementVisible, isEventInside, isHTMLElement, isTouchPinchEvent, observeVisibility, onPress, requestScopedAnimationFrame, setARIALabel, setAttributeIfEmpty, useActive, useResizeObserver, useTransitionActive, watchColorScheme };\n","import { Component, State, effect, tick, peek, setAttribute, isString, setStyle, createContext, signal, EventsController, provideContext, listenEvent, onDispose, useContext, prop, useState, isNull, functionThrottle, computed, method, scoped, createScope, animationFrameThrottle, functionDebounce, hasProvidedContext, isNumber, isPointerEvent, isTouchEvent, isMouseEvent, DOMEvent, kebabToCamelCase } from './vidstack-DVpy0IqK.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\nimport { setAttributeIfEmpty, requestScopedAnimationFrame, autoPlacement, setARIALabel, onPress, isTouchPinchEvent } from './vidstack-CGUlKgT8.js';\nimport { formatSpokenTime, Popper, ToggleButtonController, Slider, SliderController, sliderState, sliderValueFormatContext, TimeSlider, RadioGroupController, menuContext, radioControllerContext, formatTime } from './vidstack-CWb-Pl1C.js';\nimport { FocusVisibleController, $keyboard } from './vidstack-9MhB-Ya7.js';\nimport { $ariaBool, sortVideoQualities } from './vidstack-BOTZD4tC.js';\nimport { round } from './vidstack-Dihypf8P.js';\nimport { watchActiveTextTrack, isCueActive } from './vidstack-C1THCRTj.js';\nimport { isTrackCaptionKind } from './vidstack-DghpoXbA.js';\n\nclass MediaAnnouncer extends Component {\n  static props = {\n    translations: null\n  };\n  static state = new State({\n    label: null,\n    busy: false\n  });\n  #media;\n  #initializing = false;\n  onSetup() {\n    this.#media = useMediaContext();\n  }\n  onAttach(el) {\n    el.style.display = \"contents\";\n  }\n  onConnect(el) {\n    el.setAttribute(\"data-media-announcer\", \"\");\n    setAttributeIfEmpty(el, \"role\", \"status\");\n    setAttributeIfEmpty(el, \"aria-live\", \"polite\");\n    const { busy } = this.$state;\n    this.setAttributes({\n      \"aria-busy\": () => busy() ? \"true\" : null\n    });\n    this.#initializing = true;\n    effect(this.#watchPaused.bind(this));\n    effect(this.#watchVolume.bind(this));\n    effect(this.#watchCaptions.bind(this));\n    effect(this.#watchFullscreen.bind(this));\n    effect(this.#watchPiP.bind(this));\n    effect(this.#watchSeeking.bind(this));\n    effect(this.#watchLabel.bind(this));\n    tick();\n    this.#initializing = false;\n  }\n  #watchPaused() {\n    const { paused } = this.#media.$state;\n    this.#setLabel(!paused() ? \"Play\" : \"Pause\");\n  }\n  #watchFullscreen() {\n    const { fullscreen } = this.#media.$state;\n    this.#setLabel(fullscreen() ? \"Enter Fullscreen\" : \"Exit Fullscreen\");\n  }\n  #watchPiP() {\n    const { pictureInPicture } = this.#media.$state;\n    this.#setLabel(pictureInPicture() ? \"Enter PiP\" : \"Exit PiP\");\n  }\n  #watchCaptions() {\n    const { textTrack } = this.#media.$state;\n    this.#setLabel(textTrack() ? \"Closed-Captions On\" : \"Closed-Captions Off\");\n  }\n  #watchVolume() {\n    const { muted, volume, audioGain } = this.#media.$state;\n    this.#setLabel(\n      muted() || volume() === 0 ? \"Mute\" : `${Math.round(volume() * (audioGain() ?? 1) * 100)}% ${this.#translate(\"Volume\")}`\n    );\n  }\n  #startedSeekingAt = -1;\n  #seekTimer = -1;\n  #watchSeeking() {\n    const { seeking, currentTime } = this.#media.$state, isSeeking = seeking();\n    if (this.#startedSeekingAt > 0) {\n      window.clearTimeout(this.#seekTimer);\n      this.#seekTimer = window.setTimeout(() => {\n        if (!this.scope) return;\n        const newTime = peek(currentTime), seconds = Math.abs(newTime - this.#startedSeekingAt);\n        if (seconds >= 1) {\n          const isForward = newTime >= this.#startedSeekingAt, spokenTime = formatSpokenTime(seconds);\n          this.#setLabel(\n            `${this.#translate(isForward ? \"Seek Forward\" : \"Seek Backward\")} ${spokenTime}`\n          );\n        }\n        this.#startedSeekingAt = -1;\n        this.#seekTimer = -1;\n      }, 300);\n    } else if (isSeeking) {\n      this.#startedSeekingAt = peek(currentTime);\n    }\n  }\n  #translate(word) {\n    const { translations } = this.$props;\n    return translations?.()?.[word || \"\"] ?? word;\n  }\n  #watchLabel() {\n    const { label, busy } = this.$state, $label = this.#translate(label());\n    if (this.#initializing) return;\n    busy.set(true);\n    const id = window.setTimeout(() => void busy.set(false), 150);\n    this.el && setAttribute(this.el, \"aria-label\", $label);\n    if (isString($label)) {\n      this.dispatch(\"change\", { detail: $label });\n    }\n    return () => window.clearTimeout(id);\n  }\n  #setLabel(word) {\n    const { label } = this.$state;\n    label.set(word);\n  }\n}\n\nclass Controls extends Component {\n  static props = {\n    hideDelay: 2e3,\n    hideOnMouseLeave: false\n  };\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n    effect(this.#watchProps.bind(this));\n  }\n  onAttach(el) {\n    const { pictureInPicture, fullscreen } = this.#media.$state;\n    setStyle(el, \"pointer-events\", \"none\");\n    setAttributeIfEmpty(el, \"role\", \"group\");\n    this.setAttributes({\n      \"data-visible\": this.#isShowing.bind(this),\n      \"data-fullscreen\": fullscreen,\n      \"data-pip\": pictureInPicture\n    });\n    effect(() => {\n      this.dispatch(\"change\", { detail: this.#isShowing() });\n    });\n    effect(this.#hideControls.bind(this));\n    effect(() => {\n      const isFullscreen = fullscreen();\n      for (const side of [\"top\", \"right\", \"bottom\", \"left\"]) {\n        setStyle(el, `padding-${side}`, isFullscreen && `env(safe-area-inset-${side})`);\n      }\n    });\n  }\n  #hideControls() {\n    if (!this.el) return;\n    const { nativeControls } = this.#media.$state, isHidden = nativeControls();\n    setAttribute(this.el, \"aria-hidden\", isHidden ? \"true\" : null);\n    setStyle(this.el, \"display\", isHidden ? \"none\" : null);\n  }\n  #watchProps() {\n    const { controls } = this.#media.player, { hideDelay, hideOnMouseLeave } = this.$props;\n    controls.defaultDelay = hideDelay() === 2e3 ? this.#media.$props.controlsDelay() : hideDelay();\n    controls.hideOnMouseLeave = hideOnMouseLeave();\n  }\n  #isShowing() {\n    const { controlsVisible } = this.#media.$state;\n    return controlsVisible();\n  }\n}\n\nclass ControlsGroup extends Component {\n  onAttach(el) {\n    if (!el.style.pointerEvents) setStyle(el, \"pointer-events\", \"auto\");\n  }\n}\n\nconst tooltipContext = createContext();\n\nlet id = 0;\nclass Tooltip extends Component {\n  static props = {\n    showDelay: 700\n  };\n  #id = `media-tooltip-${++id}`;\n  #trigger = signal(null);\n  #content = signal(null);\n  #showing = signal(false);\n  constructor() {\n    super();\n    new FocusVisibleController();\n    const { showDelay } = this.$props;\n    new Popper({\n      trigger: this.#trigger,\n      content: this.#content,\n      showDelay,\n      listen(trigger, show, hide) {\n        effect(() => {\n          if ($keyboard()) listenEvent(trigger, \"focus\", show);\n          listenEvent(trigger, \"blur\", hide);\n        });\n        new EventsController(trigger).add(\"touchstart\", (e) => e.preventDefault(), { passive: false }).add(\"mouseenter\", show).add(\"mouseleave\", hide);\n      },\n      onChange: this.#onShowingChange.bind(this)\n    });\n  }\n  onAttach(el) {\n    el.style.setProperty(\"display\", \"contents\");\n  }\n  onSetup() {\n    provideContext(tooltipContext, {\n      trigger: this.#trigger,\n      content: this.#content,\n      showing: this.#showing,\n      attachTrigger: this.#attachTrigger.bind(this),\n      detachTrigger: this.#detachTrigger.bind(this),\n      attachContent: this.#attachContent.bind(this),\n      detachContent: this.#detachContent.bind(this)\n    });\n  }\n  #attachTrigger(el) {\n    this.#trigger.set(el);\n    let tooltipName = el.getAttribute(\"data-media-tooltip\");\n    if (tooltipName) {\n      this.el?.setAttribute(`data-media-${tooltipName}-tooltip`, \"\");\n    }\n    setAttribute(el, \"data-describedby\", this.#id);\n  }\n  #detachTrigger(el) {\n    el.removeAttribute(\"data-describedby\");\n    el.removeAttribute(\"aria-describedby\");\n    this.#trigger.set(null);\n  }\n  #attachContent(el) {\n    el.setAttribute(\"id\", this.#id);\n    el.style.display = \"none\";\n    setAttributeIfEmpty(el, \"role\", \"tooltip\");\n    this.#content.set(el);\n  }\n  #detachContent(el) {\n    el.removeAttribute(\"id\");\n    el.removeAttribute(\"role\");\n    this.#content.set(null);\n  }\n  #onShowingChange(isShowing) {\n    const trigger = this.#trigger(), content = this.#content();\n    if (trigger) {\n      setAttribute(trigger, \"aria-describedby\", isShowing ? this.#id : null);\n    }\n    for (const el of [this.el, trigger, content]) {\n      el && setAttribute(el, \"data-visible\", isShowing);\n    }\n    this.#showing.set(isShowing);\n  }\n}\n\nclass TooltipTrigger extends Component {\n  constructor() {\n    super();\n    new FocusVisibleController();\n  }\n  onConnect(el) {\n    onDispose(\n      requestScopedAnimationFrame(() => {\n        if (!this.connectScope) return;\n        this.#attach();\n        const tooltip = useContext(tooltipContext);\n        onDispose(() => {\n          const button = this.#getButton();\n          button && tooltip.detachTrigger(button);\n        });\n      })\n    );\n  }\n  #attach() {\n    const button = this.#getButton(), tooltip = useContext(tooltipContext);\n    button && tooltip.attachTrigger(button);\n  }\n  #getButton() {\n    const candidate = this.el.firstElementChild;\n    return candidate?.localName === \"button\" || candidate?.getAttribute(\"role\") === \"button\" ? candidate : this.el;\n  }\n}\n\nclass TooltipContent extends Component {\n  static props = {\n    placement: \"top center\",\n    offset: 0,\n    alignOffset: 0\n  };\n  constructor() {\n    super();\n    new FocusVisibleController();\n    const { placement } = this.$props;\n    this.setAttributes({\n      \"data-placement\": placement\n    });\n  }\n  onAttach(el) {\n    this.#attach(el);\n    Object.assign(el.style, {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: \"max-content\"\n    });\n  }\n  onConnect(el) {\n    this.#attach(el);\n    const tooltip = useContext(tooltipContext);\n    onDispose(() => tooltip.detachContent(el));\n    onDispose(\n      requestScopedAnimationFrame(() => {\n        if (!this.connectScope) return;\n        effect(this.#watchPlacement.bind(this));\n      })\n    );\n  }\n  #attach(el) {\n    const tooltip = useContext(tooltipContext);\n    tooltip.attachContent(el);\n  }\n  #watchPlacement() {\n    const { showing } = useContext(tooltipContext);\n    if (!showing()) return;\n    const { placement, offset: mainOffset, alignOffset } = this.$props;\n    return autoPlacement(this.el, this.#getTrigger(), placement(), {\n      offsetVarName: \"media-tooltip\",\n      xOffset: alignOffset(),\n      yOffset: mainOffset()\n    });\n  }\n  #getTrigger() {\n    return useContext(tooltipContext).trigger();\n  }\n}\n\nclass ToggleButton extends Component {\n  static props = {\n    disabled: false,\n    defaultPressed: false\n  };\n  #pressed = signal(false);\n  /**\n   * Whether the toggle is currently in a `pressed` state.\n   */\n  get pressed() {\n    return this.#pressed();\n  }\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#pressed\n    });\n  }\n}\nconst togglebutton__proto = ToggleButton.prototype;\nprop(togglebutton__proto, \"pressed\");\n\nclass GoogleCastButton extends Component {\n  static props = ToggleButtonController.props;\n  #media;\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#isPressed.bind(this),\n      onPress: this.#onPress.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const { canGoogleCast, isGoogleCastConnected } = this.#media.$state;\n    this.setAttributes({\n      \"data-active\": isGoogleCastConnected,\n      \"data-supported\": canGoogleCast,\n      \"data-state\": this.#getState.bind(this),\n      \"aria-hidden\": $ariaBool(() => !canGoogleCast())\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-tooltip\", \"google-cast\");\n    setARIALabel(el, this.#getDefaultLabel.bind(this));\n  }\n  #onPress(event) {\n    const remote = this.#media.remote;\n    remote.requestGoogleCast(event);\n  }\n  #isPressed() {\n    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;\n    return remotePlaybackType() === \"google-cast\" && remotePlaybackState() !== \"disconnected\";\n  }\n  #getState() {\n    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;\n    return remotePlaybackType() === \"google-cast\" && remotePlaybackState();\n  }\n  #getDefaultLabel() {\n    const { remotePlaybackState } = this.#media.$state;\n    return `Google Cast ${remotePlaybackState()}`;\n  }\n}\n\nclass SliderVideo extends Component {\n  static props = {\n    src: null,\n    crossOrigin: null\n  };\n  static state = new State({\n    video: null,\n    src: null,\n    crossOrigin: null,\n    canPlay: false,\n    error: null,\n    hidden: false\n  });\n  #media;\n  #slider;\n  get video() {\n    return this.$state.video();\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    this.#slider = useState(Slider.state);\n    this.#watchCrossOrigin();\n    this.setAttributes({\n      \"data-loading\": this.#isLoading.bind(this),\n      \"data-hidden\": this.$state.hidden,\n      \"data-error\": this.#hasError.bind(this),\n      \"aria-hidden\": $ariaBool(this.$state.hidden)\n    });\n  }\n  onAttach(el) {\n    effect(this.#watchVideo.bind(this));\n    effect(this.#watchSrc.bind(this));\n    effect(this.#watchCrossOrigin.bind(this));\n    effect(this.#watchHidden.bind(this));\n    effect(this.#onSrcChange.bind(this));\n    effect(this.#onUpdateTime.bind(this));\n  }\n  #watchVideo() {\n    const video = this.$state.video();\n    if (!video) return;\n    if (video.readyState >= 2) this.#onCanPlay();\n    new EventsController(video).add(\"canplay\", this.#onCanPlay.bind(this)).add(\"error\", this.#onError.bind(this));\n  }\n  #watchSrc() {\n    const { src } = this.$state, { canLoad } = this.#media.$state;\n    src.set(canLoad() ? this.$props.src() : null);\n  }\n  #watchCrossOrigin() {\n    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();\n    crossOriginState.set(crossOrigin === true ? \"anonymous\" : crossOrigin);\n  }\n  #isLoading() {\n    const { canPlay, hidden } = this.$state;\n    return !canPlay() && !hidden();\n  }\n  #hasError() {\n    const { error } = this.$state;\n    return !isNull(error);\n  }\n  #watchHidden() {\n    const { src, hidden } = this.$state, { canLoad, duration } = this.#media.$state;\n    hidden.set(canLoad() && (!src() || this.#hasError() || !Number.isFinite(duration())));\n  }\n  #onSrcChange() {\n    const { src, canPlay, error } = this.$state;\n    src();\n    canPlay.set(false);\n    error.set(null);\n  }\n  #onCanPlay(event) {\n    const { canPlay, error } = this.$state;\n    canPlay.set(true);\n    error.set(null);\n    this.dispatch(\"can-play\", { trigger: event });\n  }\n  #onError(event) {\n    const { canPlay, error } = this.$state;\n    canPlay.set(false);\n    error.set(event);\n    this.dispatch(\"error\", { trigger: event });\n  }\n  #onUpdateTime() {\n    const { video, canPlay } = this.$state, { duration } = this.#media.$state, { pointerRate } = this.#slider, media = video(), canUpdate = canPlay() && media && Number.isFinite(duration()) && Number.isFinite(pointerRate());\n    if (canUpdate) {\n      media.currentTime = pointerRate() * duration();\n    }\n  }\n}\nconst slidervideo__proto = SliderVideo.prototype;\nprop(slidervideo__proto, \"video\");\n\nclass AudioGainSlider extends Component {\n  static props = {\n    ...SliderController.props,\n    step: 25,\n    keyStep: 25,\n    shiftKeyMultiplier: 2,\n    min: 0,\n    max: 300\n  };\n  static state = sliderState;\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n    provideContext(sliderValueFormatContext, {\n      default: \"percent\",\n      percent: (_, decimalPlaces) => {\n        return round(this.$state.value(), decimalPlaces) + \"%\";\n      }\n    });\n    new SliderController({\n      getStep: this.$props.step,\n      getKeyStep: this.$props.keyStep,\n      roundValue: Math.round,\n      isDisabled: this.#isDisabled.bind(this),\n      aria: {\n        valueNow: this.#getARIAValueNow.bind(this),\n        valueText: this.#getARIAValueText.bind(this)\n      },\n      onDragValueChange: this.#onDragValueChange.bind(this),\n      onValueChange: this.#onValueChange.bind(this)\n    }).attach(this);\n    effect(this.#watchMinMax.bind(this));\n    effect(this.#watchAudioGain.bind(this));\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-audio-gain-slider\", \"\");\n    setAttributeIfEmpty(el, \"aria-label\", \"Audio Boost\");\n    const { canSetAudioGain } = this.#media.$state;\n    this.setAttributes({\n      \"data-supported\": canSetAudioGain,\n      \"aria-hidden\": $ariaBool(() => !canSetAudioGain())\n    });\n  }\n  #getARIAValueNow() {\n    const { value } = this.$state;\n    return Math.round(value());\n  }\n  #getARIAValueText() {\n    const { value } = this.$state;\n    return value() + \"%\";\n  }\n  #watchMinMax() {\n    const { min, max } = this.$props;\n    this.$state.min.set(min());\n    this.$state.max.set(max());\n  }\n  #watchAudioGain() {\n    const { audioGain } = this.#media.$state, value = ((audioGain() ?? 1) - 1) * 100;\n    this.$state.value.set(value);\n    this.dispatch(\"value-change\", { detail: value });\n  }\n  #isDisabled() {\n    const { disabled } = this.$props, { canSetAudioGain } = this.#media.$state;\n    return disabled() || !canSetAudioGain();\n  }\n  #onAudioGainChange(event) {\n    if (!event.trigger) return;\n    const gain = round(1 + event.detail / 100, 2);\n    this.#media.remote.changeAudioGain(gain, event);\n  }\n  #onValueChange(event) {\n    this.#onAudioGainChange(event);\n  }\n  #onDragValueChange(event) {\n    this.#onAudioGainChange(event);\n  }\n}\n\nclass SpeedSlider extends Component {\n  static props = {\n    ...SliderController.props,\n    step: 0.25,\n    keyStep: 0.25,\n    shiftKeyMultiplier: 2,\n    min: 0,\n    max: 2\n  };\n  static state = sliderState;\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n    new SliderController({\n      getStep: this.$props.step,\n      getKeyStep: this.$props.keyStep,\n      roundValue: this.#roundValue,\n      isDisabled: this.#isDisabled.bind(this),\n      aria: {\n        valueNow: this.#getARIAValueNow.bind(this),\n        valueText: this.#getARIAValueText.bind(this)\n      },\n      onDragValueChange: this.#onDragValueChange.bind(this),\n      onValueChange: this.#onValueChange.bind(this)\n    }).attach(this);\n    effect(this.#watchMinMax.bind(this));\n    effect(this.#watchPlaybackRate.bind(this));\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-speed-slider\", \"\");\n    setAttributeIfEmpty(el, \"aria-label\", \"Speed\");\n    const { canSetPlaybackRate } = this.#media.$state;\n    this.setAttributes({\n      \"data-supported\": canSetPlaybackRate,\n      \"aria-hidden\": $ariaBool(() => !canSetPlaybackRate())\n    });\n  }\n  #getARIAValueNow() {\n    const { value } = this.$state;\n    return value();\n  }\n  #getARIAValueText() {\n    const { value } = this.$state;\n    return value() + \"x\";\n  }\n  #watchMinMax() {\n    const { min, max } = this.$props;\n    this.$state.min.set(min());\n    this.$state.max.set(max());\n  }\n  #watchPlaybackRate() {\n    const { playbackRate } = this.#media.$state;\n    const newValue = playbackRate();\n    this.$state.value.set(newValue);\n    this.dispatch(\"value-change\", { detail: newValue });\n  }\n  #roundValue(value) {\n    return round(value, 2);\n  }\n  #isDisabled() {\n    const { disabled } = this.$props, { canSetPlaybackRate } = this.#media.$state;\n    return disabled() || !canSetPlaybackRate();\n  }\n  #throttledSpeedChange = functionThrottle(this.#onPlaybackRateChange.bind(this), 25);\n  #onPlaybackRateChange(event) {\n    if (!event.trigger) return;\n    const rate = event.detail;\n    this.#media.remote.changePlaybackRate(rate, event);\n  }\n  #onValueChange(event) {\n    this.#throttledSpeedChange(event);\n  }\n  #onDragValueChange(event) {\n    this.#throttledSpeedChange(event);\n  }\n}\n\nclass QualitySlider extends Component {\n  static props = {\n    ...SliderController.props,\n    step: 1,\n    keyStep: 1,\n    shiftKeyMultiplier: 1\n  };\n  static state = sliderState;\n  #media;\n  #sortedQualities = computed(() => {\n    const { qualities } = this.#media.$state;\n    return sortVideoQualities(qualities());\n  });\n  onSetup() {\n    this.#media = useMediaContext();\n    new SliderController({\n      getStep: this.$props.step,\n      getKeyStep: this.$props.keyStep,\n      roundValue: Math.round,\n      isDisabled: this.#isDisabled.bind(this),\n      aria: {\n        valueNow: this.#getARIAValueNow.bind(this),\n        valueText: this.#getARIAValueText.bind(this)\n      },\n      onDragValueChange: this.#onDragValueChange.bind(this),\n      onValueChange: this.#onValueChange.bind(this)\n    }).attach(this);\n    effect(this.#watchMax.bind(this));\n    effect(this.#watchQuality.bind(this));\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-quality-slider\", \"\");\n    setAttributeIfEmpty(el, \"aria-label\", \"Video Quality\");\n    const { qualities, canSetQuality } = this.#media.$state, $supported = computed(() => canSetQuality() && qualities().length > 0);\n    this.setAttributes({\n      \"data-supported\": $supported,\n      \"aria-hidden\": $ariaBool(() => !$supported())\n    });\n  }\n  #getARIAValueNow() {\n    const { value } = this.$state;\n    return value();\n  }\n  #getARIAValueText() {\n    const { quality } = this.#media.$state;\n    if (!quality()) return \"\";\n    const { height, bitrate } = quality(), bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null;\n    return height ? `${height}p${bitrateText ? ` (${bitrateText})` : \"\"}` : \"Auto\";\n  }\n  #watchMax() {\n    const $qualities = this.#sortedQualities();\n    this.$state.max.set(Math.max(0, $qualities.length - 1));\n  }\n  #watchQuality() {\n    let { quality } = this.#media.$state, $qualities = this.#sortedQualities(), value = Math.max(0, $qualities.indexOf(quality()));\n    this.$state.value.set(value);\n    this.dispatch(\"value-change\", { detail: value });\n  }\n  #isDisabled() {\n    const { disabled } = this.$props, { canSetQuality, qualities } = this.#media.$state;\n    return disabled() || qualities().length <= 1 || !canSetQuality();\n  }\n  #throttledQualityChange = functionThrottle(this.#onQualityChange.bind(this), 25);\n  #onQualityChange(event) {\n    if (!event.trigger) return;\n    const { qualities } = this.#media, quality = peek(this.#sortedQualities)[event.detail];\n    this.#media.remote.changeQuality(qualities.indexOf(quality), event);\n  }\n  #onValueChange(event) {\n    this.#throttledQualityChange(event);\n  }\n  #onDragValueChange(event) {\n    this.#throttledQualityChange(event);\n  }\n}\n\nclass SliderChapters extends Component {\n  static props = {\n    disabled: false\n  };\n  #media;\n  #sliderState;\n  #updateScope;\n  #titleRef = null;\n  #refs = [];\n  #$track = signal(null);\n  #$cues = signal([]);\n  #activeIndex = signal(-1);\n  #activePointerIndex = signal(-1);\n  #bufferedIndex = 0;\n  get cues() {\n    return this.#$cues();\n  }\n  get activeCue() {\n    return this.#$cues()[this.#activeIndex()] || null;\n  }\n  get activePointerCue() {\n    return this.#$cues()[this.#activePointerIndex()] || null;\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    this.#sliderState = useState(TimeSlider.state);\n  }\n  onAttach(el) {\n    watchActiveTextTrack(this.#media.textTracks, \"chapters\", this.#setTrack.bind(this));\n    effect(this.#watchSource.bind(this));\n  }\n  onConnect() {\n    onDispose(() => this.#reset.bind(this));\n  }\n  onDestroy() {\n    this.#setTrack(null);\n  }\n  setRefs(refs) {\n    this.#refs = refs;\n    this.#updateScope?.dispose();\n    if (this.#refs.length === 1) {\n      const el = this.#refs[0];\n      el.style.width = \"100%\";\n      el.style.setProperty(\"--chapter-fill\", \"var(--slider-fill)\");\n      el.style.setProperty(\"--chapter-progress\", \"var(--slider-progress)\");\n    } else if (this.#refs.length > 0) {\n      scoped(() => this.#watch(), this.#updateScope = createScope());\n    }\n  }\n  #setTrack(track) {\n    if (peek(this.#$track) === track) return;\n    this.#reset();\n    this.#$track.set(track);\n  }\n  #reset() {\n    this.#refs = [];\n    this.#$cues.set([]);\n    this.#activeIndex.set(-1);\n    this.#activePointerIndex.set(-1);\n    this.#bufferedIndex = 0;\n    this.#updateScope?.dispose();\n  }\n  #watch() {\n    if (!this.#refs.length) return;\n    effect(this.#watchUpdates.bind(this));\n  }\n  #watchUpdates() {\n    const { hidden } = this.#sliderState;\n    if (hidden()) return;\n    effect(this.#watchContainerWidths.bind(this));\n    effect(this.#watchFillPercent.bind(this));\n    effect(this.#watchPointerPercent.bind(this));\n    effect(this.#watchBufferedPercent.bind(this));\n  }\n  #watchContainerWidths() {\n    const cues = this.#$cues();\n    if (!cues.length) return;\n    let cue, { clipStartTime, clipEndTime } = this.#media.$state, startTime = clipStartTime(), endTime = clipEndTime() || cues[cues.length - 1].endTime, duration = endTime - startTime, remainingWidth = 100;\n    for (let i = 0; i < cues.length; i++) {\n      cue = cues[i];\n      if (this.#refs[i]) {\n        const width = i === cues.length - 1 ? remainingWidth : round((cue.endTime - Math.max(startTime, cue.startTime)) / duration * 100, 3);\n        this.#refs[i].style.width = width + \"%\";\n        remainingWidth -= width;\n      }\n    }\n  }\n  #watchFillPercent() {\n    let { liveEdge, clipStartTime, duration } = this.#media.$state, { fillPercent, value } = this.#sliderState, cues = this.#$cues(), isLiveEdge = liveEdge(), prevActiveIndex = peek(this.#activeIndex), currentChapter = cues[prevActiveIndex];\n    let currentActiveIndex = isLiveEdge ? this.#$cues.length - 1 : this.#findActiveChapterIndex(\n      currentChapter ? currentChapter.startTime / duration() * 100 <= peek(value) ? prevActiveIndex : 0 : 0,\n      fillPercent()\n    );\n    if (isLiveEdge || !currentChapter) {\n      this.#updateFillPercents(0, cues.length, 100);\n    } else if (currentActiveIndex > prevActiveIndex) {\n      this.#updateFillPercents(prevActiveIndex, currentActiveIndex, 100);\n    } else if (currentActiveIndex < prevActiveIndex) {\n      this.#updateFillPercents(currentActiveIndex + 1, prevActiveIndex + 1, 0);\n    }\n    const percent = isLiveEdge ? 100 : this.#calcPercent(\n      cues[currentActiveIndex],\n      fillPercent(),\n      clipStartTime(),\n      this.#getEndTime(cues)\n    );\n    this.#updateFillPercent(this.#refs[currentActiveIndex], percent);\n    this.#activeIndex.set(currentActiveIndex);\n  }\n  #watchPointerPercent() {\n    let { pointing, pointerPercent } = this.#sliderState;\n    if (!pointing()) {\n      this.#activePointerIndex.set(-1);\n      return;\n    }\n    const activeIndex = this.#findActiveChapterIndex(0, pointerPercent());\n    this.#activePointerIndex.set(activeIndex);\n  }\n  #updateFillPercents(start, end, percent) {\n    for (let i = start; i < end; i++) this.#updateFillPercent(this.#refs[i], percent);\n  }\n  #updateFillPercent(ref, percent) {\n    if (!ref) return;\n    ref.style.setProperty(\"--chapter-fill\", percent + \"%\");\n    setAttribute(ref, \"data-active\", percent > 0 && percent < 100);\n    setAttribute(ref, \"data-ended\", percent === 100);\n  }\n  #findActiveChapterIndex(startIndex, percent) {\n    let chapterPercent = 0, cues = this.#$cues();\n    if (percent === 0) return 0;\n    else if (percent === 100) return cues.length - 1;\n    let { clipStartTime } = this.#media.$state, startTime = clipStartTime(), endTime = this.#getEndTime(cues);\n    for (let i = startIndex; i < cues.length; i++) {\n      chapterPercent = this.#calcPercent(cues[i], percent, startTime, endTime);\n      if (chapterPercent >= 0 && chapterPercent < 100) return i;\n    }\n    return 0;\n  }\n  #watchBufferedPercent() {\n    this.#updateBufferedPercent(this.#bufferedPercent());\n  }\n  #updateBufferedPercent = animationFrameThrottle((bufferedPercent) => {\n    let percent, cues = this.#$cues(), { clipStartTime } = this.#media.$state, startTime = clipStartTime(), endTime = this.#getEndTime(cues);\n    for (let i = this.#bufferedIndex; i < this.#refs.length; i++) {\n      percent = this.#calcPercent(cues[i], bufferedPercent, startTime, endTime);\n      this.#refs[i]?.style.setProperty(\"--chapter-progress\", percent + \"%\");\n      if (percent < 100) {\n        this.#bufferedIndex = i;\n        break;\n      }\n    }\n  });\n  #bufferedPercent = computed(this.#calcMediaBufferedPercent.bind(this));\n  #calcMediaBufferedPercent() {\n    const { bufferedEnd, duration } = this.#media.$state;\n    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1), 3) * 100;\n  }\n  #getEndTime(cues) {\n    const { clipEndTime } = this.#media.$state, endTime = clipEndTime();\n    return endTime > 0 ? endTime : cues[cues.length - 1]?.endTime || 0;\n  }\n  #calcPercent(cue, percent, startTime, endTime) {\n    const cues = this.#$cues();\n    if (cues.length === 0) return 0;\n    const duration = endTime - startTime, cueStartTime = Math.max(0, cue.startTime - startTime), cueEndTime = Math.min(endTime, cue.endTime) - startTime;\n    const startRatio = cueStartTime / duration, startPercent = startRatio * 100, endPercent = Math.min(1, startRatio + (cueEndTime - cueStartTime) / duration) * 100;\n    return Math.max(\n      0,\n      round(\n        percent >= endPercent ? 100 : (percent - startPercent) / (endPercent - startPercent) * 100,\n        3\n      )\n    );\n  }\n  #fillGaps(cues) {\n    let chapters = [], { clipStartTime, clipEndTime, duration } = this.#media.$state, startTime = clipStartTime(), endTime = clipEndTime() || Infinity;\n    cues = cues.filter((cue) => cue.startTime <= endTime && cue.endTime >= startTime);\n    const firstCue = cues[0];\n    if (firstCue && firstCue.startTime > startTime) {\n      chapters.push(new window.VTTCue(startTime, firstCue.startTime, \"\"));\n    }\n    for (let i = 0; i < cues.length - 1; i++) {\n      const currentCue = cues[i], nextCue = cues[i + 1];\n      chapters.push(currentCue);\n      if (nextCue) {\n        const timeDiff = nextCue.startTime - currentCue.endTime;\n        if (timeDiff > 0) {\n          chapters.push(new window.VTTCue(currentCue.endTime, currentCue.endTime + timeDiff, \"\"));\n        }\n      }\n    }\n    const lastCue = cues[cues.length - 1];\n    if (lastCue) {\n      chapters.push(lastCue);\n      const endTime2 = duration();\n      if (endTime2 >= 0 && endTime2 - lastCue.endTime > 1) {\n        chapters.push(new window.VTTCue(lastCue.endTime, duration(), \"\"));\n      }\n    }\n    return chapters;\n  }\n  #watchSource() {\n    const { source } = this.#media.$state;\n    source();\n    this.#onTrackChange();\n  }\n  #onTrackChange() {\n    if (!this.scope) return;\n    const { disabled } = this.$props;\n    if (disabled()) {\n      this.#$cues.set([]);\n      this.#activeIndex.set(0);\n      this.#bufferedIndex = 0;\n      return;\n    }\n    const track = this.#$track();\n    if (track) {\n      const onCuesChange = this.#onCuesChange.bind(this);\n      onCuesChange();\n      new EventsController(track).add(\"add-cue\", onCuesChange).add(\"remove-cue\", onCuesChange);\n      effect(this.#watchMediaDuration.bind(this));\n    }\n    this.#titleRef = this.#findChapterTitleRef();\n    if (this.#titleRef) effect(this.#onChapterTitleChange.bind(this));\n    return () => {\n      if (this.#titleRef) {\n        this.#titleRef.textContent = \"\";\n        this.#titleRef = null;\n      }\n    };\n  }\n  #watchMediaDuration() {\n    this.#media.$state.duration();\n    this.#onCuesChange();\n  }\n  #onCuesChange = functionDebounce(\n    () => {\n      const track = peek(this.#$track);\n      if (!this.scope || !track || !track.cues.length) return;\n      this.#$cues.set(this.#fillGaps(track.cues));\n      this.#activeIndex.set(0);\n      this.#bufferedIndex = 0;\n    },\n    150,\n    true\n  );\n  #onChapterTitleChange() {\n    const cue = this.activePointerCue || this.activeCue;\n    if (this.#titleRef) this.#titleRef.textContent = cue?.text || \"\";\n  }\n  #findParentSlider() {\n    let node = this.el;\n    while (node && node.getAttribute(\"role\") !== \"slider\") {\n      node = node.parentElement;\n    }\n    return node;\n  }\n  #findChapterTitleRef() {\n    const slider = this.#findParentSlider();\n    return slider ? slider.querySelector('[data-part=\"chapter-title\"]') : null;\n  }\n}\nconst sliderchapters__proto = SliderChapters.prototype;\nprop(sliderchapters__proto, \"cues\");\nprop(sliderchapters__proto, \"activeCue\");\nprop(sliderchapters__proto, \"activePointerCue\");\nmethod(sliderchapters__proto, \"setRefs\");\n\nclass RadioGroup extends Component {\n  static props = {\n    value: \"\"\n  };\n  #controller;\n  /**\n   * A list of radio values that belong this group.\n   */\n  get values() {\n    return this.#controller.values;\n  }\n  /**\n   * The radio value that is checked in this group.\n   */\n  get value() {\n    return this.#controller.value;\n  }\n  set value(newValue) {\n    this.#controller.value = newValue;\n  }\n  constructor() {\n    super();\n    this.#controller = new RadioGroupController();\n    this.#controller.onValueChange = this.#onValueChange.bind(this);\n  }\n  onSetup() {\n    effect(this.#watchValue.bind(this));\n  }\n  #watchValue() {\n    this.#controller.value = this.$props.value();\n  }\n  #onValueChange(value, trigger) {\n    const event = this.createEvent(\"change\", { detail: value, trigger });\n    this.dispatch(event);\n  }\n}\nconst radiogroup__proto = RadioGroup.prototype;\nprop(radiogroup__proto, \"values\");\nprop(radiogroup__proto, \"value\");\n\nclass Radio extends Component {\n  static props = {\n    value: \"\"\n  };\n  #checked = signal(false);\n  #controller = {\n    value: this.$props.value,\n    check: this.#check.bind(this),\n    onCheck: null\n  };\n  /**\n   * Whether this radio is currently checked.\n   */\n  get checked() {\n    return this.#checked();\n  }\n  constructor() {\n    super();\n    new FocusVisibleController();\n  }\n  onSetup() {\n    this.setAttributes({\n      value: this.$props.value,\n      \"data-checked\": this.#checked,\n      \"aria-checked\": $ariaBool(this.#checked)\n    });\n  }\n  onAttach(el) {\n    const isMenuItem = hasProvidedContext(menuContext);\n    setAttributeIfEmpty(el, \"tabindex\", isMenuItem ? \"-1\" : \"0\");\n    setAttributeIfEmpty(el, \"role\", isMenuItem ? \"menuitemradio\" : \"radio\");\n    effect(this.#watchValue.bind(this));\n  }\n  onConnect(el) {\n    this.#addToGroup();\n    onPress(el, this.#onPress.bind(this));\n    onDispose(this.#onDisconnect.bind(this));\n  }\n  #onDisconnect() {\n    scoped(() => {\n      const group = useContext(radioControllerContext);\n      group.remove(this.#controller);\n    }, this.connectScope);\n  }\n  #addToGroup() {\n    const group = useContext(radioControllerContext);\n    group.add(this.#controller);\n  }\n  #watchValue() {\n    const { value } = this.$props, newValue = value();\n    if (peek(this.#checked)) {\n      this.#controller.onCheck?.(newValue);\n    }\n  }\n  #onPress(event) {\n    if (peek(this.#checked)) return;\n    this.#onChange(true, event);\n    this.#onSelect(event);\n    this.#controller.onCheck?.(peek(this.$props.value), event);\n  }\n  #check(value, trigger) {\n    if (peek(this.#checked) === value) return;\n    this.#onChange(value, trigger);\n  }\n  #onChange(value, trigger) {\n    this.#checked.set(value);\n    this.dispatch(\"change\", { detail: value, trigger });\n  }\n  #onSelect(trigger) {\n    this.dispatch(\"select\", { trigger });\n  }\n}\nconst radio__proto = Radio.prototype;\nprop(radio__proto, \"checked\");\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = __getOwnPropDesc(target, key) ;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (decorator(target, key, result) ) || result;\n  if (result) __defProp(target, key, result);\n  return result;\n};\nclass ChaptersRadioGroup extends Component {\n  static props = {\n    thumbnails: null\n  };\n  #media;\n  #menu;\n  #controller;\n  #track = signal(null);\n  #cues = signal([]);\n  get value() {\n    return this.#controller.value;\n  }\n  get disabled() {\n    return !this.#cues()?.length;\n  }\n  constructor() {\n    super();\n    this.#controller = new RadioGroupController();\n    this.#controller.onValueChange = this.#onValueChange.bind(this);\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    if (hasProvidedContext(menuContext)) {\n      this.#menu = useContext(menuContext);\n    }\n    const { thumbnails } = this.$props;\n    this.setAttributes({\n      \"data-thumbnails\": () => !!thumbnails()\n    });\n  }\n  onAttach(el) {\n    this.#menu?.attachObserver({\n      onOpen: this.#onOpen.bind(this)\n    });\n  }\n  getOptions() {\n    const { clipStartTime, clipEndTime } = this.#media.$state, startTime = clipStartTime(), endTime = clipEndTime() || Infinity;\n    return this.#cues().map((cue, i) => ({\n      cue,\n      value: i.toString(),\n      label: cue.text,\n      startTime: formatTime(Math.max(0, cue.startTime - startTime)),\n      duration: formatSpokenTime(\n        Math.min(endTime, cue.endTime) - Math.max(startTime, cue.startTime)\n      )\n    }));\n  }\n  #onOpen() {\n    peek(() => this.#watchCurrentTime());\n  }\n  onConnect(el) {\n    effect(this.#watchCurrentTime.bind(this));\n    effect(this.#watchControllerDisabled.bind(this));\n    effect(this.#watchTrack.bind(this));\n    watchActiveTextTrack(this.#media.textTracks, \"chapters\", this.#track.set);\n  }\n  #watchTrack() {\n    const track = this.#track();\n    if (!track) return;\n    const onCuesChange = this.#onCuesChange.bind(this, track);\n    onCuesChange();\n    new EventsController(track).add(\"add-cue\", onCuesChange).add(\"remove-cue\", onCuesChange);\n    return () => {\n      this.#cues.set([]);\n    };\n  }\n  #onCuesChange(track) {\n    const { clipStartTime, clipEndTime } = this.#media.$state, startTime = clipStartTime(), endTime = clipEndTime() || Infinity;\n    this.#cues.set(\n      [...track.cues].filter((cue) => cue.startTime <= endTime && cue.endTime >= startTime)\n    );\n  }\n  #watchCurrentTime() {\n    if (!this.#menu?.expanded()) return;\n    const track = this.#track();\n    if (!track) {\n      this.#controller.value = \"-1\";\n      return;\n    }\n    const { realCurrentTime, clipStartTime, clipEndTime } = this.#media.$state, startTime = clipStartTime(), endTime = clipEndTime() || Infinity, time = realCurrentTime(), activeCueIndex = this.#cues().findIndex((cue) => isCueActive(cue, time));\n    this.#controller.value = activeCueIndex.toString();\n    if (activeCueIndex >= 0) {\n      requestScopedAnimationFrame(() => {\n        if (!this.connectScope) return;\n        const cue = this.#cues()[activeCueIndex], radio = this.el.querySelector(`[aria-checked='true']`), cueStartTime = Math.max(startTime, cue.startTime), duration = Math.min(endTime, cue.endTime) - cueStartTime, playedPercent = Math.max(0, time - cueStartTime) / duration * 100;\n        radio && setStyle(radio, \"--progress\", round(playedPercent, 3) + \"%\");\n      });\n    }\n  }\n  #watchControllerDisabled() {\n    this.#menu?.disable(this.disabled);\n  }\n  #onValueChange(value, trigger) {\n    if (this.disabled || !trigger) return;\n    const index = +value, cues = this.#cues(), { clipStartTime } = this.#media.$state;\n    if (isNumber(index) && cues?.[index]) {\n      this.#controller.value = index.toString();\n      this.#media.remote.seek(cues[index].startTime - clipStartTime(), trigger);\n      this.dispatch(\"change\", { detail: cues[index], trigger });\n    }\n  }\n}\n__decorateClass([\n  prop\n], ChaptersRadioGroup.prototype, \"value\");\n__decorateClass([\n  prop\n], ChaptersRadioGroup.prototype, \"disabled\");\n__decorateClass([\n  method\n], ChaptersRadioGroup.prototype, \"getOptions\");\n\nconst DEFAULT_AUDIO_GAINS = [1, 1.25, 1.5, 1.75, 2, 2.5, 3, 4];\nclass AudioGainRadioGroup extends Component {\n  static props = {\n    normalLabel: \"Disabled\",\n    gains: DEFAULT_AUDIO_GAINS\n  };\n  #media;\n  #menu;\n  #controller;\n  get value() {\n    return this.#controller.value;\n  }\n  get disabled() {\n    const { gains } = this.$props, { canSetAudioGain } = this.#media.$state;\n    return !canSetAudioGain() || gains().length === 0;\n  }\n  constructor() {\n    super();\n    this.#controller = new RadioGroupController();\n    this.#controller.onValueChange = this.#onValueChange.bind(this);\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    if (hasProvidedContext(menuContext)) {\n      this.#menu = useContext(menuContext);\n    }\n  }\n  onConnect(el) {\n    effect(this.#watchValue.bind(this));\n    effect(this.#watchHintText.bind(this));\n    effect(this.#watchControllerDisabled.bind(this));\n  }\n  getOptions() {\n    const { gains, normalLabel } = this.$props;\n    return gains().map((gain) => ({\n      label: gain === 1 || gain === null ? normalLabel : String(gain * 100) + \"%\",\n      value: gain.toString()\n    }));\n  }\n  #watchValue() {\n    this.#controller.value = this.#getValue();\n  }\n  #watchHintText() {\n    const { normalLabel } = this.$props, { audioGain } = this.#media.$state, gain = audioGain();\n    this.#menu?.hint.set(gain === 1 || gain == null ? normalLabel() : String(gain * 100) + \"%\");\n  }\n  #watchControllerDisabled() {\n    this.#menu?.disable(this.disabled);\n  }\n  #getValue() {\n    const { audioGain } = this.#media.$state;\n    return audioGain()?.toString() ?? \"1\";\n  }\n  #onValueChange(value, trigger) {\n    if (this.disabled) return;\n    const gain = +value;\n    this.#media.remote.changeAudioGain(gain, trigger);\n    this.dispatch(\"change\", { detail: gain, trigger });\n  }\n}\nconst audiogainradiogroup__proto = AudioGainRadioGroup.prototype;\nprop(audiogainradiogroup__proto, \"value\");\nprop(audiogainradiogroup__proto, \"disabled\");\nmethod(audiogainradiogroup__proto, \"getOptions\");\n\nclass Gesture extends Component {\n  static props = {\n    disabled: false,\n    event: void 0,\n    action: void 0\n  };\n  #media;\n  #provider = null;\n  onSetup() {\n    this.#media = useMediaContext();\n    const { event, action } = this.$props;\n    this.setAttributes({\n      event,\n      action\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-gesture\", \"\");\n    el.style.setProperty(\"pointer-events\", \"none\");\n  }\n  onConnect(el) {\n    this.#provider = this.#media.player.el?.querySelector(\n      \"[data-media-provider]\"\n    );\n    effect(this.#attachListener.bind(this));\n  }\n  #attachListener() {\n    let eventType = this.$props.event(), disabled = this.$props.disabled();\n    if (!this.#provider || !eventType || disabled) return;\n    if (/^dbl/.test(eventType)) {\n      eventType = eventType.split(/^dbl/)[1];\n    }\n    if (eventType === \"pointerup\" || eventType === \"pointerdown\") {\n      const pointer = this.#media.$state.pointer();\n      if (pointer === \"coarse\") {\n        eventType = eventType === \"pointerup\" ? \"touchend\" : \"touchstart\";\n      }\n    }\n    listenEvent(\n      this.#provider,\n      eventType,\n      this.#acceptEvent.bind(this),\n      { passive: false }\n    );\n  }\n  #presses = 0;\n  #pressTimerId = -1;\n  #acceptEvent(event) {\n    if (this.$props.disabled() || isPointerEvent(event) && (event.button !== 0 || this.#media.activeMenu) || isTouchEvent(event) && this.#media.activeMenu || isTouchPinchEvent(event) || !this.#inBounds(event)) {\n      return;\n    }\n    event.MEDIA_GESTURE = true;\n    event.preventDefault();\n    const eventType = peek(this.$props.event), isDblEvent = eventType?.startsWith(\"dbl\");\n    if (!isDblEvent) {\n      if (this.#presses === 0) {\n        setTimeout(() => {\n          if (this.#presses === 1) this.#handleEvent(event);\n        }, 250);\n      }\n    } else if (this.#presses === 1) {\n      queueMicrotask(() => this.#handleEvent(event));\n      clearTimeout(this.#pressTimerId);\n      this.#presses = 0;\n      return;\n    }\n    if (this.#presses === 0) {\n      this.#pressTimerId = window.setTimeout(() => {\n        this.#presses = 0;\n      }, 275);\n    }\n    this.#presses++;\n  }\n  #handleEvent(event) {\n    this.el.setAttribute(\"data-triggered\", \"\");\n    requestAnimationFrame(() => {\n      if (this.#isTopLayer()) {\n        this.#performAction(peek(this.$props.action), event);\n      }\n      requestAnimationFrame(() => {\n        this.el.removeAttribute(\"data-triggered\");\n      });\n    });\n  }\n  /** Validate event occurred in gesture bounds. */\n  #inBounds(event) {\n    if (!this.el) return false;\n    if (isPointerEvent(event) || isMouseEvent(event) || isTouchEvent(event)) {\n      const touch = isTouchEvent(event) ? event.changedTouches[0] ?? event.touches[0] : void 0;\n      const clientX = touch?.clientX ?? event.clientX;\n      const clientY = touch?.clientY ?? event.clientY;\n      const rect = this.el.getBoundingClientRect();\n      const inBounds = clientY >= rect.top && clientY <= rect.bottom && clientX >= rect.left && clientX <= rect.right;\n      return event.type.includes(\"leave\") ? !inBounds : inBounds;\n    }\n    return true;\n  }\n  /** Validate gesture has the highest z-index in this triggered group. */\n  #isTopLayer() {\n    const gestures = this.#media.player.el.querySelectorAll(\n      \"[data-media-gesture][data-triggered]\"\n    );\n    return Array.from(gestures).sort(\n      (a, b) => +getComputedStyle(b).zIndex - +getComputedStyle(a).zIndex\n    )[0] === this.el;\n  }\n  #performAction(action, trigger) {\n    if (!action) return;\n    const willTriggerEvent = new DOMEvent(\"will-trigger\", {\n      detail: action,\n      cancelable: true,\n      trigger\n    });\n    this.dispatchEvent(willTriggerEvent);\n    if (willTriggerEvent.defaultPrevented) return;\n    const [method, value] = action.replace(/:([a-z])/, \"-$1\").split(\":\");\n    if (action.includes(\":fullscreen\")) {\n      this.#media.remote.toggleFullscreen(\"prefer-media\", trigger);\n    } else if (action.includes(\"seek:\")) {\n      this.#media.remote.seek(peek(this.#media.$state.currentTime) + (+value || 0), trigger);\n    } else {\n      this.#media.remote[kebabToCamelCase(method)](trigger);\n    }\n    this.dispatch(\"trigger\", {\n      detail: action,\n      trigger\n    });\n  }\n}\n\nclass CaptionsTextRenderer {\n  priority = 10;\n  #track = null;\n  #renderer;\n  #events;\n  constructor(renderer) {\n    this.#renderer = renderer;\n  }\n  attach() {\n  }\n  canRender() {\n    return true;\n  }\n  detach() {\n    this.#events?.abort();\n    this.#events = void 0;\n    this.#renderer.reset();\n    this.#track = null;\n  }\n  changeTrack(track) {\n    if (!track || this.#track === track) return;\n    this.#events?.abort();\n    this.#events = new EventsController(track);\n    if (track.readyState < 2) {\n      this.#renderer.reset();\n      this.#events.add(\"load\", () => this.#changeTrack(track), { once: true });\n    } else {\n      this.#changeTrack(track);\n    }\n    this.#events.add(\"add-cue\", (event) => {\n      this.#renderer.addCue(event.detail);\n    }).add(\"remove-cue\", (event) => {\n      this.#renderer.removeCue(event.detail);\n    });\n    this.#track = track;\n  }\n  #changeTrack(track) {\n    this.#renderer.changeTrack({\n      cues: [...track.cues],\n      regions: [...track.regions]\n    });\n  }\n}\n\nclass Captions extends Component {\n  static props = {\n    textDir: \"ltr\",\n    exampleText: \"Captions look like this.\"\n  };\n  #media;\n  static lib = signal(null);\n  onSetup() {\n    this.#media = useMediaContext();\n    this.setAttributes({\n      \"aria-hidden\": $ariaBool(this.#isHidden.bind(this))\n    });\n  }\n  onAttach(el) {\n    el.style.setProperty(\"pointer-events\", \"none\");\n  }\n  onConnect(el) {\n    if (!Captions.lib()) {\n      import('media-captions').then((lib) => Captions.lib.set(lib));\n    }\n    effect(this.#watchViewType.bind(this));\n  }\n  #isHidden() {\n    const { textTrack, remotePlaybackState, iOSControls } = this.#media.$state, track = textTrack();\n    return iOSControls() || remotePlaybackState() === \"connected\" || !track || !isTrackCaptionKind(track);\n  }\n  #watchViewType() {\n    if (!Captions.lib()) return;\n    const { viewType } = this.#media.$state;\n    if (viewType() === \"audio\") {\n      return this.#setupAudioView();\n    } else {\n      return this.#setupVideoView();\n    }\n  }\n  #setupAudioView() {\n    effect(this.#onTrackChange.bind(this));\n    this.#listenToFontStyleChanges(null);\n    return () => {\n      this.el.textContent = \"\";\n    };\n  }\n  #onTrackChange() {\n    if (this.#isHidden()) return;\n    this.#onCueChange();\n    const { textTrack } = this.#media.$state;\n    listenEvent(textTrack(), \"cue-change\", this.#onCueChange.bind(this));\n    effect(this.#onUpdateTimedNodes.bind(this));\n  }\n  #onCueChange() {\n    this.el.textContent = \"\";\n    if (this.#hideExampleTimer >= 0) {\n      this.#removeExample();\n    }\n    const { realCurrentTime, textTrack } = this.#media.$state, { renderVTTCueString } = Captions.lib(), time = peek(realCurrentTime), activeCues = peek(textTrack).activeCues;\n    for (const cue of activeCues) {\n      const displayEl = this.#createCueDisplayElement(), cueEl = this.#createCueElement();\n      cueEl.innerHTML = renderVTTCueString(cue, time);\n      displayEl.append(cueEl);\n      this.el.append(cueEl);\n    }\n  }\n  #onUpdateTimedNodes() {\n    const { realCurrentTime } = this.#media.$state, { updateTimedVTTCueNodes } = Captions.lib();\n    updateTimedVTTCueNodes(this.el, realCurrentTime());\n  }\n  #setupVideoView() {\n    const { CaptionsRenderer } = Captions.lib(), renderer = new CaptionsRenderer(this.el), textRenderer = new CaptionsTextRenderer(renderer);\n    this.#media.textRenderers.add(textRenderer);\n    effect(this.#watchTextDirection.bind(this, renderer));\n    effect(this.#watchMediaTime.bind(this, renderer));\n    this.#listenToFontStyleChanges(renderer);\n    return () => {\n      this.el.textContent = \"\";\n      this.#media.textRenderers.remove(textRenderer);\n      renderer.destroy();\n    };\n  }\n  #watchTextDirection(renderer) {\n    renderer.dir = this.$props.textDir();\n  }\n  #watchMediaTime(renderer) {\n    if (this.#isHidden()) return;\n    const { realCurrentTime, textTrack } = this.#media.$state;\n    renderer.currentTime = realCurrentTime();\n    if (this.#hideExampleTimer >= 0 && textTrack()?.activeCues[0]) {\n      this.#removeExample();\n    }\n  }\n  #listenToFontStyleChanges(renderer) {\n    const player = this.#media.player;\n    if (!player) return;\n    const onChange = this.#onFontStyleChange.bind(this, renderer);\n    listenEvent(player, \"vds-font-change\", onChange);\n  }\n  #onFontStyleChange(renderer) {\n    if (this.#hideExampleTimer >= 0) {\n      this.#hideExample();\n      return;\n    }\n    const { textTrack } = this.#media.$state;\n    if (!textTrack()?.activeCues[0]) {\n      this.#showExample();\n    } else {\n      renderer?.update(true);\n    }\n  }\n  #showExample() {\n    const display = this.#createCueDisplayElement();\n    setAttribute(display, \"data-example\", \"\");\n    const cue = this.#createCueElement();\n    setAttribute(cue, \"data-example\", \"\");\n    cue.textContent = this.$props.exampleText();\n    display?.append(cue);\n    this.el?.append(display);\n    this.el?.setAttribute(\"data-example\", \"\");\n    this.#hideExample();\n  }\n  #hideExampleTimer = -1;\n  #hideExample() {\n    window.clearTimeout(this.#hideExampleTimer);\n    this.#hideExampleTimer = window.setTimeout(this.#removeExample.bind(this), 2500);\n  }\n  #removeExample() {\n    this.el?.removeAttribute(\"data-example\");\n    if (this.el?.querySelector(\"[data-example]\")) this.el.textContent = \"\";\n    this.#hideExampleTimer = -1;\n  }\n  #createCueDisplayElement() {\n    const el = document.createElement(\"div\");\n    setAttribute(el, \"data-part\", \"cue-display\");\n    return el;\n  }\n  #createCueElement() {\n    const el = document.createElement(\"div\");\n    setAttribute(el, \"data-part\", \"cue\");\n    return el;\n  }\n}\n\nexport { AudioGainRadioGroup, AudioGainSlider, Captions, ChaptersRadioGroup, Controls, ControlsGroup, DEFAULT_AUDIO_GAINS, Gesture, GoogleCastButton, MediaAnnouncer, QualitySlider, Radio, RadioGroup, SliderChapters, SliderVideo, SpeedSlider, ToggleButton, Tooltip, TooltipContent, TooltipTrigger };\n","import { createContext, useContext } from './vidstack-DVpy0IqK.js';\n\nconst mediaContext = createContext();\nfunction useMediaContext() {\n  return useContext(mediaContext);\n}\nfunction useMediaState() {\n  return useMediaContext().$state;\n}\n\nexport { mediaContext, useMediaContext, useMediaState };\n","import { ViewController, onDispose, isArray, isString, isNull, effect, peek, listenEvent, ariaBool, isWriteSignal, Component, State, createContext, hasProvidedContext, useContext, EventsController, isNumber, functionThrottle, signal, provideContext, animationFrameThrottle, isObject, method, useState, computed, setAttribute, r, wasEnterKeyPressed, isKeyboardEvent, tick, prop, setStyle } from './vidstack-DVpy0IqK.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\nimport { $ariaBool, sortVideoQualities } from './vidstack-BOTZD4tC.js';\nimport { hasAnimation, setAttributeIfEmpty, onPress, setARIALabel, isTouchPinchEvent, observeVisibility, isHTMLElement, isElementParent, isEventInside, isElementVisible, requestScopedAnimationFrame, autoPlacement } from './vidstack-CGUlKgT8.js';\nimport { isTrackCaptionKind } from './vidstack-DghpoXbA.js';\nimport { FocusVisibleController } from './vidstack-9MhB-Ya7.js';\nimport { assert } from './vidstack-DbBJlz7I.js';\nimport { getRequestCredentials } from './vidstack-BgIVvpNy.js';\nimport { clampNumber, round, getNumberOfDecimalPlaces } from './vidstack-Dihypf8P.js';\nimport { watchActiveTextTrack } from './vidstack-C1THCRTj.js';\n\nclass ARIAKeyShortcuts extends ViewController {\n  #shortcut;\n  constructor(shortcut) {\n    super();\n    this.#shortcut = shortcut;\n  }\n  onAttach(el) {\n    const { $props, ariaKeys } = useMediaContext(), keys = el.getAttribute(\"aria-keyshortcuts\");\n    if (keys) {\n      ariaKeys[this.#shortcut] = keys;\n      {\n        onDispose(() => {\n          delete ariaKeys[this.#shortcut];\n        });\n      }\n      return;\n    }\n    const shortcuts = $props.keyShortcuts()[this.#shortcut];\n    if (shortcuts) {\n      const keys2 = isArray(shortcuts) ? shortcuts.join(\" \") : isString(shortcuts) ? shortcuts : shortcuts?.keys;\n      el.setAttribute(\"aria-keyshortcuts\", isArray(keys2) ? keys2.join(\" \") : keys2);\n    }\n  }\n}\n\nfunction padNumberWithZeroes(num, expectedLength) {\n  const str = String(num);\n  const actualLength = str.length;\n  const shouldPad = actualLength < expectedLength;\n  if (shouldPad) {\n    const padLength = expectedLength - actualLength;\n    const padding = `0`.repeat(padLength);\n    return `${padding}${num}`;\n  }\n  return str;\n}\nfunction parseTime(duration) {\n  const hours = Math.trunc(duration / 3600);\n  const minutes = Math.trunc(duration % 3600 / 60);\n  const seconds = Math.trunc(duration % 60);\n  const fraction = Number((duration - Math.trunc(duration)).toPrecision(3));\n  return {\n    hours,\n    minutes,\n    seconds,\n    fraction\n  };\n}\nfunction formatTime(duration, { padHrs = null, padMins = null, showHrs = false, showMs = false } = {}) {\n  const { hours, minutes, seconds, fraction } = parseTime(duration), paddedHours = padHrs ? padNumberWithZeroes(hours, 2) : hours, paddedMinutes = padMins || isNull(padMins) && duration >= 3600 ? padNumberWithZeroes(minutes, 2) : minutes, paddedSeconds = padNumberWithZeroes(seconds, 2), paddedMs = showMs && fraction > 0 ? `.${String(fraction).replace(/^0?\\./, \"\")}` : \"\", time = `${paddedMinutes}:${paddedSeconds}${paddedMs}`;\n  return hours > 0 || showHrs ? `${paddedHours}:${time}` : time;\n}\nfunction formatSpokenTime(duration) {\n  const spokenParts = [];\n  const { hours, minutes, seconds } = parseTime(duration);\n  if (hours > 0) {\n    spokenParts.push(`${hours} hour`);\n  }\n  if (minutes > 0) {\n    spokenParts.push(`${minutes} min`);\n  }\n  if (seconds > 0 || spokenParts.length === 0) {\n    spokenParts.push(`${seconds} sec`);\n  }\n  return spokenParts.join(\" \");\n}\n\nclass Popper extends ViewController {\n  #delegate;\n  constructor(delegate) {\n    super();\n    this.#delegate = delegate;\n    effect(this.#watchTrigger.bind(this));\n  }\n  onDestroy() {\n    this.#stopAnimationEndListener?.();\n    this.#stopAnimationEndListener = null;\n  }\n  #watchTrigger() {\n    const trigger = this.#delegate.trigger();\n    if (!trigger) {\n      this.hide();\n      return;\n    }\n    const show = this.show.bind(this), hide = this.hide.bind(this);\n    this.#delegate.listen(trigger, show, hide);\n  }\n  #showTimerId = -1;\n  #hideRafId = -1;\n  #stopAnimationEndListener = null;\n  show(trigger) {\n    this.#cancelShowing();\n    window.cancelAnimationFrame(this.#hideRafId);\n    this.#hideRafId = -1;\n    this.#stopAnimationEndListener?.();\n    this.#stopAnimationEndListener = null;\n    this.#showTimerId = window.setTimeout(() => {\n      this.#showTimerId = -1;\n      const content = this.#delegate.content();\n      if (content) content.style.removeProperty(\"display\");\n      peek(() => this.#delegate.onChange(true, trigger));\n    }, this.#delegate.showDelay?.() ?? 0);\n  }\n  hide(trigger) {\n    this.#cancelShowing();\n    peek(() => this.#delegate.onChange(false, trigger));\n    this.#hideRafId = requestAnimationFrame(() => {\n      this.#cancelShowing();\n      this.#hideRafId = -1;\n      const content = this.#delegate.content();\n      if (content) {\n        const onHide = () => {\n          content.style.display = \"none\";\n          this.#stopAnimationEndListener = null;\n        };\n        const isAnimated = hasAnimation(content);\n        if (isAnimated) {\n          this.#stopAnimationEndListener?.();\n          const stop = listenEvent(content, \"animationend\", onHide, { once: true });\n          this.#stopAnimationEndListener = stop;\n        } else {\n          onHide();\n        }\n      }\n    });\n  }\n  #cancelShowing() {\n    window.clearTimeout(this.#showTimerId);\n    this.#showTimerId = -1;\n  }\n}\n\nclass ToggleButtonController extends ViewController {\n  static props = {\n    disabled: false\n  };\n  #delegate;\n  constructor(delegate) {\n    super();\n    this.#delegate = delegate;\n    new FocusVisibleController();\n    if (delegate.keyShortcut) {\n      new ARIAKeyShortcuts(delegate.keyShortcut);\n    }\n  }\n  onSetup() {\n    const { disabled } = this.$props;\n    this.setAttributes({\n      \"data-pressed\": this.#delegate.isPresssed,\n      \"aria-pressed\": this.#isARIAPressed.bind(this),\n      \"aria-disabled\": () => disabled() ? \"true\" : null\n    });\n  }\n  onAttach(el) {\n    setAttributeIfEmpty(el, \"tabindex\", \"0\");\n    setAttributeIfEmpty(el, \"role\", \"button\");\n    setAttributeIfEmpty(el, \"type\", \"button\");\n  }\n  onConnect(el) {\n    const events = onPress(el, this.#onMaybePress.bind(this));\n    for (const type of [\"click\", \"touchstart\"]) {\n      events.add(type, this.#onInteraction.bind(this), {\n        passive: true\n      });\n    }\n  }\n  #isARIAPressed() {\n    return ariaBool(this.#delegate.isPresssed());\n  }\n  #onPressed(event) {\n    if (isWriteSignal(this.#delegate.isPresssed)) {\n      this.#delegate.isPresssed.set((p) => !p);\n    }\n  }\n  #onMaybePress(event) {\n    const disabled = this.$props.disabled() || this.el.hasAttribute(\"data-disabled\");\n    if (disabled) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n      return;\n    }\n    event.preventDefault();\n    (this.#delegate.onPress ?? this.#onPressed).call(this, event);\n  }\n  #onInteraction(event) {\n    if (this.$props.disabled()) {\n      event.preventDefault();\n      event.stopImmediatePropagation();\n    }\n  }\n}\n\nclass AirPlayButton extends Component {\n  static props = ToggleButtonController.props;\n  #media;\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#isPressed.bind(this),\n      onPress: this.#onPress.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const { canAirPlay, isAirPlayConnected } = this.#media.$state;\n    this.setAttributes({\n      \"data-active\": isAirPlayConnected,\n      \"data-supported\": canAirPlay,\n      \"data-state\": this.#getState.bind(this),\n      \"aria-hidden\": $ariaBool(() => !canAirPlay())\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-tooltip\", \"airplay\");\n    setARIALabel(el, this.#getDefaultLabel.bind(this));\n  }\n  #onPress(event) {\n    const remote = this.#media.remote;\n    remote.requestAirPlay(event);\n  }\n  #isPressed() {\n    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;\n    return remotePlaybackType() === \"airplay\" && remotePlaybackState() !== \"disconnected\";\n  }\n  #getState() {\n    const { remotePlaybackType, remotePlaybackState } = this.#media.$state;\n    return remotePlaybackType() === \"airplay\" && remotePlaybackState();\n  }\n  #getDefaultLabel() {\n    const { remotePlaybackState } = this.#media.$state;\n    return `AirPlay ${remotePlaybackState()}`;\n  }\n}\n\nclass PlayButton extends Component {\n  static props = ToggleButtonController.props;\n  #media;\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#isPressed.bind(this),\n      keyShortcut: \"togglePaused\",\n      onPress: this.#onPress.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const { paused, ended } = this.#media.$state;\n    this.setAttributes({\n      \"data-paused\": paused,\n      \"data-ended\": ended\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-tooltip\", \"play\");\n    setARIALabel(el, \"Play\");\n  }\n  #onPress(event) {\n    const remote = this.#media.remote;\n    this.#isPressed() ? remote.pause(event) : remote.play(event);\n  }\n  #isPressed() {\n    const { paused } = this.#media.$state;\n    return !paused();\n  }\n}\n\nclass CaptionButton extends Component {\n  static props = ToggleButtonController.props;\n  #media;\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#isPressed.bind(this),\n      keyShortcut: \"toggleCaptions\",\n      onPress: this.#onPress.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    this.setAttributes({\n      \"data-active\": this.#isPressed.bind(this),\n      \"data-supported\": () => !this.#isHidden(),\n      \"aria-hidden\": $ariaBool(this.#isHidden.bind(this))\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-tooltip\", \"caption\");\n    setARIALabel(el, \"Captions\");\n  }\n  #onPress(event) {\n    this.#media.remote.toggleCaptions(event);\n  }\n  #isPressed() {\n    const { textTrack } = this.#media.$state, track = textTrack();\n    return !!track && isTrackCaptionKind(track);\n  }\n  #isHidden() {\n    const { hasCaptions } = this.#media.$state;\n    return !hasCaptions();\n  }\n}\n\nclass FullscreenButton extends Component {\n  static props = {\n    ...ToggleButtonController.props,\n    target: \"prefer-media\"\n  };\n  #media;\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#isPressed.bind(this),\n      keyShortcut: \"toggleFullscreen\",\n      onPress: this.#onPress.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const { fullscreen } = this.#media.$state, isSupported = this.#isSupported.bind(this);\n    this.setAttributes({\n      \"data-active\": fullscreen,\n      \"data-supported\": isSupported,\n      \"aria-hidden\": $ariaBool(() => !isSupported())\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-tooltip\", \"fullscreen\");\n    setARIALabel(el, \"Fullscreen\");\n  }\n  #onPress(event) {\n    const remote = this.#media.remote, target = this.$props.target();\n    this.#isPressed() ? remote.exitFullscreen(target, event) : remote.enterFullscreen(target, event);\n  }\n  #isPressed() {\n    const { fullscreen } = this.#media.$state;\n    return fullscreen();\n  }\n  #isSupported() {\n    const { canFullscreen } = this.#media.$state;\n    return canFullscreen();\n  }\n}\n\nclass MuteButton extends Component {\n  static props = ToggleButtonController.props;\n  #media;\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#isPressed.bind(this),\n      keyShortcut: \"toggleMuted\",\n      onPress: this.#onPress.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    this.setAttributes({\n      \"data-muted\": this.#isPressed.bind(this),\n      \"data-state\": this.#getState.bind(this)\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-mute-button\", \"\");\n    el.setAttribute(\"data-media-tooltip\", \"mute\");\n    setARIALabel(el, \"Mute\");\n  }\n  #onPress(event) {\n    const remote = this.#media.remote;\n    this.#isPressed() ? remote.unmute(event) : remote.mute(event);\n  }\n  #isPressed() {\n    const { muted, volume } = this.#media.$state;\n    return muted() || volume() === 0;\n  }\n  #getState() {\n    const { muted, volume } = this.#media.$state, $volume = volume();\n    if (muted() || $volume === 0) return \"muted\";\n    else if ($volume >= 0.5) return \"high\";\n    else if ($volume < 0.5) return \"low\";\n  }\n}\n\nclass PIPButton extends Component {\n  static props = ToggleButtonController.props;\n  #media;\n  constructor() {\n    super();\n    new ToggleButtonController({\n      isPresssed: this.#isPressed.bind(this),\n      keyShortcut: \"togglePictureInPicture\",\n      onPress: this.#onPress.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const { pictureInPicture } = this.#media.$state, isSupported = this.#isSupported.bind(this);\n    this.setAttributes({\n      \"data-active\": pictureInPicture,\n      \"data-supported\": isSupported,\n      \"aria-hidden\": $ariaBool(() => !isSupported())\n    });\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-tooltip\", \"pip\");\n    setARIALabel(el, \"PiP\");\n  }\n  #onPress(event) {\n    const remote = this.#media.remote;\n    this.#isPressed() ? remote.exitPictureInPicture(event) : remote.enterPictureInPicture(event);\n  }\n  #isPressed() {\n    const { pictureInPicture } = this.#media.$state;\n    return pictureInPicture();\n  }\n  #isSupported() {\n    const { canPictureInPicture } = this.#media.$state;\n    return canPictureInPicture();\n  }\n}\n\nclass SeekButton extends Component {\n  static props = {\n    disabled: false,\n    seconds: 30\n  };\n  #media;\n  constructor() {\n    super();\n    new FocusVisibleController();\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const { seeking } = this.#media.$state, { seconds } = this.$props, isSupported = this.#isSupported.bind(this);\n    this.setAttributes({\n      seconds,\n      \"data-seeking\": seeking,\n      \"data-supported\": isSupported,\n      \"aria-hidden\": $ariaBool(() => !isSupported())\n    });\n  }\n  onAttach(el) {\n    setAttributeIfEmpty(el, \"tabindex\", \"0\");\n    setAttributeIfEmpty(el, \"role\", \"button\");\n    setAttributeIfEmpty(el, \"type\", \"button\");\n    el.setAttribute(\"data-media-tooltip\", \"seek\");\n    setARIALabel(el, this.#getDefaultLabel.bind(this));\n  }\n  onConnect(el) {\n    onPress(el, this.#onPress.bind(this));\n  }\n  #isSupported() {\n    const { canSeek } = this.#media.$state;\n    return canSeek();\n  }\n  #getDefaultLabel() {\n    const { seconds } = this.$props;\n    return `Seek ${seconds() > 0 ? \"forward\" : \"backward\"} ${seconds()} seconds`;\n  }\n  #onPress(event) {\n    const { seconds, disabled } = this.$props;\n    if (disabled()) return;\n    const { currentTime } = this.#media.$state, seekTo = currentTime() + seconds();\n    this.#media.remote.seek(seekTo, event);\n  }\n}\n\nclass LiveButton extends Component {\n  static props = {\n    disabled: false\n  };\n  #media;\n  constructor() {\n    super();\n    new FocusVisibleController();\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const { disabled } = this.$props, { live, liveEdge } = this.#media.$state, isHidden = () => !live();\n    this.setAttributes({\n      \"data-edge\": liveEdge,\n      \"data-hidden\": isHidden,\n      \"aria-disabled\": $ariaBool(() => disabled() || liveEdge()),\n      \"aria-hidden\": $ariaBool(isHidden)\n    });\n  }\n  onAttach(el) {\n    setAttributeIfEmpty(el, \"tabindex\", \"0\");\n    setAttributeIfEmpty(el, \"role\", \"button\");\n    setAttributeIfEmpty(el, \"type\", \"button\");\n    el.setAttribute(\"data-media-tooltip\", \"live\");\n  }\n  onConnect(el) {\n    onPress(el, this.#onPress.bind(this));\n  }\n  #onPress(event) {\n    const { disabled } = this.$props, { liveEdge } = this.#media.$state;\n    if (disabled() || liveEdge()) return;\n    this.#media.remote.seekToLiveEdge(event);\n  }\n}\n\nconst sliderState = new State({\n  min: 0,\n  max: 100,\n  value: 0,\n  step: 1,\n  pointerValue: 0,\n  focused: false,\n  dragging: false,\n  pointing: false,\n  hidden: false,\n  get active() {\n    return this.dragging || this.focused || this.pointing;\n  },\n  get fillRate() {\n    return calcRate(this.min, this.max, this.value);\n  },\n  get fillPercent() {\n    return this.fillRate * 100;\n  },\n  get pointerRate() {\n    return calcRate(this.min, this.max, this.pointerValue);\n  },\n  get pointerPercent() {\n    return this.pointerRate * 100;\n  }\n});\nfunction calcRate(min, max, value) {\n  const range = max - min, offset = value - min;\n  return range > 0 ? offset / range : 0;\n}\n\nclass IntersectionObserverController extends ViewController {\n  #init;\n  #observer;\n  constructor(init) {\n    super();\n    this.#init = init;\n  }\n  onConnect(el) {\n    this.#observer = new IntersectionObserver((entries) => {\n      this.#init.callback?.(entries, this.#observer);\n    }, this.#init);\n    this.#observer.observe(el);\n    onDispose(this.#onDisconnect.bind(this));\n  }\n  /**\n   * Disconnect any active intersection observers.\n   */\n  #onDisconnect() {\n    this.#observer?.disconnect();\n    this.#observer = void 0;\n  }\n}\n\nconst sliderContext = createContext();\nconst sliderObserverContext = createContext();\n\nfunction getClampedValue(min, max, value, step) {\n  return clampNumber(min, round(value, getNumberOfDecimalPlaces(step)), max);\n}\nfunction getValueFromRate(min, max, rate, step) {\n  const boundRate = clampNumber(0, rate, 1), range = max - min, fill = range * boundRate, stepRatio = fill / step, steps = step * Math.round(stepRatio);\n  return min + steps;\n}\n\nconst SliderKeyDirection = {\n  Left: -1,\n  ArrowLeft: -1,\n  Up: 1,\n  ArrowUp: 1,\n  Right: 1,\n  ArrowRight: 1,\n  Down: -1,\n  ArrowDown: -1\n};\nclass SliderEventsController extends ViewController {\n  #delegate;\n  #media;\n  #observer;\n  constructor(delegate, media) {\n    super();\n    this.#delegate = delegate;\n    this.#media = media;\n  }\n  onSetup() {\n    if (hasProvidedContext(sliderObserverContext)) {\n      this.#observer = useContext(sliderObserverContext);\n    }\n  }\n  onConnect(el) {\n    effect(this.#attachEventListeners.bind(this, el));\n    effect(this.#attachPointerListeners.bind(this, el));\n    if (this.#delegate.swipeGesture) effect(this.#watchSwipeGesture.bind(this));\n  }\n  #watchSwipeGesture() {\n    const { pointer } = this.#media.$state;\n    if (pointer() !== \"coarse\" || !this.#delegate.swipeGesture()) {\n      this.#provider = null;\n      return;\n    }\n    this.#provider = this.#media.player.el?.querySelector(\n      \"media-provider,[data-media-provider]\"\n    );\n    if (!this.#provider) return;\n    new EventsController(this.#provider).add(\"touchstart\", this.#onTouchStart.bind(this), {\n      passive: true\n    }).add(\"touchmove\", this.#onTouchMove.bind(this), { passive: false });\n  }\n  #provider = null;\n  #touch = null;\n  #touchStartValue = null;\n  #onTouchStart(event) {\n    this.#touch = event.touches[0];\n  }\n  #onTouchMove(event) {\n    if (isNull(this.#touch) || isTouchPinchEvent(event)) return;\n    const touch = event.touches[0], xDiff = touch.clientX - this.#touch.clientX, yDiff = touch.clientY - this.#touch.clientY, isDragging = this.$state.dragging();\n    if (!isDragging && Math.abs(yDiff) > 5) {\n      return;\n    }\n    if (isDragging) return;\n    event.preventDefault();\n    if (Math.abs(xDiff) > 20) {\n      this.#touch = touch;\n      this.#touchStartValue = this.$state.value();\n      this.#onStartDragging(this.#touchStartValue, event);\n    }\n  }\n  #attachEventListeners(el) {\n    const { hidden } = this.$props;\n    new EventsController(el).add(\"focus\", this.#onFocus.bind(this)).add(\"keyup\", this.#onKeyUp.bind(this)).add(\"keydown\", this.#onKeyDown.bind(this));\n    if (hidden() || this.#delegate.isDisabled()) return;\n    new EventsController(el).add(\"pointerenter\", this.#onPointerEnter.bind(this)).add(\"pointermove\", this.#onPointerMove.bind(this)).add(\"pointerleave\", this.#onPointerLeave.bind(this)).add(\"pointerdown\", this.#onPointerDown.bind(this));\n  }\n  #attachPointerListeners(el) {\n    if (this.#delegate.isDisabled() || !this.$state.dragging()) return;\n    new EventsController(document).add(\"pointerup\", this.#onDocumentPointerUp.bind(this), { capture: true }).add(\"pointermove\", this.#onDocumentPointerMove.bind(this)).add(\"touchmove\", this.#onDocumentTouchMove.bind(this), {\n      passive: false\n    });\n  }\n  #onFocus() {\n    this.#updatePointerValue(this.$state.value());\n  }\n  #updateValue(newValue, trigger) {\n    const { value, min, max, dragging } = this.$state;\n    const clampedValue = Math.max(min(), Math.min(newValue, max()));\n    value.set(clampedValue);\n    const event = this.createEvent(\"value-change\", { detail: clampedValue, trigger });\n    this.dispatch(event);\n    this.#delegate.onValueChange?.(event);\n    if (dragging()) {\n      const event2 = this.createEvent(\"drag-value-change\", { detail: clampedValue, trigger });\n      this.dispatch(event2);\n      this.#delegate.onDragValueChange?.(event2);\n    }\n  }\n  #updatePointerValue(value, trigger) {\n    const { pointerValue, dragging } = this.$state;\n    pointerValue.set(value);\n    this.dispatch(\"pointer-value-change\", { detail: value, trigger });\n    if (dragging()) {\n      this.#updateValue(value, trigger);\n    }\n  }\n  #getPointerValue(event) {\n    let thumbPositionRate, rect = this.el.getBoundingClientRect(), { min, max } = this.$state;\n    if (this.$props.orientation() === \"vertical\") {\n      const { bottom: trackBottom, height: trackHeight } = rect;\n      thumbPositionRate = (trackBottom - event.clientY) / trackHeight;\n    } else {\n      if (this.#touch && isNumber(this.#touchStartValue)) {\n        const { width } = this.#provider.getBoundingClientRect(), rate = (event.clientX - this.#touch.clientX) / width, range = max() - min(), diff = range * Math.abs(rate);\n        thumbPositionRate = (rate < 0 ? this.#touchStartValue - diff : this.#touchStartValue + diff) / range;\n      } else {\n        const { left: trackLeft, width: trackWidth } = rect;\n        thumbPositionRate = (event.clientX - trackLeft) / trackWidth;\n      }\n    }\n    return Math.max(\n      min(),\n      Math.min(\n        max(),\n        this.#delegate.roundValue(\n          getValueFromRate(min(), max(), thumbPositionRate, this.#delegate.getStep())\n        )\n      )\n    );\n  }\n  #onPointerEnter(event) {\n    this.$state.pointing.set(true);\n  }\n  #onPointerMove(event) {\n    const { dragging } = this.$state;\n    if (dragging()) return;\n    this.#updatePointerValue(this.#getPointerValue(event), event);\n  }\n  #onPointerLeave(event) {\n    this.$state.pointing.set(false);\n  }\n  #onPointerDown(event) {\n    if (event.button !== 0) return;\n    const value = this.#getPointerValue(event);\n    this.#onStartDragging(value, event);\n    this.#updatePointerValue(value, event);\n  }\n  #onStartDragging(value, trigger) {\n    const { dragging } = this.$state;\n    if (dragging()) return;\n    dragging.set(true);\n    this.#media.remote.pauseControls(trigger);\n    const event = this.createEvent(\"drag-start\", { detail: value, trigger });\n    this.dispatch(event);\n    this.#delegate.onDragStart?.(event);\n    this.#observer?.onDragStart?.();\n  }\n  #onStopDragging(value, trigger) {\n    const { dragging } = this.$state;\n    if (!dragging()) return;\n    dragging.set(false);\n    this.#media.remote.resumeControls(trigger);\n    const event = this.createEvent(\"drag-end\", { detail: value, trigger });\n    this.dispatch(event);\n    this.#delegate.onDragEnd?.(event);\n    this.#touch = null;\n    this.#touchStartValue = null;\n    this.#observer?.onDragEnd?.();\n  }\n  // -------------------------------------------------------------------------------------------\n  // Keyboard Events\n  // -------------------------------------------------------------------------------------------\n  #lastDownKey;\n  #repeatedKeys = false;\n  #onKeyDown(event) {\n    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);\n    if (!isValidKey) return;\n    const { key } = event, jumpValue = this.#calcJumpValue(event);\n    if (!isNull(jumpValue)) {\n      this.#updatePointerValue(jumpValue, event);\n      this.#updateValue(jumpValue, event);\n      return;\n    }\n    const newValue = this.#calcNewKeyValue(event);\n    if (!this.#repeatedKeys) {\n      this.#repeatedKeys = key === this.#lastDownKey;\n      if (!this.$state.dragging() && this.#repeatedKeys) {\n        this.#onStartDragging(newValue, event);\n      }\n    }\n    this.#updatePointerValue(newValue, event);\n    this.#lastDownKey = key;\n  }\n  #onKeyUp(event) {\n    const isValidKey = Object.keys(SliderKeyDirection).includes(event.key);\n    if (!isValidKey || !isNull(this.#calcJumpValue(event))) return;\n    const newValue = this.#repeatedKeys ? this.$state.pointerValue() : this.#calcNewKeyValue(event);\n    this.#updateValue(newValue, event);\n    this.#onStopDragging(newValue, event);\n    this.#lastDownKey = \"\";\n    this.#repeatedKeys = false;\n  }\n  #calcJumpValue(event) {\n    let key = event.key, { min, max } = this.$state;\n    if (key === \"Home\" || key === \"PageUp\") {\n      return min();\n    } else if (key === \"End\" || key === \"PageDown\") {\n      return max();\n    } else if (!event.metaKey && /^[0-9]$/.test(key)) {\n      return (max() - min()) / 10 * Number(key);\n    }\n    return null;\n  }\n  #calcNewKeyValue(event) {\n    const { key, shiftKey } = event;\n    event.preventDefault();\n    event.stopPropagation();\n    const { shiftKeyMultiplier } = this.$props;\n    const { min, max, value, pointerValue } = this.$state, step = this.#delegate.getStep(), keyStep = this.#delegate.getKeyStep();\n    const modifiedStep = !shiftKey ? keyStep : keyStep * shiftKeyMultiplier(), direction = Number(SliderKeyDirection[key]), diff = modifiedStep * direction, currentValue = this.#repeatedKeys ? pointerValue() : this.#delegate.getValue?.() ?? value(), steps = (currentValue + diff) / step;\n    return Math.max(min(), Math.min(max(), Number((step * steps).toFixed(3))));\n  }\n  // -------------------------------------------------------------------------------------------\n  // Document (Pointer Events)\n  // -------------------------------------------------------------------------------------------\n  #onDocumentPointerUp(event) {\n    if (event.button !== 0) return;\n    event.preventDefault();\n    event.stopImmediatePropagation();\n    const value = this.#getPointerValue(event);\n    this.#updatePointerValue(value, event);\n    this.#onStopDragging(value, event);\n  }\n  #onDocumentTouchMove(event) {\n    event.preventDefault();\n  }\n  #onDocumentPointerMove = functionThrottle(\n    (event) => {\n      this.#updatePointerValue(this.#getPointerValue(event), event);\n    },\n    20,\n    { leading: true }\n  );\n}\n\nconst sliderValueFormatContext = createContext(() => ({}));\n\nclass SliderController extends ViewController {\n  static props = {\n    hidden: false,\n    disabled: false,\n    step: 1,\n    keyStep: 1,\n    orientation: \"horizontal\",\n    shiftKeyMultiplier: 5\n  };\n  #media;\n  #delegate;\n  #isVisible = signal(true);\n  #isIntersecting = signal(true);\n  constructor(delegate) {\n    super();\n    this.#delegate = delegate;\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const focus = new FocusVisibleController();\n    focus.attach(this);\n    this.$state.focused = focus.focused.bind(focus);\n    if (!hasProvidedContext(sliderValueFormatContext)) {\n      provideContext(sliderValueFormatContext, {\n        default: \"value\"\n      });\n    }\n    provideContext(sliderContext, {\n      orientation: this.$props.orientation,\n      disabled: this.#delegate.isDisabled,\n      preview: signal(null)\n    });\n    effect(this.#watchValue.bind(this));\n    effect(this.#watchStep.bind(this));\n    effect(this.#watchDisabled.bind(this));\n    this.#setupAttrs();\n    new SliderEventsController(this.#delegate, this.#media).attach(this);\n    new IntersectionObserverController({\n      callback: this.#onIntersectionChange.bind(this)\n    }).attach(this);\n  }\n  onAttach(el) {\n    setAttributeIfEmpty(el, \"role\", \"slider\");\n    setAttributeIfEmpty(el, \"tabindex\", \"0\");\n    setAttributeIfEmpty(el, \"autocomplete\", \"off\");\n    effect(this.#watchCSSVars.bind(this));\n  }\n  onConnect(el) {\n    onDispose(observeVisibility(el, this.#isVisible.set));\n    effect(this.#watchHidden.bind(this));\n  }\n  #onIntersectionChange(entries) {\n    this.#isIntersecting.set(entries[0].isIntersecting);\n  }\n  // -------------------------------------------------------------------------------------------\n  // Watch\n  // -------------------------------------------------------------------------------------------\n  #watchHidden() {\n    const { hidden } = this.$props;\n    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting.bind(this));\n  }\n  #watchValue() {\n    const { dragging, value, min, max } = this.$state;\n    if (peek(dragging)) return;\n    value.set(getClampedValue(min(), max(), value(), this.#delegate.getStep()));\n  }\n  #watchStep() {\n    this.$state.step.set(this.#delegate.getStep());\n  }\n  #watchDisabled() {\n    if (!this.#delegate.isDisabled()) return;\n    const { dragging, pointing } = this.$state;\n    dragging.set(false);\n    pointing.set(false);\n  }\n  // -------------------------------------------------------------------------------------------\n  // ARIA\n  // -------------------------------------------------------------------------------------------\n  #getARIADisabled() {\n    return ariaBool(this.#delegate.isDisabled());\n  }\n  // -------------------------------------------------------------------------------------------\n  // Attributes\n  // -------------------------------------------------------------------------------------------\n  #setupAttrs() {\n    const { orientation } = this.$props, { dragging, active, pointing } = this.$state;\n    this.setAttributes({\n      \"data-dragging\": dragging,\n      \"data-pointing\": pointing,\n      \"data-active\": active,\n      \"aria-disabled\": this.#getARIADisabled.bind(this),\n      \"aria-valuemin\": this.#delegate.aria.valueMin ?? this.$state.min,\n      \"aria-valuemax\": this.#delegate.aria.valueMax ?? this.$state.max,\n      \"aria-valuenow\": this.#delegate.aria.valueNow,\n      \"aria-valuetext\": this.#delegate.aria.valueText,\n      \"aria-orientation\": orientation\n    });\n  }\n  #watchCSSVars() {\n    const { fillPercent, pointerPercent } = this.$state;\n    this.#updateSliderVars(round(fillPercent(), 3), round(pointerPercent(), 3));\n  }\n  #updateSliderVars = animationFrameThrottle((fillPercent, pointerPercent) => {\n    this.el?.style.setProperty(\"--slider-fill\", fillPercent + \"%\");\n    this.el?.style.setProperty(\"--slider-pointer\", pointerPercent + \"%\");\n  });\n}\n\nclass Slider extends Component {\n  static props = {\n    ...SliderController.props,\n    min: 0,\n    max: 100,\n    value: 0\n  };\n  static state = sliderState;\n  constructor() {\n    super();\n    new SliderController({\n      getStep: this.$props.step,\n      getKeyStep: this.$props.keyStep,\n      roundValue: Math.round,\n      isDisabled: this.$props.disabled,\n      aria: {\n        valueNow: this.#getARIAValueNow.bind(this),\n        valueText: this.#getARIAValueText.bind(this)\n      }\n    });\n  }\n  onSetup() {\n    effect(this.#watchValue.bind(this));\n    effect(this.#watchMinMax.bind(this));\n  }\n  // -------------------------------------------------------------------------------------------\n  // Props\n  // -------------------------------------------------------------------------------------------\n  #getARIAValueNow() {\n    const { value } = this.$state;\n    return Math.round(value());\n  }\n  #getARIAValueText() {\n    const { value, max } = this.$state;\n    return round(value() / max() * 100, 2) + \"%\";\n  }\n  // -------------------------------------------------------------------------------------------\n  // Watch\n  // -------------------------------------------------------------------------------------------\n  #watchValue() {\n    const { value } = this.$props;\n    this.$state.value.set(value());\n  }\n  #watchMinMax() {\n    const { min, max } = this.$props;\n    this.$state.min.set(min());\n    this.$state.max.set(max());\n  }\n}\n\nconst cache = /* @__PURE__ */ new Map(), pending = /* @__PURE__ */ new Map(), warned = /* @__PURE__ */ new Set() ;\nclass ThumbnailsLoader {\n  #media;\n  #src;\n  #crossOrigin;\n  $images = signal([]);\n  static create(src, crossOrigin) {\n    const media = useMediaContext();\n    return new ThumbnailsLoader(src, crossOrigin, media);\n  }\n  constructor(src, crossOrigin, media) {\n    this.#src = src;\n    this.#crossOrigin = crossOrigin;\n    this.#media = media;\n    effect(this.#onLoadCues.bind(this));\n  }\n  #onLoadCues() {\n    const { canLoad } = this.#media.$state;\n    if (!canLoad()) return;\n    const src = this.#src();\n    if (!src) return;\n    if (isString(src) && cache.has(src)) {\n      const cues = cache.get(src);\n      cache.delete(src);\n      cache.set(src, cues);\n      if (cache.size > 99) {\n        const firstKey = cache.keys().next().value;\n        cache.delete(firstKey);\n      }\n      this.$images.set(cache.get(src));\n    } else if (isString(src)) {\n      const crossOrigin = this.#crossOrigin(), currentKey = src + \"::\" + crossOrigin;\n      if (!pending.has(currentKey)) {\n        const promise = new Promise(async (resolve, reject) => {\n          try {\n            const response = await fetch(src, {\n              credentials: getRequestCredentials(crossOrigin)\n            }), isJSON = response.headers.get(\"content-type\") === \"application/json\";\n            if (isJSON) {\n              const json = await response.json();\n              if (isArray(json)) {\n                if (json[0] && \"text\" in json[0]) {\n                  resolve(this.#processVTTCues(json));\n                } else {\n                  for (let i = 0; i < json.length; i++) {\n                    const image = json[i];\n                    assert(isObject(image), `Item not an object at index ${i}`);\n                    assert(\n                      \"url\" in image && isString(image.url),\n                      `Invalid or missing \\`url\\` property at index ${i}`\n                    );\n                    assert(\n                      \"startTime\" in image && isNumber(image.startTime),\n                      `Invalid or missing \\`startTime\\` property at index ${i}`\n                    );\n                  }\n                  resolve(json);\n                }\n              } else {\n                resolve(this.#processStoryboard(json));\n              }\n              return;\n            }\n            import('media-captions').then(async ({ parseResponse }) => {\n              try {\n                const { cues } = await parseResponse(response);\n                resolve(this.#processVTTCues(cues));\n              } catch (e) {\n                reject(e);\n              }\n            });\n          } catch (e) {\n            reject(e);\n          }\n        }).then((images) => {\n          cache.set(currentKey, images);\n          return images;\n        }).catch((error) => {\n          this.#onError(src, error);\n        }).finally(() => {\n          if (isString(currentKey)) pending.delete(currentKey);\n        });\n        pending.set(currentKey, promise);\n      }\n      pending.get(currentKey)?.then((images) => {\n        this.$images.set(images || []);\n      });\n    } else if (isArray(src)) {\n      try {\n        this.$images.set(this.#processImages(src));\n      } catch (error) {\n        this.#onError(src, error);\n      }\n    } else {\n      try {\n        this.$images.set(this.#processStoryboard(src));\n      } catch (error) {\n        this.#onError(src, error);\n      }\n    }\n    return () => {\n      this.$images.set([]);\n    };\n  }\n  #processImages(images) {\n    const baseURL = this.#resolveBaseUrl();\n    return images.map((img, i) => {\n      assert(\n        img.url && isString(img.url),\n        `Invalid or missing \\`url\\` property at index ${i}`\n      );\n      assert(\n        \"startTime\" in img && isNumber(img.startTime),\n        `Invalid or missing \\`startTime\\` property at index ${i}`\n      );\n      return {\n        ...img,\n        url: isString(img.url) ? this.#resolveURL(img.url, baseURL) : img.url\n      };\n    });\n  }\n  #processStoryboard(board) {\n    assert(isString(board.url), \"Missing `url` in storyboard object\");\n    assert(isArray(board.tiles) && board.tiles?.length, `Empty tiles in storyboard`);\n    const url = new URL(board.url), images = [];\n    const tileWidth = \"tile_width\" in board ? board.tile_width : board.tileWidth, tileHeight = \"tile_height\" in board ? board.tile_height : board.tileHeight;\n    for (const tile of board.tiles) {\n      images.push({\n        url,\n        startTime: \"start\" in tile ? tile.start : tile.startTime,\n        width: tileWidth,\n        height: tileHeight,\n        coords: { x: tile.x, y: tile.y }\n      });\n    }\n    return images;\n  }\n  #processVTTCues(cues) {\n    for (let i = 0; i < cues.length; i++) {\n      const cue = cues[i];\n      assert(\n        \"startTime\" in cue && isNumber(cue.startTime),\n        `Invalid or missing \\`startTime\\` property at index ${i}`\n      );\n      assert(\n        \"text\" in cue && isString(cue.text),\n        `Invalid or missing \\`text\\` property at index ${i}`\n      );\n    }\n    const images = [], baseURL = this.#resolveBaseUrl();\n    for (const cue of cues) {\n      const [url, hash] = cue.text.split(\"#\"), data = this.#resolveData(hash);\n      images.push({\n        url: this.#resolveURL(url, baseURL),\n        startTime: cue.startTime,\n        endTime: cue.endTime,\n        width: data?.w,\n        height: data?.h,\n        coords: data && isNumber(data.x) && isNumber(data.y) ? { x: data.x, y: data.y } : void 0\n      });\n    }\n    return images;\n  }\n  #resolveBaseUrl() {\n    let baseURL = peek(this.#src);\n    if (!isString(baseURL) || !/^https?:/.test(baseURL)) {\n      return location.href;\n    }\n    return baseURL;\n  }\n  #resolveURL(src, baseURL) {\n    return /^https?:/.test(src) ? new URL(src) : new URL(src, baseURL);\n  }\n  #resolveData(hash) {\n    if (!hash) return {};\n    const [hashProps, values] = hash.split(\"=\"), hashValues = values?.split(\",\"), data = {};\n    if (!hashProps || !hashValues) {\n      return null;\n    }\n    for (let i = 0; i < hashProps.length; i++) {\n      const value = +hashValues[i];\n      if (!isNaN(value)) data[hashProps[i]] = value;\n    }\n    return data;\n  }\n  #onError(src, error) {\n    if (warned?.has(src)) return;\n    this.#media.logger?.errorGroup(\"[vidstack] failed to load thumbnails\").labelledLog(\"Src\", src).labelledLog(\"Error\", error).dispatch();\n    warned?.add(src);\n  }\n}\n\nclass Thumbnail extends Component {\n  static props = {\n    src: null,\n    time: 0,\n    crossOrigin: null\n  };\n  static state = new State({\n    src: \"\",\n    img: null,\n    thumbnails: [],\n    activeThumbnail: null,\n    crossOrigin: null,\n    loading: false,\n    error: null,\n    hidden: false\n  });\n  media;\n  #loader;\n  #styleResets = [];\n  onSetup() {\n    this.media = useMediaContext();\n    this.#loader = ThumbnailsLoader.create(this.$props.src, this.$state.crossOrigin);\n    this.#watchCrossOrigin();\n    this.setAttributes({\n      \"data-loading\": this.#isLoading.bind(this),\n      \"data-error\": this.#hasError.bind(this),\n      \"data-hidden\": this.$state.hidden,\n      \"aria-hidden\": $ariaBool(this.$state.hidden)\n    });\n  }\n  onConnect(el) {\n    effect(this.#watchImg.bind(this));\n    effect(this.#watchHidden.bind(this));\n    effect(this.#watchCrossOrigin.bind(this));\n    effect(this.#onLoadStart.bind(this));\n    effect(this.#onFindActiveThumbnail.bind(this));\n    effect(this.#resize.bind(this));\n  }\n  #watchImg() {\n    const img = this.$state.img();\n    if (!img) return;\n    new EventsController(img).add(\"load\", this.#onLoaded.bind(this)).add(\"error\", this.#onError.bind(this));\n  }\n  #watchCrossOrigin() {\n    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin } = this.media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();\n    crossOriginState.set(crossOrigin === true ? \"anonymous\" : crossOrigin);\n  }\n  #onLoadStart() {\n    const { src, loading, error } = this.$state;\n    if (src()) {\n      loading.set(true);\n      error.set(null);\n    }\n    return () => {\n      this.#resetStyles();\n      loading.set(false);\n      error.set(null);\n    };\n  }\n  #onLoaded() {\n    const { loading, error } = this.$state;\n    this.#resize();\n    loading.set(false);\n    error.set(null);\n  }\n  #onError(event) {\n    const { loading, error } = this.$state;\n    loading.set(false);\n    error.set(event);\n  }\n  #isLoading() {\n    const { loading, hidden } = this.$state;\n    return !hidden() && loading();\n  }\n  #hasError() {\n    const { error } = this.$state;\n    return !isNull(error());\n  }\n  #watchHidden() {\n    const { hidden } = this.$state, { duration } = this.media.$state, images = this.#loader.$images();\n    hidden.set(this.#hasError() || !Number.isFinite(duration()) || images.length === 0);\n  }\n  getTime() {\n    return this.$props.time();\n  }\n  #onFindActiveThumbnail() {\n    let images = this.#loader.$images();\n    if (!images.length) return;\n    let time = this.getTime(), { src, activeThumbnail } = this.$state, activeIndex = -1, activeImage = null;\n    for (let i = images.length - 1; i >= 0; i--) {\n      const image = images[i];\n      if (time >= image.startTime && (!image.endTime || time < image.endTime)) {\n        activeIndex = i;\n        break;\n      }\n    }\n    if (images[activeIndex]) {\n      activeImage = images[activeIndex];\n    }\n    activeThumbnail.set(activeImage);\n    src.set(activeImage?.url.href || \"\");\n  }\n  #resize() {\n    if (!this.scope || this.$state.hidden()) return;\n    const rootEl = this.el, imgEl = this.$state.img(), thumbnail = this.$state.activeThumbnail();\n    if (!imgEl || !thumbnail || !rootEl) return;\n    let width = thumbnail.width ?? imgEl.naturalWidth, height = thumbnail?.height ?? imgEl.naturalHeight, {\n      maxWidth,\n      maxHeight,\n      minWidth,\n      minHeight,\n      width: elWidth,\n      height: elHeight\n    } = getComputedStyle(this.el);\n    if (minWidth === \"100%\") minWidth = parseFloat(elWidth) + \"\";\n    if (minHeight === \"100%\") minHeight = parseFloat(elHeight) + \"\";\n    let minRatio = Math.max(parseInt(minWidth) / width, parseInt(minHeight) / height), maxRatio = Math.min(\n      Math.max(parseInt(minWidth), parseInt(maxWidth)) / width,\n      Math.max(parseInt(minHeight), parseInt(maxHeight)) / height\n    ), scale = !isNaN(maxRatio) && maxRatio < 1 ? maxRatio : minRatio > 1 ? minRatio : 1;\n    this.#style(rootEl, \"--thumbnail-width\", `${width * scale}px`);\n    this.#style(rootEl, \"--thumbnail-height\", `${height * scale}px`);\n    this.#style(imgEl, \"width\", `${imgEl.naturalWidth * scale}px`);\n    this.#style(imgEl, \"height\", `${imgEl.naturalHeight * scale}px`);\n    this.#style(\n      imgEl,\n      \"transform\",\n      thumbnail.coords ? `translate(-${thumbnail.coords.x * scale}px, -${thumbnail.coords.y * scale}px)` : \"\"\n    );\n    this.#style(imgEl, \"max-width\", \"none\");\n  }\n  #style(el, name, value) {\n    el.style.setProperty(name, value);\n    this.#styleResets.push(() => el.style.removeProperty(name));\n  }\n  #resetStyles() {\n    for (const reset of this.#styleResets) reset();\n    this.#styleResets = [];\n  }\n}\n\nclass SliderValue extends Component {\n  static props = {\n    type: \"pointer\",\n    format: null,\n    showHours: false,\n    showMs: false,\n    padHours: null,\n    padMinutes: null,\n    decimalPlaces: 2\n  };\n  #format;\n  #text;\n  #slider;\n  onSetup() {\n    this.#slider = useState(Slider.state);\n    this.#format = useContext(sliderValueFormatContext);\n    this.#text = computed(this.getValueText.bind(this));\n  }\n  /**\n   * Returns the current value formatted as text based on prop settings.\n   */\n  getValueText() {\n    const {\n      type,\n      format: $format,\n      decimalPlaces,\n      padHours,\n      padMinutes,\n      showHours,\n      showMs\n    } = this.$props, { value: sliderValue, pointerValue, min, max } = this.#slider, format = $format?.() ?? this.#format.default;\n    const value = type() === \"current\" ? sliderValue() : pointerValue();\n    if (format === \"percent\") {\n      const range = max() - min();\n      const percent = value / range * 100;\n      return (this.#format.percent ?? round)(percent, decimalPlaces()) + \"%\";\n    } else if (format === \"time\") {\n      return (this.#format.time ?? formatTime)(value, {\n        padHrs: padHours(),\n        padMins: padMinutes(),\n        showHrs: showHours(),\n        showMs: showMs()\n      });\n    } else {\n      return (this.#format.value?.(value) ?? value.toFixed(2)) + \"\";\n    }\n  }\n}\nconst slidervalue__proto = SliderValue.prototype;\nmethod(slidervalue__proto, \"getValueText\");\n\nclass SliderPreview extends Component {\n  static props = {\n    offset: 0,\n    noClamp: false\n  };\n  #slider;\n  onSetup() {\n    this.#slider = useContext(sliderContext);\n    const { active } = useState(Slider.state);\n    this.setAttributes({\n      \"data-visible\": active\n    });\n  }\n  onAttach(el) {\n    Object.assign(el.style, {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: \"max-content\"\n    });\n  }\n  onConnect(el) {\n    const { preview } = this.#slider;\n    preview.set(el);\n    onDispose(() => preview.set(null));\n    effect(this.#updatePlacement.bind(this));\n    const resize = new ResizeObserver(this.#updatePlacement.bind(this));\n    resize.observe(el);\n    onDispose(() => resize.disconnect());\n  }\n  #updatePlacement = animationFrameThrottle(() => {\n    const { disabled, orientation } = this.#slider;\n    if (disabled()) return;\n    const el = this.el, { offset, noClamp } = this.$props;\n    if (!el) return;\n    updateSliderPreviewPlacement(el, {\n      clamp: !noClamp(),\n      offset: offset(),\n      orientation: orientation()\n    });\n  });\n}\nfunction updateSliderPreviewPlacement(el, {\n  clamp,\n  offset,\n  orientation\n}) {\n  const computedStyle = getComputedStyle(el), width = parseFloat(computedStyle.width), height = parseFloat(computedStyle.height), styles = {\n    top: null,\n    right: null,\n    bottom: null,\n    left: null\n  };\n  styles[orientation === \"horizontal\" ? \"bottom\" : \"left\"] = `calc(100% + var(--media-slider-preview-offset, ${offset}px))`;\n  if (orientation === \"horizontal\") {\n    const widthHalf = width / 2;\n    if (!clamp) {\n      styles.left = `calc(var(--slider-pointer) - ${widthHalf}px)`;\n    } else {\n      const leftClamp = `max(0px, calc(var(--slider-pointer) - ${widthHalf}px))`, rightClamp = `calc(100% - ${width}px)`;\n      styles.left = `min(${leftClamp}, ${rightClamp})`;\n    }\n  } else {\n    const heightHalf = height / 2;\n    if (!clamp) {\n      styles.bottom = `calc(var(--slider-pointer) - ${heightHalf}px)`;\n    } else {\n      const topClamp = `max(${heightHalf}px, calc(var(--slider-pointer) - ${heightHalf}px))`, bottomClamp = `calc(100% - ${height}px)`;\n      styles.bottom = `min(${topClamp}, ${bottomClamp})`;\n    }\n  }\n  Object.assign(el.style, styles);\n}\n\nclass VolumeSlider extends Component {\n  static props = {\n    ...SliderController.props,\n    keyStep: 5,\n    shiftKeyMultiplier: 2\n  };\n  static state = sliderState;\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n    const { audioGain } = this.#media.$state;\n    provideContext(sliderValueFormatContext, {\n      default: \"percent\",\n      value(value) {\n        return (value * (audioGain() ?? 1)).toFixed(2);\n      },\n      percent(value) {\n        return Math.round(value * (audioGain() ?? 1));\n      }\n    });\n    new SliderController({\n      getStep: this.$props.step,\n      getKeyStep: this.$props.keyStep,\n      roundValue: Math.round,\n      isDisabled: this.#isDisabled.bind(this),\n      aria: {\n        valueMax: this.#getARIAValueMax.bind(this),\n        valueNow: this.#getARIAValueNow.bind(this),\n        valueText: this.#getARIAValueText.bind(this)\n      },\n      onDragValueChange: this.#onDragValueChange.bind(this),\n      onValueChange: this.#onValueChange.bind(this)\n    }).attach(this);\n    effect(this.#watchVolume.bind(this));\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-volume-slider\", \"\");\n    setAttributeIfEmpty(el, \"aria-label\", \"Volume\");\n    const { canSetVolume } = this.#media.$state;\n    this.setAttributes({\n      \"data-supported\": canSetVolume,\n      \"aria-hidden\": $ariaBool(() => !canSetVolume())\n    });\n  }\n  #getARIAValueNow() {\n    const { value } = this.$state, { audioGain } = this.#media.$state;\n    return Math.round(value() * (audioGain() ?? 1));\n  }\n  #getARIAValueText() {\n    const { value, max } = this.$state, { audioGain } = this.#media.$state;\n    return round(value() / max() * (audioGain() ?? 1) * 100, 2) + \"%\";\n  }\n  #getARIAValueMax() {\n    const { audioGain } = this.#media.$state;\n    return this.$state.max() * (audioGain() ?? 1);\n  }\n  #isDisabled() {\n    const { disabled } = this.$props, { canSetVolume } = this.#media.$state;\n    return disabled() || !canSetVolume();\n  }\n  #watchVolume() {\n    const { muted, volume } = this.#media.$state;\n    const newValue = muted() ? 0 : volume() * 100;\n    this.$state.value.set(newValue);\n    this.dispatch(\"value-change\", { detail: newValue });\n  }\n  #throttleVolumeChange = functionThrottle(this.#onVolumeChange.bind(this), 25);\n  #onVolumeChange(event) {\n    if (!event.trigger) return;\n    const mediaVolume = round(event.detail / 100, 3);\n    this.#media.remote.changeVolume(mediaVolume, event);\n  }\n  #onValueChange(event) {\n    this.#throttleVolumeChange(event);\n  }\n  #onDragValueChange(event) {\n    this.#throttleVolumeChange(event);\n  }\n}\n\nclass TimeSlider extends Component {\n  static props = {\n    ...SliderController.props,\n    step: 0.1,\n    keyStep: 5,\n    shiftKeyMultiplier: 2,\n    pauseWhileDragging: false,\n    noSwipeGesture: false,\n    seekingRequestThrottle: 100\n  };\n  static state = sliderState;\n  #media;\n  #dispatchSeeking;\n  #chapter = signal(null);\n  constructor() {\n    super();\n    const { noSwipeGesture } = this.$props;\n    new SliderController({\n      swipeGesture: () => !noSwipeGesture(),\n      getValue: this.#getValue.bind(this),\n      getStep: this.#getStep.bind(this),\n      getKeyStep: this.#getKeyStep.bind(this),\n      roundValue: this.#roundValue,\n      isDisabled: this.#isDisabled.bind(this),\n      aria: {\n        valueNow: this.#getARIAValueNow.bind(this),\n        valueText: this.#getARIAValueText.bind(this)\n      },\n      onDragStart: this.#onDragStart.bind(this),\n      onDragValueChange: this.#onDragValueChange.bind(this),\n      onDragEnd: this.#onDragEnd.bind(this),\n      onValueChange: this.#onValueChange.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    provideContext(sliderValueFormatContext, {\n      default: \"time\",\n      value: this.#formatValue.bind(this),\n      time: this.#formatTime.bind(this)\n    });\n    this.setAttributes({\n      \"data-chapters\": this.#hasChapters.bind(this)\n    });\n    this.setStyles({\n      \"--slider-progress\": this.#calcBufferedPercent.bind(this)\n    });\n    effect(this.#watchCurrentTime.bind(this));\n    effect(this.#watchSeekingThrottle.bind(this));\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-time-slider\", \"\");\n    setAttributeIfEmpty(el, \"aria-label\", \"Seek\");\n  }\n  onConnect(el) {\n    effect(this.#watchPreviewing.bind(this));\n    watchActiveTextTrack(this.#media.textTracks, \"chapters\", this.#chapter.set);\n  }\n  #calcBufferedPercent() {\n    const { bufferedEnd, duration } = this.#media.$state;\n    return round(Math.min(bufferedEnd() / Math.max(duration(), 1), 1) * 100, 3) + \"%\";\n  }\n  #hasChapters() {\n    const { duration } = this.#media.$state;\n    return this.#chapter()?.cues.length && Number.isFinite(duration()) && duration() > 0;\n  }\n  #watchSeekingThrottle() {\n    this.#dispatchSeeking = functionThrottle(\n      this.#seeking.bind(this),\n      this.$props.seekingRequestThrottle()\n    );\n  }\n  #watchCurrentTime() {\n    if (this.$state.hidden()) return;\n    const { value, dragging } = this.$state, newValue = this.#getValue();\n    if (!peek(dragging)) {\n      value.set(newValue);\n      this.dispatch(\"value-change\", { detail: newValue });\n    }\n  }\n  #watchPreviewing() {\n    const player = this.#media.player.el, { preview } = useContext(sliderContext);\n    player && preview() && setAttribute(player, \"data-preview\", this.$state.active());\n  }\n  #seeking(time, event) {\n    this.#media.remote.seeking(time, event);\n  }\n  #seek(time, percent, event) {\n    this.#dispatchSeeking.cancel();\n    const { live } = this.#media.$state;\n    if (live() && percent >= 99) {\n      this.#media.remote.seekToLiveEdge(event);\n      return;\n    }\n    this.#media.remote.seek(time, event);\n  }\n  #playingBeforeDragStart = false;\n  #onDragStart(event) {\n    const { pauseWhileDragging } = this.$props;\n    if (pauseWhileDragging()) {\n      const { paused } = this.#media.$state;\n      this.#playingBeforeDragStart = !paused();\n      this.#media.remote.pause(event);\n    }\n  }\n  #onDragValueChange(event) {\n    this.#dispatchSeeking(this.#percentToTime(event.detail), event);\n  }\n  #onDragEnd(event) {\n    const { seeking } = this.#media.$state;\n    if (!peek(seeking)) this.#seeking(this.#percentToTime(event.detail), event);\n    const percent = event.detail;\n    this.#seek(this.#percentToTime(percent), percent, event);\n    const { pauseWhileDragging } = this.$props;\n    if (pauseWhileDragging() && this.#playingBeforeDragStart) {\n      this.#media.remote.play(event);\n      this.#playingBeforeDragStart = false;\n    }\n  }\n  #onValueChange(event) {\n    const { dragging } = this.$state;\n    if (dragging() || !event.trigger) return;\n    this.#onDragEnd(event);\n  }\n  // -------------------------------------------------------------------------------------------\n  // Props\n  // -------------------------------------------------------------------------------------------\n  #getValue() {\n    const { currentTime } = this.#media.$state;\n    return this.#timeToPercent(currentTime());\n  }\n  #getStep() {\n    const value = this.$props.step() / this.#media.$state.duration() * 100;\n    return Number.isFinite(value) ? value : 1;\n  }\n  #getKeyStep() {\n    const value = this.$props.keyStep() / this.#media.$state.duration() * 100;\n    return Number.isFinite(value) ? value : 1;\n  }\n  #roundValue(value) {\n    return round(value, 3);\n  }\n  #isDisabled() {\n    const { disabled } = this.$props, { canSeek } = this.#media.$state;\n    return disabled() || !canSeek();\n  }\n  // -------------------------------------------------------------------------------------------\n  // ARIA\n  // -------------------------------------------------------------------------------------------\n  #getARIAValueNow() {\n    const { value } = this.$state;\n    return Math.round(value());\n  }\n  #getARIAValueText() {\n    const time = this.#percentToTime(this.$state.value()), { duration } = this.#media.$state;\n    return Number.isFinite(time) ? `${formatSpokenTime(time)} out of ${formatSpokenTime(duration())}` : \"live\";\n  }\n  // -------------------------------------------------------------------------------------------\n  // Format\n  // -------------------------------------------------------------------------------------------\n  #percentToTime(percent) {\n    const { duration } = this.#media.$state;\n    return round(percent / 100 * duration(), 5);\n  }\n  #timeToPercent(time) {\n    const { liveEdge, duration } = this.#media.$state, rate = Math.max(0, Math.min(1, liveEdge() ? 1 : Math.min(time, duration()) / duration()));\n    return Number.isNaN(rate) ? 0 : Number.isFinite(rate) ? rate * 100 : 100;\n  }\n  #formatValue(percent) {\n    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state;\n    return Number.isFinite(time) ? (live() ? time - duration() : time).toFixed(0) : \"LIVE\";\n  }\n  #formatTime(percent, options) {\n    const time = this.#percentToTime(percent), { live, duration } = this.#media.$state, value = live() ? time - duration() : time;\n    return Number.isFinite(time) ? `${value < 0 ? \"-\" : \"\"}${formatTime(Math.abs(value), options)}` : \"LIVE\";\n  }\n}\n\nconst menuContext = createContext();\n\nfunction scrollIntoView(el, options) {\n  const scrolls = r(el, options);\n  for (const { el: el2, top, left } of scrolls) {\n    el2.scroll({ top, left, behavior: options.behavior });\n  }\n}\nfunction scrollIntoCenter(el, options = {}) {\n  scrollIntoView(el, {\n    scrollMode: \"if-needed\",\n    block: \"center\",\n    inline: \"center\",\n    ...options\n  });\n}\n\nconst FOCUSABLE_ELEMENTS_SELECTOR = /* @__PURE__ */ [\n  \"a[href]\",\n  \"[tabindex]\",\n  \"input\",\n  \"select\",\n  \"button\"\n].map((selector) => `${selector}:not([aria-hidden='true'])`).join(\",\");\nconst VALID_KEYS = /* @__PURE__ */ new Set([\n  \"Escape\",\n  \"Tab\",\n  \"ArrowUp\",\n  \"ArrowDown\",\n  \"Home\",\n  \"PageUp\",\n  \"End\",\n  \"PageDown\",\n  \"Enter\",\n  \" \"\n]);\nclass MenuFocusController {\n  #index = -1;\n  #el = null;\n  #elements = [];\n  #delegate;\n  get items() {\n    return this.#elements;\n  }\n  constructor(delegate) {\n    this.#delegate = delegate;\n  }\n  attachMenu(el) {\n    listenEvent(el, \"focus\", this.#onFocus.bind(this));\n    this.#el = el;\n    onDispose(() => {\n      this.#el = null;\n    });\n  }\n  listen() {\n    if (!this.#el) return;\n    this.update();\n    new EventsController(this.#el).add(\"keyup\", this.#onKeyUp.bind(this)).add(\"keydown\", this.#onKeyDown.bind(this));\n    onDispose(() => {\n      this.#index = -1;\n      this.#elements = [];\n    });\n  }\n  update() {\n    this.#index = 0;\n    this.#elements = this.#getFocusableElements();\n  }\n  scroll(index = this.#findActiveIndex()) {\n    const element = this.#elements[index];\n    if (element) {\n      requestAnimationFrame(() => {\n        requestAnimationFrame(() => {\n          scrollIntoCenter(element, {\n            behavior: \"smooth\",\n            boundary: (el) => {\n              return !el.hasAttribute(\"data-root\");\n            }\n          });\n        });\n      });\n    }\n  }\n  focusActive(scroll = true) {\n    const index = this.#findActiveIndex();\n    this.#focusAt(index >= 0 ? index : 0, scroll);\n  }\n  #focusAt(index, scroll = true) {\n    this.#index = index;\n    if (this.#elements[index]) {\n      this.#elements[index].focus({ preventScroll: true });\n      if (scroll) this.scroll(index);\n    } else {\n      this.#el?.focus({ preventScroll: true });\n    }\n  }\n  #findActiveIndex() {\n    return this.#elements.findIndex(\n      (el) => document.activeElement === el || el.getAttribute(\"role\") === \"menuitemradio\" && el.getAttribute(\"aria-checked\") === \"true\"\n    );\n  }\n  #onFocus() {\n    if (this.#index >= 0) return;\n    this.update();\n    this.focusActive();\n  }\n  #validateKeyEvent(event) {\n    const el = event.target;\n    if (wasEnterKeyPressed(event) && el instanceof Element) {\n      const role = el.getAttribute(\"role\");\n      return !/a|input|select|button/.test(el.localName) && !role;\n    }\n    return VALID_KEYS.has(event.key);\n  }\n  #onKeyUp(event) {\n    if (!this.#validateKeyEvent(event)) return;\n    event.stopPropagation();\n    event.preventDefault();\n  }\n  #onKeyDown(event) {\n    if (!this.#validateKeyEvent(event)) return;\n    event.stopPropagation();\n    event.preventDefault();\n    switch (event.key) {\n      case \"Escape\":\n        this.#delegate.closeMenu(event);\n        break;\n      case \"Tab\":\n        this.#focusAt(this.#nextIndex(event.shiftKey ? -1 : 1));\n        break;\n      case \"ArrowUp\":\n        this.#focusAt(this.#nextIndex(-1));\n        break;\n      case \"ArrowDown\":\n        this.#focusAt(this.#nextIndex(1));\n        break;\n      case \"Home\":\n      case \"PageUp\":\n        this.#focusAt(0);\n        break;\n      case \"End\":\n      case \"PageDown\":\n        this.#focusAt(this.#elements.length - 1);\n        break;\n    }\n  }\n  #nextIndex(delta) {\n    let index = this.#index;\n    do {\n      index = (index + delta + this.#elements.length) % this.#elements.length;\n    } while (this.#elements[index]?.offsetParent === null);\n    return index;\n  }\n  #getFocusableElements() {\n    if (!this.#el) return [];\n    const focusableElements = this.#el.querySelectorAll(FOCUSABLE_ELEMENTS_SELECTOR), elements = [];\n    const is = (node) => {\n      return node.getAttribute(\"role\") === \"menu\";\n    };\n    for (const el of focusableElements) {\n      if (isHTMLElement(el) && el.offsetParent !== null && // does not have display: none\n      isElementParent(this.#el, el, is)) {\n        elements.push(el);\n      }\n    }\n    return elements;\n  }\n}\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropDesc = Object.getOwnPropertyDescriptor;\nvar __decorateClass = (decorators, target, key, kind) => {\n  var result = __getOwnPropDesc(target, key) ;\n  for (var i = decorators.length - 1, decorator; i >= 0; i--)\n    if (decorator = decorators[i])\n      result = (decorator(target, key, result) ) || result;\n  if (result) __defProp(target, key, result);\n  return result;\n};\nlet idCount = 0;\nclass Menu extends Component {\n  static props = {\n    showDelay: 0\n  };\n  #media;\n  #menuId;\n  #menuButtonId;\n  #expanded = signal(false);\n  #disabled = signal(false);\n  #trigger = signal(null);\n  #content = signal(null);\n  #parentMenu;\n  #submenus = /* @__PURE__ */ new Set();\n  #menuObserver = null;\n  #popper;\n  #focus;\n  #isSliderActive = false;\n  #isTriggerDisabled = signal(false);\n  #transitionCallbacks = /* @__PURE__ */ new Set();\n  get triggerElement() {\n    return this.#trigger();\n  }\n  get contentElement() {\n    return this.#content();\n  }\n  get isSubmenu() {\n    return !!this.#parentMenu;\n  }\n  constructor() {\n    super();\n    const { showDelay } = this.$props;\n    this.#popper = new Popper({\n      trigger: this.#trigger,\n      content: this.#content,\n      showDelay,\n      listen: (trigger, show, hide) => {\n        onPress(trigger, (event) => {\n          if (this.#expanded()) hide(event);\n          else show(event);\n        });\n        const closeTarget = this.#getCloseTarget();\n        if (closeTarget) {\n          onPress(closeTarget, (event) => {\n            event.stopPropagation();\n            hide(event);\n          });\n        }\n      },\n      onChange: this.#onExpandedChange.bind(this)\n    });\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    const currentIdCount = ++idCount;\n    this.#menuId = `media-menu-${currentIdCount}`;\n    this.#menuButtonId = `media-menu-button-${currentIdCount}`;\n    this.#focus = new MenuFocusController({\n      closeMenu: this.close.bind(this)\n    });\n    if (hasProvidedContext(menuContext)) {\n      this.#parentMenu = useContext(menuContext);\n    }\n    this.#observeSliders();\n    this.setAttributes({\n      \"data-open\": this.#expanded,\n      \"data-root\": !this.isSubmenu,\n      \"data-submenu\": this.isSubmenu,\n      \"data-disabled\": this.#isDisabled.bind(this)\n    });\n    provideContext(menuContext, {\n      button: this.#trigger,\n      content: this.#content,\n      expanded: this.#expanded,\n      hint: signal(\"\"),\n      submenu: !!this.#parentMenu,\n      disable: this.#disable.bind(this),\n      attachMenuButton: this.#attachMenuButton.bind(this),\n      attachMenuItems: this.#attachMenuItems.bind(this),\n      attachObserver: this.#attachObserver.bind(this),\n      disableMenuButton: this.#disableMenuButton.bind(this),\n      addSubmenu: this.#addSubmenu.bind(this),\n      onTransitionEvent: (callback) => {\n        this.#transitionCallbacks.add(callback);\n        onDispose(() => {\n          this.#transitionCallbacks.delete(callback);\n        });\n      }\n    });\n  }\n  onAttach(el) {\n    el.style.setProperty(\"display\", \"contents\");\n  }\n  onConnect(el) {\n    effect(this.#watchExpanded.bind(this));\n    if (this.isSubmenu) {\n      this.#parentMenu?.addSubmenu(this);\n    }\n  }\n  onDestroy() {\n    this.#trigger.set(null);\n    this.#content.set(null);\n    this.#menuObserver = null;\n    this.#transitionCallbacks.clear();\n  }\n  #observeSliders() {\n    let sliderActiveTimer = -1, parentSliderObserver = hasProvidedContext(sliderObserverContext) ? useContext(sliderObserverContext) : null;\n    provideContext(sliderObserverContext, {\n      onDragStart: () => {\n        parentSliderObserver?.onDragStart?.();\n        window.clearTimeout(sliderActiveTimer);\n        sliderActiveTimer = -1;\n        this.#isSliderActive = true;\n      },\n      onDragEnd: () => {\n        parentSliderObserver?.onDragEnd?.();\n        sliderActiveTimer = window.setTimeout(() => {\n          this.#isSliderActive = false;\n          sliderActiveTimer = -1;\n        }, 300);\n      }\n    });\n  }\n  #watchExpanded() {\n    const expanded = this.#isExpanded();\n    if (!this.isSubmenu) this.#onResize();\n    this.#updateMenuItemsHidden(expanded);\n    if (!expanded) return;\n    effect(() => {\n      const { height } = this.#media.$state, content = this.#content();\n      content && setStyle(content, \"--player-height\", height() + \"px\");\n    });\n    this.#focus.listen();\n    this.listen(\"pointerup\", this.#onPointerUp.bind(this));\n    listenEvent(window, \"pointerup\", this.#onWindowPointerUp.bind(this));\n  }\n  #attachMenuButton(button) {\n    const el = button.el, isMenuItem = this.isSubmenu, isARIADisabled = $ariaBool(this.#isDisabled.bind(this));\n    setAttributeIfEmpty(el, \"tabindex\", isMenuItem ? \"-1\" : \"0\");\n    setAttributeIfEmpty(el, \"role\", isMenuItem ? \"menuitem\" : \"button\");\n    setAttribute(el, \"id\", this.#menuButtonId);\n    setAttribute(el, \"aria-haspopup\", \"menu\");\n    setAttribute(el, \"aria-expanded\", \"false\");\n    setAttribute(el, \"data-root\", !this.isSubmenu);\n    setAttribute(el, \"data-submenu\", this.isSubmenu);\n    const watchAttrs = () => {\n      setAttribute(el, \"data-open\", this.#expanded());\n      setAttribute(el, \"aria-disabled\", isARIADisabled());\n    };\n    effect(watchAttrs);\n    this.#trigger.set(el);\n    onDispose(() => {\n      this.#trigger.set(null);\n    });\n  }\n  #attachMenuItems(items) {\n    const el = items.el;\n    el.style.setProperty(\"display\", \"none\");\n    setAttribute(el, \"id\", this.#menuId);\n    setAttributeIfEmpty(el, \"role\", \"menu\");\n    setAttributeIfEmpty(el, \"tabindex\", \"-1\");\n    setAttribute(el, \"data-root\", !this.isSubmenu);\n    setAttribute(el, \"data-submenu\", this.isSubmenu);\n    this.#content.set(el);\n    onDispose(() => this.#content.set(null));\n    const watchAttrs = () => setAttribute(el, \"data-open\", this.#expanded());\n    effect(watchAttrs);\n    this.#focus.attachMenu(el);\n    this.#updateMenuItemsHidden(false);\n    const onTransition = this.#onResizeTransition.bind(this);\n    if (!this.isSubmenu) {\n      items.listen(\"transitionstart\", onTransition);\n      items.listen(\"transitionend\", onTransition);\n      items.listen(\"animationend\", this.#onResize);\n      items.listen(\"vds-menu-resize\", this.#onResize);\n    } else {\n      this.#parentMenu?.onTransitionEvent(onTransition);\n    }\n  }\n  #attachObserver(observer) {\n    this.#menuObserver = observer;\n  }\n  #updateMenuItemsHidden(expanded) {\n    const content = peek(this.#content);\n    if (content) setAttribute(content, \"aria-hidden\", ariaBool(!expanded));\n  }\n  #disableMenuButton(disabled) {\n    this.#isTriggerDisabled.set(disabled);\n  }\n  #wasKeyboardExpand = false;\n  #onExpandedChange(isExpanded, event) {\n    this.#wasKeyboardExpand = isKeyboardEvent(event);\n    event?.stopPropagation();\n    if (this.#expanded() === isExpanded) return;\n    if (this.#isDisabled()) {\n      if (isExpanded) this.#popper.hide(event);\n      return;\n    }\n    this.el?.dispatchEvent(\n      new Event(\"vds-menu-resize\", {\n        bubbles: true,\n        composed: true\n      })\n    );\n    const trigger = this.#trigger(), content = this.#content();\n    if (trigger) {\n      setAttribute(trigger, \"aria-controls\", isExpanded && this.#menuId);\n      setAttribute(trigger, \"aria-expanded\", ariaBool(isExpanded));\n    }\n    if (content) setAttribute(content, \"aria-labelledby\", isExpanded && this.#menuButtonId);\n    this.#expanded.set(isExpanded);\n    this.#toggleMediaControls(event);\n    tick();\n    if (this.#wasKeyboardExpand) {\n      if (isExpanded) content?.focus();\n      else trigger?.focus();\n      for (const el of [this.el, content]) {\n        el && el.setAttribute(\"data-keyboard\", \"\");\n      }\n    } else {\n      for (const el of [this.el, content]) {\n        el && el.removeAttribute(\"data-keyboard\");\n      }\n    }\n    this.dispatch(isExpanded ? \"open\" : \"close\", { trigger: event });\n    if (isExpanded) {\n      if (!this.isSubmenu && this.#media.activeMenu !== this) {\n        this.#media.activeMenu?.close(event);\n        this.#media.activeMenu = this;\n      }\n      this.#menuObserver?.onOpen?.(event);\n    } else {\n      if (this.isSubmenu) {\n        for (const el of this.#submenus) el.close(event);\n      } else {\n        this.#media.activeMenu = null;\n      }\n      this.#menuObserver?.onClose?.(event);\n    }\n    if (isExpanded) {\n      requestAnimationFrame(this.#updateFocus.bind(this));\n    }\n  }\n  #updateFocus() {\n    if (this.#isTransitionActive || this.#isSubmenuOpen) return;\n    this.#focus.update();\n    requestAnimationFrame(() => {\n      if (this.#wasKeyboardExpand) {\n        this.#focus.focusActive();\n      } else {\n        this.#focus.scroll();\n      }\n    });\n  }\n  #isExpanded() {\n    return !this.#isDisabled() && this.#expanded();\n  }\n  #isDisabled() {\n    return this.#disabled() || this.#isTriggerDisabled();\n  }\n  #disable(disabled) {\n    this.#disabled.set(disabled);\n  }\n  #onPointerUp(event) {\n    const content = this.#content();\n    if (this.#isSliderActive || content && isEventInside(content, event)) {\n      return;\n    }\n    event.stopPropagation();\n  }\n  #onWindowPointerUp(event) {\n    const content = this.#content();\n    if (this.#isSliderActive || content && isEventInside(content, event)) {\n      return;\n    }\n    this.close(event);\n  }\n  #getCloseTarget() {\n    const target = this.el?.querySelector('[data-part=\"close-target\"]');\n    return this.el && target && isElementParent(this.el, target, (node) => node.getAttribute(\"role\") === \"menu\") ? target : null;\n  }\n  #toggleMediaControls(trigger) {\n    if (this.isSubmenu) return;\n    if (this.#expanded()) this.#media.remote.pauseControls(trigger);\n    else this.#media.remote.resumeControls(trigger);\n  }\n  #addSubmenu(menu) {\n    this.#submenus.add(menu);\n    new EventsController(menu).add(\"open\", this.#onSubmenuOpenBind).add(\"close\", this.#onSubmenuCloseBind);\n    onDispose(this.#removeSubmenuBind);\n  }\n  #removeSubmenuBind = this.#removeSubmenu.bind(this);\n  #removeSubmenu(menu) {\n    this.#submenus.delete(menu);\n  }\n  #isSubmenuOpen = false;\n  #onSubmenuOpenBind = this.#onSubmenuOpen.bind(this);\n  #onSubmenuOpen(event) {\n    this.#isSubmenuOpen = true;\n    const content = this.#content();\n    if (this.isSubmenu) {\n      this.triggerElement?.setAttribute(\"aria-hidden\", \"true\");\n    }\n    for (const target of this.#submenus) {\n      if (target !== event.target) {\n        for (const el of [target.el, target.triggerElement]) {\n          el?.setAttribute(\"aria-hidden\", \"true\");\n        }\n      }\n    }\n    if (content) {\n      const el = event.target.el;\n      for (const child of content.children) {\n        if (child.contains(el)) {\n          child.setAttribute(\"data-open\", \"\");\n        } else if (child !== el) {\n          child.setAttribute(\"data-hidden\", \"\");\n        }\n      }\n    }\n  }\n  #onSubmenuCloseBind = this.#onSubmenuClose.bind(this);\n  #onSubmenuClose(event) {\n    this.#isSubmenuOpen = false;\n    const content = this.#content();\n    if (this.isSubmenu) {\n      this.triggerElement?.setAttribute(\"aria-hidden\", \"false\");\n    }\n    for (const target of this.#submenus) {\n      for (const el of [target.el, target.triggerElement]) {\n        el?.setAttribute(\"aria-hidden\", \"false\");\n      }\n    }\n    if (content) {\n      for (const child of content.children) {\n        child.removeAttribute(\"data-open\");\n        child.removeAttribute(\"data-hidden\");\n      }\n    }\n  }\n  #onResize = animationFrameThrottle(() => {\n    const content = peek(this.#content);\n    if (!content || false) return;\n    let height = 0, styles = getComputedStyle(content), children = [...content.children];\n    for (const prop2 of [\"paddingTop\", \"paddingBottom\", \"borderTopWidth\", \"borderBottomWidth\"]) {\n      height += parseFloat(styles[prop2]) || 0;\n    }\n    for (const child of children) {\n      if (isHTMLElement(child) && child.style.display === \"contents\") {\n        children.push(...child.children);\n      } else if (child.nodeType === 3) {\n        height += parseFloat(getComputedStyle(child).fontSize);\n      } else if (isHTMLElement(child)) {\n        if (!isElementVisible(child)) continue;\n        const style = getComputedStyle(child);\n        height += child.offsetHeight + (parseFloat(style.marginTop) || 0) + (parseFloat(style.marginBottom) || 0);\n      }\n    }\n    setStyle(content, \"--menu-height\", height + \"px\");\n  });\n  #isTransitionActive = false;\n  #onResizeTransition(event) {\n    const content = this.#content();\n    if (content && event.propertyName === \"height\") {\n      this.#isTransitionActive = event.type === \"transitionstart\";\n      setAttribute(content, \"data-transition\", this.#isTransitionActive ? \"height\" : null);\n      if (this.#expanded()) this.#updateFocus();\n    }\n    for (const callback of this.#transitionCallbacks) callback(event);\n  }\n  open(trigger) {\n    if (peek(this.#expanded)) return;\n    this.#popper.show(trigger);\n    tick();\n  }\n  close(trigger) {\n    if (!peek(this.#expanded)) return;\n    this.#popper.hide(trigger);\n    tick();\n  }\n}\n__decorateClass([\n  prop\n], Menu.prototype, \"triggerElement\");\n__decorateClass([\n  prop\n], Menu.prototype, \"contentElement\");\n__decorateClass([\n  prop\n], Menu.prototype, \"isSubmenu\");\n__decorateClass([\n  method\n], Menu.prototype, \"open\");\n__decorateClass([\n  method\n], Menu.prototype, \"close\");\n\nclass MenuButton extends Component {\n  static props = {\n    disabled: false\n  };\n  #menu;\n  #hintEl = signal(null);\n  get expanded() {\n    return this.#menu?.expanded() ?? false;\n  }\n  constructor() {\n    super();\n    new FocusVisibleController();\n  }\n  onSetup() {\n    this.#menu = useContext(menuContext);\n  }\n  onAttach(el) {\n    this.#menu.attachMenuButton(this);\n    effect(this.#watchDisabled.bind(this));\n    setAttributeIfEmpty(el, \"type\", \"button\");\n  }\n  onConnect(el) {\n    effect(this.#watchHintEl.bind(this));\n    this.#onMutation();\n    const mutations = new MutationObserver(this.#onMutation.bind(this));\n    mutations.observe(el, { attributeFilter: [\"data-part\"], childList: true, subtree: true });\n    onDispose(() => mutations.disconnect());\n    onPress(el, (trigger) => {\n      this.dispatch(\"select\", { trigger });\n    });\n  }\n  #watchDisabled() {\n    this.#menu.disableMenuButton(this.$props.disabled());\n  }\n  #watchHintEl() {\n    const el = this.#hintEl();\n    if (!el) return;\n    effect(() => {\n      const text = this.#menu.hint();\n      if (text) el.textContent = text;\n    });\n  }\n  #onMutation() {\n    const hintEl = this.el?.querySelector('[data-part=\"hint\"]');\n    this.#hintEl.set(hintEl ?? null);\n  }\n}\nconst menubutton__proto = MenuButton.prototype;\nprop(menubutton__proto, \"expanded\");\n\nclass MenuItem extends MenuButton {\n}\n\nclass MenuPortal extends Component {\n  static props = {\n    container: null,\n    disabled: false\n  };\n  #target = null;\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n    provideContext(menuPortalContext, {\n      attach: this.#attachElement.bind(this)\n    });\n  }\n  onAttach(el) {\n    el.style.setProperty(\"display\", \"contents\");\n  }\n  // Need this so connect scope is defined.\n  onConnect(el) {\n  }\n  onDestroy() {\n    this.#target?.remove();\n    this.#target = null;\n  }\n  #attachElement(el) {\n    this.#portal(false);\n    this.#target = el;\n    requestScopedAnimationFrame(() => {\n      requestScopedAnimationFrame(() => {\n        if (!this.connectScope) return;\n        effect(this.#watchDisabled.bind(this));\n      });\n    });\n  }\n  #watchDisabled() {\n    const { fullscreen } = this.#media.$state, { disabled } = this.$props;\n    this.#portal(disabled() === \"fullscreen\" ? !fullscreen() : !disabled());\n  }\n  #portal(shouldPortal) {\n    if (!this.#target) return;\n    let container = this.#getContainer(this.$props.container());\n    if (!container) return;\n    const isPortalled = this.#target.parentElement === container;\n    setAttribute(this.#target, \"data-portal\", shouldPortal);\n    if (shouldPortal) {\n      if (!isPortalled) {\n        this.#target.remove();\n        container.append(this.#target);\n      }\n    } else if (isPortalled && this.#target.parentElement === container) {\n      this.#target.remove();\n      this.el?.append(this.#target);\n    }\n  }\n  #getContainer(selector) {\n    if (isHTMLElement(selector)) return selector;\n    return selector ? document.querySelector(selector) : document.body;\n  }\n}\nconst menuPortalContext = createContext();\n\nclass MenuItems extends Component {\n  static props = {\n    placement: null,\n    offset: 0,\n    alignOffset: 0\n  };\n  #menu;\n  constructor() {\n    super();\n    new FocusVisibleController();\n    const { placement } = this.$props;\n    this.setAttributes({\n      \"data-placement\": placement\n    });\n  }\n  onAttach(el) {\n    this.#menu = useContext(menuContext);\n    this.#menu.attachMenuItems(this);\n    if (hasProvidedContext(menuPortalContext)) {\n      const portal = useContext(menuPortalContext);\n      if (portal) {\n        provideContext(menuPortalContext, null);\n        portal.attach(el);\n        onDispose(() => portal.attach(null));\n      }\n    }\n  }\n  onConnect(el) {\n    effect(this.#watchPlacement.bind(this));\n  }\n  #watchPlacement() {\n    const { expanded } = this.#menu;\n    if (!this.el || !expanded()) return;\n    const placement = this.$props.placement();\n    if (!placement) return;\n    Object.assign(this.el.style, {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      width: \"max-content\"\n    });\n    const { offset: mainOffset, alignOffset } = this.$props;\n    onDispose(\n      autoPlacement(this.el, this.#getButton(), placement, {\n        offsetVarName: \"media-menu\",\n        xOffset: alignOffset(),\n        yOffset: mainOffset()\n      })\n    );\n    onDispose(this.#hide.bind(this));\n  }\n  #hide() {\n    if (!this.el) return;\n    this.el.removeAttribute(\"style\");\n    this.el.style.display = \"none\";\n  }\n  #getButton() {\n    return this.#menu.button();\n  }\n}\n\nconst radioControllerContext = createContext();\n\nclass RadioGroupController extends ViewController {\n  #group = /* @__PURE__ */ new Set();\n  #value = signal(\"\");\n  #controller = null;\n  onValueChange;\n  get values() {\n    return Array.from(this.#group).map((radio) => radio.value());\n  }\n  get value() {\n    return this.#value();\n  }\n  set value(value) {\n    this.#onChange(value);\n  }\n  onSetup() {\n    provideContext(radioControllerContext, {\n      add: this.#addRadio.bind(this),\n      remove: this.#removeRadio.bind(this)\n    });\n  }\n  onAttach(el) {\n    const isMenuItem = hasProvidedContext(menuContext);\n    if (!isMenuItem) setAttributeIfEmpty(el, \"role\", \"radiogroup\");\n    this.setAttributes({ value: this.#value });\n  }\n  onDestroy() {\n    this.#group.clear();\n  }\n  #addRadio(radio) {\n    if (this.#group.has(radio)) return;\n    this.#group.add(radio);\n    radio.onCheck = this.#onChangeBind;\n    radio.check(radio.value() === this.#value());\n  }\n  #removeRadio(radio) {\n    radio.onCheck = null;\n    this.#group.delete(radio);\n  }\n  #onChangeBind = this.#onChange.bind(this);\n  #onChange(newValue, trigger) {\n    const currentValue = peek(this.#value);\n    if (!newValue || newValue === currentValue) return;\n    const currentRadio = this.#findRadio(currentValue), newRadio = this.#findRadio(newValue);\n    currentRadio?.check(false, trigger);\n    newRadio?.check(true, trigger);\n    this.#value.set(newValue);\n    this.onValueChange?.(newValue, trigger);\n  }\n  #findRadio(newValue) {\n    for (const radio of this.#group) {\n      if (newValue === peek(radio.value)) return radio;\n    }\n    return null;\n  }\n}\n\nclass AudioRadioGroup extends Component {\n  static props = {\n    emptyLabel: \"Default\"\n  };\n  #menu;\n  #media;\n  #controller;\n  get value() {\n    return this.#controller.value;\n  }\n  get disabled() {\n    const { audioTracks } = this.#media.$state;\n    return audioTracks().length <= 1;\n  }\n  constructor() {\n    super();\n    this.#controller = new RadioGroupController();\n    this.#controller.onValueChange = this.#onValueChange.bind(this);\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    if (hasProvidedContext(menuContext)) {\n      this.#menu = useContext(menuContext);\n    }\n  }\n  onConnect(el) {\n    effect(this.#watchValue.bind(this));\n    effect(this.#watchControllerDisabled.bind(this));\n    effect(this.#watchHintText.bind(this));\n  }\n  getOptions() {\n    const { audioTracks } = this.#media.$state;\n    return audioTracks().map((track) => ({\n      track,\n      label: track.label,\n      value: track.label.toLowerCase()\n    }));\n  }\n  #watchValue() {\n    this.#controller.value = this.#getValue();\n  }\n  #watchHintText() {\n    const { emptyLabel } = this.$props, { audioTrack } = this.#media.$state, track = audioTrack();\n    this.#menu?.hint.set(track?.label ?? emptyLabel());\n  }\n  #watchControllerDisabled() {\n    this.#menu?.disable(this.disabled);\n  }\n  #getValue() {\n    const { audioTrack } = this.#media.$state;\n    const track = audioTrack();\n    return track ? track.label.toLowerCase() : \"\";\n  }\n  #onValueChange(value, trigger) {\n    if (this.disabled) return;\n    const index = this.#media.audioTracks.toArray().findIndex((track) => track.label.toLowerCase() === value);\n    if (index >= 0) {\n      const track = this.#media.audioTracks[index];\n      this.#media.remote.changeAudioTrack(index, trigger);\n      this.dispatch(\"change\", { detail: track, trigger });\n    }\n  }\n}\nconst audioradiogroup__proto = AudioRadioGroup.prototype;\nprop(audioradiogroup__proto, \"value\");\nprop(audioradiogroup__proto, \"disabled\");\nmethod(audioradiogroup__proto, \"getOptions\");\n\nclass CaptionsRadioGroup extends Component {\n  static props = {\n    offLabel: \"Off\"\n  };\n  #media;\n  #menu;\n  #controller;\n  get value() {\n    return this.#controller.value;\n  }\n  get disabled() {\n    const { hasCaptions } = this.#media.$state;\n    return !hasCaptions();\n  }\n  constructor() {\n    super();\n    this.#controller = new RadioGroupController();\n    this.#controller.onValueChange = this.#onValueChange.bind(this);\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    if (hasProvidedContext(menuContext)) {\n      this.#menu = useContext(menuContext);\n    }\n  }\n  onConnect(el) {\n    super.onConnect?.(el);\n    effect(this.#watchValue.bind(this));\n    effect(this.#watchControllerDisabled.bind(this));\n    effect(this.#watchHintText.bind(this));\n  }\n  getOptions() {\n    const { offLabel } = this.$props, { textTracks } = this.#media.$state;\n    return [\n      { value: \"off\", label: offLabel },\n      ...textTracks().filter(isTrackCaptionKind).map((track) => ({\n        track,\n        label: track.label,\n        value: this.#getTrackValue(track)\n      }))\n    ];\n  }\n  #watchValue() {\n    this.#controller.value = this.#getValue();\n  }\n  #watchHintText() {\n    const { offLabel } = this.$props, { textTrack } = this.#media.$state, track = textTrack();\n    this.#menu?.hint.set(\n      track && isTrackCaptionKind(track) && track.mode === \"showing\" ? track.label : offLabel()\n    );\n  }\n  #watchControllerDisabled() {\n    this.#menu?.disable(this.disabled);\n  }\n  #getValue() {\n    const { textTrack } = this.#media.$state, track = textTrack();\n    return track && isTrackCaptionKind(track) && track.mode === \"showing\" ? this.#getTrackValue(track) : \"off\";\n  }\n  #onValueChange(value, trigger) {\n    if (this.disabled) return;\n    if (value === \"off\") {\n      const track = this.#media.textTracks.selected;\n      if (track) {\n        const index2 = this.#media.textTracks.indexOf(track);\n        this.#media.remote.changeTextTrackMode(index2, \"disabled\", trigger);\n        this.dispatch(\"change\", { detail: null, trigger });\n      }\n      return;\n    }\n    const index = this.#media.textTracks.toArray().findIndex((track) => this.#getTrackValue(track) === value);\n    if (index >= 0) {\n      const track = this.#media.textTracks[index];\n      this.#media.remote.changeTextTrackMode(index, \"showing\", trigger);\n      this.dispatch(\"change\", { detail: track, trigger });\n    }\n  }\n  #getTrackValue(track) {\n    return track.id + \":\" + track.kind + \"-\" + track.label.toLowerCase();\n  }\n}\nconst captionsradiogroup__proto = CaptionsRadioGroup.prototype;\nprop(captionsradiogroup__proto, \"value\");\nprop(captionsradiogroup__proto, \"disabled\");\nmethod(captionsradiogroup__proto, \"getOptions\");\n\nconst DEFAULT_PLAYBACK_RATES = [0.25, 0.5, 0.75, 1, 1.25, 1.5, 1.75, 2];\nclass SpeedRadioGroup extends Component {\n  static props = {\n    normalLabel: \"Normal\",\n    rates: DEFAULT_PLAYBACK_RATES\n  };\n  #media;\n  #menu;\n  #controller;\n  get value() {\n    return this.#controller.value;\n  }\n  get disabled() {\n    const { rates } = this.$props, { canSetPlaybackRate } = this.#media.$state;\n    return !canSetPlaybackRate() || rates().length === 0;\n  }\n  constructor() {\n    super();\n    this.#controller = new RadioGroupController();\n    this.#controller.onValueChange = this.#onValueChange.bind(this);\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    if (hasProvidedContext(menuContext)) {\n      this.#menu = useContext(menuContext);\n    }\n  }\n  onConnect(el) {\n    effect(this.#watchValue.bind(this));\n    effect(this.#watchHintText.bind(this));\n    effect(this.#watchControllerDisabled.bind(this));\n  }\n  getOptions() {\n    const { rates, normalLabel } = this.$props;\n    return rates().map((rate) => ({\n      label: rate === 1 ? normalLabel : rate + \"\\xD7\",\n      value: rate.toString()\n    }));\n  }\n  #watchValue() {\n    this.#controller.value = this.#getValue();\n  }\n  #watchHintText() {\n    const { normalLabel } = this.$props, { playbackRate } = this.#media.$state, rate = playbackRate();\n    this.#menu?.hint.set(rate === 1 ? normalLabel() : rate + \"\\xD7\");\n  }\n  #watchControllerDisabled() {\n    this.#menu?.disable(this.disabled);\n  }\n  #getValue() {\n    const { playbackRate } = this.#media.$state;\n    return playbackRate().toString();\n  }\n  #onValueChange(value, trigger) {\n    if (this.disabled) return;\n    const rate = +value;\n    this.#media.remote.changePlaybackRate(rate, trigger);\n    this.dispatch(\"change\", { detail: rate, trigger });\n  }\n}\nconst speedradiogroup__proto = SpeedRadioGroup.prototype;\nprop(speedradiogroup__proto, \"value\");\nprop(speedradiogroup__proto, \"disabled\");\nmethod(speedradiogroup__proto, \"getOptions\");\n\nclass QualityRadioGroup extends Component {\n  static props = {\n    autoLabel: \"Auto\",\n    hideBitrate: false,\n    sort: \"descending\"\n  };\n  #media;\n  #menu;\n  #controller;\n  get value() {\n    return this.#controller.value;\n  }\n  get disabled() {\n    const { canSetQuality, qualities } = this.#media.$state;\n    return !canSetQuality() || qualities().length <= 1;\n  }\n  #sortedQualities = computed(() => {\n    const { sort } = this.$props, { qualities } = this.#media.$state;\n    return sortVideoQualities(qualities(), sort() === \"descending\");\n  });\n  constructor() {\n    super();\n    this.#controller = new RadioGroupController();\n    this.#controller.onValueChange = this.#onValueChange.bind(this);\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    if (hasProvidedContext(menuContext)) {\n      this.#menu = useContext(menuContext);\n    }\n  }\n  onConnect(el) {\n    effect(this.#watchValue.bind(this));\n    effect(this.#watchControllerDisabled.bind(this));\n    effect(this.#watchHintText.bind(this));\n  }\n  getOptions() {\n    const { autoLabel, hideBitrate } = this.$props;\n    return [\n      { value: \"auto\", label: autoLabel },\n      ...this.#sortedQualities().map((quality) => {\n        const bitrate = quality.bitrate && quality.bitrate >= 0 ? `${round(quality.bitrate / 1e6, 2)} Mbps` : null;\n        return {\n          quality,\n          label: quality.height + \"p\",\n          value: this.#getQualityId(quality),\n          bitrate: () => !hideBitrate() ? bitrate : null\n        };\n      })\n    ];\n  }\n  #watchValue() {\n    this.#controller.value = this.#getValue();\n  }\n  #watchHintText() {\n    const { autoLabel } = this.$props, { autoQuality, quality } = this.#media.$state, qualityText = quality() ? quality().height + \"p\" : \"\";\n    this.#menu?.hint.set(\n      !autoQuality() ? qualityText : autoLabel() + (qualityText ? ` (${qualityText})` : \"\")\n    );\n  }\n  #watchControllerDisabled() {\n    this.#menu?.disable(this.disabled);\n  }\n  #onValueChange(value, trigger) {\n    if (this.disabled) return;\n    if (value === \"auto\") {\n      this.#media.remote.changeQuality(-1, trigger);\n      this.dispatch(\"change\", { detail: \"auto\", trigger });\n      return;\n    }\n    const { qualities } = this.#media.$state, index = peek(qualities).findIndex((quality) => this.#getQualityId(quality) === value);\n    if (index >= 0) {\n      const quality = peek(qualities)[index];\n      this.#media.remote.changeQuality(index, trigger);\n      this.dispatch(\"change\", { detail: quality, trigger });\n    }\n  }\n  #getValue() {\n    const { quality, autoQuality } = this.#media.$state;\n    if (autoQuality()) return \"auto\";\n    const currentQuality = quality();\n    return currentQuality ? this.#getQualityId(currentQuality) : \"auto\";\n  }\n  #getQualityId(quality) {\n    return quality.height + \"_\" + quality.bitrate;\n  }\n}\nconst qualityradiogroup__proto = QualityRadioGroup.prototype;\nprop(qualityradiogroup__proto, \"value\");\nprop(qualityradiogroup__proto, \"disabled\");\nmethod(qualityradiogroup__proto, \"getOptions\");\n\nclass Time extends Component {\n  static props = {\n    type: \"current\",\n    showHours: false,\n    padHours: null,\n    padMinutes: null,\n    remainder: false,\n    toggle: false,\n    hidden: false\n  };\n  static state = new State({\n    timeText: \"\",\n    hidden: false\n  });\n  #media;\n  #invert = signal(null);\n  #isVisible = signal(true);\n  #isIntersecting = signal(true);\n  onSetup() {\n    this.#media = useMediaContext();\n    this.#watchTime();\n    const { type } = this.$props;\n    this.setAttributes({\n      \"data-type\": type,\n      \"data-remainder\": this.#shouldInvert.bind(this)\n    });\n    new IntersectionObserverController({\n      callback: this.#onIntersectionChange.bind(this)\n    }).attach(this);\n  }\n  onAttach(el) {\n    if (!el.hasAttribute(\"role\")) effect(this.#watchRole.bind(this));\n    effect(this.#watchTime.bind(this));\n  }\n  onConnect(el) {\n    onDispose(observeVisibility(el, this.#isVisible.set));\n    effect(this.#watchHidden.bind(this));\n    effect(this.#watchToggle.bind(this));\n  }\n  #onIntersectionChange(entries) {\n    this.#isIntersecting.set(entries[0].isIntersecting);\n  }\n  #watchHidden() {\n    const { hidden } = this.$props;\n    this.$state.hidden.set(hidden() || !this.#isVisible() || !this.#isIntersecting());\n  }\n  #watchToggle() {\n    if (!this.$props.toggle()) {\n      this.#invert.set(null);\n      return;\n    }\n    if (this.el) {\n      onPress(this.el, this.#onToggle.bind(this));\n    }\n  }\n  #watchTime() {\n    const { hidden, timeText } = this.$state, { duration } = this.#media.$state;\n    if (hidden()) return;\n    const { type, padHours, padMinutes, showHours } = this.$props, seconds = this.#getSeconds(type()), $duration = duration(), shouldInvert = this.#shouldInvert();\n    if (!Number.isFinite(seconds + $duration)) {\n      timeText.set(\"LIVE\");\n      return;\n    }\n    const time = shouldInvert ? Math.max(0, $duration - seconds) : seconds, formattedTime = formatTime(time, {\n      padHrs: padHours(),\n      padMins: padMinutes(),\n      showHrs: showHours()\n    });\n    timeText.set((shouldInvert ? \"-\" : \"\") + formattedTime);\n  }\n  #watchRole() {\n    if (!this.el) return;\n    const { toggle } = this.$props;\n    setAttribute(this.el, \"role\", toggle() ? \"timer\" : null);\n    setAttribute(this.el, \"tabindex\", toggle() ? 0 : null);\n  }\n  #getSeconds(type) {\n    const { bufferedEnd, duration, currentTime } = this.#media.$state;\n    switch (type) {\n      case \"buffered\":\n        return bufferedEnd();\n      case \"duration\":\n        return duration();\n      default:\n        return currentTime();\n    }\n  }\n  #shouldInvert() {\n    return this.$props.remainder() && this.#invert() !== false;\n  }\n  #onToggle(event) {\n    event.preventDefault();\n    if (this.#invert() === null) {\n      this.#invert.set(!this.$props.remainder());\n      return;\n    }\n    this.#invert.set((v) => !v);\n  }\n}\n\nexport { ARIAKeyShortcuts, AirPlayButton, AudioRadioGroup, CaptionButton, CaptionsRadioGroup, DEFAULT_PLAYBACK_RATES, FullscreenButton, LiveButton, Menu, MenuButton, MenuItem, MenuItems, MenuPortal, MuteButton, PIPButton, PlayButton, Popper, QualityRadioGroup, RadioGroupController, SeekButton, Slider, SliderController, SliderPreview, SliderValue, SpeedRadioGroup, Thumbnail, ThumbnailsLoader, Time, TimeSlider, ToggleButtonController, VolumeSlider, formatSpokenTime, formatTime, menuContext, menuPortalContext, radioControllerContext, sliderContext, sliderState, sliderValueFormatContext, updateSliderPreviewPlacement };\n","import { isFunction, isUndefined, waitTimeout, isString } from './vidstack-DVpy0IqK.js';\n\nconst UA = navigator?.userAgent.toLowerCase() || \"\";\nconst IS_IOS = /iphone|ipad|ipod|ios|crios|fxios/i.test(UA);\nconst IS_IPHONE = /(iphone|ipod)/gi.test(navigator?.platform || \"\");\nconst IS_CHROME = !!window.chrome;\nconst IS_SAFARI = !!window.safari || IS_IOS;\nfunction canOrientScreen() {\n  return canRotateScreen() && isFunction(screen.orientation.unlock);\n}\nfunction canRotateScreen() {\n  return !isUndefined(window.screen.orientation) && !isUndefined(window.screen.orientation.lock);\n}\nfunction canPlayAudioType(audio, type) {\n  if (!audio) audio = document.createElement(\"audio\");\n  return audio.canPlayType(type).length > 0;\n}\nfunction canPlayVideoType(video, type) {\n  if (!video) video = document.createElement(\"video\");\n  return video.canPlayType(type).length > 0;\n}\nfunction canPlayHLSNatively(video) {\n  if (!video) video = document.createElement(\"video\");\n  return video.canPlayType(\"application/vnd.apple.mpegurl\").length > 0;\n}\nfunction canUsePictureInPicture(video) {\n  return !!document.pictureInPictureEnabled && !video?.disablePictureInPicture;\n}\nfunction canUseVideoPresentation(video) {\n  return isFunction(video?.webkitSupportsPresentationMode) && isFunction(video?.webkitSetPresentationMode);\n}\nasync function canChangeVolume() {\n  const video = document.createElement(\"video\");\n  video.volume = 0.5;\n  await waitTimeout(0);\n  return video.volume === 0.5;\n}\nfunction getMediaSource() {\n  return window?.ManagedMediaSource ?? window?.MediaSource ?? window?.WebKitMediaSource;\n}\nfunction getSourceBuffer() {\n  return window?.SourceBuffer ?? window?.WebKitSourceBuffer;\n}\nfunction isHLSSupported() {\n  const MediaSource = getMediaSource();\n  if (isUndefined(MediaSource)) return false;\n  const isTypeSupported = MediaSource && isFunction(MediaSource.isTypeSupported) && MediaSource.isTypeSupported('video/mp4; codecs=\"avc1.42E01E,mp4a.40.2\"');\n  const SourceBuffer = getSourceBuffer();\n  const isSourceBufferValid = isUndefined(SourceBuffer) || !isUndefined(SourceBuffer.prototype) && isFunction(SourceBuffer.prototype.appendBuffer) && isFunction(SourceBuffer.prototype.remove);\n  return !!isTypeSupported && !!isSourceBufferValid;\n}\nfunction isDASHSupported() {\n  return isHLSSupported();\n}\n\nconst AUDIO_EXTENSIONS = /\\.(m4a|m4b|mp4a|mpga|mp2|mp2a|mp3|m2a|m3a|wav|weba|aac|oga|spx|flac)($|\\?)/i;\nconst AUDIO_TYPES = /* @__PURE__ */ new Set([\n  \"audio/mpeg\",\n  \"audio/ogg\",\n  \"audio/3gp\",\n  \"audio/mp3\",\n  \"audio/webm\",\n  \"audio/flac\",\n  \"audio/m4a\",\n  \"audio/m4b\",\n  \"audio/mp4a\"\n]);\nconst VIDEO_EXTENSIONS = /\\.(mp4|og[gv]|webm|mov|m4v)(#t=[,\\d+]+)?($|\\?)/i;\nconst VIDEO_TYPES = /* @__PURE__ */ new Set([\n  \"video/mp4\",\n  \"video/webm\",\n  \"video/3gp\",\n  \"video/ogg\",\n  \"video/avi\",\n  \"video/mpeg\"\n]);\nconst HLS_VIDEO_EXTENSIONS = /\\.(m3u8)($|\\?)/i;\nconst DASH_VIDEO_EXTENSIONS = /\\.(mpd)($|\\?)/i;\nconst HLS_VIDEO_TYPES = /* @__PURE__ */ new Set([\n  // Apple sanctioned\n  \"application/vnd.apple.mpegurl\",\n  // Apple sanctioned for backwards compatibility\n  \"audio/mpegurl\",\n  // Very common\n  \"audio/x-mpegurl\",\n  // Very common\n  \"application/x-mpegurl\",\n  // Included for completeness\n  \"video/x-mpegurl\",\n  \"video/mpegurl\",\n  \"application/mpegurl\"\n]);\nconst DASH_VIDEO_TYPES = /* @__PURE__ */ new Set([\"application/dash+xml\"]);\nfunction isAudioSrc({ src, type }) {\n  return isString(src) ? AUDIO_EXTENSIONS.test(src) || AUDIO_TYPES.has(type) || src.startsWith(\"blob:\") && type === \"audio/object\" : type === \"audio/object\";\n}\nfunction isVideoSrc(src) {\n  return isString(src.src) ? VIDEO_EXTENSIONS.test(src.src) || VIDEO_TYPES.has(src.type) || src.src.startsWith(\"blob:\") && src.type === \"video/object\" || isHLSSrc(src) && canPlayHLSNatively() : src.type === \"video/object\";\n}\nfunction isHLSSrc({ src, type }) {\n  return isString(src) && HLS_VIDEO_EXTENSIONS.test(src) || HLS_VIDEO_TYPES.has(type);\n}\nfunction isDASHSrc({ src, type }) {\n  return isString(src) && DASH_VIDEO_EXTENSIONS.test(src) || DASH_VIDEO_TYPES.has(type);\n}\nfunction canGoogleCastSrc(src) {\n  return isString(src.src) && (isAudioSrc(src) || isVideoSrc(src) || isHLSSrc(src));\n}\nfunction isMediaStream(src) {\n  return typeof window.MediaStream !== \"undefined\" && src instanceof window.MediaStream;\n}\n\nexport { AUDIO_EXTENSIONS, AUDIO_TYPES, DASH_VIDEO_EXTENSIONS, DASH_VIDEO_TYPES, HLS_VIDEO_EXTENSIONS, HLS_VIDEO_TYPES, IS_CHROME, IS_IOS, IS_IPHONE, IS_SAFARI, VIDEO_EXTENSIONS, VIDEO_TYPES, canChangeVolume, canGoogleCastSrc, canOrientScreen, canPlayAudioType, canPlayHLSNatively, canPlayVideoType, canRotateScreen, canUsePictureInPicture, canUseVideoPresentation, isAudioSrc, isDASHSrc, isDASHSupported, isHLSSrc, isHLSSupported, isMediaStream, isVideoSrc };\n","import { useContext, createContext, effect, createDisposalBin, Component, provideContext, signal } from './vidstack-DVpy0IqK.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\n\nconst plyrLayoutContext = createContext();\nfunction usePlyrLayoutContext() {\n  return useContext(plyrLayoutContext);\n}\n\nconst plyrLayoutProps = {\n  clickToPlay: true,\n  clickToFullscreen: true,\n  controls: [\n    \"play-large\",\n    \"play\",\n    \"progress\",\n    \"current-time\",\n    \"mute+volume\",\n    \"captions\",\n    \"settings\",\n    \"pip\",\n    \"airplay\",\n    \"fullscreen\"\n  ],\n  customIcons: false,\n  displayDuration: false,\n  download: null,\n  markers: null,\n  invertTime: true,\n  thumbnails: null,\n  toggleTime: true,\n  translations: null,\n  seekTime: 10,\n  speed: [0.5, 0.75, 1, 1.25, 1.5, 1.75, 2, 4]\n};\n\nclass PlyrLayout extends Component {\n  static props = plyrLayoutProps;\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n    provideContext(plyrLayoutContext, {\n      ...this.$props,\n      previewTime: signal(0)\n    });\n  }\n}\nfunction usePlyrLayoutClasses(el, media) {\n  const {\n    canAirPlay,\n    canFullscreen,\n    canPictureInPicture,\n    controlsHidden,\n    currentTime,\n    fullscreen,\n    hasCaptions,\n    isAirPlayConnected,\n    paused,\n    pictureInPicture,\n    playing,\n    pointer,\n    poster,\n    textTrack,\n    viewType,\n    waiting\n  } = media.$state;\n  el.classList.add(\"plyr\");\n  el.classList.add(\"plyr--full-ui\");\n  const classes = {\n    \"plyr--airplay-active\": isAirPlayConnected,\n    \"plyr--airplay-supported\": canAirPlay,\n    \"plyr--fullscreen-active\": fullscreen,\n    \"plyr--fullscreen-enabled\": canFullscreen,\n    \"plyr--hide-controls\": controlsHidden,\n    \"plyr--is-touch\": () => pointer() === \"coarse\",\n    \"plyr--loading\": waiting,\n    \"plyr--paused\": paused,\n    \"plyr--pip-active\": pictureInPicture,\n    \"plyr--pip-enabled\": canPictureInPicture,\n    \"plyr--playing\": playing,\n    \"plyr__poster-enabled\": poster,\n    \"plyr--stopped\": () => paused() && currentTime() === 0,\n    \"plyr--captions-active\": textTrack,\n    \"plyr--captions-enabled\": hasCaptions\n  };\n  const disposal = createDisposalBin();\n  for (const token of Object.keys(classes)) {\n    disposal.add(effect(() => void el.classList.toggle(token, !!classes[token]())));\n  }\n  disposal.add(\n    effect(() => {\n      const token = `plyr--${viewType()}`;\n      el.classList.add(token);\n      return () => el.classList.remove(token);\n    }),\n    effect(() => {\n      const { $provider } = media, type = $provider()?.type, token = `plyr--${isHTMLProvider(type) ? \"html5\" : type}`;\n      el.classList.toggle(token, !!type);\n      return () => el.classList.remove(token);\n    })\n  );\n  return () => disposal.empty();\n}\nfunction isHTMLProvider(type) {\n  return type === \"audio\" || type === \"video\";\n}\n\nexport { PlyrLayout, usePlyrLayoutClasses, usePlyrLayoutContext };\n","import { render } from 'lit-html';\n\nclass LitElement extends HTMLElement {\n  rootPart = null;\n  connectedCallback() {\n    this.rootPart = render(this.render(), this, {\n      renderBefore: this.firstChild\n    });\n    this.rootPart.setConnected(true);\n  }\n  disconnectedCallback() {\n    this.rootPart?.setConnected(false);\n    this.rootPart = null;\n    render(null, this);\n  }\n}\n\nexport { LitElement };\n","import { Component, State, effect, isNull, setAttribute, EventsController } from './vidstack-DVpy0IqK.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\nimport { preconnect } from './vidstack-BgIVvpNy.js';\n\nclass Poster extends Component {\n  static props = {\n    src: null,\n    alt: null,\n    crossOrigin: null\n  };\n  static state = new State({\n    img: null,\n    src: null,\n    alt: null,\n    crossOrigin: null,\n    loading: true,\n    error: null,\n    hidden: false\n  });\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n    this.#watchSrc();\n    this.#watchAlt();\n    this.#watchCrossOrigin();\n    this.#watchHidden();\n  }\n  onAttach(el) {\n    el.style.setProperty(\"pointer-events\", \"none\");\n    effect(this.#watchImg.bind(this));\n    effect(this.#watchSrc.bind(this));\n    effect(this.#watchAlt.bind(this));\n    effect(this.#watchCrossOrigin.bind(this));\n    effect(this.#watchHidden.bind(this));\n    const { started } = this.#media.$state;\n    this.setAttributes({\n      \"data-visible\": () => !started() && !this.$state.hidden(),\n      \"data-loading\": this.#isLoading.bind(this),\n      \"data-error\": this.#hasError.bind(this),\n      \"data-hidden\": this.$state.hidden\n    });\n  }\n  onConnect(el) {\n    effect(this.#onPreconnect.bind(this));\n    effect(this.#onLoadStart.bind(this));\n  }\n  #hasError() {\n    const { error } = this.$state;\n    return !isNull(error());\n  }\n  #onPreconnect() {\n    const { canLoadPoster, poster } = this.#media.$state;\n    if (!canLoadPoster() && poster()) preconnect(poster(), \"preconnect\");\n  }\n  #watchHidden() {\n    const { src } = this.$props, { poster, nativeControls } = this.#media.$state;\n    this.el && setAttribute(this.el, \"display\", nativeControls() ? \"none\" : null);\n    this.$state.hidden.set(this.#hasError() || !(src() || poster()) || nativeControls());\n  }\n  #isLoading() {\n    const { loading, hidden } = this.$state;\n    return !hidden() && loading();\n  }\n  #watchImg() {\n    const img = this.$state.img();\n    if (!img) return;\n    new EventsController(img).add(\"load\", this.#onLoad.bind(this)).add(\"error\", this.#onError.bind(this));\n    if (img.complete) this.#onLoad();\n  }\n  #prevSrc = \"\";\n  #watchSrc() {\n    const { poster: defaultPoster } = this.#media.$props, { canLoadPoster, providedPoster, inferredPoster } = this.#media.$state;\n    const src = this.$props.src() || \"\", poster = src || defaultPoster() || inferredPoster();\n    if (this.#prevSrc === providedPoster()) {\n      providedPoster.set(src);\n    }\n    this.$state.src.set(canLoadPoster() && poster.length ? poster : null);\n    this.#prevSrc = src;\n  }\n  #watchAlt() {\n    const { src } = this.$props, { alt } = this.$state, { poster } = this.#media.$state;\n    alt.set(src() || poster() ? this.$props.alt() : null);\n  }\n  #watchCrossOrigin() {\n    const { crossOrigin: crossOriginProp } = this.$props, { crossOrigin: crossOriginState } = this.$state, { crossOrigin: mediaCrossOrigin, poster: src } = this.#media.$state, crossOrigin = crossOriginProp() !== null ? crossOriginProp() : mediaCrossOrigin();\n    crossOriginState.set(\n      /ytimg\\.com|vimeo/.test(src() || \"\") ? null : crossOrigin === true ? \"anonymous\" : crossOrigin\n    );\n  }\n  #onLoadStart() {\n    const { loading, error } = this.$state, { canLoadPoster, poster } = this.#media.$state;\n    loading.set(canLoadPoster() && !!poster());\n    error.set(null);\n  }\n  #onLoad() {\n    const { loading, error } = this.$state;\n    loading.set(false);\n    error.set(null);\n  }\n  #onError(event) {\n    const { loading, error } = this.$state;\n    loading.set(false);\n    error.set(event);\n  }\n}\n\nexport { Poster };\n","import { Host, effect, Component, signal, setAttribute, isBoolean, computed, isString, useState } from './vidstack-DVpy0IqK.js';\nimport { Captions, Gesture, MediaAnnouncer, Controls, ControlsGroup, GoogleCastButton, ToggleButton, Tooltip, TooltipTrigger, TooltipContent, ChaptersRadioGroup, AudioGainRadioGroup, Radio, RadioGroup, SliderVideo, AudioGainSlider, SpeedSlider, QualitySlider, SliderChapters } from './vidstack-CK0M3MJg.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\nimport { watchCueTextChange } from './vidstack-C1THCRTj.js';\nimport { html } from 'lit-html';\nimport { requestScopedAnimationFrame, isHTMLElement, cloneTemplateContent, createTemplate, cloneTemplate } from './vidstack-CGUlKgT8.js';\nimport { LitElement } from './vidstack-CwTj4H1w.js';\nimport { MenuPortal, Slider, sliderState } from './vidstack-CWb-Pl1C.js';\nimport { renderMenuItemsTemplate } from './vidstack-U09LnPQC.js';\n\nclass MediaCaptionsElement extends Host(HTMLElement, Captions) {\n  static tagName = \"media-captions\";\n}\n\nclass MediaGestureElement extends Host(HTMLElement, Gesture) {\n  static tagName = \"media-gesture\";\n}\n\nclass MediaAnnouncerElement extends Host(HTMLElement, MediaAnnouncer) {\n  static tagName = \"media-announcer\";\n}\n\nclass MediaControlsElement extends Host(HTMLElement, Controls) {\n  static tagName = \"media-controls\";\n}\n\nclass MediaControlsGroupElement extends Host(HTMLElement, ControlsGroup) {\n  static tagName = \"media-controls-group\";\n}\n\nclass Title extends Component {\n}\nclass MediaTitleElement extends Host(HTMLElement, Title) {\n  static tagName = \"media-title\";\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n  }\n  onConnect() {\n    effect(this.#watchTitle.bind(this));\n  }\n  #watchTitle() {\n    const { title } = this.#media.$state;\n    this.textContent = title();\n  }\n}\n\nclass ChapterTitle extends Component {\n  static props = {\n    defaultText: \"\"\n  };\n}\nclass MediaChapterTitleElement extends Host(HTMLElement, ChapterTitle) {\n  static tagName = \"media-chapter-title\";\n  #media;\n  #chapterTitle;\n  onSetup() {\n    this.#media = useMediaContext();\n    this.#chapterTitle = signal(\"\");\n  }\n  onConnect() {\n    const tracks = this.#media.textTracks;\n    watchCueTextChange(tracks, \"chapters\", this.#chapterTitle.set);\n    effect(this.#watchChapterTitle.bind(this));\n  }\n  #watchChapterTitle() {\n    const { defaultText } = this.$props;\n    this.textContent = this.#chapterTitle() || defaultText();\n  }\n}\n\nclass Spinner extends Component {\n  static props = {\n    size: 96,\n    trackWidth: 8,\n    fillPercent: 50\n  };\n  onConnect(el) {\n    requestScopedAnimationFrame(() => {\n      if (!this.connectScope) return;\n      const root = el.querySelector(\"svg\"), track = root.firstElementChild, trackFill = track.nextElementSibling;\n      effect(this.#update.bind(this, root, track, trackFill));\n    });\n  }\n  #update(root, track, trackFill) {\n    const { size, trackWidth, fillPercent } = this.$props;\n    setAttribute(root, \"width\", size());\n    setAttribute(root, \"height\", size());\n    setAttribute(track, \"stroke-width\", trackWidth());\n    setAttribute(trackFill, \"stroke-width\", trackWidth());\n    setAttribute(trackFill, \"stroke-dashoffset\", 100 - fillPercent());\n  }\n}\nclass MediaSpinnerElement extends Host(LitElement, Spinner) {\n  static tagName = \"media-spinner\";\n  render() {\n    return html`\n      <svg fill=\"none\" viewBox=\"0 0 120 120\" aria-hidden=\"true\" data-part=\"root\">\n        <circle cx=\"60\" cy=\"60\" r=\"54\" stroke=\"currentColor\" data-part=\"track\"></circle>\n        <circle\n          cx=\"60\"\n          cy=\"60\"\n          r=\"54\"\n          stroke=\"currentColor\"\n          pathLength=\"100\"\n          stroke-dasharray=\"100\"\n          data-part=\"track-fill\"\n        ></circle>\n      </svg>\n    `;\n  }\n}\n\nclass MediaLayout extends Component {\n  static props = {\n    when: false\n  };\n}\nclass MediaLayoutElement extends Host(HTMLElement, MediaLayout) {\n  static tagName = \"media-layout\";\n  #media;\n  onSetup() {\n    this.#media = useMediaContext();\n  }\n  onConnect() {\n    effect(this.#watchWhen.bind(this));\n  }\n  #watchWhen() {\n    const root = this.firstElementChild, isTemplate = root?.localName === \"template\", when = this.$props.when(), matches = isBoolean(when) ? when : computed(() => when(this.#media.player.state))();\n    if (!matches) {\n      if (isTemplate) {\n        this.textContent = \"\";\n        this.appendChild(root);\n      } else if (isHTMLElement(root)) {\n        root.style.display = \"none\";\n      }\n      return;\n    }\n    if (isTemplate) {\n      this.append(root.content.cloneNode(true));\n    } else if (isHTMLElement(root)) {\n      root.style.display = \"\";\n    }\n  }\n}\n\nclass MediaGoogleCastButtonElement extends Host(HTMLElement, GoogleCastButton) {\n  static tagName = \"media-google-cast-button\";\n}\n\nclass MediaToggleButtonElement extends Host(HTMLElement, ToggleButton) {\n  static tagName = \"media-toggle-button\";\n}\n\nclass MediaTooltipElement extends Host(HTMLElement, Tooltip) {\n  static tagName = \"media-tooltip\";\n}\n\nclass MediaTooltipTriggerElement extends Host(HTMLElement, TooltipTrigger) {\n  static tagName = \"media-tooltip-trigger\";\n  onConnect() {\n    this.style.display = \"contents\";\n  }\n}\n\nclass MediaTooltipContentElement extends Host(HTMLElement, TooltipContent) {\n  static tagName = \"media-tooltip-content\";\n}\n\nclass MediaMenuPortalElement extends Host(HTMLElement, MenuPortal) {\n  static tagName = \"media-menu-portal\";\n  static attrs = {\n    disabled: {\n      converter(value) {\n        if (isString(value)) return value;\n        return value !== null;\n      }\n    }\n  };\n}\n\nclass MediaChaptersRadioGroupElement extends Host(HTMLElement, ChaptersRadioGroup) {\n  static tagName = \"media-chapters-radio-group\";\n  onConnect() {\n    renderMenuItemsTemplate(this, (el, option) => {\n      const { cue, startTime, duration } = option, thumbnailEl = el.querySelector(\".vds-thumbnail,media-thumbnail\"), startEl = el.querySelector('[data-part=\"start-time\"]'), durationEl = el.querySelector('[data-part=\"duration\"]');\n      if (startEl) startEl.textContent = startTime;\n      if (durationEl) durationEl.textContent = duration;\n      if (thumbnailEl) {\n        thumbnailEl.setAttribute(\"time\", cue.startTime + \"\");\n        effect(() => {\n          const thumbnails = this.$props.thumbnails();\n          if (\"src\" in thumbnailEl) {\n            thumbnailEl.src = thumbnails;\n          } else if (isString(thumbnails)) {\n            thumbnailEl.setAttribute(\"src\", thumbnails);\n          }\n        });\n      }\n    });\n  }\n}\n\nclass MediaAudioGainRadioGroupElement extends Host(HTMLElement, AudioGainRadioGroup) {\n  static tagName = \"media-audio-gain-radio-group\";\n  onConnect() {\n    renderMenuItemsTemplate(this);\n  }\n}\n\nclass MediaRadioElement extends Host(HTMLElement, Radio) {\n  static tagName = \"media-radio\";\n}\n\nclass MediaRadioGroupElement extends Host(HTMLElement, RadioGroup) {\n  static tagName = \"media-radio-group\";\n}\n\nclass MediaSliderElement extends Host(HTMLElement, Slider) {\n  static tagName = \"media-slider\";\n}\n\nconst videoTemplate = /* @__PURE__ */ createTemplate(\n  `<video muted playsinline preload=\"none\" style=\"max-width: unset;\"></video>`\n);\nclass MediaSliderVideoElement extends Host(HTMLElement, SliderVideo) {\n  static tagName = \"media-slider-video\";\n  #media;\n  #video = this.#createVideo();\n  onSetup() {\n    this.#media = useMediaContext();\n    this.$state.video.set(this.#video);\n  }\n  onConnect() {\n    const { canLoad } = this.#media.$state, { src, crossOrigin } = this.$state;\n    if (this.#video.parentNode !== this) {\n      this.prepend(this.#video);\n    }\n    effect(() => {\n      setAttribute(this.#video, \"crossorigin\", crossOrigin());\n      setAttribute(this.#video, \"preload\", canLoad() ? \"auto\" : \"none\");\n      setAttribute(this.#video, \"src\", src());\n    });\n  }\n  #createVideo() {\n    return cloneTemplateContent(videoTemplate);\n  }\n}\n\nclass MediaAudioGainSliderElement extends Host(HTMLElement, AudioGainSlider) {\n  static tagName = \"media-audio-gain-slider\";\n}\n\nclass MediaSpeedSliderElement extends Host(HTMLElement, SpeedSlider) {\n  static tagName = \"media-speed-slider\";\n}\n\nclass MediaQualitySliderElement extends Host(HTMLElement, QualitySlider) {\n  static tagName = \"media-quality-slider\";\n}\n\nclass MediaSliderChaptersElement extends Host(HTMLElement, SliderChapters) {\n  static tagName = \"media-slider-chapters\";\n  #template = null;\n  onConnect() {\n    requestScopedAnimationFrame(() => {\n      if (!this.connectScope) return;\n      const template = this.querySelector(\"template\");\n      if (template) {\n        this.#template = template;\n        effect(this.#renderTemplate.bind(this));\n      }\n    });\n  }\n  #renderTemplate() {\n    if (!this.#template) return;\n    const elements = cloneTemplate(this.#template, this.cues.length || 1);\n    this.setRefs(elements);\n  }\n}\n\nclass SliderSteps extends Component {\n}\nclass MediaSliderStepsElement extends Host(HTMLElement, SliderSteps) {\n  static tagName = \"media-slider-steps\";\n  #template = null;\n  onConnect(el) {\n    requestScopedAnimationFrame(() => {\n      if (!this.connectScope) return;\n      this.#template = el.querySelector(\"template\");\n      if (this.#template) effect(this.#render.bind(this));\n    });\n  }\n  #render() {\n    if (!this.#template) return;\n    const { min, max, step } = useState(sliderState), steps = (max() - min()) / step();\n    cloneTemplate(this.#template, Math.floor(steps) + 1);\n  }\n}\n\nexport { MediaAnnouncerElement, MediaAudioGainRadioGroupElement, MediaAudioGainSliderElement, MediaCaptionsElement, MediaChapterTitleElement, MediaChaptersRadioGroupElement, MediaControlsElement, MediaControlsGroupElement, MediaGestureElement, MediaGoogleCastButtonElement, MediaLayoutElement, MediaMenuPortalElement, MediaQualitySliderElement, MediaRadioElement, MediaRadioGroupElement, MediaSliderChaptersElement, MediaSliderElement, MediaSliderStepsElement, MediaSliderVideoElement, MediaSpeedSliderElement, MediaSpinnerElement, MediaTitleElement, MediaToggleButtonElement, MediaTooltipContentElement, MediaTooltipElement, MediaTooltipTriggerElement };\n","const SCOPE = Symbol(\"SCOPE\");\nlet scheduledEffects = false, runningEffects = false, currentScope = null, currentObserver = null, currentObservers = null, currentObserversIndex = 0, effects = [], defaultContext = {};\nconst NOOP = () => {\n}, STATE_CLEAN = 0, STATE_CHECK = 1, STATE_DIRTY = 2, STATE_DISPOSED = 3;\nfunction flushEffects() {\n  scheduledEffects = true;\n  queueMicrotask(runEffects);\n}\nfunction runEffects() {\n  if (!effects.length) {\n    scheduledEffects = false;\n    return;\n  }\n  runningEffects = true;\n  for (let i = 0; i < effects.length; i++) {\n    if (effects[i]._state !== STATE_CLEAN)\n      runTop(effects[i]);\n  }\n  effects = [];\n  scheduledEffects = false;\n  runningEffects = false;\n}\nfunction runTop(node) {\n  let ancestors = [node];\n  while (node = node[SCOPE]) {\n    if (node._effect && node._state !== STATE_CLEAN)\n      ancestors.push(node);\n  }\n  for (let i = ancestors.length - 1; i >= 0; i--) {\n    updateCheck(ancestors[i]);\n  }\n}\nfunction root(init) {\n  const scope = createScope();\n  return compute(scope, !init.length ? init : init.bind(null, dispose.bind(scope)), null);\n}\nfunction peek(fn) {\n  return compute(currentScope, fn, null);\n}\nfunction untrack(fn) {\n  return compute(null, fn, null);\n}\nfunction tick() {\n  if (!runningEffects)\n    runEffects();\n}\nfunction getScope() {\n  return currentScope;\n}\nfunction scoped(run, scope) {\n  try {\n    return compute(scope, run, null);\n  } catch (error) {\n    handleError(scope, error);\n    return;\n  }\n}\nfunction getContext(key, scope = currentScope) {\n  return scope?._context[key];\n}\nfunction setContext(key, value, scope = currentScope) {\n  if (scope)\n    scope._context = { ...scope._context, [key]: value };\n}\nfunction onDispose(disposable) {\n  if (!disposable || !currentScope)\n    return disposable || NOOP;\n  const node = currentScope;\n  if (!node._disposal) {\n    node._disposal = disposable;\n  } else if (Array.isArray(node._disposal)) {\n    node._disposal.push(disposable);\n  } else {\n    node._disposal = [node._disposal, disposable];\n  }\n  return function removeDispose() {\n    if (node._state === STATE_DISPOSED)\n      return;\n    disposable.call(null);\n    if (isFunction$1(node._disposal)) {\n      node._disposal = null;\n    } else if (Array.isArray(node._disposal)) {\n      node._disposal.splice(node._disposal.indexOf(disposable), 1);\n    }\n  };\n}\nfunction dispose(self = true) {\n  if (this._state === STATE_DISPOSED)\n    return;\n  if (this._children) {\n    if (Array.isArray(this._children)) {\n      for (let i = this._children.length - 1; i >= 0; i--) {\n        dispose.call(this._children[i]);\n      }\n    } else {\n      dispose.call(this._children);\n    }\n  }\n  if (self) {\n    const parent = this[SCOPE];\n    if (parent) {\n      if (Array.isArray(parent._children)) {\n        parent._children.splice(parent._children.indexOf(this), 1);\n      } else {\n        parent._children = null;\n      }\n    }\n    disposeNode(this);\n  }\n}\nfunction disposeNode(node) {\n  node._state = STATE_DISPOSED;\n  if (node._disposal)\n    emptyDisposal(node);\n  if (node._sources)\n    removeSourceObservers(node, 0);\n  node[SCOPE] = null;\n  node._sources = null;\n  node._observers = null;\n  node._children = null;\n  node._context = defaultContext;\n  node._handlers = null;\n}\nfunction emptyDisposal(scope) {\n  try {\n    if (Array.isArray(scope._disposal)) {\n      for (let i = scope._disposal.length - 1; i >= 0; i--) {\n        const callable = scope._disposal[i];\n        callable.call(callable);\n      }\n    } else {\n      scope._disposal.call(scope._disposal);\n    }\n    scope._disposal = null;\n  } catch (error) {\n    handleError(scope, error);\n  }\n}\nfunction compute(scope, compute2, observer) {\n  const prevScope = currentScope, prevObserver = currentObserver;\n  currentScope = scope;\n  currentObserver = observer;\n  try {\n    return compute2.call(scope);\n  } finally {\n    currentScope = prevScope;\n    currentObserver = prevObserver;\n  }\n}\nfunction handleError(scope, error) {\n  if (!scope || !scope._handlers)\n    throw error;\n  let i = 0, len = scope._handlers.length, currentError = error;\n  for (i = 0; i < len; i++) {\n    try {\n      scope._handlers[i](currentError);\n      break;\n    } catch (error2) {\n      currentError = error2;\n    }\n  }\n  if (i === len)\n    throw currentError;\n}\nfunction read() {\n  if (this._state === STATE_DISPOSED)\n    return this._value;\n  if (currentObserver && !this._effect) {\n    if (!currentObservers && currentObserver._sources && currentObserver._sources[currentObserversIndex] == this) {\n      currentObserversIndex++;\n    } else if (!currentObservers)\n      currentObservers = [this];\n    else\n      currentObservers.push(this);\n  }\n  if (this._compute)\n    updateCheck(this);\n  return this._value;\n}\nfunction write(newValue) {\n  const value = isFunction$1(newValue) ? newValue(this._value) : newValue;\n  if (this._changed(this._value, value)) {\n    this._value = value;\n    if (this._observers) {\n      for (let i = 0; i < this._observers.length; i++) {\n        notify(this._observers[i], STATE_DIRTY);\n      }\n    }\n  }\n  return this._value;\n}\nconst ScopeNode = function Scope() {\n  this[SCOPE] = null;\n  this._children = null;\n  if (currentScope)\n    currentScope.append(this);\n};\nconst ScopeProto = ScopeNode.prototype;\nScopeProto._context = defaultContext;\nScopeProto._handlers = null;\nScopeProto._compute = null;\nScopeProto._disposal = null;\nScopeProto.append = function(child) {\n  child[SCOPE] = this;\n  if (!this._children) {\n    this._children = child;\n  } else if (Array.isArray(this._children)) {\n    this._children.push(child);\n  } else {\n    this._children = [this._children, child];\n  }\n  child._context = child._context === defaultContext ? this._context : { ...this._context, ...child._context };\n  if (this._handlers) {\n    child._handlers = !child._handlers ? this._handlers : [...child._handlers, ...this._handlers];\n  }\n};\nScopeProto.dispose = function() {\n  dispose.call(this);\n};\nfunction createScope() {\n  return new ScopeNode();\n}\nconst ComputeNode = function Computation(initialValue, compute2, options) {\n  ScopeNode.call(this);\n  this._state = compute2 ? STATE_DIRTY : STATE_CLEAN;\n  this._init = false;\n  this._effect = false;\n  this._sources = null;\n  this._observers = null;\n  this._value = initialValue;\n  this.id = options?.id ?? (this._compute ? \"computed\" : \"signal\");\n  if (compute2)\n    this._compute = compute2;\n  if (options && options.dirty)\n    this._changed = options.dirty;\n};\nconst ComputeProto = ComputeNode.prototype;\nObject.setPrototypeOf(ComputeProto, ScopeProto);\nComputeProto._changed = isNotEqual;\nComputeProto.call = read;\nfunction createComputation(initialValue, compute2, options) {\n  return new ComputeNode(initialValue, compute2, options);\n}\nfunction isNotEqual(a, b) {\n  return a !== b;\n}\nfunction isFunction$1(value) {\n  return typeof value === \"function\";\n}\nfunction updateCheck(node) {\n  if (node._state === STATE_CHECK) {\n    for (let i = 0; i < node._sources.length; i++) {\n      updateCheck(node._sources[i]);\n      if (node._state === STATE_DIRTY) {\n        break;\n      }\n    }\n  }\n  if (node._state === STATE_DIRTY)\n    update(node);\n  else\n    node._state = STATE_CLEAN;\n}\nfunction cleanup(node) {\n  if (node._children)\n    dispose.call(node, false);\n  if (node._disposal)\n    emptyDisposal(node);\n  node._handlers = node[SCOPE] ? node[SCOPE]._handlers : null;\n}\nfunction update(node) {\n  let prevObservers = currentObservers, prevObserversIndex = currentObserversIndex;\n  currentObservers = null;\n  currentObserversIndex = 0;\n  try {\n    cleanup(node);\n    const result = compute(node, node._compute, node);\n    updateObservers(node);\n    if (!node._effect && node._init) {\n      write.call(node, result);\n    } else {\n      node._value = result;\n      node._init = true;\n    }\n  } catch (error) {\n    if (!node._init && typeof node._value === \"undefined\") {\n      console.error(\n        `computed \\`${node.id}\\` threw error during first run, this can be fatal.\n\nSolutions:\n\n1. Set the \\`initial\\` option to silence this error`,\n        \"\\n2. Or, use an `effect` if the return value is not being used\",\n        \"\\n\\n\",\n        error\n      );\n    }\n    updateObservers(node);\n    handleError(node, error);\n  } finally {\n    currentObservers = prevObservers;\n    currentObserversIndex = prevObserversIndex;\n    node._state = STATE_CLEAN;\n  }\n}\nfunction updateObservers(node) {\n  if (currentObservers) {\n    if (node._sources)\n      removeSourceObservers(node, currentObserversIndex);\n    if (node._sources && currentObserversIndex > 0) {\n      node._sources.length = currentObserversIndex + currentObservers.length;\n      for (let i = 0; i < currentObservers.length; i++) {\n        node._sources[currentObserversIndex + i] = currentObservers[i];\n      }\n    } else {\n      node._sources = currentObservers;\n    }\n    let source;\n    for (let i = currentObserversIndex; i < node._sources.length; i++) {\n      source = node._sources[i];\n      if (!source._observers)\n        source._observers = [node];\n      else\n        source._observers.push(node);\n    }\n  } else if (node._sources && currentObserversIndex < node._sources.length) {\n    removeSourceObservers(node, currentObserversIndex);\n    node._sources.length = currentObserversIndex;\n  }\n}\nfunction notify(node, state) {\n  if (node._state >= state)\n    return;\n  if (node._effect && node._state === STATE_CLEAN) {\n    effects.push(node);\n    if (!scheduledEffects)\n      flushEffects();\n  }\n  node._state = state;\n  if (node._observers) {\n    for (let i = 0; i < node._observers.length; i++) {\n      notify(node._observers[i], STATE_CHECK);\n    }\n  }\n}\nfunction removeSourceObservers(node, index) {\n  let source, swap;\n  for (let i = index; i < node._sources.length; i++) {\n    source = node._sources[i];\n    if (source._observers) {\n      swap = source._observers.indexOf(node);\n      source._observers[swap] = source._observers[source._observers.length - 1];\n      source._observers.pop();\n    }\n  }\n}\nfunction noop(...args) {\n}\nfunction isNull(value) {\n  return value === null;\n}\nfunction isUndefined(value) {\n  return typeof value === \"undefined\";\n}\nfunction isNil(value) {\n  return isNull(value) || isUndefined(value);\n}\nfunction isObject(value) {\n  return value?.constructor === Object;\n}\nfunction isNumber(value) {\n  return typeof value === \"number\" && !Number.isNaN(value);\n}\nfunction isString(value) {\n  return typeof value === \"string\";\n}\nfunction isBoolean(value) {\n  return typeof value === \"boolean\";\n}\nfunction isFunction(value) {\n  return typeof value === \"function\";\n}\nfunction isArray(value) {\n  return Array.isArray(value);\n}\nconst EVENT = Event, DOM_EVENT = Symbol(\"DOM_EVENT\");\nclass DOMEvent extends EVENT {\n  [DOM_EVENT] = true;\n  /**\n   * The event detail.\n   */\n  detail;\n  /**\n   * The event trigger chain.\n   */\n  triggers = new EventTriggers();\n  /**\n   * The preceding event that was responsible for this event being fired.\n   */\n  get trigger() {\n    return this.triggers.source;\n  }\n  /**\n   * The origin event that lead to this event being fired.\n   */\n  get originEvent() {\n    return this.triggers.origin;\n  }\n  /**\n   * Whether the origin event was triggered by the user.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/isTrusted}\n   */\n  get isOriginTrusted() {\n    return this.triggers.origin?.isTrusted ?? false;\n  }\n  constructor(type, ...init) {\n    super(type, init[0]);\n    this.detail = init[0]?.detail;\n    const trigger = init[0]?.trigger;\n    if (trigger) this.triggers.add(trigger);\n  }\n}\nclass EventTriggers {\n  chain = [];\n  get source() {\n    return this.chain[0];\n  }\n  get origin() {\n    return this.chain[this.chain.length - 1];\n  }\n  /**\n   * Appends the event to the end of the chain.\n   */\n  add(event) {\n    this.chain.push(event);\n    if (isDOMEvent(event)) {\n      this.chain.push(...event.triggers);\n    }\n  }\n  /**\n   * Removes the event from the chain and returns it (if found).\n   */\n  remove(event) {\n    return this.chain.splice(this.chain.indexOf(event), 1)[0];\n  }\n  /**\n   * Returns whether the chain contains the given `event`.\n   */\n  has(event) {\n    return this.chain.some((e) => e === event);\n  }\n  /**\n   * Returns whether the chain contains the given event type.\n   */\n  hasType(type) {\n    return !!this.findType(type);\n  }\n  /**\n   * Returns the first event with the given `type` found in the chain.\n   */\n  findType(type) {\n    return this.chain.find((e) => e.type === type);\n  }\n  /**\n   * Walks an event chain on a given `event`, and invokes the given `callback` for each trigger event.\n   */\n  walk(callback) {\n    for (const event of this.chain) {\n      const returnValue = callback(event);\n      if (returnValue) return [event, returnValue];\n    }\n  }\n  [Symbol.iterator]() {\n    return this.chain.values();\n  }\n}\nfunction isDOMEvent(event) {\n  return !!event?.[DOM_EVENT];\n}\nfunction walkTriggerEventChain(event, callback) {\n  if (!isDOMEvent(event)) return;\n  return event.triggers.walk(callback);\n}\nfunction findTriggerEvent(event, type) {\n  return isDOMEvent(event) ? event.triggers.findType(type) : void 0;\n}\nfunction hasTriggerEvent(event, type) {\n  return !!findTriggerEvent(event, type);\n}\nfunction appendTriggerEvent(event, trigger) {\n  if (trigger) event.triggers.add(trigger);\n}\nclass EventsTarget extends EventTarget {\n  /** @internal type only */\n  $ts__events;\n  addEventListener(type, callback, options) {\n    return super.addEventListener(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    return super.removeEventListener(type, callback, options);\n  }\n}\nfunction listenEvent(target, type, handler, options) {\n  target.addEventListener(type, handler, options);\n  return onDispose(() => target.removeEventListener(type, handler, options));\n}\nclass EventsController {\n  #target;\n  #controller;\n  get signal() {\n    return this.#controller.signal;\n  }\n  constructor(target) {\n    this.#target = target;\n    this.#controller = new AbortController();\n    onDispose(this.abort.bind(this));\n  }\n  add(type, handler, options) {\n    if (this.signal.aborted) throw Error(\"aborted\");\n    this.#target.addEventListener(type, handler, {\n      ...options,\n      signal: options?.signal ? anySignal(this.signal, options.signal) : this.signal\n    });\n    return this;\n  }\n  remove(type, handler) {\n    this.#target.removeEventListener(type, handler);\n    return this;\n  }\n  abort(reason) {\n    this.#controller.abort(reason);\n  }\n}\nfunction anySignal(...signals) {\n  const controller = new AbortController(), options = { signal: controller.signal };\n  function onAbort(event) {\n    controller.abort(event.target.reason);\n  }\n  for (const signal of signals) {\n    if (signal.aborted) {\n      controller.abort(signal.reason);\n      break;\n    }\n    signal.addEventListener(\"abort\", onAbort, options);\n  }\n  return controller.signal;\n}\nfunction isPointerEvent(event) {\n  return !!event?.type.startsWith(\"pointer\");\n}\nfunction isTouchEvent(event) {\n  return !!event?.type.startsWith(\"touch\");\n}\nfunction isMouseEvent(event) {\n  return /^(click|mouse)/.test(event?.type ?? \"\");\n}\nfunction isKeyboardEvent(event) {\n  return !!event?.type.startsWith(\"key\");\n}\nfunction wasEnterKeyPressed(event) {\n  return isKeyboardEvent(event) && event.key === \"Enter\";\n}\nfunction isKeyboardClick(event) {\n  return isKeyboardEvent(event) && (event.key === \"Enter\" || event.key === \" \");\n}\nfunction isDOMNode(node) {\n  return node instanceof Node;\n}\nfunction setAttribute(host, name, value) {\n  if (!host) return;\n  else if (!value && value !== \"\" && value !== 0) {\n    host.removeAttribute(name);\n  } else {\n    const attrValue = value === true ? \"\" : value + \"\";\n    if (host.getAttribute(name) !== attrValue) {\n      host.setAttribute(name, attrValue);\n    }\n  }\n}\nfunction setStyle(host, property, value) {\n  if (!host) return;\n  else if (!value && value !== 0) {\n    host.style.removeProperty(property);\n  } else {\n    host.style.setProperty(property, value + \"\");\n  }\n}\nfunction toggleClass(host, name, value) {\n  host.classList[value ? \"add\" : \"remove\"](name);\n}\n\nfunction signal(initialValue, options) {\n  const node = createComputation(initialValue, null, options), signal2 = read.bind(node);\n  signal2.node = node;\n  signal2[SCOPE] = true;\n  signal2.set = write.bind(node);\n  return signal2;\n}\nfunction isReadSignal(fn) {\n  return isFunction$1(fn) && SCOPE in fn;\n}\nfunction computed(compute, options) {\n  const node = createComputation(\n    options?.initial,\n    compute,\n    options\n  ), signal2 = read.bind(node);\n  signal2[SCOPE] = true;\n  signal2.node = node;\n  return signal2;\n}\nfunction effect$1(effect2, options) {\n  const signal2 = createComputation(\n    null,\n    function runEffect() {\n      let effectResult = effect2();\n      isFunction$1(effectResult) && onDispose(effectResult);\n      return null;\n    },\n    { id: options?.id ?? \"effect\" }\n  );\n  signal2._effect = true;\n  update(signal2);\n  {\n    return function stopEffect() {\n      dispose.call(signal2, true);\n    };\n  }\n}\nfunction isWriteSignal(fn) {\n  return isReadSignal(fn) && \"set\" in fn;\n}\nconst effect = effect$1;\nfunction createContext(provide) {\n  return { id: Symbol(), provide };\n}\nfunction provideContext(context, value, scope = getScope()) {\n  if (!scope) {\n    throw Error(\"[maverick] attempting to provide context outside root\");\n  }\n  const hasProvidedValue = !isUndefined(value);\n  if (!hasProvidedValue && !context.provide) {\n    throw Error(\"[maverick] context can not be provided without a value or `provide` function\");\n  }\n  setContext(context.id, hasProvidedValue ? value : context.provide?.(), scope);\n}\nfunction useContext(context) {\n  const value = getContext(context.id);\n  if (isUndefined(value)) {\n    throw Error(\"[maverick] attempting to use context without providing first\");\n  }\n  return value;\n}\nfunction hasProvidedContext(context) {\n  return !isUndefined(getContext(context.id));\n}\nconst PROPS = /* @__PURE__ */ Symbol(\"PROPS\");\nconst METHODS = /* @__PURE__ */ Symbol(\"METHODS\");\nconst ON_DISPATCH = /* @__PURE__ */ Symbol(\"ON_DISPATCH\");\nconst EMPTY_PROPS = {};\nclass Instance {\n  /** @internal type only */\n  $ts__events;\n  /** @internal type only */\n  $ts__vars;\n  /* @internal */\n  [ON_DISPATCH] = null;\n  $el = signal(null);\n  el = null;\n  scope = null;\n  attachScope = null;\n  connectScope = null;\n  component = null;\n  destroyed = false;\n  props = EMPTY_PROPS;\n  attrs = null;\n  styles = null;\n  state;\n  $state;\n  #setupCallbacks = [];\n  #attachCallbacks = [];\n  #connectCallbacks = [];\n  #destroyCallbacks = [];\n  constructor(Component, scope, init) {\n    this.scope = scope;\n    if (init?.scope) init.scope.append(scope);\n    let stateFactory = Component.state, props = Component.props;\n    if (stateFactory) {\n      this.$state = stateFactory.create();\n      this.state = new Proxy(this.$state, {\n        get: (_, prop) => this.$state[prop]()\n      });\n      provideContext(stateFactory, this.$state);\n    }\n    if (props) {\n      this.props = createInstanceProps(props);\n      if (init?.props) {\n        for (const prop of Object.keys(init.props)) {\n          this.props[prop]?.set(init.props[prop]);\n        }\n      }\n    }\n    onDispose(this.destroy.bind(this));\n  }\n  setup() {\n    scoped(() => {\n      for (const callback of this.#setupCallbacks) callback();\n    }, this.scope);\n  }\n  attach(el) {\n    if (this.el) return;\n    this.el = el;\n    this.$el.set(el);\n    {\n      el.$$COMPONENT_NAME = this.component?.constructor.name;\n    }\n    scoped(() => {\n      this.attachScope = createScope();\n      scoped(() => {\n        for (const callback of this.#attachCallbacks) callback(this.el);\n        this.#attachAttrs();\n        this.#attachStyles();\n      }, this.attachScope);\n    }, this.scope);\n    el.dispatchEvent(new Event(\"attached\"));\n  }\n  detach() {\n    this.attachScope?.dispose();\n    this.attachScope = null;\n    this.connectScope = null;\n    if (this.el) {\n      this.el.$$COMPONENT_NAME = null;\n    }\n    this.el = null;\n    this.$el.set(null);\n  }\n  connect() {\n    if (!this.el || !this.attachScope || !this.#connectCallbacks.length) return;\n    scoped(() => {\n      this.connectScope = createScope();\n      scoped(() => {\n        for (const callback of this.#connectCallbacks) callback(this.el);\n      }, this.connectScope);\n    }, this.attachScope);\n  }\n  disconnect() {\n    this.connectScope?.dispose();\n    this.connectScope = null;\n  }\n  destroy() {\n    if (this.destroyed) return;\n    this.destroyed = true;\n    scoped(() => {\n      for (const callback of this.#destroyCallbacks) callback(this.el);\n    }, this.scope);\n    const el = this.el;\n    this.detach();\n    this.scope.dispose();\n    this.#setupCallbacks.length = 0;\n    this.#attachCallbacks.length = 0;\n    this.#connectCallbacks.length = 0;\n    this.#destroyCallbacks.length = 0;\n    this.component = null;\n    this.attrs = null;\n    this.styles = null;\n    this.props = EMPTY_PROPS;\n    this.scope = null;\n    this.state = EMPTY_PROPS;\n    this.$state = null;\n    if (el) delete el.$;\n  }\n  addHooks(target) {\n    if (target.onSetup) this.#setupCallbacks.push(target.onSetup.bind(target));\n    if (target.onAttach) this.#attachCallbacks.push(target.onAttach.bind(target));\n    if (target.onConnect) this.#connectCallbacks.push(target.onConnect.bind(target));\n    if (target.onDestroy) this.#destroyCallbacks.push(target.onDestroy.bind(target));\n  }\n  #attachAttrs() {\n    if (!this.attrs) return;\n    for (const name of Object.keys(this.attrs)) {\n      if (isFunction(this.attrs[name])) {\n        effect(this.#setAttr.bind(this, name));\n      } else {\n        setAttribute(this.el, name, this.attrs[name]);\n      }\n    }\n  }\n  #attachStyles() {\n    if (!this.styles) return;\n    for (const name of Object.keys(this.styles)) {\n      if (isFunction(this.styles[name])) {\n        effect(this.#setStyle.bind(this, name));\n      } else {\n        setStyle(this.el, name, this.styles[name]);\n      }\n    }\n  }\n  #setAttr(name) {\n    setAttribute(this.el, name, this.attrs[name].call(this.component));\n  }\n  #setStyle(name) {\n    setStyle(this.el, name, this.styles[name].call(this.component));\n  }\n}\nfunction createInstanceProps(props) {\n  const $props = {};\n  for (const name of Object.keys(props)) {\n    const def = props[name];\n    $props[name] = signal(def, def);\n  }\n  return $props;\n}\nlet currentInstance = { $$: null };\nfunction createComponent(Component, init) {\n  return root(() => {\n    currentInstance.$$ = new Instance(Component, getScope(), init);\n    const component = new Component();\n    currentInstance.$$.component = component;\n    currentInstance.$$ = null;\n    return component;\n  });\n}\nclass ViewController extends EventTarget {\n  /** @internal */\n  $$;\n  get el() {\n    return this.$$.el;\n  }\n  get $el() {\n    return this.$$.$el();\n  }\n  get scope() {\n    return this.$$.scope;\n  }\n  get attachScope() {\n    return this.$$.attachScope;\n  }\n  get connectScope() {\n    return this.$$.connectScope;\n  }\n  /** @internal */\n  get $props() {\n    return this.$$.props;\n  }\n  /** @internal */\n  get $state() {\n    return this.$$.$state;\n  }\n  get state() {\n    return this.$$.state;\n  }\n  constructor() {\n    super();\n    if (currentInstance.$$) this.attach(currentInstance);\n  }\n  attach({ $$ }) {\n    this.$$ = $$;\n    $$.addHooks(this);\n    return this;\n  }\n  addEventListener(type, callback, options) {\n    if (!this.el) {\n      const name = this.constructor.name;\n      console.warn(`[maverick] adding event listener to \\`${name}\\` before element is attached`);\n    }\n    this.listen(type, callback, options);\n  }\n  removeEventListener(type, callback, options) {\n    this.el?.removeEventListener(type, callback, options);\n  }\n  /**\n   * The given callback is invoked when the component is ready to be set up.\n   *\n   * - This hook will run once.\n   * - This hook is called both client-side and server-side.\n   * - It's safe to use context inside this hook.\n   * - The host element has not attached yet - wait for `onAttach`.\n   */\n  /**\n   * This method can be used to specify attributes that should be set on the host element. Any\n   * attributes that are assigned to a function will be considered a signal and updated accordingly.\n   */\n  setAttributes(attributes) {\n    if (!this.$$.attrs) this.$$.attrs = {};\n    Object.assign(this.$$.attrs, attributes);\n  }\n  /**\n   * This method can be used to specify styles that should set be set on the host element. Any\n   * styles that are assigned to a function will be considered a signal and updated accordingly.\n   */\n  setStyles(styles) {\n    if (!this.$$.styles) this.$$.styles = {};\n    Object.assign(this.$$.styles, styles);\n  }\n  /**\n   * This method is used to satisfy the CSS variables contract specified on the current\n   * component. Other CSS variables can be set via the `setStyles` method.\n   */\n  setCSSVars(vars) {\n    this.setStyles(vars);\n  }\n  /**\n   * Type-safe utility for creating component DOM events.\n   */\n  createEvent(type, ...init) {\n    return new DOMEvent(type, init[0]);\n  }\n  /**\n   * Creates a `DOMEvent` and dispatches it from the host element. This method is typed to\n   * match all component events.\n   */\n  dispatch(type, ...init) {\n    if (!this.el) return false;\n    const event = type instanceof Event ? type : new DOMEvent(type, init[0]);\n    Object.defineProperty(event, \"target\", {\n      get: () => this.$$.component\n    });\n    return untrack(() => {\n      this.$$[ON_DISPATCH]?.(event);\n      return this.el.dispatchEvent(event);\n    });\n  }\n  dispatchEvent(event) {\n    return this.dispatch(event);\n  }\n  /**\n   * Adds an event listener for the given `type` and returns a function which can be invoked to\n   * remove the event listener.\n   *\n   * - The listener is removed if the current scope is disposed.\n   * - This method is safe to use on the server (noop).\n   */\n  listen(type, handler, options) {\n    if (!this.el) return noop;\n    return listenEvent(this.el, type, handler, options);\n  }\n}\n\nclass Component extends ViewController {\n  subscribe(callback) {\n    if (!this.state) {\n      const name = this.constructor.name;\n      throw Error(\n        `[maverick] component \\`${name}\\` can not be subscribed to because it has no internal state`\n      );\n    }\n    return scoped(() => effect(() => callback(this.state)), this.$$.scope);\n  }\n  destroy() {\n    this.$$.destroy();\n  }\n}\nfunction prop(target, propertyKey, descriptor) {\n  if (!target[PROPS]) target[PROPS] = /* @__PURE__ */ new Set();\n  target[PROPS].add(propertyKey);\n}\nfunction method(target, propertyKey, descriptor) {\n  if (!target[METHODS]) target[METHODS] = /* @__PURE__ */ new Set();\n  target[METHODS].add(propertyKey);\n}\nclass State {\n  id = Symbol(\"STATE\");\n  record;\n  #descriptors;\n  constructor(record) {\n    this.record = record;\n    this.#descriptors = Object.getOwnPropertyDescriptors(record);\n  }\n  create() {\n    const store = {}, state = new Proxy(store, { get: (_, prop2) => store[prop2]() });\n    for (const name of Object.keys(this.record)) {\n      const getter = this.#descriptors[name].get;\n      store[name] = getter ? computed(getter.bind(state)) : signal(this.record[name]);\n    }\n    return store;\n  }\n  reset(record, filter) {\n    for (const name of Object.keys(record)) {\n      if (!this.#descriptors[name].get && (!filter || filter(name))) {\n        record[name].set(this.record[name]);\n      }\n    }\n  }\n}\nfunction useState(state) {\n  return useContext(state);\n}\n\nfunction runAll(fns, arg) {\n  for (const fn of fns) fn(arg);\n}\n\nfunction camelToKebabCase(str) {\n  return str.replace(/([a-z])([A-Z])/g, \"$1-$2\").toLowerCase();\n}\nfunction kebabToCamelCase(str) {\n  return str.replace(/-./g, (x) => x[1].toUpperCase());\n}\nfunction uppercaseFirstChar(str) {\n  return str.charAt(0).toUpperCase() + str.slice(1);\n}\n\nfunction unwrap(fn) {\n  return isFunction(fn) ? fn() : fn;\n}\nfunction ariaBool(value) {\n  return value ? \"true\" : \"false\";\n}\nfunction createDisposalBin() {\n  const disposal = /* @__PURE__ */ new Set();\n  return {\n    add(...callbacks) {\n      for (const callback of callbacks) disposal.add(callback);\n    },\n    empty() {\n      for (const callback of disposal) callback();\n      disposal.clear();\n    }\n  };\n}\nfunction keysOf(obj) {\n  return Object.keys(obj);\n}\nfunction deferredPromise() {\n  let resolve, reject;\n  const promise = new Promise((res, rej) => {\n    resolve = res;\n    reject = rej;\n  });\n  return { promise, resolve, reject };\n}\nfunction waitTimeout(delay) {\n  return new Promise((resolve) => setTimeout(resolve, delay));\n}\nfunction animationFrameThrottle(func) {\n  let id = -1, lastArgs;\n  function throttle(...args) {\n    lastArgs = args;\n    if (id >= 0) return;\n    id = window.requestAnimationFrame(() => {\n      func.apply(this, lastArgs);\n      id = -1;\n      lastArgs = void 0;\n    });\n  }\n  return throttle;\n}\nconst requestIdleCallback = typeof window !== \"undefined\" ? \"requestIdleCallback\" in window ? window.requestIdleCallback : (cb) => window.setTimeout(cb, 1) : noop;\nfunction waitIdlePeriod(callback, options) {\n  return new Promise((resolve) => {\n    requestIdleCallback((deadline) => {\n      callback?.(deadline);\n      resolve();\n    }, options);\n  });\n}\n\nvar key = {\n  fullscreenEnabled: 0,\n  fullscreenElement: 1,\n  requestFullscreen: 2,\n  exitFullscreen: 3,\n  fullscreenchange: 4,\n  fullscreenerror: 5,\n  fullscreen: 6\n};\nvar webkit = [\n  \"webkitFullscreenEnabled\",\n  \"webkitFullscreenElement\",\n  \"webkitRequestFullscreen\",\n  \"webkitExitFullscreen\",\n  \"webkitfullscreenchange\",\n  \"webkitfullscreenerror\",\n  \"-webkit-full-screen\"\n];\nvar moz = [\n  \"mozFullScreenEnabled\",\n  \"mozFullScreenElement\",\n  \"mozRequestFullScreen\",\n  \"mozCancelFullScreen\",\n  \"mozfullscreenchange\",\n  \"mozfullscreenerror\",\n  \"-moz-full-screen\"\n];\nvar ms = [\n  \"msFullscreenEnabled\",\n  \"msFullscreenElement\",\n  \"msRequestFullscreen\",\n  \"msExitFullscreen\",\n  \"MSFullscreenChange\",\n  \"MSFullscreenError\",\n  \"-ms-fullscreen\"\n];\nvar document$1 = typeof window !== \"undefined\" && typeof window.document !== \"undefined\" ? window.document : {};\nvar vendor = \"fullscreenEnabled\" in document$1 && Object.keys(key) || webkit[0] in document$1 && webkit || moz[0] in document$1 && moz || ms[0] in document$1 && ms || [];\nvar fscreen = {\n  requestFullscreen: function(element) {\n    return element[vendor[key.requestFullscreen]]();\n  },\n  requestFullscreenFunction: function(element) {\n    return element[vendor[key.requestFullscreen]];\n  },\n  get exitFullscreen() {\n    return document$1[vendor[key.exitFullscreen]].bind(document$1);\n  },\n  get fullscreenPseudoClass() {\n    return \":\" + vendor[key.fullscreen];\n  },\n  addEventListener: function(type, handler, options) {\n    return document$1.addEventListener(vendor[key[type]], handler, options);\n  },\n  removeEventListener: function(type, handler, options) {\n    return document$1.removeEventListener(vendor[key[type]], handler, options);\n  },\n  get fullscreenEnabled() {\n    return Boolean(document$1[vendor[key.fullscreenEnabled]]);\n  },\n  set fullscreenEnabled(val) {\n  },\n  get fullscreenElement() {\n    return document$1[vendor[key.fullscreenElement]];\n  },\n  set fullscreenElement(val) {\n  },\n  get onfullscreenchange() {\n    return document$1[(\"on\" + vendor[key.fullscreenchange]).toLowerCase()];\n  },\n  set onfullscreenchange(handler) {\n    return document$1[(\"on\" + vendor[key.fullscreenchange]).toLowerCase()] = handler;\n  },\n  get onfullscreenerror() {\n    return document$1[(\"on\" + vendor[key.fullscreenerror]).toLowerCase()];\n  },\n  set onfullscreenerror(handler) {\n    return document$1[(\"on\" + vendor[key.fullscreenerror]).toLowerCase()] = handler;\n  }\n};\n\nvar functionThrottle = throttle;\n\nfunction throttle(fn, interval, options) {\n  var timeoutId = null;\n  var throttledFn = null;\n  var leading = (options && options.leading);\n  var trailing = (options && options.trailing);\n\n  if (leading == null) {\n    leading = true; // default\n  }\n\n  if (trailing == null) {\n    trailing = !leading; //default\n  }\n\n  if (leading == true) {\n    trailing = false; // forced because there should be invocation per call\n  }\n\n  var cancel = function() {\n    if (timeoutId) {\n      clearTimeout(timeoutId);\n      timeoutId = null;\n    }\n  };\n\n  var flush = function() {\n    var call = throttledFn;\n    cancel();\n\n    if (call) {\n      call();\n    }\n  };\n\n  var throttleWrapper = function() {\n    var callNow = leading && !timeoutId;\n    var context = this;\n    var args = arguments;\n\n    throttledFn = function() {\n      return fn.apply(context, args);\n    };\n\n    if (!timeoutId) {\n      timeoutId = setTimeout(function() {\n        timeoutId = null;\n\n        if (trailing) {\n          return throttledFn();\n        }\n      }, interval);\n    }\n\n    if (callNow) {\n      callNow = false;\n      return throttledFn();\n    }\n  };\n\n  throttleWrapper.cancel = cancel;\n  throttleWrapper.flush = flush;\n\n  return throttleWrapper;\n}\n\nvar functionDebounce = debounce;\n\nfunction debounce(fn, wait, callFirst) {\n  var timeout = null;\n  var debouncedFn = null;\n\n  var clear = function() {\n    if (timeout) {\n      clearTimeout(timeout);\n\n      debouncedFn = null;\n      timeout = null;\n    }\n  };\n\n  var flush = function() {\n    var call = debouncedFn;\n    clear();\n\n    if (call) {\n      call();\n    }\n  };\n\n  var debounceWrapper = function() {\n    if (!wait) {\n      return fn.apply(this, arguments);\n    }\n\n    var context = this;\n    var args = arguments;\n    var callNow = callFirst && !timeout;\n    clear();\n\n    debouncedFn = function() {\n      fn.apply(context, args);\n    };\n\n    timeout = setTimeout(function() {\n      timeout = null;\n\n      if (!callNow) {\n        var call = debouncedFn;\n        debouncedFn = null;\n\n        return call();\n      }\n    }, wait);\n\n    if (callNow) {\n      return debouncedFn();\n    }\n  };\n\n  debounceWrapper.cancel = clear;\n  debounceWrapper.flush = flush;\n\n  return debounceWrapper;\n}\n\nconst t = (t2) => \"object\" == typeof t2 && null != t2 && 1 === t2.nodeType, e = (t2, e2) => (!e2 || \"hidden\" !== t2) && (\"visible\" !== t2 && \"clip\" !== t2), n = (t2, n2) => {\n  if (t2.clientHeight < t2.scrollHeight || t2.clientWidth < t2.scrollWidth) {\n    const o2 = getComputedStyle(t2, null);\n    return e(o2.overflowY, n2) || e(o2.overflowX, n2) || ((t3) => {\n      const e2 = ((t4) => {\n        if (!t4.ownerDocument || !t4.ownerDocument.defaultView) return null;\n        try {\n          return t4.ownerDocument.defaultView.frameElement;\n        } catch (t5) {\n          return null;\n        }\n      })(t3);\n      return !!e2 && (e2.clientHeight < t3.scrollHeight || e2.clientWidth < t3.scrollWidth);\n    })(t2);\n  }\n  return false;\n}, o = (t2, e2, n2, o2, l2, r2, i, s) => r2 < t2 && i > e2 || r2 > t2 && i < e2 ? 0 : r2 <= t2 && s <= n2 || i >= e2 && s >= n2 ? r2 - t2 - o2 : i > e2 && s < n2 || r2 < t2 && s > n2 ? i - e2 + l2 : 0, l = (t2) => {\n  const e2 = t2.parentElement;\n  return null == e2 ? t2.getRootNode().host || null : e2;\n}, r = (e2, r2) => {\n  var i, s, d, h;\n  if (\"undefined\" == typeof document) return [];\n  const { scrollMode: c, block: f, inline: u, boundary: a, skipOverflowHiddenElements: g } = r2, p = \"function\" == typeof a ? a : (t2) => t2 !== a;\n  if (!t(e2)) throw new TypeError(\"Invalid target\");\n  const m = document.scrollingElement || document.documentElement, w = [];\n  let W = e2;\n  for (; t(W) && p(W); ) {\n    if (W = l(W), W === m) {\n      w.push(W);\n      break;\n    }\n    null != W && W === document.body && n(W) && !n(document.documentElement) || null != W && n(W, g) && w.push(W);\n  }\n  const b = null != (s = null == (i = window.visualViewport) ? void 0 : i.width) ? s : innerWidth, H = null != (h = null == (d = window.visualViewport) ? void 0 : d.height) ? h : innerHeight, { scrollX: y, scrollY: M } = window, { height: v, width: E, top: x, right: C, bottom: I, left: R } = e2.getBoundingClientRect(), { top: T, right: B, bottom: F, left: V } = ((t2) => {\n    const e3 = window.getComputedStyle(t2);\n    return { top: parseFloat(e3.scrollMarginTop) || 0, right: parseFloat(e3.scrollMarginRight) || 0, bottom: parseFloat(e3.scrollMarginBottom) || 0, left: parseFloat(e3.scrollMarginLeft) || 0 };\n  })(e2);\n  let k = \"start\" === f || \"nearest\" === f ? x - T : \"end\" === f ? I + F : x + v / 2 - T + F, D = \"center\" === u ? R + E / 2 - V + B : \"end\" === u ? C + B : R - V;\n  const L = [];\n  for (let t2 = 0; t2 < w.length; t2++) {\n    const e3 = w[t2], { height: n2, width: l2, top: r3, right: i2, bottom: s2, left: d2 } = e3.getBoundingClientRect();\n    if (\"if-needed\" === c && x >= 0 && R >= 0 && I <= H && C <= b && x >= r3 && I <= s2 && R >= d2 && C <= i2) return L;\n    const h2 = getComputedStyle(e3), a2 = parseInt(h2.borderLeftWidth, 10), g2 = parseInt(h2.borderTopWidth, 10), p2 = parseInt(h2.borderRightWidth, 10), W2 = parseInt(h2.borderBottomWidth, 10);\n    let T2 = 0, B2 = 0;\n    const F2 = \"offsetWidth\" in e3 ? e3.offsetWidth - e3.clientWidth - a2 - p2 : 0, V2 = \"offsetHeight\" in e3 ? e3.offsetHeight - e3.clientHeight - g2 - W2 : 0, S = \"offsetWidth\" in e3 ? 0 === e3.offsetWidth ? 0 : l2 / e3.offsetWidth : 0, X = \"offsetHeight\" in e3 ? 0 === e3.offsetHeight ? 0 : n2 / e3.offsetHeight : 0;\n    if (m === e3) T2 = \"start\" === f ? k : \"end\" === f ? k - H : \"nearest\" === f ? o(M, M + H, H, g2, W2, M + k, M + k + v, v) : k - H / 2, B2 = \"start\" === u ? D : \"center\" === u ? D - b / 2 : \"end\" === u ? D - b : o(y, y + b, b, a2, p2, y + D, y + D + E, E), T2 = Math.max(0, T2 + M), B2 = Math.max(0, B2 + y);\n    else {\n      T2 = \"start\" === f ? k - r3 - g2 : \"end\" === f ? k - s2 + W2 + V2 : \"nearest\" === f ? o(r3, s2, n2, g2, W2 + V2, k, k + v, v) : k - (r3 + n2 / 2) + V2 / 2, B2 = \"start\" === u ? D - d2 - a2 : \"center\" === u ? D - (d2 + l2 / 2) + F2 / 2 : \"end\" === u ? D - i2 + p2 + F2 : o(d2, i2, l2, a2, p2 + F2, D, D + E, E);\n      const { scrollLeft: t3, scrollTop: h3 } = e3;\n      T2 = 0 === X ? 0 : Math.max(0, Math.min(h3 + T2 / X, e3.scrollHeight - n2 / X + V2)), B2 = 0 === S ? 0 : Math.max(0, Math.min(t3 + B2 / S, e3.scrollWidth - l2 / S + F2)), k += h3 - T2, D += t3 - B2;\n    }\n    L.push({ el: e3, top: T2, left: B2 });\n  }\n  return L;\n};\n\nconst STRING = (v) => v === null ? \"\" : v + \"\";\nconst NULLABLE_STRING = (v) => v === null ? null : v + \"\";\nconst NUMBER = (v) => v === null ? 0 : Number(v);\nconst BOOLEAN = (v) => v !== null;\nconst FUNCTION = () => null;\nconst ARRAY = (v) => v === null ? [] : JSON.parse(v);\nconst OBJECT = (v) => v === null ? {} : JSON.parse(v);\nfunction inferAttributeConverter(value) {\n  if (value === null) return NULLABLE_STRING;\n  switch (typeof value) {\n    case \"undefined\":\n      return STRING;\n    case \"string\":\n      return STRING;\n    case \"boolean\":\n      return BOOLEAN;\n    case \"number\":\n      return NUMBER;\n    case \"function\":\n      return FUNCTION;\n    case \"object\":\n      return isArray(value) ? ARRAY : OBJECT;\n    default:\n      return STRING;\n  }\n}\nconst ATTRS = /* @__PURE__ */ Symbol(\"ATTRS\");\nconst SETUP = /* @__PURE__ */ Symbol(\"SETUP\");\nconst SETUP_STATE = /* @__PURE__ */ Symbol(\"SETUP_STATE\");\nconst SETUP_CALLBACKS = /* @__PURE__ */ Symbol(\"SETUP_CALLBACKS\");\nvar SetupState;\n(function(SetupState2) {\n  const Idle = 0;\n  SetupState2[SetupState2[\"Idle\"] = Idle] = \"Idle\";\n  const Pending = 1;\n  SetupState2[SetupState2[\"Pending\"] = Pending] = \"Pending\";\n  const Ready = 2;\n  SetupState2[SetupState2[\"Ready\"] = Ready] = \"Ready\";\n})(SetupState || (SetupState = {}));\nfunction Host(Super, Component) {\n  class MaverickElement extends Super {\n    static attrs;\n    static [ATTRS] = null;\n    static get observedAttributes() {\n      if (!this[ATTRS] && Component.props) {\n        const map = /* @__PURE__ */ new Map();\n        for (const propName of Object.keys(Component.props)) {\n          let attr = this.attrs?.[propName], attrName = isString(attr) ? attr : !attr ? attr : attr?.attr;\n          if (attrName === false) continue;\n          if (!attrName) attrName = camelToKebabCase(propName);\n          map.set(attrName, {\n            prop: propName,\n            converter: attr && !isString(attr) && attr?.converter || inferAttributeConverter(Component.props[propName])\n          });\n        }\n        this[ATTRS] = map;\n      }\n      return this[ATTRS] ? Array.from(this[ATTRS].keys()) : [];\n    }\n    $;\n    [SETUP_STATE] = SetupState.Idle;\n    [SETUP_CALLBACKS] = null;\n    keepAlive = false;\n    forwardKeepAlive = true;\n    get scope() {\n      return this.$.$$.scope;\n    }\n    get attachScope() {\n      return this.$.$$.attachScope;\n    }\n    get connectScope() {\n      return this.$.$$.connectScope;\n    }\n    get $props() {\n      return this.$.$$.props;\n    }\n    get $state() {\n      return this.$.$$.$state;\n    }\n    get state() {\n      return this.$.state;\n    }\n    constructor(...args) {\n      super(...args);\n      this.$ = scoped(() => createComponent(Component), null);\n      this.$.$$.addHooks(this);\n      if (Component.props) {\n        const props = this.$props, descriptors = Object.getOwnPropertyDescriptors(this);\n        for (const prop of Object.keys(descriptors)) {\n          if (prop in Component.props) {\n            props[prop].set(this[prop]);\n            delete this[prop];\n          }\n        }\n      }\n    }\n    attributeChangedCallback(name, _, newValue) {\n      const Ctor = this.constructor;\n      if (!Ctor[ATTRS]) {\n        super.attributeChangedCallback?.(name, _, newValue);\n        return;\n      }\n      const def = Ctor[ATTRS].get(name);\n      if (def) this[def.prop] = def.converter(newValue);\n    }\n    connectedCallback() {\n      const instance = this.$?.$$;\n      if (!instance || instance.destroyed) return;\n      if (this[SETUP_STATE] !== SetupState.Ready) {\n        setup.call(this);\n        return;\n      }\n      if (!this.isConnected) return;\n      if (this.hasAttribute(\"keep-alive\")) {\n        this.keepAlive = true;\n      }\n      instance.connect();\n      if (isArray(this[SETUP_CALLBACKS])) runAll(this[SETUP_CALLBACKS], this);\n      this[SETUP_CALLBACKS] = null;\n      const callback = super.connectedCallback;\n      if (callback) scoped(() => callback.call(this), this.connectScope);\n      return;\n    }\n    disconnectedCallback() {\n      const instance = this.$?.$$;\n      if (!instance || instance.destroyed) return;\n      instance.disconnect();\n      const callback = super.disconnectedCallback;\n      if (callback) callback.call(this);\n      if (!this.keepAlive && !this.hasAttribute(\"keep-alive\")) {\n        setTimeout(() => {\n          requestAnimationFrame(() => {\n            if (!this.isConnected) instance.destroy();\n          });\n        }, 0);\n      }\n    }\n    [SETUP]() {\n      const instance = this.$.$$, Ctor = this.constructor;\n      if (instance.destroyed) {\n        console.warn(`[maverick] attempted attaching to destroyed element \\`${this.tagName}\\``);\n      }\n      if (instance.destroyed) return;\n      const attrs = Ctor[ATTRS];\n      if (attrs) {\n        for (const attr of this.attributes) {\n          let def = attrs.get(attr.name);\n          if (def && def.converter) {\n            instance.props[def.prop].set(def.converter(this.getAttribute(attr.name)));\n          }\n        }\n      }\n      instance.setup();\n      instance.attach(this);\n      this[SETUP_STATE] = SetupState.Ready;\n      this.connectedCallback();\n    }\n    // @ts-expect-error\n    subscribe(callback) {\n      return this.$.subscribe(callback);\n    }\n    destroy() {\n      this.disconnectedCallback();\n      this.$.destroy();\n    }\n  }\n  extendProto(MaverickElement, Component);\n  return MaverickElement;\n}\nfunction extendProto(Element, Component) {\n  const ElementProto = Element.prototype, ComponentProto = Component.prototype;\n  if (Component.props) {\n    for (const prop of Object.keys(Component.props)) {\n      Object.defineProperty(ElementProto, prop, {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this.$props[prop]();\n        },\n        set(value) {\n          this.$props[prop].set(value);\n        }\n      });\n    }\n  }\n  if (ComponentProto[PROPS]) {\n    for (const name of ComponentProto[PROPS]) {\n      Object.defineProperty(ElementProto, name, {\n        enumerable: true,\n        configurable: true,\n        get() {\n          return this.$[name];\n        },\n        set(value) {\n          this.$[name] = value;\n        }\n      });\n    }\n  }\n  if (ComponentProto[METHODS]) {\n    for (const name of ComponentProto[METHODS]) {\n      ElementProto[name] = function(...args) {\n        return this.$[name](...args);\n      };\n    }\n  }\n}\nfunction setup() {\n  if (this[SETUP_STATE] !== SetupState.Idle) return;\n  this[SETUP_STATE] = SetupState.Pending;\n  const parent = findParent(this), isParentRegistered = parent && window.customElements.get(parent.localName), isParentSetup = parent && parent[SETUP_STATE] === SetupState.Ready;\n  if (parent && (!isParentRegistered || !isParentSetup)) {\n    waitForParent.call(this, parent);\n    return;\n  }\n  attach.call(this, parent);\n}\nasync function waitForParent(parent) {\n  await window.customElements.whenDefined(parent.localName);\n  if (parent[SETUP_STATE] !== SetupState.Ready) {\n    await new Promise((res) => (parent[SETUP_CALLBACKS] ??= []).push(res));\n  }\n  attach.call(this, parent);\n}\nfunction attach(parent) {\n  if (!this.isConnected) return;\n  if (parent) {\n    if (parent.keepAlive && parent.forwardKeepAlive) {\n      this.keepAlive = true;\n      this.setAttribute(\"keep-alive\", \"\");\n    }\n    const scope = this.$.$$.scope;\n    if (scope) parent.$.$$.attachScope.append(scope);\n  }\n  this[SETUP]();\n}\nfunction findParent(host) {\n  let node = host.parentNode, prefix = host.localName.split(\"-\", 1)[0] + \"-\";\n  while (node) {\n    if (node.nodeType === 1 && node.localName.startsWith(prefix)) {\n      return node;\n    }\n    node = node.parentNode;\n  }\n  return null;\n}\nfunction defineCustomElement(element, throws = false) {\n  if (throws || !window.customElements.get(element.tagName)) {\n    window.customElements.define(element.tagName, element);\n  }\n}\n\nvar Icon$24 = `<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M6 7C5.63181 7 5.33333 7.29848 5.33333 7.66667V14.8667C5.33333 14.9403 5.39361 14.9999 5.46724 15.0009C10.8844 15.0719 15.2614 19.449 15.3325 24.8661C15.3334 24.9397 15.393 25 15.4667 25H26C26.3682 25 26.6667 24.7015 26.6667 24.3333V7.66667C26.6667 7.29848 26.3682 7 26 7H6ZM17.0119 22.2294C17.0263 22.29 17.0802 22.3333 17.1425 22.3333H23.3333C23.7015 22.3333 24 22.0349 24 21.6667V10.3333C24 9.96514 23.7015 9.66667 23.3333 9.66667H8.66667C8.29848 9.66667 8 9.96514 8 10.3333V13.1909C8 13.2531 8.04332 13.3071 8.10392 13.3214C12.5063 14.3618 15.9715 17.827 17.0119 22.2294Z\" fill=\"currentColor\"/> <path d=\"M13.2 25C13.2736 25 13.3334 24.9398 13.3322 24.8661C13.2615 20.5544 9.77889 17.0718 5.46718 17.0011C5.39356 16.9999 5.33333 17.0597 5.33333 17.1333V18.8667C5.33333 18.9403 5.39348 18.9999 5.4671 19.0015C8.67465 19.0716 11.2617 21.6587 11.3319 24.8662C11.3335 24.9399 11.393 25 11.4667 25H13.2Z\" fill=\"currentColor\"/> <path d=\"M5.33333 21.1333C5.33333 21.0597 5.39332 20.9998 5.46692 21.0022C7.57033 21.0712 9.26217 22.763 9.33114 24.8664C9.33356 24.94 9.27364 25 9.2 25H6C5.63181 25 5.33333 24.7015 5.33333 24.3333V21.1333Z\" fill=\"currentColor\"/>`;\n\nvar Icon$0 = `<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M15.0007 28.7923C15.0007 29.0152 14.9774 29.096 14.9339 29.1775C14.8903 29.259 14.8263 29.323 14.7449 29.3665C14.6634 29.4101 14.5826 29.4333 14.3597 29.4333H12.575C12.3521 29.4333 12.2713 29.4101 12.1898 29.3665C12.1083 29.323 12.0443 29.259 12.0008 29.1775C11.9572 29.096 11.934 29.0152 11.934 28.7923V12.2993L5.97496 12.3C5.75208 12.3 5.67125 12.2768 5.58977 12.2332C5.50829 12.1896 5.44434 12.1257 5.40077 12.0442C5.35719 11.9627 5.33398 11.8819 5.33398 11.659V9.87429C5.33398 9.65141 5.35719 9.57059 5.40077 9.48911C5.44434 9.40762 5.50829 9.34368 5.58977 9.3001C5.67125 9.25652 5.75208 9.23332 5.97496 9.23332H26.0263C26.2492 9.23332 26.33 9.25652 26.4115 9.3001C26.493 9.34368 26.557 9.40762 26.6005 9.48911C26.6441 9.57059 26.6673 9.65141 26.6673 9.87429V11.659C26.6673 11.8819 26.6441 11.9627 26.6005 12.0442C26.557 12.1257 26.493 12.1896 26.4115 12.2332C26.33 12.2768 26.2492 12.3 26.0263 12.3L20.067 12.2993L20.0673 28.7923C20.0673 29.0152 20.0441 29.096 20.0005 29.1775C19.957 29.259 19.893 29.323 19.8115 29.3665C19.73 29.4101 19.6492 29.4333 19.4263 29.4333H17.6416C17.4187 29.4333 17.3379 29.4101 17.2564 29.3665C17.175 29.323 17.111 29.259 17.0674 29.1775C17.0239 29.096 17.0007 29.0152 17.0007 28.7923L17 22.7663H15L15.0007 28.7923Z\" fill=\"currentColor\"/> <path d=\"M16.0007 7.89998C17.4734 7.89998 18.6673 6.70608 18.6673 5.23332C18.6673 3.76056 17.4734 2.56665 16.0007 2.56665C14.5279 2.56665 13.334 3.76056 13.334 5.23332C13.334 6.70608 14.5279 7.89998 16.0007 7.89998Z\" fill=\"currentColor\"/>`;\n\nvar Icon$5 = `<path d=\"M5.33334 6.00001C5.33334 5.63182 5.63181 5.33334 6 5.33334H26C26.3682 5.33334 26.6667 5.63182 26.6667 6.00001V20.6667C26.6667 21.0349 26.3682 21.3333 26 21.3333H23.7072C23.4956 21.3333 23.2966 21.233 23.171 21.0628L22.1859 19.7295C21.8607 19.2894 22.1749 18.6667 22.7221 18.6667H23.3333C23.7015 18.6667 24 18.3682 24 18V8.66668C24 8.29849 23.7015 8.00001 23.3333 8.00001H8.66667C8.29848 8.00001 8 8.29849 8 8.66668V18C8 18.3682 8.29848 18.6667 8.66667 18.6667H9.29357C9.84072 18.6667 10.1549 19.2894 9.82976 19.7295L8.84467 21.0628C8.71898 21.233 8.52 21.3333 8.30848 21.3333H6C5.63181 21.3333 5.33334 21.0349 5.33334 20.6667V6.00001Z\" fill=\"currentColor\"/> <path d=\"M8.78528 25.6038C8.46013 26.0439 8.77431 26.6667 9.32147 26.6667L22.6785 26.6667C23.2256 26.6667 23.5398 26.0439 23.2146 25.6038L16.5358 16.5653C16.2693 16.2046 15.73 16.2047 15.4635 16.5653L8.78528 25.6038Z\" fill=\"currentColor\"/>`;\n\nvar Icon$8 = `<path d=\"M17.4853 18.9093C17.4853 19.0281 17.6289 19.0875 17.7129 19.0035L22.4185 14.2979C22.6788 14.0376 23.1009 14.0376 23.3613 14.2979L24.7755 15.7122C25.0359 15.9725 25.0359 16.3946 24.7755 16.655L16.2902 25.1403C16.0299 25.4006 15.6078 25.4006 15.3474 25.1403L13.9332 23.726L13.9319 23.7247L6.86189 16.6547C6.60154 16.3944 6.60154 15.9723 6.86189 15.7119L8.2761 14.2977C8.53645 14.0373 8.95856 14.0373 9.21891 14.2977L13.9243 19.0031C14.0083 19.0871 14.1519 19.0276 14.1519 18.9088L14.1519 6.00004C14.1519 5.63185 14.4504 5.33337 14.8186 5.33337L16.8186 5.33337C17.1868 5.33337 17.4853 5.63185 17.4853 6.00004L17.4853 18.9093Z\" fill=\"currentColor\"/>`;\n\nvar Icon$11 = `<path d=\"M13.0908 14.3334C12.972 14.3334 12.9125 14.1898 12.9965 14.1058L17.7021 9.40022C17.9625 9.13987 17.9625 8.71776 17.7021 8.45741L16.2879 7.04319C16.0275 6.78284 15.6054 6.78284 15.3451 7.04319L6.8598 15.5285C6.59945 15.7888 6.59945 16.2109 6.8598 16.4713L8.27401 17.8855L8.27536 17.8868L15.3453 24.9568C15.6057 25.2172 16.0278 25.2172 16.2881 24.9568L17.7024 23.5426C17.9627 23.2822 17.9627 22.8601 17.7024 22.5998L12.9969 17.8944C12.9129 17.8104 12.9724 17.6668 13.0912 17.6668L26 17.6668C26.3682 17.6668 26.6667 17.3683 26.6667 17.0001V15.0001C26.6667 14.6319 26.3682 14.3334 26 14.3334L13.0908 14.3334Z\" fill=\"currentColor\"/>`;\n\nvar Icon$13 = `<path d=\"M14.1521 13.0929C14.1521 12.9741 14.0085 12.9147 13.9245 12.9987L9.21891 17.7043C8.95856 17.9646 8.53645 17.9646 8.2761 17.7043L6.86189 16.29C6.60154 16.0297 6.60154 15.6076 6.86189 15.3472L15.3472 6.86195C15.6075 6.6016 16.0296 6.6016 16.29 6.86195L17.7042 8.27616L17.7055 8.27751L24.7755 15.3475C25.0359 15.6078 25.0359 16.0299 24.7755 16.2903L23.3613 17.7045C23.1009 17.9649 22.6788 17.9649 22.4185 17.7045L17.7131 12.9991C17.6291 12.9151 17.4855 12.9746 17.4855 13.0934V26.0022C17.4855 26.3704 17.187 26.6688 16.8188 26.6688H14.8188C14.4506 26.6688 14.1521 26.3704 14.1521 26.0022L14.1521 13.0929Z\" fill=\"currentColor\"/>`;\n\nvar Icon$16 = `<path d=\"M16.6927 25.3346C16.3245 25.3346 16.026 25.0361 16.026 24.6679L16.026 7.3346C16.026 6.96641 16.3245 6.66794 16.6927 6.66794L18.6927 6.66794C19.0609 6.66794 19.3594 6.96642 19.3594 7.3346L19.3594 24.6679C19.3594 25.0361 19.0609 25.3346 18.6927 25.3346H16.6927Z\" fill=\"currentColor\"/> <path d=\"M24.026 25.3346C23.6578 25.3346 23.3594 25.0361 23.3594 24.6679L23.3594 7.3346C23.3594 6.96641 23.6578 6.66794 24.026 6.66794L26.026 6.66794C26.3942 6.66794 26.6927 6.96642 26.6927 7.3346V24.6679C26.6927 25.0361 26.3942 25.3346 26.026 25.3346H24.026Z\" fill=\"currentColor\"/> <path d=\"M5.48113 23.9407C5.38584 24.2963 5.59689 24.6619 5.95254 24.7572L7.88439 25.2748C8.24003 25.3701 8.60559 25.159 8.70089 24.8034L13.1871 8.06067C13.2824 7.70503 13.0713 7.33947 12.7157 7.24417L10.7838 6.72654C10.4282 6.63124 10.0626 6.8423 9.96733 7.19794L5.48113 23.9407Z\" fill=\"currentColor\"/>`;\n\nvar Icon$19 = `<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M24.9266 7.57992C25.015 7.60672 25.0886 7.64746 25.2462 7.80506L26.956 9.51488C27.1136 9.67248 27.1543 9.74604 27.1811 9.83447C27.2079 9.9229 27.2079 10.0133 27.1811 10.1018C27.1543 10.1902 27.1136 10.2638 26.956 10.4214L13.1822 24.1951C13.0246 24.3527 12.951 24.3935 12.8626 24.4203C12.797 24.4402 12.7304 24.4453 12.6642 24.4357L12.7319 24.4203C12.6435 24.4471 12.553 24.4471 12.4646 24.4203C12.3762 24.3935 12.3026 24.3527 12.145 24.1951L5.04407 17.0942C4.88647 16.9366 4.84573 16.863 4.81893 16.7746C4.79213 16.6862 4.79213 16.5957 4.81893 16.5073C4.84573 16.4189 4.88647 16.3453 5.04407 16.1877L6.7539 14.4779C6.9115 14.3203 6.98506 14.2796 7.07349 14.2528C7.16191 14.226 7.25235 14.226 7.34078 14.2528C7.42921 14.2796 7.50277 14.3203 7.66037 14.4779L12.6628 19.4808L24.3397 7.80506C24.4973 7.64746 24.5709 7.60672 24.6593 7.57992C24.7477 7.55311 24.8382 7.55311 24.9266 7.57992Z\" fill=\"currentColor\"/>`;\n\nvar Icon$22 = `<path d=\"M17.947 16.095C17.999 16.043 17.999 15.9585 17.947 15.9065L11.6295 9.58899C11.3691 9.32864 11.3691 8.90653 11.6295 8.64618L13.2323 7.04341C13.4926 6.78306 13.9147 6.78306 14.1751 7.04341L21.0289 13.8973C21.0392 13.9064 21.0493 13.9158 21.0591 13.9257L22.6619 15.5285C22.9223 15.7888 22.9223 16.2109 22.6619 16.4713L14.1766 24.9565C13.9163 25.2169 13.4942 25.2169 13.2338 24.9565L11.631 23.3538C11.3707 23.0934 11.3707 22.6713 11.631 22.411L17.947 16.095Z\" fill=\"currentColor\"/>`;\n\nvar Icon$26 = `<path d=\"M8 28.0003C8 27.6321 8.29848 27.3336 8.66667 27.3336H23.3333C23.7015 27.3336 24 27.6321 24 28.0003V29.3336C24 29.7018 23.7015 30.0003 23.3333 30.0003H8.66667C8.29848 30.0003 8 29.7018 8 29.3336V28.0003Z\" fill=\"currentColor\"/> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.66602 6.66699C4.29783 6.66699 3.99935 6.96547 3.99935 7.33366V24.667C3.99935 25.0352 4.29783 25.3337 4.66602 25.3337H27.3327C27.7009 25.3337 27.9994 25.0352 27.9994 24.667V7.33366C27.9994 6.96547 27.7009 6.66699 27.3327 6.66699H4.66602ZM8.66659 21.3333C8.2984 21.3333 7.99992 21.0349 7.99992 20.6667V11.3333C7.99992 10.9651 8.2984 10.6667 8.66659 10.6667H13.9999C14.3681 10.6667 14.6666 10.9651 14.6666 11.3333V12.6667C14.6666 13.0349 14.3681 13.3333 13.9999 13.3333H10.7999C10.7263 13.3333 10.6666 13.393 10.6666 13.4667V18.5333C10.6666 18.607 10.7263 18.6667 10.7999 18.6667H13.9999C14.3681 18.6667 14.6666 18.9651 14.6666 19.3333V20.6667C14.6666 21.0349 14.3681 21.3333 13.9999 21.3333H8.66659ZM17.9999 21.3333C17.6317 21.3333 17.3333 21.0349 17.3333 20.6667V11.3333C17.3333 10.9651 17.6317 10.6667 17.9999 10.6667H23.3333C23.7014 10.6667 23.9999 10.9651 23.9999 11.3333V12.6667C23.9999 13.0349 23.7014 13.3333 23.3333 13.3333H20.1333C20.0596 13.3333 19.9999 13.393 19.9999 13.4667V18.5333C19.9999 18.607 20.0596 18.6667 20.1333 18.6667H23.3333C23.7014 18.6667 23.9999 18.9651 23.9999 19.3333V20.6667C23.9999 21.0349 23.7014 21.3333 23.3333 21.3333H17.9999Z\" fill=\"currentColor\"/>`;\n\nvar Icon$27 = `<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M4.6661 6.66699C4.29791 6.66699 3.99943 6.96547 3.99943 7.33366V24.667C3.99943 25.0352 4.29791 25.3337 4.6661 25.3337H27.3328C27.701 25.3337 27.9994 25.0352 27.9994 24.667V7.33366C27.9994 6.96547 27.701 6.66699 27.3328 6.66699H4.6661ZM8.66667 21.3333C8.29848 21.3333 8 21.0349 8 20.6667V11.3333C8 10.9651 8.29848 10.6667 8.66667 10.6667H14C14.3682 10.6667 14.6667 10.9651 14.6667 11.3333V12.6667C14.6667 13.0349 14.3682 13.3333 14 13.3333H10.8C10.7264 13.3333 10.6667 13.393 10.6667 13.4667V18.5333C10.6667 18.607 10.7264 18.6667 10.8 18.6667H14C14.3682 18.6667 14.6667 18.9651 14.6667 19.3333V20.6667C14.6667 21.0349 14.3682 21.3333 14 21.3333H8.66667ZM18 21.3333C17.6318 21.3333 17.3333 21.0349 17.3333 20.6667V11.3333C17.3333 10.9651 17.6318 10.6667 18 10.6667H23.3333C23.7015 10.6667 24 10.9651 24 11.3333V12.6667C24 13.0349 23.7015 13.3333 23.3333 13.3333H20.1333C20.0597 13.3333 20 13.393 20 13.4667V18.5333C20 18.607 20.0597 18.6667 20.1333 18.6667H23.3333C23.7015 18.6667 24 18.9651 24 19.3333V20.6667C24 21.0349 23.7015 21.3333 23.3333 21.3333H18Z\" fill=\"currentColor\"/>`;\n\nvar Icon$31 = `<path d=\"M14.2225 13.7867C14.3065 13.8706 14.4501 13.8112 14.4501 13.6924V5.99955C14.4501 5.63136 14.7486 5.33289 15.1167 5.33289H16.8501C17.2183 5.33289 17.5167 5.63136 17.5167 5.99955V13.6916C17.5167 13.8104 17.6604 13.8699 17.7444 13.7859L19.9433 11.5869C20.2037 11.3266 20.6258 11.3266 20.8861 11.5869L22.1118 12.8126C22.3722 13.0729 22.3722 13.4951 22.1118 13.7554L16.4549 19.4123C16.1946 19.6726 15.772 19.6731 15.5116 19.4128L9.85479 13.7559C9.59444 13.4956 9.59444 13.0734 9.85479 12.8131L11.0804 11.5874C11.3408 11.3271 11.7629 11.3271 12.0233 11.5874L14.2225 13.7867Z\" fill=\"currentColor\"/> <path d=\"M5.99998 20.267C5.63179 20.267 5.33331 20.5654 5.33331 20.9336V25.9997C5.33331 26.3678 5.63179 26.6663 5.99998 26.6663H26C26.3682 26.6663 26.6666 26.3678 26.6666 25.9997V20.9336C26.6666 20.5654 26.3682 20.267 26 20.267H24.2666C23.8985 20.267 23.6 20.5654 23.6 20.9336V22.9333C23.6 23.3014 23.3015 23.5999 22.9333 23.5999H9.06638C8.69819 23.5999 8.39972 23.3014 8.39972 22.9333V20.9336C8.39972 20.5654 8.10124 20.267 7.73305 20.267H5.99998Z\" fill=\"currentColor\"/>`;\n\nvar Icon$33 = `<path d=\"M16 20C18.2091 20 20 18.2092 20 16C20 13.7909 18.2091 12 16 12C13.7909 12 12 13.7909 12 16C12 18.2092 13.7909 20 16 20Z\" fill=\"currentColor\"/> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M28 16.0058C28 18.671 23.5 25.3334 16 25.3334C8.5 25.3334 4 18.6762 4 16.0058C4 13.3354 8.50447 6.66669 16 6.66669C23.4955 6.66669 28 13.3406 28 16.0058ZM25.3318 15.9934C25.3328 16.0017 25.3328 16.0099 25.3318 16.0182C25.3274 16.0571 25.3108 16.1728 25.2485 16.3708C25.1691 16.6229 25.0352 16.9462 24.8327 17.3216C24.4264 18.0749 23.7969 18.9398 22.9567 19.754C21.2791 21.3798 18.9148 22.6667 16 22.6667C13.0845 22.6667 10.7202 21.3805 9.04298 19.7557C8.20295 18.9419 7.57362 18.0773 7.16745 17.3241C6.96499 16.9486 6.83114 16.6252 6.75172 16.3729C6.67942 16.1431 6.66856 16.0243 6.66695 16.0066L6.66695 16.005C6.66859 15.9871 6.67951 15.8682 6.75188 15.6383C6.83145 15.3854 6.96554 15.0614 7.16831 14.6853C7.57507 13.9306 8.20514 13.0644 9.04577 12.249C10.7245 10.6208 13.0886 9.33335 16 9.33335C18.9108 9.33335 21.2748 10.6215 22.9539 12.2507C23.7947 13.0664 24.4249 13.933 24.8318 14.6877C25.0346 15.0639 25.1688 15.3878 25.2483 15.6404C25.3107 15.8386 25.3274 15.9545 25.3318 15.9934Z\" fill=\"currentColor\"/>`;\n\nvar Icon$34 = `<path d=\"M15.8747 8.11857C16.3148 7.79342 16.9375 8.10759 16.9375 8.65476V14.2575C16.9375 14.3669 17.0621 14.4297 17.1501 14.3647L25.6038 8.11857C26.0439 7.79342 26.6667 8.10759 26.6667 8.65476V23.3451C26.6667 23.8923 26.0439 24.2064 25.6038 23.8813L17.1501 17.6346C17.0621 17.5695 16.9375 17.6324 16.9375 17.7418L16.9375 23.3451C16.9375 23.8923 16.3147 24.2064 15.8747 23.8813L5.93387 16.5358C5.57322 16.2693 5.57323 15.7299 5.93389 15.4634L15.8747 8.11857Z\" fill=\"currentColor\"/>`;\n\nvar Icon$35 = `<path d=\"M16.1253 8.11866C15.6852 7.7935 15.0625 8.10768 15.0625 8.65484V14.2576C15.0625 14.367 14.9379 14.4298 14.8499 14.3648L6.39615 8.11866C5.95607 7.7935 5.33331 8.10768 5.33331 8.65484V23.3452C5.33331 23.8923 5.9561 24.2065 6.39617 23.8813L14.8499 17.6347C14.9379 17.5696 15.0625 17.6325 15.0625 17.7419L15.0625 23.3452C15.0625 23.8923 15.6853 24.2065 16.1253 23.8813L26.0661 16.5358C26.4268 16.2694 26.4268 15.73 26.0661 15.4635L16.1253 8.11866Z\" fill=\"currentColor\"/>`;\n\nvar Icon$39 = `<path d=\"M19.3334 13.3333C18.9652 13.3333 18.6667 13.0349 18.6667 12.6667L18.6667 7.33333C18.6667 6.96514 18.9652 6.66666 19.3334 6.66666H21.3334C21.7015 6.66666 22 6.96514 22 7.33333V9.86666C22 9.9403 22.0597 10 22.1334 10L24.6667 10C25.0349 10 25.3334 10.2985 25.3334 10.6667V12.6667C25.3334 13.0349 25.0349 13.3333 24.6667 13.3333L19.3334 13.3333Z\" fill=\"currentColor\"/> <path d=\"M13.3334 19.3333C13.3334 18.9651 13.0349 18.6667 12.6667 18.6667H7.33335C6.96516 18.6667 6.66669 18.9651 6.66669 19.3333V21.3333C6.66669 21.7015 6.96516 22 7.33335 22H9.86669C9.94032 22 10 22.0597 10 22.1333L10 24.6667C10 25.0349 10.2985 25.3333 10.6667 25.3333H12.6667C13.0349 25.3333 13.3334 25.0349 13.3334 24.6667L13.3334 19.3333Z\" fill=\"currentColor\"/> <path d=\"M18.6667 24.6667C18.6667 25.0349 18.9652 25.3333 19.3334 25.3333H21.3334C21.7015 25.3333 22 25.0349 22 24.6667V22.1333C22 22.0597 22.0597 22 22.1334 22H24.6667C25.0349 22 25.3334 21.7015 25.3334 21.3333V19.3333C25.3334 18.9651 25.0349 18.6667 24.6667 18.6667L19.3334 18.6667C18.9652 18.6667 18.6667 18.9651 18.6667 19.3333L18.6667 24.6667Z\" fill=\"currentColor\"/> <path d=\"M10.6667 13.3333H12.6667C13.0349 13.3333 13.3334 13.0349 13.3334 12.6667L13.3334 10.6667V7.33333C13.3334 6.96514 13.0349 6.66666 12.6667 6.66666H10.6667C10.2985 6.66666 10 6.96514 10 7.33333L10 9.86666C10 9.9403 9.94033 10 9.86669 10L7.33335 10C6.96516 10 6.66669 10.2985 6.66669 10.6667V12.6667C6.66669 13.0349 6.96516 13.3333 7.33335 13.3333L10.6667 13.3333Z\" fill=\"currentColor\"/>`;\n\nvar Icon$40 = `<path d=\"M25.3299 7.26517C25.2958 6.929 25.0119 6.66666 24.6667 6.66666H19.3334C18.9652 6.66666 18.6667 6.96514 18.6667 7.33333V9.33333C18.6667 9.70152 18.9652 10 19.3334 10L21.8667 10C21.9403 10 22 10.0597 22 10.1333V12.6667C22 13.0349 22.2985 13.3333 22.6667 13.3333H24.6667C25.0349 13.3333 25.3334 13.0349 25.3334 12.6667V7.33333C25.3334 7.31032 25.3322 7.28758 25.3299 7.26517Z\" fill=\"currentColor\"/> <path d=\"M22 21.8667C22 21.9403 21.9403 22 21.8667 22L19.3334 22C18.9652 22 18.6667 22.2985 18.6667 22.6667V24.6667C18.6667 25.0349 18.9652 25.3333 19.3334 25.3333L24.6667 25.3333C25.0349 25.3333 25.3334 25.0349 25.3334 24.6667V19.3333C25.3334 18.9651 25.0349 18.6667 24.6667 18.6667H22.6667C22.2985 18.6667 22 18.9651 22 19.3333V21.8667Z\" fill=\"currentColor\"/> <path d=\"M12.6667 22H10.1334C10.0597 22 10 21.9403 10 21.8667V19.3333C10 18.9651 9.70154 18.6667 9.33335 18.6667H7.33335C6.96516 18.6667 6.66669 18.9651 6.66669 19.3333V24.6667C6.66669 25.0349 6.96516 25.3333 7.33335 25.3333H12.6667C13.0349 25.3333 13.3334 25.0349 13.3334 24.6667V22.6667C13.3334 22.2985 13.0349 22 12.6667 22Z\" fill=\"currentColor\"/> <path d=\"M10 12.6667V10.1333C10 10.0597 10.0597 10 10.1334 10L12.6667 10C13.0349 10 13.3334 9.70152 13.3334 9.33333V7.33333C13.3334 6.96514 13.0349 6.66666 12.6667 6.66666H7.33335C6.96516 6.66666 6.66669 6.96514 6.66669 7.33333V12.6667C6.66669 13.0349 6.96516 13.3333 7.33335 13.3333H9.33335C9.70154 13.3333 10 13.0349 10 12.6667Z\" fill=\"currentColor\"/>`;\n\nvar Icon$53 = `<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M26.6667 5.99998C26.6667 5.63179 26.3682 5.33331 26 5.33331H11.3333C10.9651 5.33331 10.6667 5.63179 10.6667 5.99998V17.5714C10.6667 17.6694 10.5644 17.7342 10.4741 17.6962C9.91823 17.4625 9.30754 17.3333 8.66667 17.3333C6.08934 17.3333 4 19.4226 4 22C4 24.5773 6.08934 26.6666 8.66667 26.6666C11.244 26.6666 13.3333 24.5773 13.3333 22V8.66665C13.3333 8.29846 13.6318 7.99998 14 7.99998L23.3333 7.99998C23.7015 7.99998 24 8.29846 24 8.66665V14.9048C24 15.0027 23.8978 15.0675 23.8075 15.0296C23.2516 14.7958 22.6409 14.6666 22 14.6666C19.4227 14.6666 17.3333 16.756 17.3333 19.3333C17.3333 21.9106 19.4227 24 22 24C24.5773 24 26.6667 21.9106 26.6667 19.3333V5.99998ZM22 21.3333C23.1046 21.3333 24 20.4379 24 19.3333C24 18.2287 23.1046 17.3333 22 17.3333C20.8954 17.3333 20 18.2287 20 19.3333C20 20.4379 20.8954 21.3333 22 21.3333ZM8.66667 24C9.77124 24 10.6667 23.1045 10.6667 22C10.6667 20.8954 9.77124 20 8.66667 20C7.5621 20 6.66667 20.8954 6.66667 22C6.66667 23.1045 7.5621 24 8.66667 24Z\" fill=\"currentColor\"/>`;\n\nvar Icon$54 = `<path d=\"M17.5091 24.6594C17.5091 25.2066 16.8864 25.5208 16.4463 25.1956L9.44847 20.0252C9.42553 20.0083 9.39776 19.9991 9.36923 19.9991H4.66667C4.29848 19.9991 4 19.7006 4 19.3325V12.6658C4 12.2976 4.29848 11.9991 4.66667 11.9991H9.37115C9.39967 11.9991 9.42745 11.99 9.45039 11.973L16.4463 6.8036C16.8863 6.47842 17.5091 6.79259 17.5091 7.33977L17.5091 24.6594Z\" fill=\"currentColor\"/> <path d=\"M28.8621 13.6422C29.1225 13.3818 29.1225 12.9597 28.8621 12.6994L27.9193 11.7566C27.659 11.4962 27.2368 11.4962 26.9765 11.7566L24.7134 14.0197C24.6613 14.0717 24.5769 14.0717 24.5248 14.0197L22.262 11.7568C22.0016 11.4964 21.5795 11.4964 21.3191 11.7568L20.3763 12.6996C20.116 12.9599 20.116 13.382 20.3763 13.6424L22.6392 15.9053C22.6913 15.9573 22.6913 16.0418 22.6392 16.0938L20.3768 18.3562C20.1165 18.6166 20.1165 19.0387 20.3768 19.299L21.3196 20.2419C21.58 20.5022 22.0021 20.5022 22.2624 20.2418L24.5248 17.9795C24.5769 17.9274 24.6613 17.9274 24.7134 17.9795L26.976 20.2421C27.2363 20.5024 27.6585 20.5024 27.9188 20.2421L28.8616 19.2992C29.122 19.0389 29.122 18.6168 28.8616 18.3564L26.599 16.0938C26.547 16.0418 26.547 15.9573 26.599 15.9053L28.8621 13.6422Z\" fill=\"currentColor\"/>`;\n\nvar Icon$56 = `<path d=\"M26.6009 16.0725C26.6009 16.424 26.4302 17.1125 25.9409 18.0213C25.4676 18.8976 24.7542 19.8715 23.8182 20.7783C21.9489 22.5905 19.2662 24.0667 15.9342 24.0667C12.6009 24.0667 9.91958 22.5915 8.04891 20.78C7.11424 19.8736 6.40091 18.9 5.92758 18.0236C5.43824 17.1149 5.26758 16.4257 5.26758 16.0725C5.26758 15.7193 5.43824 15.0293 5.92891 14.1193C6.40224 13.2416 7.11558 12.2665 8.05158 11.3587C9.92224 9.54398 12.6049 8.06665 15.9342 8.06665C19.2636 8.06665 21.9449 9.54505 23.8169 11.3604C24.7529 12.2687 25.4662 13.2441 25.9396 14.1216C26.4302 15.0317 26.6009 15.7209 26.6009 16.0725Z\" stroke=\"currentColor\" stroke-width=\"3\"/> <path d=\"M15.9336 20.0667C18.1427 20.0667 19.9336 18.2758 19.9336 16.0667C19.9336 13.8575 18.1427 12.0667 15.9336 12.0667C13.7245 12.0667 11.9336 13.8575 11.9336 16.0667C11.9336 18.2758 13.7245 20.0667 15.9336 20.0667Z\" fill=\"currentColor\"/> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M27.2323 25.0624L6.93878 4.76886C6.78118 4.61126 6.70762 4.57052 6.61919 4.54372C6.53077 4.51692 6.44033 4.51691 6.3519 4.54372C6.26347 4.57052 6.18991 4.61126 6.03231 4.76886L4.77032 6.03085C4.61272 6.18845 4.57198 6.26201 4.54518 6.35044C4.51838 6.43887 4.51838 6.5293 4.54518 6.61773C4.57198 6.70616 4.61272 6.77972 4.77032 6.93732L25.0639 27.2308C25.2215 27.3884 25.295 27.4292 25.3834 27.456C25.4719 27.4828 25.5623 27.4828 25.6507 27.456C25.7392 27.4292 25.8127 27.3885 25.9703 27.2309L27.2323 25.9689C27.3899 25.8113 27.4307 25.7377 27.4575 25.6493C27.4843 25.5608 27.4843 25.4704 27.4575 25.382C27.4307 25.2935 27.3899 25.22 27.2323 25.0624Z\" fill=\"currentColor\"/>`;\n\nvar Icon$59 = `<path d=\"M8.66667 6.66667C8.29848 6.66667 8 6.96514 8 7.33333V24.6667C8 25.0349 8.29848 25.3333 8.66667 25.3333H12.6667C13.0349 25.3333 13.3333 25.0349 13.3333 24.6667V7.33333C13.3333 6.96514 13.0349 6.66667 12.6667 6.66667H8.66667Z\" fill=\"currentColor\"/> <path d=\"M19.3333 6.66667C18.9651 6.66667 18.6667 6.96514 18.6667 7.33333V24.6667C18.6667 25.0349 18.9651 25.3333 19.3333 25.3333H23.3333C23.7015 25.3333 24 25.0349 24 24.6667V7.33333C24 6.96514 23.7015 6.66667 23.3333 6.66667H19.3333Z\" fill=\"currentColor\"/>`;\n\nvar Icon$60 = `<path d=\"M5.33334 26V19.4667C5.33334 19.393 5.39304 19.3333 5.46668 19.3333H7.86668C7.94031 19.3333 8.00001 19.393 8.00001 19.4667V23.3333C8.00001 23.7015 8.29849 24 8.66668 24H23.3333C23.7015 24 24 23.7015 24 23.3333V8.66666C24 8.29847 23.7015 7.99999 23.3333 7.99999H19.4667C19.393 7.99999 19.3333 7.9403 19.3333 7.86666V5.46666C19.3333 5.39302 19.393 5.33333 19.4667 5.33333H26C26.3682 5.33333 26.6667 5.63181 26.6667 5.99999V26C26.6667 26.3682 26.3682 26.6667 26 26.6667H6.00001C5.63182 26.6667 5.33334 26.3682 5.33334 26Z\" fill=\"currentColor\"/> <path d=\"M14.0098 8.42359H10.806C10.6872 8.42359 10.6277 8.56721 10.7117 8.6512L16.5491 14.4886C16.8094 14.7489 16.8094 15.171 16.5491 15.4314L15.3234 16.657C15.0631 16.9174 14.641 16.9174 14.3806 16.657L8.63739 10.9138C8.55339 10.8298 8.40978 10.8893 8.40978 11.0081V14.0236C8.40978 14.3918 8.1113 14.6903 7.74311 14.6903H6.00978C5.64159 14.6903 5.34311 14.3918 5.34311 14.0236L5.34311 6.02359C5.34311 5.6554 5.64159 5.35692 6.00978 5.35692L14.0098 5.35692C14.378 5.35692 14.6764 5.6554 14.6764 6.02359V7.75692C14.6764 8.12511 14.378 8.42359 14.0098 8.42359Z\" fill=\"currentColor\"/>`;\n\nvar Icon$61 = `<path d=\"M16 15.3333C15.6318 15.3333 15.3333 15.6318 15.3333 16V20C15.3333 20.3682 15.6318 20.6667 16 20.6667H21.3333C21.7015 20.6667 22 20.3682 22 20V16C22 15.6318 21.7015 15.3333 21.3333 15.3333H16Z\" fill=\"currentColor\"/> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M5.33333 7.33334C5.33333 6.96515 5.63181 6.66667 5.99999 6.66667H26C26.3682 6.66667 26.6667 6.96515 26.6667 7.33334V24.6667C26.6667 25.0349 26.3682 25.3333 26 25.3333H5.99999C5.63181 25.3333 5.33333 25.0349 5.33333 24.6667V7.33334ZM7.99999 10C7.99999 9.63182 8.29847 9.33334 8.66666 9.33334H23.3333C23.7015 9.33334 24 9.63182 24 10V22C24 22.3682 23.7015 22.6667 23.3333 22.6667H8.66666C8.29847 22.6667 7.99999 22.3682 7.99999 22V10Z\" fill=\"currentColor\"/>`;\n\nvar Icon$62 = `<path d=\"M10.6667 6.6548C10.6667 6.10764 11.2894 5.79346 11.7295 6.11862L24.377 15.4634C24.7377 15.7298 24.7377 16.2692 24.3771 16.5357L11.7295 25.8813C11.2895 26.2065 10.6667 25.8923 10.6667 25.3451L10.6667 6.6548Z\" fill=\"currentColor\"/>`;\n\nvar Icon$63 = `<path d=\"M13.9213 5.53573C14.3146 5.45804 14.6666 5.76987 14.6666 6.17079V7.57215C14.6666 7.89777 14.4305 8.17277 14.114 8.24925C12.5981 8.61559 11.2506 9.41368 10.2091 10.506C9.98474 10.7414 9.62903 10.8079 9.34742 10.6453L8.14112 9.94885C7.79394 9.7484 7.69985 9.28777 7.96359 8.98585C9.48505 7.24409 11.5636 6.00143 13.9213 5.53573Z\" fill=\"currentColor\"/> <path d=\"M5.88974 12.5908C6.01805 12.2101 6.46491 12.0603 6.81279 12.2611L8.01201 12.9535C8.29379 13.1162 8.41396 13.4577 8.32238 13.7699C8.11252 14.4854 7.99998 15.2424 7.99998 16.0257C7.99998 16.809 8.11252 17.566 8.32238 18.2814C8.41396 18.5936 8.29378 18.9352 8.01201 19.0979L6.82742 19.7818C6.48051 19.9821 6.03488 19.8337 5.90521 19.4547C5.5345 18.3712 5.33331 17.2091 5.33331 16C5.33331 14.8078 5.5289 13.6613 5.88974 12.5908Z\" fill=\"currentColor\"/> <path d=\"M8.17106 22.0852C7.82291 22.2862 7.72949 22.7486 7.99532 23.0502C9.51387 24.773 11.5799 26.0017 13.9213 26.4642C14.3146 26.5419 14.6666 26.2301 14.6666 25.8291V24.4792C14.6666 24.1536 14.4305 23.8786 14.114 23.8021C12.5981 23.4358 11.2506 22.6377 10.2091 21.5453C9.98474 21.31 9.62903 21.2435 9.34742 21.4061L8.17106 22.0852Z\" fill=\"currentColor\"/> <path d=\"M17.3333 25.8291C17.3333 26.2301 17.6857 26.5418 18.079 26.4641C22.9748 25.4969 26.6666 21.1796 26.6666 16C26.6666 10.8204 22.9748 6.50302 18.079 5.5358C17.6857 5.4581 17.3333 5.76987 17.3333 6.17079V7.57215C17.3333 7.89777 17.5697 8.17282 17.8862 8.24932C21.3942 9.09721 24 12.2572 24 16.0257C24 19.7942 21.3942 22.9542 17.8862 23.802C17.5697 23.8785 17.3333 24.1536 17.3333 24.4792V25.8291Z\" fill=\"currentColor\"/> <path d=\"M14.3961 10.4163C13.9561 10.0911 13.3333 10.4053 13.3333 10.9525L13.3333 21.0474C13.3333 21.5946 13.9561 21.9087 14.3962 21.5836L21.2273 16.5359C21.5879 16.2694 21.5879 15.73 21.2273 15.4635L14.3961 10.4163Z\" fill=\"currentColor\"/>`;\n\nvar Icon$74 = `<path d=\"M15.6038 12.2147C16.0439 12.5399 16.6667 12.2257 16.6667 11.6786V10.1789C16.6667 10.1001 16.7351 10.0384 16.8134 10.0479C20.1116 10.4494 22.6667 13.2593 22.6667 16.6659C22.6667 20.3481 19.6817 23.3332 15.9995 23.3332C12.542 23.3332 9.69927 20.7014 9.36509 17.332C9.32875 16.9655 9.03371 16.6662 8.66548 16.6662L6.66655 16.6666C6.29841 16.6666 5.99769 16.966 6.02187 17.3334C6.36494 22.5454 10.7012 26.6667 16 26.6667C21.5228 26.6667 26 22.1895 26 16.6667C26 11.4103 21.9444 7.10112 16.7916 6.69757C16.7216 6.69209 16.6667 6.63396 16.6667 6.56372V4.98824C16.6667 4.44106 16.0439 4.12689 15.6038 4.45206L11.0765 7.79738C10.7159 8.06387 10.7159 8.60326 11.0766 8.86973L15.6038 12.2147Z\" fill=\"currentColor\"/>`;\n\nvar Icon$77 = `<path d=\"M16.6667 10.3452C16.6667 10.8924 16.0439 11.2066 15.6038 10.8814L11.0766 7.5364C10.7159 7.26993 10.7159 6.73054 11.0766 6.46405L15.6038 3.11873C16.0439 2.79356 16.6667 3.10773 16.6667 3.6549V5.22682C16.6667 5.29746 16.7223 5.35579 16.7927 5.36066C22.6821 5.76757 27.3333 10.674 27.3333 16.6667C27.3333 22.9259 22.2592 28 16 28C9.96483 28 5.03145 23.2827 4.68601 17.3341C4.66466 16.9665 4.96518 16.6673 5.33339 16.6673H7.3334C7.70157 16.6673 7.99714 16.9668 8.02743 17.3337C8.36638 21.4399 11.8064 24.6667 16 24.6667C20.4183 24.6667 24 21.085 24 16.6667C24 12.5225 20.8483 9.11428 16.8113 8.70739C16.7337 8.69957 16.6667 8.76096 16.6667 8.83893V10.3452Z\" fill=\"currentColor\"/> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17.0879 19.679C17.4553 19.9195 17.8928 20.0398 18.4004 20.0398C18.9099 20.0398 19.3474 19.9205 19.7129 19.6818C20.0803 19.4413 20.3635 19.0938 20.5623 18.6392C20.7612 18.1847 20.8606 17.6373 20.8606 16.9972C20.8625 16.3608 20.764 15.8192 20.5652 15.3722C20.3663 14.9252 20.0822 14.5853 19.7129 14.3523C19.3455 14.1175 18.908 14 18.4004 14C17.8928 14 17.4553 14.1175 17.0879 14.3523C16.7224 14.5853 16.4402 14.9252 16.2413 15.3722C16.0443 15.8173 15.9449 16.3589 15.943 16.9972C15.9411 17.6354 16.0396 18.1818 16.2385 18.6364C16.4373 19.089 16.7205 19.4366 17.0879 19.679ZM19.1362 18.4262C18.9487 18.7349 18.7034 18.8892 18.4004 18.8892C18.1996 18.8892 18.0226 18.8211 17.8691 18.6847C17.7157 18.5464 17.5964 18.3372 17.5112 18.0568C17.4279 17.7765 17.3871 17.4233 17.389 16.9972C17.3909 16.3684 17.4847 15.9025 17.6703 15.5995C17.8559 15.2945 18.0993 15.1421 18.4004 15.1421C18.603 15.1421 18.7801 15.2093 18.9316 15.3438C19.0832 15.4782 19.2015 15.6828 19.2868 15.9574C19.372 16.2301 19.4146 16.5767 19.4146 16.9972C19.4165 17.6392 19.3237 18.1156 19.1362 18.4262Z\" fill=\"currentColor\"/> <path d=\"M13.7746 19.8978C13.8482 19.8978 13.9079 19.8381 13.9079 19.7644V14.2129C13.9079 14.1393 13.8482 14.0796 13.7746 14.0796H12.642C12.6171 14.0796 12.5927 14.0865 12.5716 14.0997L11.2322 14.9325C11.1931 14.9568 11.1693 14.9996 11.1693 15.0457V15.9497C11.1693 16.0539 11.2833 16.1178 11.3722 16.0635L12.464 15.396C12.4682 15.3934 12.473 15.3921 12.4779 15.3921C12.4926 15.3921 12.5045 15.404 12.5045 15.4187V19.7644C12.5045 19.8381 12.5642 19.8978 12.6378 19.8978H13.7746Z\" fill=\"currentColor\"/>`;\n\nvar Icon$81 = `<path d=\"M15.3333 10.3452C15.3333 10.8924 15.9561 11.2066 16.3962 10.8814L20.9234 7.5364C21.2841 7.26993 21.2841 6.73054 20.9235 6.46405L16.3962 3.11873C15.9561 2.79356 15.3333 3.10773 15.3333 3.6549V5.22682C15.3333 5.29746 15.2778 5.35579 15.2073 5.36066C9.31791 5.76757 4.66667 10.674 4.66667 16.6667C4.66667 22.9259 9.74078 28 16 28C22.0352 28 26.9686 23.2827 27.314 17.3341C27.3354 16.9665 27.0348 16.6673 26.6666 16.6673H24.6666C24.2984 16.6673 24.0029 16.9668 23.9726 17.3337C23.6336 21.4399 20.1937 24.6667 16 24.6667C11.5817 24.6667 8 21.085 8 16.6667C8 12.5225 11.1517 9.11428 15.1887 8.70739C15.2663 8.69957 15.3333 8.76096 15.3333 8.83893V10.3452Z\" fill=\"currentColor\"/> <path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M17.0879 19.679C17.4553 19.9195 17.8928 20.0398 18.4004 20.0398C18.9099 20.0398 19.3474 19.9205 19.7129 19.6818C20.0803 19.4413 20.3635 19.0938 20.5623 18.6392C20.7612 18.1847 20.8606 17.6373 20.8606 16.9972C20.8625 16.3608 20.764 15.8192 20.5652 15.3722C20.3663 14.9252 20.0822 14.5853 19.7129 14.3523C19.3455 14.1175 18.908 14 18.4004 14C17.8928 14 17.4553 14.1175 17.0879 14.3523C16.7224 14.5853 16.4402 14.9252 16.2413 15.3722C16.0443 15.8173 15.9449 16.3589 15.943 16.9972C15.9411 17.6354 16.0396 18.1818 16.2385 18.6364C16.4373 19.089 16.7205 19.4366 17.0879 19.679ZM19.1362 18.4262C18.9487 18.7349 18.7034 18.8892 18.4004 18.8892C18.1996 18.8892 18.0225 18.8211 17.8691 18.6847C17.7157 18.5464 17.5964 18.3372 17.5112 18.0568C17.4278 17.7765 17.3871 17.4233 17.389 16.9972C17.3909 16.3684 17.4847 15.9025 17.6703 15.5995C17.8559 15.2945 18.0992 15.1421 18.4004 15.1421C18.603 15.1421 18.7801 15.2093 18.9316 15.3438C19.0831 15.4782 19.2015 15.6828 19.2867 15.9574C19.372 16.2301 19.4146 16.5767 19.4146 16.9972C19.4165 17.6392 19.3237 18.1156 19.1362 18.4262Z\" fill=\"currentColor\"/> <path d=\"M13.7746 19.8978C13.8482 19.8978 13.9079 19.8381 13.9079 19.7644V14.2129C13.9079 14.1393 13.8482 14.0796 13.7746 14.0796H12.642C12.6171 14.0796 12.5927 14.0865 12.5716 14.0997L11.2322 14.9325C11.1931 14.9568 11.1693 14.9996 11.1693 15.0457V15.9497C11.1693 16.0539 11.2833 16.1178 11.3722 16.0635L12.464 15.396C12.4682 15.3934 12.473 15.3921 12.4779 15.3921C12.4926 15.3921 12.5045 15.404 12.5045 15.4187V19.7644C12.5045 19.8381 12.5642 19.8978 12.6378 19.8978H13.7746Z\" fill=\"currentColor\"/>`;\n\nvar Icon$88 = `<path fill-rule=\"evenodd\" clip-rule=\"evenodd\" d=\"M13.5722 5.33333C13.2429 5.33333 12.9629 5.57382 12.9132 5.89938L12.4063 9.21916C12.4 9.26058 12.3746 9.29655 12.3378 9.31672C12.2387 9.37118 12.1409 9.42779 12.0444 9.48648C12.0086 9.5083 11.9646 9.51242 11.9255 9.49718L8.79572 8.27692C8.48896 8.15732 8.14083 8.27958 7.9762 8.56472L5.5491 12.7686C5.38444 13.0538 5.45271 13.4165 5.70981 13.6223L8.33308 15.7225C8.3658 15.7487 8.38422 15.7887 8.38331 15.8306C8.38209 15.8867 8.38148 15.9429 8.38148 15.9993C8.38148 16.0558 8.3821 16.1121 8.38332 16.1684C8.38423 16.2102 8.36582 16.2503 8.33313 16.2765L5.7103 18.3778C5.45334 18.5836 5.38515 18.9462 5.54978 19.2314L7.97688 23.4352C8.14155 23.7205 8.48981 23.8427 8.79661 23.723L11.926 22.5016C11.9651 22.4864 12.009 22.4905 12.0449 22.5123C12.1412 22.5709 12.2388 22.6274 12.3378 22.6818C12.3745 22.7019 12.4 22.7379 12.4063 22.7793L12.9132 26.0993C12.9629 26.4249 13.2429 26.6654 13.5722 26.6654H18.4264C18.7556 26.6654 19.0356 26.425 19.0854 26.0995L19.5933 22.7801C19.5997 22.7386 19.6252 22.7027 19.6619 22.6825C19.7614 22.6279 19.8596 22.5711 19.9564 22.5121C19.9923 22.4903 20.0362 22.4862 20.0754 22.5015L23.2035 23.7223C23.5103 23.842 23.8585 23.7198 24.0232 23.4346L26.4503 19.2307C26.6149 18.9456 26.5467 18.583 26.2898 18.3771L23.6679 16.2766C23.6352 16.2504 23.6168 16.2104 23.6177 16.1685C23.619 16.1122 23.6196 16.0558 23.6196 15.9993C23.6196 15.9429 23.619 15.8866 23.6177 15.8305C23.6168 15.7886 23.6353 15.7486 23.668 15.7224L26.2903 13.623C26.5474 13.4172 26.6156 13.0544 26.451 12.7692L24.0239 8.56537C23.8592 8.28023 23.5111 8.15797 23.2043 8.27757L20.0758 9.49734C20.0367 9.51258 19.9927 9.50846 19.9569 9.48664C19.8599 9.42762 19.7616 9.37071 19.6618 9.31596C19.6251 9.2958 19.5997 9.25984 19.5933 9.21843L19.0854 5.89915C19.0356 5.57369 18.7556 5.33333 18.4264 5.33333H13.5722ZM16.0001 20.2854C18.3672 20.2854 20.2862 18.3664 20.2862 15.9993C20.2862 13.6322 18.3672 11.7132 16.0001 11.7132C13.6329 11.7132 11.714 13.6322 11.714 15.9993C11.714 18.3664 13.6329 20.2854 16.0001 20.2854Z\" fill=\"currentColor\"/>`;\n\nvar Icon$104 = `<path d=\"M17.5091 24.6595C17.5091 25.2066 16.8864 25.5208 16.4463 25.1956L9.44847 20.0252C9.42553 20.0083 9.39776 19.9992 9.36923 19.9992H4.66667C4.29848 19.9992 4 19.7007 4 19.3325V12.6658C4 12.2976 4.29848 11.9992 4.66667 11.9992H9.37115C9.39967 11.9992 9.42745 11.99 9.45039 11.9731L16.4463 6.80363C16.8863 6.47845 17.5091 6.79262 17.5091 7.3398L17.5091 24.6595Z\" fill=\"currentColor\"/> <path d=\"M27.5091 9.33336C27.8773 9.33336 28.1758 9.63184 28.1758 10V22C28.1758 22.3682 27.8773 22.6667 27.5091 22.6667H26.1758C25.8076 22.6667 25.5091 22.3682 25.5091 22V10C25.5091 9.63184 25.8076 9.33336 26.1758 9.33336L27.5091 9.33336Z\" fill=\"currentColor\"/> <path d=\"M22.1758 12C22.544 12 22.8424 12.2985 22.8424 12.6667V19.3334C22.8424 19.7016 22.544 20 22.1758 20H20.8424C20.4743 20 20.1758 19.7016 20.1758 19.3334V12.6667C20.1758 12.2985 20.4743 12 20.8424 12H22.1758Z\" fill=\"currentColor\"/>`;\n\nvar Icon$105 = `<path d=\"M17.5091 24.6594C17.5091 25.2066 16.8864 25.5207 16.4463 25.1956L9.44847 20.0252C9.42553 20.0083 9.39776 19.9991 9.36923 19.9991H4.66667C4.29848 19.9991 4 19.7006 4 19.3324V12.6658C4 12.2976 4.29848 11.9991 4.66667 11.9991H9.37115C9.39967 11.9991 9.42745 11.99 9.45039 11.973L16.4463 6.80358C16.8863 6.4784 17.5091 6.79258 17.5091 7.33975L17.5091 24.6594Z\" fill=\"currentColor\"/> <path d=\"M22.8424 12.6667C22.8424 12.2985 22.544 12 22.1758 12H20.8424C20.4743 12 20.1758 12.2985 20.1758 12.6667V19.3333C20.1758 19.7015 20.4743 20 20.8424 20H22.1758C22.544 20 22.8424 19.7015 22.8424 19.3333V12.6667Z\" fill=\"currentColor\"/>`;\n\nexport { BOOLEAN, Component, DOMEvent, EventsController, EventsTarget, Host, Icon$0, Icon$104, Icon$105, Icon$11, Icon$13, Icon$16, Icon$19, Icon$22, Icon$24, Icon$26, Icon$27, Icon$31, Icon$33, Icon$34, Icon$35, Icon$39, Icon$40, Icon$5, Icon$53, Icon$54, Icon$56, Icon$59, Icon$60, Icon$61, Icon$62, Icon$63, Icon$74, Icon$77, Icon$8, Icon$81, Icon$88, State, ViewController, animationFrameThrottle, appendTriggerEvent, ariaBool, camelToKebabCase, computed, createContext, createDisposalBin, createScope, deferredPromise, defineCustomElement, effect, findTriggerEvent, fscreen, functionDebounce, functionThrottle, getScope, hasProvidedContext, hasTriggerEvent, isArray, isBoolean, isDOMNode, isFunction, isKeyboardClick, isKeyboardEvent, isMouseEvent, isNil, isNull, isNumber, isObject, isPointerEvent, isString, isTouchEvent, isUndefined, isWriteSignal, kebabToCamelCase, keysOf, listenEvent, method, noop, onDispose, peek, prop, provideContext, r, scoped, setAttribute, setStyle, signal, tick, toggleClass, untrack, unwrap, uppercaseFirstChar, useContext, useState, waitIdlePeriod, waitTimeout, walkTriggerEventChain, wasEnterKeyPressed };\n","function coerceToError(error) {\n  return error instanceof Error ? error : Error(typeof error === \"string\" ? error : JSON.stringify(error));\n}\nfunction assert(condition, message) {\n  if (!condition) {\n    throw Error(message || \"Assertion failed.\");\n  }\n}\n\nexport { assert, coerceToError };\n","import { EventsTarget, DOMEvent, isString, isArray, isNumber } from './vidstack-DVpy0IqK.js';\nimport { getRequestCredentials } from './vidstack-BgIVvpNy.js';\nimport { isCueActive } from './vidstack-C1THCRTj.js';\n\nconst CROSS_ORIGIN = Symbol(\"TEXT_TRACK_CROSS_ORIGIN\" ), READY_STATE = Symbol(\"TEXT_TRACK_READY_STATE\" ), UPDATE_ACTIVE_CUES = Symbol(\"TEXT_TRACK_UPDATE_ACTIVE_CUES\" ), CAN_LOAD = Symbol(\"TEXT_TRACK_CAN_LOAD\" ), ON_MODE_CHANGE = Symbol(\"TEXT_TRACK_ON_MODE_CHANGE\" ), NATIVE = Symbol(\"TEXT_TRACK_NATIVE\" ), NATIVE_HLS = Symbol(\"TEXT_TRACK_NATIVE_HLS\" );\nconst TextTrackSymbol = {\n  crossOrigin: CROSS_ORIGIN,\n  readyState: READY_STATE,\n  updateActiveCues: UPDATE_ACTIVE_CUES,\n  canLoad: CAN_LOAD,\n  onModeChange: ON_MODE_CHANGE,\n  native: NATIVE,\n  nativeHLS: NATIVE_HLS\n};\n\nclass TextTrack extends EventsTarget {\n  static createId(track) {\n    return `vds-${track.type}-${track.kind}-${track.src ?? track.label ?? \"?\"}`;\n  }\n  src;\n  content;\n  type;\n  encoding;\n  id = \"\";\n  label = \"\";\n  language = \"\";\n  kind;\n  default = false;\n  #canLoad = false;\n  #currentTime = 0;\n  #mode = \"disabled\";\n  #metadata = {};\n  #regions = [];\n  #cues = [];\n  #activeCues = [];\n  /** @internal */\n  [TextTrackSymbol.readyState] = 0;\n  /** @internal */\n  [TextTrackSymbol.crossOrigin];\n  /** @internal */\n  [TextTrackSymbol.onModeChange] = null;\n  /** @internal */\n  [TextTrackSymbol.native] = null;\n  get metadata() {\n    return this.#metadata;\n  }\n  get regions() {\n    return this.#regions;\n  }\n  get cues() {\n    return this.#cues;\n  }\n  get activeCues() {\n    return this.#activeCues;\n  }\n  /**\n   * - 0: Not Loading\n   * - 1: Loading\n   * - 2: Ready\n   * - 3: Error\n   */\n  get readyState() {\n    return this[TextTrackSymbol.readyState];\n  }\n  get mode() {\n    return this.#mode;\n  }\n  set mode(mode) {\n    this.setMode(mode);\n  }\n  constructor(init) {\n    super();\n    for (const prop of Object.keys(init)) this[prop] = init[prop];\n    if (!this.type) this.type = \"vtt\";\n    if (init.content) {\n      this.#parseContent(init);\n    } else if (!init.src) {\n      this[TextTrackSymbol.readyState] = 2;\n    }\n    if (isTrackCaptionKind(this) && !this.label) {\n      console.warn(`[vidstack] captions text track created without label: \\`${this.src}\\``);\n    }\n  }\n  addCue(cue, trigger) {\n    let i = 0, length = this.#cues.length;\n    for (i = 0; i < length; i++) if (cue.endTime <= this.#cues[i].startTime) break;\n    if (i === length) this.#cues.push(cue);\n    else this.#cues.splice(i, 0, cue);\n    if (!(cue instanceof TextTrackCue)) {\n      this[TextTrackSymbol.native]?.track.addCue(cue);\n    }\n    this.dispatchEvent(new DOMEvent(\"add-cue\", { detail: cue, trigger }));\n    if (isCueActive(cue, this.#currentTime)) {\n      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);\n    }\n  }\n  removeCue(cue, trigger) {\n    const index = this.#cues.indexOf(cue);\n    if (index >= 0) {\n      const isActive = this.#activeCues.includes(cue);\n      this.#cues.splice(index, 1);\n      this[TextTrackSymbol.native]?.track.removeCue(cue);\n      this.dispatchEvent(new DOMEvent(\"remove-cue\", { detail: cue, trigger }));\n      if (isActive) {\n        this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);\n      }\n    }\n  }\n  setMode(mode, trigger) {\n    if (this.#mode === mode) return;\n    this.#mode = mode;\n    if (mode === \"disabled\") {\n      this.#activeCues = [];\n      this.#activeCuesChanged();\n    } else if (this.readyState === 2) {\n      this[TextTrackSymbol.updateActiveCues](this.#currentTime, trigger);\n    } else {\n      this.#load();\n    }\n    this.dispatchEvent(new DOMEvent(\"mode-change\", { detail: this, trigger }));\n    this[TextTrackSymbol.onModeChange]?.();\n  }\n  /** @internal */\n  [TextTrackSymbol.updateActiveCues](currentTime, trigger) {\n    this.#currentTime = currentTime;\n    if (this.mode === \"disabled\" || !this.#cues.length) return;\n    const activeCues = [];\n    for (let i = 0, length = this.#cues.length; i < length; i++) {\n      const cue = this.#cues[i];\n      if (isCueActive(cue, currentTime)) activeCues.push(cue);\n    }\n    let changed = activeCues.length !== this.#activeCues.length;\n    if (!changed) {\n      for (let i = 0; i < activeCues.length; i++) {\n        if (!this.#activeCues.includes(activeCues[i])) {\n          changed = true;\n          break;\n        }\n      }\n    }\n    this.#activeCues = activeCues;\n    if (changed) this.#activeCuesChanged(trigger);\n  }\n  /** @internal */\n  [TextTrackSymbol.canLoad]() {\n    this.#canLoad = true;\n    if (this.#mode !== \"disabled\") this.#load();\n  }\n  #parseContent(init) {\n    import('media-captions').then(({ parseText, VTTCue, VTTRegion }) => {\n      if (!isString(init.content) || init.type === \"json\") {\n        this.#parseJSON(init.content, VTTCue, VTTRegion);\n        if (this.readyState !== 3) this.#ready();\n      } else {\n        parseText(init.content, { type: init.type }).then(({ cues, regions }) => {\n          this.#cues = cues;\n          this.#regions = regions;\n          this.#ready();\n        });\n      }\n    });\n  }\n  async #load() {\n    if (!this.#canLoad || this[TextTrackSymbol.readyState] > 0) return;\n    this[TextTrackSymbol.readyState] = 1;\n    this.dispatchEvent(new DOMEvent(\"load-start\"));\n    if (!this.src) {\n      this.#ready();\n      return;\n    }\n    try {\n      const { parseResponse, VTTCue, VTTRegion } = await import('media-captions'), crossOrigin = this[TextTrackSymbol.crossOrigin]?.();\n      const response = fetch(this.src, {\n        headers: this.type === \"json\" ? { \"Content-Type\": \"application/json\" } : void 0,\n        credentials: getRequestCredentials(crossOrigin)\n      });\n      if (this.type === \"json\") {\n        this.#parseJSON(await (await response).text(), VTTCue, VTTRegion);\n      } else {\n        const { errors, metadata, regions, cues } = await parseResponse(response, {\n          type: this.type,\n          encoding: this.encoding\n        });\n        if (errors[0]?.code === 0) {\n          throw errors[0];\n        } else {\n          this.#metadata = metadata;\n          this.#regions = regions;\n          this.#cues = cues;\n        }\n      }\n      this.#ready();\n    } catch (error) {\n      this.#error(error);\n    }\n  }\n  #ready() {\n    this[TextTrackSymbol.readyState] = 2;\n    if (!this.src || this.type !== \"vtt\") {\n      const native = this[TextTrackSymbol.native];\n      if (native && !native.managed) {\n        for (const cue of this.#cues) native.track.addCue(cue);\n      }\n    }\n    const loadEvent = new DOMEvent(\"load\");\n    this[TextTrackSymbol.updateActiveCues](this.#currentTime, loadEvent);\n    this.dispatchEvent(loadEvent);\n  }\n  #error(error) {\n    this[TextTrackSymbol.readyState] = 3;\n    this.dispatchEvent(new DOMEvent(\"error\", { detail: error }));\n  }\n  #parseJSON(json, VTTCue, VTTRegion) {\n    try {\n      const { regions, cues } = parseJSONCaptionsFile(json, VTTCue, VTTRegion);\n      this.#regions = regions;\n      this.#cues = cues;\n    } catch (error) {\n      {\n        console.error(`[vidstack] failed to parse JSON captions at: \\`${this.src}\\`\n\n`, error);\n      }\n      this.#error(error);\n    }\n  }\n  #activeCuesChanged(trigger) {\n    this.dispatchEvent(new DOMEvent(\"cue-change\", { trigger }));\n  }\n}\nconst captionRE = /captions|subtitles/;\nfunction isTrackCaptionKind(track) {\n  return captionRE.test(track.kind);\n}\nfunction parseJSONCaptionsFile(json, Cue, Region) {\n  const content = isString(json) ? JSON.parse(json) : json;\n  let regions = [], cues = [];\n  if (content.regions && Region) {\n    regions = content.regions.map((region) => Object.assign(new Region(), region));\n  }\n  if (content.cues || isArray(content)) {\n    cues = (isArray(content) ? content : content.cues).filter((content2) => isNumber(content2.startTime) && isNumber(content2.endTime)).map((cue) => Object.assign(new Cue(0, 0, \"\"), cue));\n  }\n  return { regions, cues };\n}\n\nexport { TextTrack, TextTrackSymbol, isTrackCaptionKind, parseJSONCaptionsFile };\n","function round(num, decimalPlaces = 2) {\n  return Number(num.toFixed(decimalPlaces));\n}\nfunction getNumberOfDecimalPlaces(num) {\n  return String(num).split(\".\")[1]?.length ?? 0;\n}\nfunction clampNumber(min, value, max) {\n  return Math.max(min, Math.min(max, value));\n}\n\nexport { clampNumber, getNumberOfDecimalPlaces, round };\n","import { DOMEvent, EventsTarget, fscreen, ViewController, EventsController, onDispose, signal, listenEvent, peek, isString, isNumber, State, tick, Component, functionThrottle, effect, untrack, functionDebounce, isArray, isKeyboardClick, isKeyboardEvent, waitIdlePeriod, deferredPromise, isUndefined, prop, method, provideContext, setAttribute, animationFrameThrottle, uppercaseFirstChar, camelToKebabCase, setStyle, computed, scoped, noop } from './vidstack-DVpy0IqK.js';\nimport { mediaContext, useMediaContext } from './vidstack-CUYciP40.js';\nimport { canOrientScreen, IS_IPHONE, isAudioSrc, canPlayAudioType, isVideoSrc, canPlayVideoType, isHLSSupported, isHLSSrc, isDASHSupported, isDASHSrc, IS_CHROME, IS_IOS, canGoogleCastSrc, canChangeVolume } from './vidstack-CrZuJYaH.js';\nimport { TimeRange, getTimeRangesStart, getTimeRangesEnd, updateTimeIntervals } from './vidstack-B5ElR9su.js';\nimport { isTrackCaptionKind, TextTrackSymbol, TextTrack } from './vidstack-DghpoXbA.js';\nimport { ListSymbol } from './vidstack-Dv_LIPFu.js';\nimport { QualitySymbol } from './vidstack-Bpr4fI4n.js';\nimport { coerceToError } from './vidstack-DbBJlz7I.js';\nimport { preconnect, getRequestCredentials } from './vidstack-BgIVvpNy.js';\nimport { isHTMLElement, isTouchPinchEvent, setAttributeIfEmpty } from './vidstack-CGUlKgT8.js';\nimport { round, clampNumber } from './vidstack-Dihypf8P.js';\nimport { FocusVisibleController } from './vidstack-9MhB-Ya7.js';\n\nconst GROUPED_LOG = Symbol(\"GROUPED_LOG\" );\nclass GroupedLog {\n  constructor(logger, level, title, root, parent) {\n    this.logger = logger;\n    this.level = level;\n    this.title = title;\n    this.root = root;\n    this.parent = parent;\n  }\n  [GROUPED_LOG] = true;\n  logs = [];\n  log(...data) {\n    this.logs.push({ data });\n    return this;\n  }\n  labelledLog(label, ...data) {\n    this.logs.push({ label, data });\n    return this;\n  }\n  groupStart(title) {\n    return new GroupedLog(this.logger, this.level, title, this.root ?? this, this);\n  }\n  groupEnd() {\n    this.parent?.logs.push(this);\n    return this.parent ?? this;\n  }\n  dispatch() {\n    return this.logger.dispatch(this.level, this.root ?? this);\n  }\n}\nfunction isGroupedLog(data) {\n  return !!data?.[GROUPED_LOG];\n}\n\nclass Logger {\n  #target = null;\n  error(...data) {\n    return this.dispatch(\"error\", ...data);\n  }\n  warn(...data) {\n    return this.dispatch(\"warn\", ...data);\n  }\n  info(...data) {\n    return this.dispatch(\"info\", ...data);\n  }\n  debug(...data) {\n    return this.dispatch(\"debug\", ...data);\n  }\n  errorGroup(title) {\n    return new GroupedLog(this, \"error\", title);\n  }\n  warnGroup(title) {\n    return new GroupedLog(this, \"warn\", title);\n  }\n  infoGroup(title) {\n    return new GroupedLog(this, \"info\", title);\n  }\n  debugGroup(title) {\n    return new GroupedLog(this, \"debug\", title);\n  }\n  setTarget(newTarget) {\n    this.#target = newTarget;\n  }\n  dispatch(level, ...data) {\n    return this.#target?.dispatchEvent(\n      new DOMEvent(\"vds-log\", {\n        bubbles: true,\n        composed: true,\n        detail: { level, data }\n      })\n    ) || false;\n  }\n}\n\nclass List extends EventsTarget {\n  items = [];\n  /** @internal */\n  [ListSymbol.readonly] = false;\n  get length() {\n    return this.items.length;\n  }\n  get readonly() {\n    return this[ListSymbol.readonly];\n  }\n  /**\n   * Returns the index of the first occurrence of the given item, or -1 if it is not present.\n   */\n  indexOf(item) {\n    return this.items.indexOf(item);\n  }\n  /**\n   * Returns an item matching the given `id`, or `null` if not present.\n   */\n  getById(id) {\n    if (id === \"\") return null;\n    return this.items.find((item) => item.id === id) ?? null;\n  }\n  /**\n   * Transform list to an array.\n   */\n  toArray() {\n    return [...this.items];\n  }\n  [Symbol.iterator]() {\n    return this.items.values();\n  }\n  /** @internal */\n  [ListSymbol.add](item, trigger) {\n    const index = this.items.length;\n    if (!(\"\" + index in this)) {\n      Object.defineProperty(this, index, {\n        get() {\n          return this.items[index];\n        }\n      });\n    }\n    if (this.items.includes(item)) return;\n    this.items.push(item);\n    this.dispatchEvent(new DOMEvent(\"add\", { detail: item, trigger }));\n  }\n  /** @internal */\n  [ListSymbol.remove](item, trigger) {\n    const index = this.items.indexOf(item);\n    if (index >= 0) {\n      this[ListSymbol.onRemove]?.(item, trigger);\n      this.items.splice(index, 1);\n      this.dispatchEvent(new DOMEvent(\"remove\", { detail: item, trigger }));\n    }\n  }\n  /** @internal */\n  [ListSymbol.reset](trigger) {\n    for (const item of [...this.items]) this[ListSymbol.remove](item, trigger);\n    this.items = [];\n    this[ListSymbol.setReadonly](false, trigger);\n    this[ListSymbol.onReset]?.();\n  }\n  /** @internal */\n  [ListSymbol.setReadonly](readonly, trigger) {\n    if (this[ListSymbol.readonly] === readonly) return;\n    this[ListSymbol.readonly] = readonly;\n    this.dispatchEvent(new DOMEvent(\"readonly-change\", { detail: readonly, trigger }));\n  }\n}\n\nconst CAN_FULLSCREEN = fscreen.fullscreenEnabled;\nclass FullscreenController extends ViewController {\n  /**\n   * Tracks whether we're the active fullscreen event listener. Fullscreen events can only be\n   * listened to globally on the document so we need to know if they relate to the current host\n   * element or not.\n   */\n  #listening = false;\n  #active = false;\n  get active() {\n    return this.#active;\n  }\n  get supported() {\n    return CAN_FULLSCREEN;\n  }\n  onConnect() {\n    new EventsController(fscreen).add(\"fullscreenchange\", this.#onChange.bind(this)).add(\"fullscreenerror\", this.#onError.bind(this));\n    onDispose(this.#onDisconnect.bind(this));\n  }\n  async #onDisconnect() {\n    if (CAN_FULLSCREEN) await this.exit();\n  }\n  #onChange(event) {\n    const active = isFullscreen(this.el);\n    if (active === this.#active) return;\n    if (!active) this.#listening = false;\n    this.#active = active;\n    this.dispatch(\"fullscreen-change\", { detail: active, trigger: event });\n  }\n  #onError(event) {\n    if (!this.#listening) return;\n    this.dispatch(\"fullscreen-error\", { detail: null, trigger: event });\n    this.#listening = false;\n  }\n  async enter() {\n    try {\n      this.#listening = true;\n      if (!this.el || isFullscreen(this.el)) return;\n      assertFullscreenAPI();\n      return fscreen.requestFullscreen(this.el);\n    } catch (error) {\n      this.#listening = false;\n      throw error;\n    }\n  }\n  async exit() {\n    if (!this.el || !isFullscreen(this.el)) return;\n    assertFullscreenAPI();\n    return fscreen.exitFullscreen();\n  }\n}\nfunction canFullscreen() {\n  return CAN_FULLSCREEN;\n}\nfunction isFullscreen(host) {\n  if (fscreen.fullscreenElement === host) return true;\n  try {\n    return host.matches(\n      // @ts-expect-error - `fullscreenPseudoClass` is missing from `@types/fscreen`.\n      fscreen.fullscreenPseudoClass\n    );\n  } catch (error) {\n    return false;\n  }\n}\nfunction assertFullscreenAPI() {\n  if (CAN_FULLSCREEN) return;\n  throw Error(\n    \"[vidstack] fullscreen API is not enabled or supported in this environment\" \n  );\n}\n\nclass ScreenOrientationController extends ViewController {\n  #type = signal(this.#getScreenOrientation());\n  #locked = signal(false);\n  #currentLock;\n  /**\n   * The current screen orientation type.\n   *\n   * @signal\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}\n   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks\n   */\n  get type() {\n    return this.#type();\n  }\n  /**\n   * Whether the screen orientation is currently locked.\n   *\n   * @signal\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/ScreenOrientation}\n   * @see https://w3c.github.io/screen-orientation/#screen-orientation-types-and-locks\n   */\n  get locked() {\n    return this.#locked();\n  }\n  /**\n   * Whether the viewport is in a portrait orientation.\n   *\n   * @signal\n   */\n  get portrait() {\n    return this.#type().startsWith(\"portrait\");\n  }\n  /**\n   * Whether the viewport is in a landscape orientation.\n   *\n   * @signal\n   */\n  get landscape() {\n    return this.#type().startsWith(\"landscape\");\n  }\n  /**\n   * Whether the native Screen Orientation API is available.\n   */\n  static supported = canOrientScreen();\n  /**\n   * Whether the native Screen Orientation API is available.\n   */\n  get supported() {\n    return ScreenOrientationController.supported;\n  }\n  onConnect() {\n    if (this.supported) {\n      listenEvent(screen.orientation, \"change\", this.#onOrientationChange.bind(this));\n    } else {\n      const query = window.matchMedia(\"(orientation: landscape)\");\n      query.onchange = this.#onOrientationChange.bind(this);\n      onDispose(() => query.onchange = null);\n    }\n    onDispose(this.#onDisconnect.bind(this));\n  }\n  async #onDisconnect() {\n    if (this.supported && this.#locked()) await this.unlock();\n  }\n  #onOrientationChange(event) {\n    this.#type.set(this.#getScreenOrientation());\n    this.dispatch(\"orientation-change\", {\n      detail: {\n        orientation: peek(this.#type),\n        lock: this.#currentLock\n      },\n      trigger: event\n    });\n  }\n  /**\n   * Locks the orientation of the screen to the desired orientation type using the\n   * Screen Orientation API.\n   *\n   * @param lockType - The screen lock orientation type.\n   * @throws Error - If screen orientation API is unavailable.\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}\n   * @see {@link https://w3c.github.io/screen-orientation}\n   */\n  async lock(lockType) {\n    if (peek(this.#locked) || this.#currentLock === lockType) return;\n    this.#assertScreenOrientationAPI();\n    await screen.orientation.lock(lockType);\n    this.#locked.set(true);\n    this.#currentLock = lockType;\n  }\n  /**\n   * Unlocks the orientation of the screen to it's default state using the Screen Orientation\n   * API. This method will throw an error if the API is unavailable.\n   *\n   * @throws Error - If screen orientation API is unavailable.\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Screen/orientation}\n   * @see {@link https://w3c.github.io/screen-orientation}\n   */\n  async unlock() {\n    if (!peek(this.#locked)) return;\n    this.#assertScreenOrientationAPI();\n    this.#currentLock = void 0;\n    await screen.orientation.unlock();\n    this.#locked.set(false);\n  }\n  #assertScreenOrientationAPI() {\n    if (this.supported) return;\n    throw Error(\n      \"[vidstack] screen orientation API is not available\" \n    );\n  }\n  #getScreenOrientation() {\n    if (this.supported) return window.screen.orientation.type;\n    return window.innerWidth >= window.innerHeight ? \"landscape-primary\" : \"portrait-primary\";\n  }\n}\n\nfunction isVideoQualitySrc(src) {\n  return !isString(src) && \"width\" in src && \"height\" in src && isNumber(src.width) && isNumber(src.height);\n}\n\nconst mediaState = new State({\n  artist: \"\",\n  artwork: null,\n  audioTrack: null,\n  audioTracks: [],\n  autoPlay: false,\n  autoPlayError: null,\n  audioGain: null,\n  buffered: new TimeRange(),\n  canLoad: false,\n  canLoadPoster: false,\n  canFullscreen: false,\n  canOrientScreen: canOrientScreen(),\n  canPictureInPicture: false,\n  canPlay: false,\n  clipStartTime: 0,\n  clipEndTime: 0,\n  controls: false,\n  get iOSControls() {\n    return IS_IPHONE && this.mediaType === \"video\" && (!this.playsInline || !fscreen.fullscreenEnabled && this.fullscreen);\n  },\n  get nativeControls() {\n    return this.controls || this.iOSControls;\n  },\n  controlsVisible: false,\n  get controlsHidden() {\n    return !this.controlsVisible;\n  },\n  crossOrigin: null,\n  ended: false,\n  error: null,\n  fullscreen: false,\n  get loop() {\n    return this.providedLoop || this.userPrefersLoop;\n  },\n  logLevel: \"warn\" ,\n  mediaType: \"unknown\",\n  muted: false,\n  paused: true,\n  played: new TimeRange(),\n  playing: false,\n  playsInline: false,\n  pictureInPicture: false,\n  preload: \"metadata\",\n  playbackRate: 1,\n  qualities: [],\n  quality: null,\n  autoQuality: false,\n  canSetQuality: true,\n  canSetPlaybackRate: true,\n  canSetVolume: false,\n  canSetAudioGain: false,\n  seekable: new TimeRange(),\n  seeking: false,\n  source: { src: \"\", type: \"\" },\n  sources: [],\n  started: false,\n  textTracks: [],\n  textTrack: null,\n  get hasCaptions() {\n    return this.textTracks.filter(isTrackCaptionKind).length > 0;\n  },\n  volume: 1,\n  waiting: false,\n  realCurrentTime: 0,\n  get currentTime() {\n    return this.ended ? this.duration : this.clipStartTime > 0 ? Math.max(0, Math.min(this.realCurrentTime - this.clipStartTime, this.duration)) : this.realCurrentTime;\n  },\n  providedDuration: -1,\n  intrinsicDuration: 0,\n  get realDuration() {\n    return this.providedDuration > 0 ? this.providedDuration : this.intrinsicDuration;\n  },\n  get duration() {\n    return this.clipEndTime > 0 ? this.clipEndTime - this.clipStartTime : Math.max(0, this.realDuration - this.clipStartTime);\n  },\n  get title() {\n    return this.providedTitle || this.inferredTitle;\n  },\n  get poster() {\n    return this.providedPoster || this.inferredPoster;\n  },\n  get viewType() {\n    return this.providedViewType !== \"unknown\" ? this.providedViewType : this.inferredViewType;\n  },\n  get streamType() {\n    return this.providedStreamType !== \"unknown\" ? this.providedStreamType : this.inferredStreamType;\n  },\n  get currentSrc() {\n    return this.source;\n  },\n  get bufferedStart() {\n    const start = getTimeRangesStart(this.buffered) ?? 0;\n    return Math.max(0, start - this.clipStartTime);\n  },\n  get bufferedEnd() {\n    const end = getTimeRangesEnd(this.buffered) ?? 0;\n    return Math.min(this.duration, Math.max(0, end - this.clipStartTime));\n  },\n  get seekableStart() {\n    const start = getTimeRangesStart(this.seekable) ?? 0;\n    return Math.max(0, Math.abs(start - this.clipStartTime));\n  },\n  get seekableEnd() {\n    const end = this.canPlay ? getTimeRangesEnd(this.seekable) ?? Infinity : 0;\n    return this.clipEndTime > 0 ? Math.max(this.clipEndTime, Math.max(0, end - this.clipStartTime)) : end;\n  },\n  get seekableWindow() {\n    return Math.max(0, this.seekableEnd - this.seekableStart);\n  },\n  // ~~ remote playback ~~\n  canAirPlay: false,\n  canGoogleCast: false,\n  remotePlaybackState: \"disconnected\",\n  remotePlaybackType: \"none\",\n  remotePlaybackLoader: null,\n  remotePlaybackInfo: null,\n  get isAirPlayConnected() {\n    return this.remotePlaybackType === \"airplay\" && this.remotePlaybackState === \"connected\";\n  },\n  get isGoogleCastConnected() {\n    return this.remotePlaybackType === \"google-cast\" && this.remotePlaybackState === \"connected\";\n  },\n  // ~~ responsive design ~~\n  pointer: \"fine\",\n  orientation: \"landscape\",\n  width: 0,\n  height: 0,\n  mediaWidth: 0,\n  mediaHeight: 0,\n  lastKeyboardAction: null,\n  // ~~ user props ~~\n  userBehindLiveEdge: false,\n  // ~~ live props ~~\n  liveEdgeTolerance: 10,\n  minLiveDVRWindow: 60,\n  get canSeek() {\n    return /unknown|on-demand|:dvr/.test(this.streamType) && Number.isFinite(this.seekableWindow) && (!this.live || /:dvr/.test(this.streamType) && this.seekableWindow >= this.minLiveDVRWindow);\n  },\n  get live() {\n    return this.streamType.includes(\"live\") || !Number.isFinite(this.realDuration);\n  },\n  get liveEdgeStart() {\n    return this.live && Number.isFinite(this.seekableEnd) ? Math.max(0, (this.liveSyncPosition ?? this.seekableEnd) - this.liveEdgeTolerance) : 0;\n  },\n  get liveEdge() {\n    return this.live && (!this.canSeek || !this.userBehindLiveEdge && this.currentTime >= this.liveEdgeStart);\n  },\n  get liveEdgeWindow() {\n    return this.live && Number.isFinite(this.seekableEnd) ? this.seekableEnd - this.liveEdgeStart : 0;\n  },\n  // ~~ internal props ~~\n  autoPlaying: false,\n  providedTitle: \"\",\n  inferredTitle: \"\",\n  providedLoop: false,\n  userPrefersLoop: false,\n  providedPoster: \"\",\n  inferredPoster: \"\",\n  inferredViewType: \"unknown\",\n  providedViewType: \"unknown\",\n  providedStreamType: \"unknown\",\n  inferredStreamType: \"unknown\",\n  liveSyncPosition: null,\n  savedState: null\n});\nconst RESET_ON_SRC_QUALITY_CHANGE = /* @__PURE__ */ new Set([\n  \"autoPlayError\",\n  \"autoPlaying\",\n  \"buffered\",\n  \"canPlay\",\n  \"error\",\n  \"paused\",\n  \"played\",\n  \"playing\",\n  \"seekable\",\n  \"seeking\",\n  \"waiting\"\n]);\nconst RESET_ON_SRC_CHANGE = /* @__PURE__ */ new Set([\n  ...RESET_ON_SRC_QUALITY_CHANGE,\n  \"ended\",\n  \"inferredPoster\",\n  \"inferredStreamType\",\n  \"inferredTitle\",\n  \"intrinsicDuration\",\n  \"liveSyncPosition\",\n  \"realCurrentTime\",\n  \"savedState\",\n  \"started\",\n  \"userBehindLiveEdge\"\n]);\nfunction softResetMediaState($media, isSourceQualityChange = false) {\n  const filter = isSourceQualityChange ? RESET_ON_SRC_QUALITY_CHANGE : RESET_ON_SRC_CHANGE;\n  mediaState.reset($media, (prop) => filter.has(prop));\n  tick();\n}\n\nclass MediaRemoteControl {\n  #target = null;\n  #player = null;\n  #prevTrackIndex = -1;\n  #logger;\n  constructor(logger = new Logger() ) {\n    this.#logger = logger;\n  }\n  /**\n   * Set the target from which to dispatch media requests events from. The events should bubble\n   * up from this target to the player element.\n   *\n   * @example\n   * ```ts\n   * const button = document.querySelector('button');\n   * remote.setTarget(button);\n   * ```\n   */\n  setTarget(target) {\n    this.#target = target;\n    this.#logger?.setTarget(target);\n  }\n  /**\n   * Returns the current player element. This method will attempt to find the player by\n   * searching up from either the given `target` or default target set via `remote.setTarget`.\n   *\n   * @example\n   * ```ts\n   * const player = remote.getPlayer();\n   * ```\n   */\n  getPlayer(target) {\n    if (this.#player) return this.#player;\n    (target ?? this.#target)?.dispatchEvent(\n      new DOMEvent(\"find-media-player\", {\n        detail: (player) => void (this.#player = player),\n        bubbles: true,\n        composed: true\n      })\n    );\n    return this.#player;\n  }\n  /**\n   * Set the current player element so the remote can support toggle methods such as\n   * `togglePaused` as they rely on the current media state.\n   */\n  setPlayer(player) {\n    this.#player = player;\n  }\n  /**\n   * Dispatch a request to start the media loading process. This will only work if the media\n   * player has been initialized with a custom loading strategy `load=\"custom\">`.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}\n   */\n  startLoading(trigger) {\n    this.#dispatchRequest(\"media-start-loading\", trigger);\n  }\n  /**\n   * Dispatch a request to start the poster loading process. This will only work if the media\n   * player has been initialized with a custom poster loading strategy `posterLoad=\"custom\">`.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/core-concepts/loading#load-strategies}\n   */\n  startLoadingPoster(trigger) {\n    this.#dispatchRequest(\"media-poster-start-loading\", trigger);\n  }\n  /**\n   * Dispatch a request to connect to AirPlay.\n   *\n   * @see {@link https://www.apple.com/au/airplay}\n   */\n  requestAirPlay(trigger) {\n    this.#dispatchRequest(\"media-airplay-request\", trigger);\n  }\n  /**\n   * Dispatch a request to connect to Google Cast.\n   *\n   * @see {@link https://developers.google.com/cast/docs/overview}\n   */\n  requestGoogleCast(trigger) {\n    this.#dispatchRequest(\"media-google-cast-request\", trigger);\n  }\n  /**\n   * Dispatch a request to begin/resume media playback.\n   */\n  play(trigger) {\n    this.#dispatchRequest(\"media-play-request\", trigger);\n  }\n  /**\n   * Dispatch a request to pause media playback.\n   */\n  pause(trigger) {\n    this.#dispatchRequest(\"media-pause-request\", trigger);\n  }\n  /**\n   * Dispatch a request to set the media volume to mute (0).\n   */\n  mute(trigger) {\n    this.#dispatchRequest(\"media-mute-request\", trigger);\n  }\n  /**\n   * Dispatch a request to unmute the media volume and set it back to it's previous state.\n   */\n  unmute(trigger) {\n    this.#dispatchRequest(\"media-unmute-request\", trigger);\n  }\n  /**\n   * Dispatch a request to enter fullscreen.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}\n   */\n  enterFullscreen(target, trigger) {\n    this.#dispatchRequest(\"media-enter-fullscreen-request\", trigger, target);\n  }\n  /**\n   * Dispatch a request to exit fullscreen.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}\n   */\n  exitFullscreen(target, trigger) {\n    this.#dispatchRequest(\"media-exit-fullscreen-request\", trigger, target);\n  }\n  /**\n   * Dispatch a request to lock the screen orientation.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/screen-orientation#remote-control}\n   */\n  lockScreenOrientation(lockType, trigger) {\n    this.#dispatchRequest(\"media-orientation-lock-request\", trigger, lockType);\n  }\n  /**\n   * Dispatch a request to unlock the screen orientation.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/screen-orientation#remote-control}\n   */\n  unlockScreenOrientation(trigger) {\n    this.#dispatchRequest(\"media-orientation-unlock-request\", trigger);\n  }\n  /**\n   * Dispatch a request to enter picture-in-picture mode.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}\n   */\n  enterPictureInPicture(trigger) {\n    this.#dispatchRequest(\"media-enter-pip-request\", trigger);\n  }\n  /**\n   * Dispatch a request to exit picture-in-picture mode.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}\n   */\n  exitPictureInPicture(trigger) {\n    this.#dispatchRequest(\"media-exit-pip-request\", trigger);\n  }\n  /**\n   * Notify the media player that a seeking process is happening and to seek to the given `time`.\n   */\n  seeking(time, trigger) {\n    this.#dispatchRequest(\"media-seeking-request\", trigger, time);\n  }\n  /**\n   * Notify the media player that a seeking operation has completed and to seek to the given `time`.\n   * This is generally called after a series of `remote.seeking()` calls.\n   */\n  seek(time, trigger) {\n    this.#dispatchRequest(\"media-seek-request\", trigger, time);\n  }\n  seekToLiveEdge(trigger) {\n    this.#dispatchRequest(\"media-live-edge-request\", trigger);\n  }\n  /**\n   * Dispatch a request to update the length of the media in seconds.\n   *\n   * @example\n   * ```ts\n   * remote.changeDuration(100); // 100 seconds\n   * ```\n   */\n  changeDuration(duration, trigger) {\n    this.#dispatchRequest(\"media-duration-change-request\", trigger, duration);\n  }\n  /**\n   * Dispatch a request to update the clip start time. This is the time at which media playback\n   * should start at.\n   *\n   * @example\n   * ```ts\n   * remote.changeClipStart(100); // start at 100 seconds\n   * ```\n   */\n  changeClipStart(startTime, trigger) {\n    this.#dispatchRequest(\"media-clip-start-change-request\", trigger, startTime);\n  }\n  /**\n   * Dispatch a request to update the clip end time. This is the time at which media playback\n   * should end at.\n   *\n   * @example\n   * ```ts\n   * remote.changeClipEnd(100); // end at 100 seconds\n   * ```\n   */\n  changeClipEnd(endTime, trigger) {\n    this.#dispatchRequest(\"media-clip-end-change-request\", trigger, endTime);\n  }\n  /**\n   * Dispatch a request to update the media volume to the given `volume` level which is a value\n   * between 0 and 1.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/audio-gain#remote-control}\n   * @example\n   * ```ts\n   * remote.changeVolume(0); // 0%\n   * remote.changeVolume(0.05); // 5%\n   * remote.changeVolume(0.5); // 50%\n   * remote.changeVolume(0.75); // 70%\n   * remote.changeVolume(1); // 100%\n   * ```\n   */\n  changeVolume(volume, trigger) {\n    this.#dispatchRequest(\"media-volume-change-request\", trigger, Math.max(0, Math.min(1, volume)));\n  }\n  /**\n   * Dispatch a request to change the current audio track.\n   *\n   * @example\n   * ```ts\n   * remote.changeAudioTrack(1); // track at index 1\n   * ```\n   */\n  changeAudioTrack(index, trigger) {\n    this.#dispatchRequest(\"media-audio-track-change-request\", trigger, index);\n  }\n  /**\n   * Dispatch a request to change the video quality. The special value `-1` represents auto quality\n   * selection.\n   *\n   * @example\n   * ```ts\n   * remote.changeQuality(-1); // auto\n   * remote.changeQuality(1); // quality at index 1\n   * ```\n   */\n  changeQuality(index, trigger) {\n    this.#dispatchRequest(\"media-quality-change-request\", trigger, index);\n  }\n  /**\n   * Request auto quality selection.\n   */\n  requestAutoQuality(trigger) {\n    this.changeQuality(-1, trigger);\n  }\n  /**\n   * Dispatch a request to change the mode of the text track at the given index.\n   *\n   * @example\n   * ```ts\n   * remote.changeTextTrackMode(1, 'showing'); // track at index 1\n   * ```\n   */\n  changeTextTrackMode(index, mode, trigger) {\n    this.#dispatchRequest(\"media-text-track-change-request\", trigger, {\n      index,\n      mode\n    });\n  }\n  /**\n   * Dispatch a request to change the media playback rate.\n   *\n   * @example\n   * ```ts\n   * remote.changePlaybackRate(0.5); // Half the normal speed\n   * remote.changePlaybackRate(1); // Normal speed\n   * remote.changePlaybackRate(1.5); // 50% faster than normal\n   * remote.changePlaybackRate(2); // Double the normal speed\n   * ```\n   */\n  changePlaybackRate(rate, trigger) {\n    this.#dispatchRequest(\"media-rate-change-request\", trigger, rate);\n  }\n  /**\n   * Dispatch a request to change the media audio gain.\n   *\n   * @example\n   * ```ts\n   * remote.changeAudioGain(1); // Disable audio gain\n   * remote.changeAudioGain(1.5); // 50% louder\n   * remote.changeAudioGain(2); // 100% louder\n   * ```\n   */\n  changeAudioGain(gain, trigger) {\n    this.#dispatchRequest(\"media-audio-gain-change-request\", trigger, gain);\n  }\n  /**\n   * Dispatch a request to resume idle tracking on controls.\n   */\n  resumeControls(trigger) {\n    this.#dispatchRequest(\"media-resume-controls-request\", trigger);\n  }\n  /**\n   * Dispatch a request to pause controls idle tracking. Pausing tracking will result in the\n   * controls being visible until `remote.resumeControls()` is called. This method\n   * is generally used when building custom controls and you'd like to prevent the UI from\n   * disappearing.\n   *\n   * @example\n   * ```ts\n   * // Prevent controls hiding while menu is being interacted with.\n   * function onSettingsOpen() {\n   *   remote.pauseControls();\n   * }\n   *\n   * function onSettingsClose() {\n   *   remote.resumeControls();\n   * }\n   * ```\n   */\n  pauseControls(trigger) {\n    this.#dispatchRequest(\"media-pause-controls-request\", trigger);\n  }\n  /**\n   * Dispatch a request to toggle the media playback state.\n   */\n  togglePaused(trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.togglePaused.name);\n      return;\n    }\n    if (player.state.paused) this.play(trigger);\n    else this.pause(trigger);\n  }\n  /**\n   * Dispatch a request to toggle the controls visibility.\n   */\n  toggleControls(trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.toggleControls.name);\n      return;\n    }\n    if (!player.controls.showing) {\n      player.controls.show(0, trigger);\n    } else {\n      player.controls.hide(0, trigger);\n    }\n  }\n  /**\n   * Dispatch a request to toggle the media muted state.\n   */\n  toggleMuted(trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.toggleMuted.name);\n      return;\n    }\n    if (player.state.muted) this.unmute(trigger);\n    else this.mute(trigger);\n  }\n  /**\n   * Dispatch a request to toggle the media fullscreen state.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/fullscreen#remote-control}\n   */\n  toggleFullscreen(target, trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.toggleFullscreen.name);\n      return;\n    }\n    if (player.state.fullscreen) this.exitFullscreen(target, trigger);\n    else this.enterFullscreen(target, trigger);\n  }\n  /**\n   * Dispatch a request to toggle the media picture-in-picture mode.\n   *\n   * @docs {@link https://www.vidstack.io/docs/player/api/picture-in-picture#remote-control}\n   */\n  togglePictureInPicture(trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.togglePictureInPicture.name);\n      return;\n    }\n    if (player.state.pictureInPicture) this.exitPictureInPicture(trigger);\n    else this.enterPictureInPicture(trigger);\n  }\n  /**\n   * Show captions.\n   */\n  showCaptions(trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.showCaptions.name);\n      return;\n    }\n    let tracks = player.state.textTracks, index = this.#prevTrackIndex;\n    if (!tracks[index] || !isTrackCaptionKind(tracks[index])) {\n      index = -1;\n    }\n    if (index === -1) {\n      index = tracks.findIndex((track) => isTrackCaptionKind(track) && track.default);\n    }\n    if (index === -1) {\n      index = tracks.findIndex((track) => isTrackCaptionKind(track));\n    }\n    if (index >= 0) this.changeTextTrackMode(index, \"showing\", trigger);\n    this.#prevTrackIndex = -1;\n  }\n  /**\n   * Turn captions off.\n   */\n  disableCaptions(trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.disableCaptions.name);\n      return;\n    }\n    const tracks = player.state.textTracks, track = player.state.textTrack;\n    if (track) {\n      const index = tracks.indexOf(track);\n      this.changeTextTrackMode(index, \"disabled\", trigger);\n      this.#prevTrackIndex = index;\n    }\n  }\n  /**\n   * Dispatch a request to toggle the current captions mode.\n   */\n  toggleCaptions(trigger) {\n    const player = this.getPlayer(trigger?.target);\n    if (!player) {\n      this.#noPlayerWarning(this.toggleCaptions.name);\n      return;\n    }\n    if (player.state.textTrack) {\n      this.disableCaptions();\n    } else {\n      this.showCaptions();\n    }\n  }\n  userPrefersLoopChange(prefersLoop, trigger) {\n    this.#dispatchRequest(\"media-user-loop-change-request\", trigger, prefersLoop);\n  }\n  #dispatchRequest(type, trigger, detail) {\n    const request = new DOMEvent(type, {\n      bubbles: true,\n      composed: true,\n      cancelable: true,\n      detail,\n      trigger\n    });\n    let target = trigger?.target || null;\n    if (target && target instanceof Component) target = target.el;\n    const shouldUsePlayer = !target || target === document || target === window || target === document.body || this.#player?.el && target instanceof Node && !this.#player.el.contains(target);\n    target = shouldUsePlayer ? this.#target ?? this.getPlayer()?.el : target ?? this.#target;\n    {\n      this.#logger?.debugGroup(`\\u{1F4E8} dispatching \\`${type}\\``).labelledLog(\"Target\", target).labelledLog(\"Player\", this.#player).labelledLog(\"Request Event\", request).labelledLog(\"Trigger Event\", trigger).dispatch();\n    }\n    if (this.#player) {\n      if (type === \"media-play-request\" && !this.#player.state.canLoad) {\n        target?.dispatchEvent(request);\n      } else {\n        this.#player.canPlayQueue.enqueue(type, () => target?.dispatchEvent(request));\n      }\n    } else {\n      target?.dispatchEvent(request);\n    }\n  }\n  #noPlayerWarning(method) {\n    {\n      console.warn(\n        `[vidstack] attempted to call \\`MediaRemoteControl.${method}\\`() that requires player but failed because remote could not find a parent player element from target`\n      );\n    }\n  }\n}\n\nclass LocalMediaStorage {\n  playerId = \"vds-player\";\n  mediaId = null;\n  #data = {\n    volume: null,\n    muted: null,\n    audioGain: null,\n    time: null,\n    lang: null,\n    captions: null,\n    rate: null,\n    quality: null\n  };\n  async getVolume() {\n    return this.#data.volume;\n  }\n  async setVolume(volume) {\n    this.#data.volume = volume;\n    this.save();\n  }\n  async getMuted() {\n    return this.#data.muted;\n  }\n  async setMuted(muted) {\n    this.#data.muted = muted;\n    this.save();\n  }\n  async getTime() {\n    return this.#data.time;\n  }\n  async setTime(time, ended) {\n    const shouldClear = time < 0;\n    this.#data.time = !shouldClear ? time : null;\n    if (shouldClear || ended) this.saveTime();\n    else this.saveTimeThrottled();\n  }\n  async getLang() {\n    return this.#data.lang;\n  }\n  async setLang(lang) {\n    this.#data.lang = lang;\n    this.save();\n  }\n  async getCaptions() {\n    return this.#data.captions;\n  }\n  async setCaptions(enabled) {\n    this.#data.captions = enabled;\n    this.save();\n  }\n  async getPlaybackRate() {\n    return this.#data.rate;\n  }\n  async setPlaybackRate(rate) {\n    this.#data.rate = rate;\n    this.save();\n  }\n  async getAudioGain() {\n    return this.#data.audioGain;\n  }\n  async setAudioGain(gain) {\n    this.#data.audioGain = gain;\n    this.save();\n  }\n  async getVideoQuality() {\n    return this.#data.quality;\n  }\n  async setVideoQuality(quality) {\n    this.#data.quality = quality;\n    this.save();\n  }\n  onChange(src, mediaId, playerId = \"vds-player\") {\n    const savedData = playerId ? localStorage.getItem(playerId) : null, savedTime = mediaId ? localStorage.getItem(mediaId) : null;\n    this.playerId = playerId;\n    this.mediaId = mediaId;\n    this.#data = {\n      volume: null,\n      muted: null,\n      audioGain: null,\n      lang: null,\n      captions: null,\n      rate: null,\n      quality: null,\n      ...savedData ? JSON.parse(savedData) : {},\n      time: savedTime ? +savedTime : null\n    };\n  }\n  save() {\n    if (!this.playerId) return;\n    const data = JSON.stringify({ ...this.#data, time: void 0 });\n    localStorage.setItem(this.playerId, data);\n  }\n  saveTimeThrottled = functionThrottle(this.saveTime.bind(this), 1e3);\n  saveTime() {\n    if (!this.mediaId) return;\n    const data = (this.#data.time ?? 0).toString();\n    localStorage.setItem(this.mediaId, data);\n  }\n}\n\nclass NativeTextRenderer {\n  priority = 0;\n  #display = true;\n  #video = null;\n  #track = null;\n  #tracks = /* @__PURE__ */ new Set();\n  canRender(_, video) {\n    return !!video;\n  }\n  attach(video) {\n    this.#video = video;\n    if (video) video.textTracks.onchange = this.#onChange.bind(this);\n  }\n  addTrack(track) {\n    this.#tracks.add(track);\n    this.#attachTrack(track);\n  }\n  removeTrack(track) {\n    track[TextTrackSymbol.native]?.remove?.();\n    track[TextTrackSymbol.native] = null;\n    this.#tracks.delete(track);\n  }\n  changeTrack(track) {\n    const current = track?.[TextTrackSymbol.native];\n    if (current && current.track.mode !== \"showing\") {\n      current.track.mode = \"showing\";\n    }\n    this.#track = track;\n  }\n  setDisplay(display) {\n    this.#display = display;\n    this.#onChange();\n  }\n  detach() {\n    if (this.#video) this.#video.textTracks.onchange = null;\n    for (const track of this.#tracks) this.removeTrack(track);\n    this.#tracks.clear();\n    this.#video = null;\n    this.#track = null;\n  }\n  #attachTrack(track) {\n    if (!this.#video) return;\n    const el = track[TextTrackSymbol.native] ??= this.#createTrackElement(track);\n    if (isHTMLElement(el)) {\n      this.#video.append(el);\n      el.track.mode = el.default ? \"showing\" : \"disabled\";\n    }\n  }\n  #createTrackElement(track) {\n    const el = document.createElement(\"track\"), isDefault = track.default || track.mode === \"showing\", isSupported = track.src && track.type === \"vtt\";\n    el.id = track.id;\n    el.src = isSupported ? track.src : \"\";\n    el.label = track.label;\n    el.kind = track.kind;\n    el.default = isDefault;\n    track.language && (el.srclang = track.language);\n    if (isDefault && !isSupported) {\n      this.#copyCues(track, el.track);\n    }\n    return el;\n  }\n  #copyCues(track, native) {\n    if (track.src && track.type === \"vtt\" || native.cues?.length) return;\n    for (const cue of track.cues) native.addCue(cue);\n  }\n  #onChange(event) {\n    for (const track of this.#tracks) {\n      const native = track[TextTrackSymbol.native];\n      if (!native) continue;\n      if (!this.#display) {\n        native.track.mode = native.managed ? \"hidden\" : \"disabled\";\n        continue;\n      }\n      const isShowing = native.track.mode === \"showing\";\n      if (isShowing) this.#copyCues(track, native.track);\n      track.setMode(isShowing ? \"showing\" : \"disabled\", event);\n    }\n  }\n}\n\nclass TextRenderers {\n  #video = null;\n  #textTracks;\n  #renderers = [];\n  #media;\n  #nativeDisplay = false;\n  #nativeRenderer = null;\n  #customRenderer = null;\n  constructor(media) {\n    this.#media = media;\n    const textTracks = media.textTracks;\n    this.#textTracks = textTracks;\n    effect(this.#watchControls.bind(this));\n    onDispose(this.#detach.bind(this));\n    new EventsController(textTracks).add(\"add\", this.#onAddTrack.bind(this)).add(\"remove\", this.#onRemoveTrack.bind(this)).add(\"mode-change\", this.#update.bind(this));\n  }\n  #watchControls() {\n    const { nativeControls } = this.#media.$state;\n    this.#nativeDisplay = nativeControls();\n    this.#update();\n  }\n  add(renderer) {\n    this.#renderers.push(renderer);\n    untrack(this.#update.bind(this));\n  }\n  remove(renderer) {\n    renderer.detach();\n    this.#renderers.splice(this.#renderers.indexOf(renderer), 1);\n    untrack(this.#update.bind(this));\n  }\n  /** @internal */\n  attachVideo(video) {\n    requestAnimationFrame(() => {\n      this.#video = video;\n      if (video) {\n        this.#nativeRenderer = new NativeTextRenderer();\n        this.#nativeRenderer.attach(video);\n        for (const track of this.#textTracks) this.#addNativeTrack(track);\n      }\n      this.#update();\n    });\n  }\n  #addNativeTrack(track) {\n    if (!isTrackCaptionKind(track)) return;\n    this.#nativeRenderer?.addTrack(track);\n  }\n  #removeNativeTrack(track) {\n    if (!isTrackCaptionKind(track)) return;\n    this.#nativeRenderer?.removeTrack(track);\n  }\n  #onAddTrack(event) {\n    this.#addNativeTrack(event.detail);\n  }\n  #onRemoveTrack(event) {\n    this.#removeNativeTrack(event.detail);\n  }\n  #update() {\n    const currentTrack = this.#textTracks.selected;\n    if (this.#video && (this.#nativeDisplay || currentTrack?.[TextTrackSymbol.nativeHLS])) {\n      this.#customRenderer?.changeTrack(null);\n      this.#nativeRenderer?.setDisplay(true);\n      this.#nativeRenderer?.changeTrack(currentTrack);\n      return;\n    }\n    this.#nativeRenderer?.setDisplay(false);\n    this.#nativeRenderer?.changeTrack(null);\n    if (!currentTrack) {\n      this.#customRenderer?.changeTrack(null);\n      return;\n    }\n    const customRenderer = this.#renderers.sort((a, b) => a.priority - b.priority).find((renderer) => renderer.canRender(currentTrack, this.#video));\n    if (this.#customRenderer !== customRenderer) {\n      this.#customRenderer?.detach();\n      customRenderer?.attach(this.#video);\n      this.#customRenderer = customRenderer ?? null;\n    }\n    customRenderer?.changeTrack(currentTrack);\n  }\n  #detach() {\n    this.#nativeRenderer?.detach();\n    this.#nativeRenderer = null;\n    this.#customRenderer?.detach();\n    this.#customRenderer = null;\n  }\n}\n\nclass TextTrackList extends List {\n  #canLoad = false;\n  #defaults = {};\n  #storage = null;\n  #preferredLang = null;\n  /** @internal */\n  [TextTrackSymbol.crossOrigin];\n  constructor() {\n    super();\n  }\n  get selected() {\n    const track = this.items.find((t) => t.mode === \"showing\" && isTrackCaptionKind(t));\n    return track ?? null;\n  }\n  get selectedIndex() {\n    const selected = this.selected;\n    return selected ? this.indexOf(selected) : -1;\n  }\n  get preferredLang() {\n    return this.#preferredLang;\n  }\n  set preferredLang(lang) {\n    this.#preferredLang = lang;\n    this.#saveLang(lang);\n  }\n  add(init, trigger) {\n    const isTrack = init instanceof TextTrack, track = isTrack ? init : new TextTrack(init), kind = init.kind === \"captions\" || init.kind === \"subtitles\" ? \"captions\" : init.kind;\n    if (this.#defaults[kind] && init.default) delete init.default;\n    track.addEventListener(\"mode-change\", this.#onTrackModeChangeBind);\n    this[ListSymbol.add](track, trigger);\n    track[TextTrackSymbol.crossOrigin] = this[TextTrackSymbol.crossOrigin];\n    if (this.#canLoad) track[TextTrackSymbol.canLoad]();\n    if (init.default) this.#defaults[kind] = track;\n    this.#selectTracks();\n    return this;\n  }\n  remove(track, trigger) {\n    this.#pendingRemoval = track;\n    if (!this.items.includes(track)) return;\n    if (track === this.#defaults[track.kind]) delete this.#defaults[track.kind];\n    track.mode = \"disabled\";\n    track[TextTrackSymbol.onModeChange] = null;\n    track.removeEventListener(\"mode-change\", this.#onTrackModeChangeBind);\n    this[ListSymbol.remove](track, trigger);\n    this.#pendingRemoval = null;\n    return this;\n  }\n  clear(trigger) {\n    for (const track of [...this.items]) {\n      this.remove(track, trigger);\n    }\n    return this;\n  }\n  getByKind(kind) {\n    const kinds = Array.isArray(kind) ? kind : [kind];\n    return this.items.filter((track) => kinds.includes(track.kind));\n  }\n  /** @internal */\n  [TextTrackSymbol.canLoad]() {\n    if (this.#canLoad) return;\n    for (const track of this.items) track[TextTrackSymbol.canLoad]();\n    this.#canLoad = true;\n    this.#selectTracks();\n  }\n  #selectTracks = functionDebounce(async () => {\n    if (!this.#canLoad) return;\n    if (!this.#preferredLang && this.#storage) {\n      this.#preferredLang = await this.#storage.getLang();\n    }\n    const showCaptions = await this.#storage?.getCaptions(), kinds = [\n      [\"captions\", \"subtitles\"],\n      \"chapters\",\n      \"descriptions\",\n      \"metadata\"\n    ];\n    for (const kind of kinds) {\n      const tracks = this.getByKind(kind);\n      if (tracks.find((t) => t.mode === \"showing\")) continue;\n      const preferredTrack = this.#preferredLang ? tracks.find((track2) => track2.language === this.#preferredLang) : null;\n      const defaultTrack = isArray(kind) ? this.#defaults[kind.find((kind2) => this.#defaults[kind2]) || \"\"] : this.#defaults[kind];\n      const track = preferredTrack ?? defaultTrack, isCaptionsKind = track && isTrackCaptionKind(track);\n      if (track && (!isCaptionsKind || showCaptions !== false)) {\n        track.mode = \"showing\";\n        if (isCaptionsKind) this.#saveCaptionsTrack(track);\n      }\n    }\n  }, 300);\n  #pendingRemoval = null;\n  #onTrackModeChangeBind = this.#onTrackModeChange.bind(this);\n  #onTrackModeChange(event) {\n    const track = event.detail;\n    if (this.#storage && isTrackCaptionKind(track) && track !== this.#pendingRemoval) {\n      this.#saveCaptionsTrack(track);\n    }\n    if (track.mode === \"showing\") {\n      const kinds = isTrackCaptionKind(track) ? [\"captions\", \"subtitles\"] : [track.kind];\n      for (const t of this.items) {\n        if (t.mode === \"showing\" && t != track && kinds.includes(t.kind)) {\n          t.mode = \"disabled\";\n        }\n      }\n    }\n    this.dispatchEvent(\n      new DOMEvent(\"mode-change\", {\n        detail: event.detail,\n        trigger: event\n      })\n    );\n  }\n  #saveCaptionsTrack(track) {\n    if (track.mode !== \"disabled\") {\n      this.#saveLang(track.language);\n    }\n    this.#storage?.setCaptions?.(track.mode === \"showing\");\n  }\n  #saveLang(lang) {\n    this.#storage?.setLang?.(this.#preferredLang = lang);\n  }\n  setStorage(storage) {\n    this.#storage = storage;\n  }\n}\n\nconst SELECTED = Symbol(\"SELECTED\" );\nclass SelectList extends List {\n  get selected() {\n    return this.items.find((item) => item.selected) ?? null;\n  }\n  get selectedIndex() {\n    return this.items.findIndex((item) => item.selected);\n  }\n  /** @internal */\n  [ListSymbol.onRemove](item, trigger) {\n    this[ListSymbol.select](item, false, trigger);\n  }\n  /** @internal */\n  [ListSymbol.add](item, trigger) {\n    item[SELECTED] = false;\n    Object.defineProperty(item, \"selected\", {\n      get() {\n        return this[SELECTED];\n      },\n      set: (selected) => {\n        if (this.readonly) return;\n        this[ListSymbol.onUserSelect]?.();\n        this[ListSymbol.select](item, selected);\n      }\n    });\n    super[ListSymbol.add](item, trigger);\n  }\n  /** @internal */\n  [ListSymbol.select](item, selected, trigger) {\n    if (selected === item?.[SELECTED]) return;\n    const prev = this.selected;\n    if (item) item[SELECTED] = selected;\n    const changed = !selected ? prev === item : prev !== item;\n    if (changed) {\n      if (prev) prev[SELECTED] = false;\n      this.dispatchEvent(\n        new DOMEvent(\"change\", {\n          detail: {\n            prev,\n            current: this.selected\n          },\n          trigger\n        })\n      );\n    }\n  }\n}\n\nclass AudioTrackList extends SelectList {\n}\n\nclass VideoQualityList extends SelectList {\n  #auto = false;\n  /**\n   * Configures quality switching:\n   *\n   * - `current`: Trigger an immediate quality level switch. This will abort the current fragment\n   * request if any, flush the whole buffer, and fetch fragment matching with current position\n   * and requested quality level.\n   *\n   * - `next`: Trigger a quality level switch for next fragment. This could eventually flush\n   * already buffered next fragment.\n   *\n   * - `load`: Set quality level for next loaded fragment.\n   *\n   * @see {@link https://www.vidstack.io/docs/player/api/video-quality#switch}\n   * @see {@link https://github.com/video-dev/hls.js/blob/master/docs/API.md#quality-switch-control-api}\n   */\n  switch = \"current\";\n  /**\n   * Whether automatic quality selection is enabled.\n   */\n  get auto() {\n    return this.#auto || this.readonly;\n  }\n  /** @internal */\n  [QualitySymbol.enableAuto];\n  /** @internal */\n  [ListSymbol.onUserSelect]() {\n    this[QualitySymbol.setAuto](false);\n  }\n  /** @internal */\n  [ListSymbol.onReset](trigger) {\n    this[QualitySymbol.enableAuto] = void 0;\n    this[QualitySymbol.setAuto](false, trigger);\n  }\n  /**\n   * Request automatic quality selection (if supported). This will be a no-op if the list is\n   * `readonly` as that already implies auto-selection.\n   */\n  autoSelect(trigger) {\n    if (this.readonly || this.#auto || !this[QualitySymbol.enableAuto]) return;\n    this[QualitySymbol.enableAuto]?.(trigger);\n    this[QualitySymbol.setAuto](true, trigger);\n  }\n  getBySrc(src) {\n    return this.items.find((quality) => quality.src === src);\n  }\n  /** @internal */\n  [QualitySymbol.setAuto](auto, trigger) {\n    if (this.#auto === auto) return;\n    this.#auto = auto;\n    this.dispatchEvent(\n      new DOMEvent(\"auto-change\", {\n        detail: auto,\n        trigger\n      })\n    );\n  }\n}\n\nfunction isAudioProvider(provider) {\n  return provider?.$$PROVIDER_TYPE === \"AUDIO\";\n}\nfunction isVideoProvider(provider) {\n  return provider?.$$PROVIDER_TYPE === \"VIDEO\";\n}\nfunction isHLSProvider(provider) {\n  return provider?.$$PROVIDER_TYPE === \"HLS\";\n}\nfunction isDASHProvider(provider) {\n  return provider?.$$PROVIDER_TYPE === \"DASH\";\n}\nfunction isYouTubeProvider(provider) {\n  return provider?.$$PROVIDER_TYPE === \"YOUTUBE\";\n}\nfunction isVimeoProvider(provider) {\n  return provider?.$$PROVIDER_TYPE === \"VIMEO\";\n}\nfunction isGoogleCastProvider(provider) {\n  return provider?.$$PROVIDER_TYPE === \"GOOGLE_CAST\";\n}\nfunction isHTMLAudioElement(element) {\n  return element instanceof HTMLAudioElement;\n}\nfunction isHTMLVideoElement(element) {\n  return element instanceof HTMLVideoElement;\n}\nfunction isHTMLMediaElement(element) {\n  return isHTMLAudioElement(element) || isHTMLVideoElement(element);\n}\nfunction isHTMLIFrameElement(element) {\n  return element instanceof HTMLIFrameElement;\n}\n\nclass MediaPlayerController extends ViewController {\n}\n\nconst MEDIA_KEY_SHORTCUTS = {\n  togglePaused: \"k Space\",\n  toggleMuted: \"m\",\n  toggleFullscreen: \"f\",\n  togglePictureInPicture: \"i\",\n  toggleCaptions: \"c\",\n  seekBackward: \"j J ArrowLeft\",\n  seekForward: \"l L ArrowRight\",\n  volumeUp: \"ArrowUp\",\n  volumeDown: \"ArrowDown\",\n  speedUp: \">\",\n  slowDown: \"<\"\n};\nconst MODIFIER_KEYS = /* @__PURE__ */ new Set([\"Shift\", \"Alt\", \"Meta\", \"Ctrl\"]), BUTTON_SELECTORS = 'button, [role=\"button\"]', IGNORE_SELECTORS = 'input, textarea, select, [contenteditable], [role^=\"menuitem\"], [role=\"timer\"]';\nclass MediaKeyboardController extends MediaPlayerController {\n  #media;\n  constructor(media) {\n    super();\n    this.#media = media;\n  }\n  onConnect() {\n    effect(this.#onTargetChange.bind(this));\n  }\n  #onTargetChange() {\n    const { keyDisabled, keyTarget } = this.$props;\n    if (keyDisabled()) return;\n    const target = keyTarget() === \"player\" ? this.el : document, $active = signal(false);\n    if (target === this.el) {\n      new EventsController(this.el).add(\"focusin\", () => $active.set(true)).add(\"focusout\", (event) => {\n        if (!this.el.contains(event.target)) $active.set(false);\n      });\n    } else {\n      if (!peek($active)) $active.set(document.querySelector(\"[data-media-player]\") === this.el);\n      listenEvent(document, \"focusin\", (event) => {\n        const activePlayer = event.composedPath().find((el) => el instanceof Element && el.localName === \"media-player\");\n        if (activePlayer !== void 0) $active.set(this.el === activePlayer);\n      });\n    }\n    effect(() => {\n      if (!$active()) return;\n      new EventsController(target).add(\"keyup\", this.#onKeyUp.bind(this)).add(\"keydown\", this.#onKeyDown.bind(this)).add(\"keydown\", this.#onPreventVideoKeys.bind(this), { capture: true });\n    });\n  }\n  #onKeyUp(event) {\n    const focusedEl = document.activeElement;\n    if (!event.key || !this.$state.canSeek() || focusedEl?.matches(IGNORE_SELECTORS)) {\n      return;\n    }\n    let { method, value } = this.#getMatchingMethod(event);\n    if (!isString(value) && !isArray(value)) {\n      value?.onKeyUp?.({\n        event,\n        player: this.#media.player,\n        remote: this.#media.remote\n      });\n      value?.callback?.(event, this.#media.remote);\n      return;\n    }\n    if (method?.startsWith(\"seek\")) {\n      event.preventDefault();\n      event.stopPropagation();\n      if (this.#timeSlider) {\n        this.#forwardTimeKeyboardEvent(event, method === \"seekForward\");\n        this.#timeSlider = null;\n      } else {\n        this.#media.remote.seek(this.#seekTotal, event);\n        this.#seekTotal = void 0;\n      }\n    }\n    if (method?.startsWith(\"volume\")) {\n      const volumeSlider = this.el.querySelector(\"[data-media-volume-slider]\");\n      volumeSlider?.dispatchEvent(\n        new KeyboardEvent(\"keyup\", {\n          key: method === \"volumeUp\" ? \"Up\" : \"Down\",\n          shiftKey: event.shiftKey,\n          trigger: event\n        })\n      );\n    }\n  }\n  #onKeyDown(event) {\n    if (!event.key || MODIFIER_KEYS.has(event.key)) return;\n    const focusedEl = document.activeElement;\n    if (focusedEl?.matches(IGNORE_SELECTORS) || isKeyboardClick(event) && focusedEl?.matches(BUTTON_SELECTORS)) {\n      return;\n    }\n    let { method, value } = this.#getMatchingMethod(event), isNumberPress = !event.metaKey && /^[0-9]$/.test(event.key);\n    if (!isString(value) && !isArray(value) && !isNumberPress) {\n      value?.onKeyDown?.({\n        event,\n        player: this.#media.player,\n        remote: this.#media.remote\n      });\n      value?.callback?.(event, this.#media.remote);\n      return;\n    }\n    if (!method && isNumberPress) {\n      event.preventDefault();\n      event.stopPropagation();\n      this.#media.remote.seek(this.$state.duration() / 10 * Number(event.key), event);\n      return;\n    }\n    if (!method) return;\n    event.preventDefault();\n    event.stopPropagation();\n    switch (method) {\n      case \"seekForward\":\n      case \"seekBackward\":\n        this.#seeking(event, method, method === \"seekForward\");\n        break;\n      case \"volumeUp\":\n      case \"volumeDown\":\n        const volumeSlider = this.el.querySelector(\"[data-media-volume-slider]\");\n        if (volumeSlider) {\n          volumeSlider.dispatchEvent(\n            new KeyboardEvent(\"keydown\", {\n              key: method === \"volumeUp\" ? \"Up\" : \"Down\",\n              shiftKey: event.shiftKey,\n              trigger: event\n            })\n          );\n        } else {\n          const value2 = event.shiftKey ? 0.1 : 0.05;\n          this.#media.remote.changeVolume(\n            this.$state.volume() + (method === \"volumeUp\" ? +value2 : -value2),\n            event\n          );\n        }\n        break;\n      case \"toggleFullscreen\":\n        this.#media.remote.toggleFullscreen(\"prefer-media\", event);\n        break;\n      case \"speedUp\":\n      case \"slowDown\":\n        const playbackRate = this.$state.playbackRate();\n        this.#media.remote.changePlaybackRate(\n          Math.max(0.25, Math.min(2, playbackRate + (method === \"speedUp\" ? 0.25 : -0.25))),\n          event\n        );\n        break;\n      default:\n        this.#media.remote[method]?.(event);\n    }\n    this.$state.lastKeyboardAction.set({\n      action: method,\n      event\n    });\n  }\n  #onPreventVideoKeys(event) {\n    if (isHTMLMediaElement(event.target) && this.#getMatchingMethod(event).method) {\n      event.preventDefault();\n    }\n  }\n  #getMatchingMethod(event) {\n    const keyShortcuts = {\n      ...this.$props.keyShortcuts(),\n      ...this.#media.ariaKeys\n    };\n    const method = Object.keys(keyShortcuts).find((method2) => {\n      const value = keyShortcuts[method2], keys = isArray(value) ? value.join(\" \") : isString(value) ? value : value?.keys;\n      const combinations = (isArray(keys) ? keys : keys?.split(\" \"))?.map(\n        (key) => replaceSymbolKeys(key).replace(/Control/g, \"Ctrl\").split(\"+\")\n      );\n      return combinations?.some((combo) => {\n        const modifierKeys = new Set(combo.filter((key) => MODIFIER_KEYS.has(key)));\n        for (const modKey of MODIFIER_KEYS) {\n          const modKeyProp = modKey.toLowerCase() + \"Key\";\n          if (!modifierKeys.has(modKey) && event[modKeyProp]) {\n            return false;\n          }\n        }\n        return combo.every((key) => {\n          return MODIFIER_KEYS.has(key) ? event[key.toLowerCase() + \"Key\"] : event.key === key.replace(\"Space\", \" \");\n        });\n      });\n    });\n    return {\n      method,\n      value: method ? keyShortcuts[method] : null\n    };\n  }\n  #seekTotal;\n  #calcSeekAmount(event, type) {\n    const seekBy = event.shiftKey ? 10 : 5;\n    return this.#seekTotal = Math.max(\n      0,\n      Math.min(\n        (this.#seekTotal ?? this.$state.currentTime()) + (type === \"seekForward\" ? +seekBy : -seekBy),\n        this.$state.duration()\n      )\n    );\n  }\n  #timeSlider = null;\n  #forwardTimeKeyboardEvent(event, forward) {\n    this.#timeSlider?.dispatchEvent(\n      new KeyboardEvent(event.type, {\n        key: !forward ? \"Left\" : \"Right\",\n        shiftKey: event.shiftKey,\n        trigger: event\n      })\n    );\n  }\n  #seeking(event, type, forward) {\n    if (!this.$state.canSeek()) return;\n    if (!this.#timeSlider) {\n      this.#timeSlider = this.el.querySelector(\"[data-media-time-slider]\");\n    }\n    if (this.#timeSlider) {\n      this.#forwardTimeKeyboardEvent(event, forward);\n    } else {\n      this.#media.remote.seeking(this.#calcSeekAmount(event, type), event);\n    }\n  }\n}\nconst SYMBOL_KEY_MAP = [\"!\", \"@\", \"#\", \"$\", \"%\", \"^\", \"&\", \"*\", \"(\", \")\"];\nfunction replaceSymbolKeys(key) {\n  return key.replace(/Shift\\+(\\d)/g, (_, num) => SYMBOL_KEY_MAP[num - 1]);\n}\n\nclass MediaControls extends MediaPlayerController {\n  #idleTimer = -2;\n  #pausedTracking = false;\n  #hideOnMouseLeave = signal(false);\n  #isMouseOutside = signal(false);\n  #focusedItem = null;\n  #canIdle = signal(true);\n  /**\n   * The default amount of delay in milliseconds while media playback is progressing without user\n   * activity to indicate an idle state (i.e., hide controls).\n   *\n   * @defaultValue 2000\n   */\n  defaultDelay = 2e3;\n  /**\n   * Whether controls can hide after a delay in user interaction. If this is false, controls will\n   * not hide and be user controlled.\n   */\n  get canIdle() {\n    return this.#canIdle();\n  }\n  set canIdle(canIdle) {\n    this.#canIdle.set(canIdle);\n  }\n  /**\n   * Whether controls visibility should be toggled when the mouse enters and leaves the player\n   * container.\n   *\n   * @defaultValue false\n   */\n  get hideOnMouseLeave() {\n    const { hideControlsOnMouseLeave } = this.$props;\n    return this.#hideOnMouseLeave() || hideControlsOnMouseLeave();\n  }\n  set hideOnMouseLeave(hide) {\n    this.#hideOnMouseLeave.set(hide);\n  }\n  /**\n   * Whether media controls are currently visible.\n   */\n  get showing() {\n    return this.$state.controlsVisible();\n  }\n  /**\n   * Show controls.\n   */\n  show(delay = 0, trigger) {\n    this.#clearIdleTimer();\n    if (!this.#pausedTracking) {\n      this.#changeVisibility(true, delay, trigger);\n    }\n  }\n  /**\n   * Hide controls.\n   */\n  hide(delay = this.defaultDelay, trigger) {\n    this.#clearIdleTimer();\n    if (!this.#pausedTracking) {\n      this.#changeVisibility(false, delay, trigger);\n    }\n  }\n  /**\n   * Whether all idle tracking on controls should be paused until resumed again.\n   */\n  pause(trigger) {\n    this.#pausedTracking = true;\n    this.#clearIdleTimer();\n    this.#changeVisibility(true, 0, trigger);\n  }\n  resume(trigger) {\n    this.#pausedTracking = false;\n    if (this.$state.paused()) return;\n    this.#changeVisibility(false, this.defaultDelay, trigger);\n  }\n  onConnect() {\n    effect(this.#init.bind(this));\n  }\n  #init() {\n    const { viewType } = this.$state;\n    if (!this.el || !this.#canIdle()) return;\n    if (viewType() === \"audio\") {\n      this.show();\n      return;\n    }\n    effect(this.#watchMouse.bind(this));\n    effect(this.#watchPaused.bind(this));\n    const onPlay = this.#onPlay.bind(this), onPause = this.#onPause.bind(this), onEnd = this.#onEnd.bind(this);\n    new EventsController(this.el).add(\"can-play\", (event) => this.show(0, event)).add(\"play\", onPlay).add(\"pause\", onPause).add(\"end\", onEnd).add(\"auto-play-fail\", onPause);\n  }\n  #watchMouse() {\n    if (!this.el) return;\n    const { started, pointer, paused } = this.$state;\n    if (!started() || pointer() !== \"fine\") return;\n    const events = new EventsController(this.el), shouldHideOnMouseLeave = this.hideOnMouseLeave;\n    if (!shouldHideOnMouseLeave || !this.#isMouseOutside()) {\n      effect(() => {\n        if (!paused()) events.add(\"pointermove\", this.#onStopIdle.bind(this));\n      });\n    }\n    if (shouldHideOnMouseLeave) {\n      events.add(\"mouseenter\", this.#onMouseEnter.bind(this)).add(\"mouseleave\", this.#onMouseLeave.bind(this));\n    }\n  }\n  #watchPaused() {\n    const { paused, started, autoPlayError } = this.$state;\n    if (paused() || autoPlayError() && !started()) return;\n    const onStopIdle = this.#onStopIdle.bind(this);\n    effect(() => {\n      if (!this.el) return;\n      const pointer = this.$state.pointer(), isTouch = pointer === \"coarse\", events = new EventsController(this.el), eventTypes = [isTouch ? \"touchend\" : \"pointerup\", \"keydown\"];\n      for (const eventType of eventTypes) {\n        events.add(eventType, onStopIdle, { passive: false });\n      }\n    });\n  }\n  #onPlay(event) {\n    if (event.triggers.hasType(\"ended\")) return;\n    this.show(0, event);\n    this.hide(void 0, event);\n  }\n  #onPause(event) {\n    this.show(0, event);\n  }\n  #onEnd(event) {\n    const { loop } = this.$state;\n    if (loop()) this.hide(0, event);\n  }\n  #onMouseEnter(event) {\n    this.#isMouseOutside.set(false);\n    this.show(0, event);\n    this.hide(void 0, event);\n  }\n  #onMouseLeave(event) {\n    this.#isMouseOutside.set(true);\n    this.hide(0, event);\n  }\n  #clearIdleTimer() {\n    window.clearTimeout(this.#idleTimer);\n    this.#idleTimer = -1;\n  }\n  #onStopIdle(event) {\n    if (\n      // @ts-expect-error\n      event.MEDIA_GESTURE || this.#pausedTracking || isTouchPinchEvent(event)\n    ) {\n      return;\n    }\n    if (isKeyboardEvent(event)) {\n      if (event.key === \"Escape\") {\n        this.el?.focus();\n        this.#focusedItem = null;\n      } else if (this.#focusedItem) {\n        event.preventDefault();\n        requestAnimationFrame(() => {\n          this.#focusedItem?.focus();\n          this.#focusedItem = null;\n        });\n      }\n    }\n    this.show(0, event);\n    this.hide(this.defaultDelay, event);\n  }\n  #changeVisibility(visible, delay, trigger) {\n    if (delay === 0) {\n      this.#onChange(visible, trigger);\n      return;\n    }\n    this.#idleTimer = window.setTimeout(() => {\n      if (!this.scope) return;\n      this.#onChange(visible && !this.#pausedTracking, trigger);\n    }, delay);\n  }\n  #onChange(visible, trigger) {\n    if (this.$state.controlsVisible() === visible) return;\n    this.$state.controlsVisible.set(visible);\n    if (!visible && document.activeElement && this.el?.contains(document.activeElement)) {\n      this.#focusedItem = document.activeElement;\n      requestAnimationFrame(() => {\n        this.el?.focus({ preventScroll: true });\n      });\n    }\n    this.dispatch(\"controls-change\", {\n      detail: visible,\n      trigger\n    });\n  }\n}\n\nclass AudioProviderLoader {\n  name = \"audio\";\n  target;\n  canPlay(src) {\n    if (!isAudioSrc(src)) return false;\n    return !isString(src.src) || src.type === \"?\" || canPlayAudioType(this.target, src.type);\n  }\n  mediaType() {\n    return \"audio\";\n  }\n  async load(ctx) {\n    if (!this.target) {\n      throw Error(\n        \"[vidstack] `<audio>` element was not found - did you forget to include `<media-provider>`?\"\n      );\n    }\n    return new (await import('../providers/vidstack-audio.js')).AudioProvider(this.target, ctx);\n  }\n}\n\nclass VideoProviderLoader {\n  name = \"video\";\n  target;\n  canPlay(src) {\n    if (!isVideoSrc(src)) return false;\n    return !isString(src.src) || src.type === \"?\" || canPlayVideoType(this.target, src.type);\n  }\n  mediaType() {\n    return \"video\";\n  }\n  async load(ctx) {\n    if (!this.target) {\n      throw Error(\n        \"[vidstack] `<video>` element was not found - did you forget to include media provider?\"\n      );\n    }\n    return new (await import('../providers/vidstack-video.js')).VideoProvider(this.target, ctx);\n  }\n}\n\nclass HLSProviderLoader extends VideoProviderLoader {\n  static supported = isHLSSupported();\n  name = \"hls\";\n  canPlay(src) {\n    return HLSProviderLoader.supported && isHLSSrc(src);\n  }\n  async load(context) {\n    if (!this.target) {\n      throw Error(\n        \"[vidstack] `<video>` element was not found - did you forget to include `<media-provider>`?\"\n      );\n    }\n    return new (await import('../providers/vidstack-hls.js')).HLSProvider(this.target, context);\n  }\n}\n\nclass DASHProviderLoader extends VideoProviderLoader {\n  static supported = isDASHSupported();\n  name = \"dash\";\n  canPlay(src) {\n    return DASHProviderLoader.supported && isDASHSrc(src);\n  }\n  async load(context) {\n    if (!this.target) {\n      throw Error(\n        \"[vidstack] `<video>` element was not found - did you forget to include `<media-provider>`?\"\n      );\n    }\n    return new (await import('../providers/vidstack-dash.js')).DASHProvider(this.target, context);\n  }\n}\n\nclass VimeoProviderLoader {\n  name = \"vimeo\";\n  target;\n  preconnect() {\n    const connections = [\n      \"https://i.vimeocdn.com\",\n      \"https://f.vimeocdn.com\",\n      \"https://fresnel.vimeocdn.com\"\n    ];\n    for (const url of connections) {\n      preconnect(url);\n    }\n  }\n  canPlay(src) {\n    return isString(src.src) && src.type === \"video/vimeo\";\n  }\n  mediaType() {\n    return \"video\";\n  }\n  async load(ctx) {\n    if (!this.target) {\n      throw Error(\n        \"[vidstack] `<iframe>` element was not found - did you forget to include media provider?\"\n      );\n    }\n    return new (await import('../providers/vidstack-vimeo.js')).VimeoProvider(this.target, ctx);\n  }\n  async loadPoster(src, ctx, abort) {\n    const { resolveVimeoVideoId, getVimeoVideoInfo } = await import('./vidstack-krOAtKMi.js');\n    if (!isString(src.src)) return null;\n    const { videoId, hash } = resolveVimeoVideoId(src.src);\n    if (videoId) {\n      return getVimeoVideoInfo(videoId, abort, hash).then((info) => info ? info.poster : null);\n    }\n    return null;\n  }\n}\n\nclass YouTubeProviderLoader {\n  name = \"youtube\";\n  target;\n  preconnect() {\n    const connections = [\n      // Botguard script.\n      \"https://www.google.com\",\n      // Posters.\n      \"https://i.ytimg.com\",\n      // Ads.\n      \"https://googleads.g.doubleclick.net\",\n      \"https://static.doubleclick.net\"\n    ];\n    for (const url of connections) {\n      preconnect(url);\n    }\n  }\n  canPlay(src) {\n    return isString(src.src) && src.type === \"video/youtube\";\n  }\n  mediaType() {\n    return \"video\";\n  }\n  async load(ctx) {\n    if (!this.target) {\n      throw Error(\n        \"[vidstack] `<iframe>` element was not found - did you forget to include media provider?\"\n      );\n    }\n    return new (await import('../providers/vidstack-youtube.js')).YouTubeProvider(this.target, ctx);\n  }\n  async loadPoster(src, ctx, abort) {\n    const { findYouTubePoster, resolveYouTubeVideoId } = await import('./vidstack-Zc3I7oOd.js');\n    const videoId = isString(src.src) && resolveYouTubeVideoId(src.src);\n    if (videoId) return findYouTubePoster(videoId, abort);\n    return null;\n  }\n}\n\nconst MEDIA_ATTRIBUTES = Symbol(\"MEDIA_ATTRIBUTES\" );\nconst mediaAttributes = [\n  \"autoPlay\",\n  \"canAirPlay\",\n  \"canFullscreen\",\n  \"canGoogleCast\",\n  \"canLoad\",\n  \"canLoadPoster\",\n  \"canPictureInPicture\",\n  \"canPlay\",\n  \"canSeek\",\n  \"ended\",\n  \"fullscreen\",\n  \"isAirPlayConnected\",\n  \"isGoogleCastConnected\",\n  \"live\",\n  \"liveEdge\",\n  \"loop\",\n  \"mediaType\",\n  \"muted\",\n  \"paused\",\n  \"pictureInPicture\",\n  \"playing\",\n  \"playsInline\",\n  \"remotePlaybackState\",\n  \"remotePlaybackType\",\n  \"seeking\",\n  \"started\",\n  \"streamType\",\n  \"viewType\",\n  \"waiting\"\n];\n\nconst mediaPlayerProps = {\n  artist: \"\",\n  artwork: null,\n  autoplay: false,\n  autoPlay: false,\n  clipStartTime: 0,\n  clipEndTime: 0,\n  controls: false,\n  currentTime: 0,\n  crossorigin: null,\n  crossOrigin: null,\n  duration: -1,\n  fullscreenOrientation: \"landscape\",\n  googleCast: {},\n  load: \"visible\",\n  posterLoad: \"visible\",\n  logLevel: \"warn\" ,\n  loop: false,\n  muted: false,\n  paused: true,\n  playsinline: false,\n  playsInline: false,\n  playbackRate: 1,\n  poster: \"\",\n  preload: \"metadata\",\n  preferNativeHLS: false,\n  src: \"\",\n  title: \"\",\n  controlsDelay: 2e3,\n  hideControlsOnMouseLeave: false,\n  viewType: \"unknown\",\n  streamType: \"unknown\",\n  volume: 1,\n  liveEdgeTolerance: 10,\n  minLiveDVRWindow: 60,\n  keyDisabled: false,\n  keyTarget: \"player\",\n  keyShortcuts: MEDIA_KEY_SHORTCUTS,\n  storage: null\n};\n\nconst MEDIA_EVENTS = [\n  \"abort\",\n  \"can-play\",\n  \"can-play-through\",\n  \"duration-change\",\n  \"emptied\",\n  \"ended\",\n  \"error\",\n  \"fullscreen-change\",\n  \"loaded-data\",\n  \"loaded-metadata\",\n  \"load-start\",\n  \"media-type-change\",\n  \"pause\",\n  \"play\",\n  \"playing\",\n  \"progress\",\n  \"seeked\",\n  \"seeking\",\n  \"source-change\",\n  \"sources-change\",\n  \"stalled\",\n  \"started\",\n  \"suspend\",\n  \"stream-type-change\",\n  \"replay\",\n  // time-change,\n  // 'time-update',\n  \"view-type-change\",\n  \"volume-change\",\n  \"waiting\"\n] ;\nclass MediaEventsLogger extends MediaPlayerController {\n  #media;\n  constructor(media) {\n    super();\n    this.#media = media;\n  }\n  onConnect(el) {\n    const events = new EventsController(el), handler = this.#onMediaEvent.bind(this);\n    for (const eventType of MEDIA_EVENTS) {\n      events.add(eventType, handler);\n    }\n  }\n  #onMediaEvent(event) {\n    this.#media.logger?.debugGroup(`\\u{1F4E1} dispatching \\`${event.type}\\``).labelledLog(\"Media Store\", { ...this.$state }).labelledLog(\"Event\", event).dispatch();\n  }\n}\n\nclass MediaLoadController extends MediaPlayerController {\n  #type;\n  #callback;\n  constructor(type, callback) {\n    super();\n    this.#type = type;\n    this.#callback = callback;\n  }\n  async onAttach(el) {\n    const load = this.$props[this.#type]();\n    if (load === \"eager\") {\n      requestAnimationFrame(this.#callback);\n    } else if (load === \"idle\") {\n      waitIdlePeriod(this.#callback);\n    } else if (load === \"visible\") {\n      let dispose, observer = new IntersectionObserver((entries) => {\n        if (!this.scope) return;\n        if (entries[0].isIntersecting) {\n          dispose?.();\n          dispose = void 0;\n          this.#callback();\n        }\n      });\n      observer.observe(el);\n      dispose = onDispose(() => observer.disconnect());\n    }\n  }\n}\n\nlet seenAutoplayWarning = false;\nclass MediaPlayerDelegate {\n  #handle;\n  #media;\n  constructor(handle, media) {\n    this.#handle = handle;\n    this.#media = media;\n  }\n  notify(type, ...init) {\n    this.#handle(\n      new DOMEvent(type, {\n        detail: init?.[0],\n        trigger: init?.[1]\n      })\n    );\n  }\n  async ready(info, trigger) {\n    return untrack(async () => {\n      const { logger } = this.#media, {\n        autoPlay,\n        canPlay,\n        started,\n        duration,\n        seekable,\n        buffered,\n        remotePlaybackInfo,\n        playsInline,\n        savedState,\n        source\n      } = this.#media.$state;\n      if (canPlay()) return;\n      const detail = {\n        duration: info?.duration ?? duration(),\n        seekable: info?.seekable ?? seekable(),\n        buffered: info?.buffered ?? buffered(),\n        provider: this.#media.$provider()\n      };\n      this.notify(\"can-play\", detail, trigger);\n      tick();\n      {\n        logger?.infoGroup(\"-~-~-~-~-~-~- \\u2705 MEDIA READY -~-~-~-~-~-~-\").labelledLog(\"Media\", this.#media).labelledLog(\"Trigger Event\", trigger).dispatch();\n      }\n      let provider = this.#media.$provider(), { storage, qualities } = this.#media, { muted, volume, clipStartTime, playbackRate } = this.#media.$props;\n      await storage?.onLoad?.(source());\n      const savedPlaybackTime = savedState()?.currentTime, savedPlayingState = savedState()?.paused, storageTime = await storage?.getTime(), startTime = savedPlaybackTime ?? storageTime ?? clipStartTime(), shouldAutoPlay = savedPlayingState || savedPlayingState !== false && !started() && autoPlay();\n      if (provider) {\n        provider.setVolume(await storage?.getVolume() ?? volume());\n        provider.setMuted(muted() || !!await storage?.getMuted());\n        const audioGain = await storage?.getAudioGain() ?? 1;\n        if (audioGain > 1) provider.audioGain?.setGain?.(audioGain);\n        provider.setPlaybackRate?.(await storage?.getPlaybackRate() ?? playbackRate());\n        provider.setPlaysInline?.(playsInline());\n        if (startTime > 0) provider.setCurrentTime(startTime);\n      }\n      const prefQuality = await storage?.getVideoQuality();\n      if (prefQuality && qualities.length) {\n        let currentQuality = null, currentScore = Infinity;\n        for (const quality of qualities) {\n          const score = Math.abs(prefQuality.width - quality.width) + Math.abs(prefQuality.height - quality.height) + (prefQuality.bitrate ? Math.abs(prefQuality.bitrate - (quality.bitrate ?? 0)) : 0);\n          if (score < currentScore) {\n            currentQuality = quality;\n            currentScore = score;\n          }\n        }\n        if (currentQuality) currentQuality.selected = true;\n      }\n      if (canPlay() && shouldAutoPlay) {\n        await this.#attemptAutoplay(trigger);\n      } else if (storageTime && storageTime > 0) {\n        this.notify(\"started\", void 0, trigger);\n      }\n      remotePlaybackInfo.set(null);\n    });\n  }\n  async #attemptAutoplay(trigger) {\n    const {\n      player,\n      $state: { autoPlaying, muted }\n    } = this.#media;\n    autoPlaying.set(true);\n    const attemptEvent = new DOMEvent(\"auto-play-attempt\", { trigger });\n    try {\n      await player.play(attemptEvent);\n    } catch (error) {\n      if (!seenAutoplayWarning) {\n        const muteMsg = !muted() ? \" Attempting with volume muted will most likely resolve the issue.\" : \"\";\n        this.#media.logger?.errorGroup(\"[vidstack] auto-play request failed\").labelledLog(\n          \"Message\",\n          `Autoplay was requested but failed most likely due to browser autoplay policies.${muteMsg}`\n        ).labelledLog(\"Trigger Event\", trigger).labelledLog(\"Error\", error).labelledLog(\"See\", \"https://developer.chrome.com/blog/autoplay\").dispatch();\n        seenAutoplayWarning = true;\n      }\n    }\n  }\n}\n\nclass Queue {\n  #queue = /* @__PURE__ */ new Map();\n  /**\n   * Queue the given `item` under the given `key` to be processed at a later time by calling\n   * `serve(key)`.\n   */\n  enqueue(key, item) {\n    this.#queue.set(key, item);\n  }\n  /**\n   * Process item in queue for the given `key`.\n   */\n  serve(key) {\n    const value = this.peek(key);\n    this.#queue.delete(key);\n    return value;\n  }\n  /**\n   * Peek at item in queue for the given `key`.\n   */\n  peek(key) {\n    return this.#queue.get(key);\n  }\n  /**\n   * Removes queued item under the given `key`.\n   */\n  delete(key) {\n    this.#queue.delete(key);\n  }\n  /**\n   * Clear all items in the queue.\n   */\n  clear() {\n    this.#queue.clear();\n  }\n}\n\nclass RequestQueue {\n  #serving = false;\n  #pending = deferredPromise();\n  #queue = /* @__PURE__ */ new Map();\n  /**\n   * The number of callbacks that are currently in queue.\n   */\n  get size() {\n    return this.#queue.size;\n  }\n  /**\n   * Whether items in the queue are being served immediately, otherwise they're queued to\n   * be processed later.\n   */\n  get isServing() {\n    return this.#serving;\n  }\n  /**\n   * Waits for the queue to be flushed (ie: start serving).\n   */\n  async waitForFlush() {\n    if (this.#serving) return;\n    await this.#pending.promise;\n  }\n  /**\n   * Queue the given `callback` to be invoked at a later time by either calling the `serve()` or\n   * `start()` methods. If the queue has started serving (i.e., `start()` was already called),\n   * then the callback will be invoked immediately.\n   *\n   * @param key - Uniquely identifies this callback so duplicates are ignored.\n   * @param callback - The function to call when this item in the queue is being served.\n   */\n  enqueue(key, callback) {\n    if (this.#serving) {\n      callback();\n      return;\n    }\n    this.#queue.delete(key);\n    this.#queue.set(key, callback);\n  }\n  /**\n   * Invokes the callback with the given `key` in the queue (if it exists).\n   */\n  serve(key) {\n    this.#queue.get(key)?.();\n    this.#queue.delete(key);\n  }\n  /**\n   * Flush all queued items and start serving future requests immediately until `stop()` is called.\n   */\n  start() {\n    this.#flush();\n    this.#serving = true;\n    if (this.#queue.size > 0) this.#flush();\n  }\n  /**\n   * Stop serving requests, they'll be queued until you begin processing again by calling `start()`.\n   */\n  stop() {\n    this.#serving = false;\n  }\n  /**\n   * Stop serving requests, empty the request queue, and release any promises waiting for the\n   * queue to flush.\n   */\n  reset() {\n    this.stop();\n    this.#queue.clear();\n    this.#release();\n  }\n  #flush() {\n    for (const key of this.#queue.keys()) this.serve(key);\n    this.#release();\n  }\n  #release() {\n    this.#pending.resolve();\n    this.#pending = deferredPromise();\n  }\n}\n\nclass MediaRequestManager extends MediaPlayerController {\n  #stateMgr;\n  #request;\n  #media;\n  controls;\n  #fullscreen;\n  #orientation;\n  #$provider;\n  #providerQueue = new RequestQueue();\n  constructor(stateMgr, request, media) {\n    super();\n    this.#stateMgr = stateMgr;\n    this.#request = request;\n    this.#media = media;\n    this.#$provider = media.$provider;\n    this.controls = new MediaControls();\n    this.#fullscreen = new FullscreenController();\n    this.#orientation = new ScreenOrientationController();\n  }\n  onAttach() {\n    this.listen(\"fullscreen-change\", this.#onFullscreenChange.bind(this));\n  }\n  onConnect(el) {\n    const names = Object.getOwnPropertyNames(Object.getPrototypeOf(this)), events = new EventsController(el), handleRequest = this.#handleRequest.bind(this);\n    for (const name of names) {\n      if (name.startsWith(\"media-\")) {\n        events.add(name, handleRequest);\n      }\n    }\n    this.#attachLoadPlayListener();\n    effect(this.#watchProvider.bind(this));\n    effect(this.#watchControlsDelayChange.bind(this));\n    effect(this.#watchAudioGainSupport.bind(this));\n    effect(this.#watchAirPlaySupport.bind(this));\n    effect(this.#watchGoogleCastSupport.bind(this));\n    effect(this.#watchFullscreenSupport.bind(this));\n    effect(this.#watchPiPSupport.bind(this));\n  }\n  onDestroy() {\n    try {\n      const destroyEvent = this.createEvent(\"destroy\"), { pictureInPicture, fullscreen } = this.$state;\n      if (fullscreen()) this.exitFullscreen(\"prefer-media\", destroyEvent);\n      if (pictureInPicture()) this.exitPictureInPicture(destroyEvent);\n    } catch (e) {\n    }\n    this.#providerQueue.reset();\n  }\n  #attachLoadPlayListener() {\n    const { load } = this.$props, { canLoad } = this.$state;\n    if (load() !== \"play\" || canLoad()) return;\n    const off = this.listen(\"media-play-request\", (event) => {\n      this.#handleLoadPlayStrategy(event);\n      off();\n    });\n  }\n  #watchProvider() {\n    const provider = this.#$provider(), canPlay = this.$state.canPlay();\n    if (provider && canPlay) {\n      this.#providerQueue.start();\n    }\n    return () => {\n      this.#providerQueue.stop();\n    };\n  }\n  #handleRequest(event) {\n    event.stopPropagation();\n    if (event.defaultPrevented) return;\n    {\n      this.#media.logger?.infoGroup(`\\u{1F4EC} received \\`${event.type}\\``).labelledLog(\"Request\", event).dispatch();\n    }\n    if (!this[event.type]) return;\n    if (peek(this.#$provider)) {\n      this[event.type](event);\n    } else {\n      this.#providerQueue.enqueue(event.type, () => {\n        if (peek(this.#$provider)) this[event.type](event);\n      });\n    }\n  }\n  async play(trigger) {\n    const { canPlay, paused, autoPlaying } = this.$state;\n    if (this.#handleLoadPlayStrategy(trigger)) return;\n    if (!peek(paused)) return;\n    if (trigger) this.#request.queue.enqueue(\"media-play-request\", trigger);\n    const isAutoPlaying = peek(autoPlaying);\n    try {\n      const provider = peek(this.#$provider);\n      throwIfNotReadyForPlayback(provider, peek(canPlay));\n      return await provider.play();\n    } catch (error) {\n      this.#logError(\"play request failed\", error, trigger);\n      const errorEvent = this.createEvent(\"play-fail\", {\n        detail: coerceToError(error),\n        trigger\n      });\n      errorEvent.autoPlay = isAutoPlaying;\n      this.#stateMgr.handle(errorEvent);\n      throw error;\n    }\n  }\n  #handleLoadPlayStrategy(trigger) {\n    const { load } = this.$props, { canLoad } = this.$state;\n    if (load() === \"play\" && !canLoad()) {\n      const event = this.createEvent(\"media-start-loading\", { trigger });\n      this.dispatchEvent(event);\n      this.#providerQueue.enqueue(\"media-play-request\", async () => {\n        try {\n          await this.play(event);\n        } catch (error) {\n        }\n      });\n      return true;\n    }\n    return false;\n  }\n  async pause(trigger) {\n    const { canPlay, paused } = this.$state;\n    if (peek(paused)) return;\n    if (trigger) {\n      this.#request.queue.enqueue(\"media-pause-request\", trigger);\n    }\n    try {\n      const provider = peek(this.#$provider);\n      throwIfNotReadyForPlayback(provider, peek(canPlay));\n      return await provider.pause();\n    } catch (error) {\n      this.#request.queue.delete(\"media-pause-request\");\n      {\n        this.#logError(\"pause request failed\", error, trigger);\n      }\n      throw error;\n    }\n  }\n  setAudioGain(gain, trigger) {\n    const { audioGain, canSetAudioGain } = this.$state;\n    if (audioGain() === gain) return;\n    const provider = this.#$provider();\n    if (!provider?.audioGain || !canSetAudioGain()) {\n      throw Error(\"[vidstack] audio gain api not available\");\n    }\n    if (trigger) {\n      this.#request.queue.enqueue(\"media-audio-gain-change-request\", trigger);\n    }\n    provider.audioGain.setGain(gain);\n  }\n  seekToLiveEdge(trigger) {\n    const { canPlay, live, liveEdge, canSeek, liveSyncPosition, seekableEnd, userBehindLiveEdge } = this.$state;\n    userBehindLiveEdge.set(false);\n    if (peek(() => !live() || liveEdge() || !canSeek())) return;\n    const provider = peek(this.#$provider);\n    throwIfNotReadyForPlayback(provider, peek(canPlay));\n    if (trigger) this.#request.queue.enqueue(\"media-seek-request\", trigger);\n    const end = seekableEnd() - 2;\n    provider.setCurrentTime(Math.min(end, liveSyncPosition() ?? end));\n  }\n  #wasPIPActive = false;\n  async enterFullscreen(target = \"prefer-media\", trigger) {\n    const adapter = this.#getFullscreenAdapter(target);\n    throwIfFullscreenNotSupported(target, adapter);\n    if (adapter.active) return;\n    if (peek(this.$state.pictureInPicture)) {\n      this.#wasPIPActive = true;\n      await this.exitPictureInPicture(trigger);\n    }\n    if (trigger) {\n      this.#request.queue.enqueue(\"media-enter-fullscreen-request\", trigger);\n    }\n    return adapter.enter();\n  }\n  async exitFullscreen(target = \"prefer-media\", trigger) {\n    const adapter = this.#getFullscreenAdapter(target);\n    throwIfFullscreenNotSupported(target, adapter);\n    if (!adapter.active) return;\n    if (trigger) {\n      this.#request.queue.enqueue(\"media-exit-fullscreen-request\", trigger);\n    }\n    try {\n      const result = await adapter.exit();\n      if (this.#wasPIPActive && peek(this.$state.canPictureInPicture)) {\n        await this.enterPictureInPicture();\n      }\n      return result;\n    } finally {\n      this.#wasPIPActive = false;\n    }\n  }\n  #getFullscreenAdapter(target) {\n    const provider = peek(this.#$provider);\n    return target === \"prefer-media\" && this.#fullscreen.supported || target === \"media\" ? this.#fullscreen : provider?.fullscreen;\n  }\n  async enterPictureInPicture(trigger) {\n    this.#throwIfPIPNotSupported();\n    if (this.$state.pictureInPicture()) return;\n    if (trigger) {\n      this.#request.queue.enqueue(\"media-enter-pip-request\", trigger);\n    }\n    return await this.#$provider().pictureInPicture.enter();\n  }\n  async exitPictureInPicture(trigger) {\n    this.#throwIfPIPNotSupported();\n    if (!this.$state.pictureInPicture()) return;\n    if (trigger) {\n      this.#request.queue.enqueue(\"media-exit-pip-request\", trigger);\n    }\n    return await this.#$provider().pictureInPicture.exit();\n  }\n  #throwIfPIPNotSupported() {\n    if (this.$state.canPictureInPicture()) return;\n    throw Error(\n      `[vidstack] picture-in-picture is not currently available` \n    );\n  }\n  #watchControlsDelayChange() {\n    this.controls.defaultDelay = this.$props.controlsDelay();\n  }\n  #watchAudioGainSupport() {\n    const { canSetAudioGain } = this.$state, supported = !!this.#$provider()?.audioGain?.supported;\n    canSetAudioGain.set(supported);\n  }\n  #watchAirPlaySupport() {\n    const { canAirPlay } = this.$state, supported = !!this.#$provider()?.airPlay?.supported;\n    canAirPlay.set(supported);\n  }\n  #watchGoogleCastSupport() {\n    const { canGoogleCast, source } = this.$state, supported = IS_CHROME && !IS_IOS && canGoogleCastSrc(source());\n    canGoogleCast.set(supported);\n  }\n  #watchFullscreenSupport() {\n    const { canFullscreen } = this.$state, supported = this.#fullscreen.supported || !!this.#$provider()?.fullscreen?.supported;\n    canFullscreen.set(supported);\n  }\n  #watchPiPSupport() {\n    const { canPictureInPicture } = this.$state, supported = !!this.#$provider()?.pictureInPicture?.supported;\n    canPictureInPicture.set(supported);\n  }\n  async [\"media-airplay-request\"](event) {\n    try {\n      await this.requestAirPlay(event);\n    } catch (error) {\n    }\n  }\n  async requestAirPlay(trigger) {\n    try {\n      const adapter = this.#$provider()?.airPlay;\n      if (!adapter?.supported) {\n        throw Error(true ? \"AirPlay adapter not available on provider.\" : \"No AirPlay adapter.\");\n      }\n      if (trigger) {\n        this.#request.queue.enqueue(\"media-airplay-request\", trigger);\n      }\n      return await adapter.prompt();\n    } catch (error) {\n      this.#request.queue.delete(\"media-airplay-request\");\n      {\n        this.#logError(\"airplay request failed\", error, trigger);\n      }\n      throw error;\n    }\n  }\n  async [\"media-google-cast-request\"](event) {\n    try {\n      await this.requestGoogleCast(event);\n    } catch (error) {\n    }\n  }\n  #googleCastLoader;\n  async requestGoogleCast(trigger) {\n    try {\n      const { canGoogleCast } = this.$state;\n      if (!peek(canGoogleCast)) {\n        const error = Error(\n          true ? \"Google Cast not available on this platform.\" : \"Cast not available.\"\n        );\n        error.code = \"CAST_NOT_AVAILABLE\";\n        throw error;\n      }\n      preconnect(\"https://www.gstatic.com\");\n      if (!this.#googleCastLoader) {\n        const $module = await import('./vidstack-Caddm6o8.js');\n        this.#googleCastLoader = new $module.GoogleCastLoader();\n      }\n      await this.#googleCastLoader.prompt(this.#media);\n      if (trigger) {\n        this.#request.queue.enqueue(\"media-google-cast-request\", trigger);\n      }\n      const isConnecting = peek(this.$state.remotePlaybackState) !== \"disconnected\";\n      if (isConnecting) {\n        this.$state.savedState.set({\n          paused: peek(this.$state.paused),\n          currentTime: peek(this.$state.currentTime)\n        });\n      }\n      this.$state.remotePlaybackLoader.set(isConnecting ? this.#googleCastLoader : null);\n    } catch (error) {\n      this.#request.queue.delete(\"media-google-cast-request\");\n      {\n        this.#logError(\"google cast request failed\", error, trigger);\n      }\n      throw error;\n    }\n  }\n  [\"media-clip-start-change-request\"](event) {\n    const { clipStartTime } = this.$state;\n    clipStartTime.set(event.detail);\n  }\n  [\"media-clip-end-change-request\"](event) {\n    const { clipEndTime } = this.$state;\n    clipEndTime.set(event.detail);\n    this.dispatch(\"duration-change\", {\n      detail: event.detail,\n      trigger: event\n    });\n  }\n  [\"media-duration-change-request\"](event) {\n    const { providedDuration, clipEndTime } = this.$state;\n    providedDuration.set(event.detail);\n    if (clipEndTime() <= 0) {\n      this.dispatch(\"duration-change\", {\n        detail: event.detail,\n        trigger: event\n      });\n    }\n  }\n  [\"media-audio-track-change-request\"](event) {\n    const { logger, audioTracks } = this.#media;\n    if (audioTracks.readonly) {\n      {\n        logger?.warnGroup(`[vidstack] attempted to change audio track but it is currently read-only`).labelledLog(\"Request Event\", event).dispatch();\n      }\n      return;\n    }\n    const index = event.detail, track = audioTracks[index];\n    if (track) {\n      const key = event.type;\n      this.#request.queue.enqueue(key, event);\n      track.selected = true;\n    } else {\n      logger?.warnGroup(\"[vidstack] failed audio track change request (invalid index)\").labelledLog(\"Audio Tracks\", audioTracks.toArray()).labelledLog(\"Index\", index).labelledLog(\"Request Event\", event).dispatch();\n    }\n  }\n  async [\"media-enter-fullscreen-request\"](event) {\n    try {\n      await this.enterFullscreen(event.detail, event);\n    } catch (error) {\n      this.#onFullscreenError(error, event);\n    }\n  }\n  async [\"media-exit-fullscreen-request\"](event) {\n    try {\n      await this.exitFullscreen(event.detail, event);\n    } catch (error) {\n      this.#onFullscreenError(error, event);\n    }\n  }\n  async #onFullscreenChange(event) {\n    const lockType = peek(this.$props.fullscreenOrientation), isFullscreen = event.detail;\n    if (isUndefined(lockType) || lockType === \"none\" || !this.#orientation.supported) return;\n    if (isFullscreen) {\n      if (this.#orientation.locked) return;\n      this.dispatch(\"media-orientation-lock-request\", {\n        detail: lockType,\n        trigger: event\n      });\n    } else if (this.#orientation.locked) {\n      this.dispatch(\"media-orientation-unlock-request\", {\n        trigger: event\n      });\n    }\n  }\n  #onFullscreenError(error, request) {\n    {\n      this.#logError(\"fullscreen request failed\", error, request);\n    }\n    this.#stateMgr.handle(\n      this.createEvent(\"fullscreen-error\", {\n        detail: coerceToError(error)\n      })\n    );\n  }\n  async [\"media-orientation-lock-request\"](event) {\n    const key = event.type;\n    try {\n      this.#request.queue.enqueue(key, event);\n      await this.#orientation.lock(event.detail);\n    } catch (error) {\n      this.#request.queue.delete(key);\n      {\n        this.#logError(\"failed to lock screen orientation\", error, event);\n      }\n    }\n  }\n  async [\"media-orientation-unlock-request\"](event) {\n    const key = event.type;\n    try {\n      this.#request.queue.enqueue(key, event);\n      await this.#orientation.unlock();\n    } catch (error) {\n      this.#request.queue.delete(key);\n      {\n        this.#logError(\"failed to unlock screen orientation\", error, event);\n      }\n    }\n  }\n  async [\"media-enter-pip-request\"](event) {\n    try {\n      await this.enterPictureInPicture(event);\n    } catch (error) {\n      this.#onPictureInPictureError(error, event);\n    }\n  }\n  async [\"media-exit-pip-request\"](event) {\n    try {\n      await this.exitPictureInPicture(event);\n    } catch (error) {\n      this.#onPictureInPictureError(error, event);\n    }\n  }\n  #onPictureInPictureError(error, request) {\n    {\n      this.#logError(\"pip request failed\", error, request);\n    }\n    this.#stateMgr.handle(\n      this.createEvent(\"picture-in-picture-error\", {\n        detail: coerceToError(error)\n      })\n    );\n  }\n  [\"media-live-edge-request\"](event) {\n    const { live, liveEdge, canSeek } = this.$state;\n    if (!live() || liveEdge() || !canSeek()) return;\n    this.#request.queue.enqueue(\"media-seek-request\", event);\n    try {\n      this.seekToLiveEdge();\n    } catch (error) {\n      this.#request.queue.delete(\"media-seek-request\");\n      {\n        this.#logError(\"seek to live edge fail\", error, event);\n      }\n    }\n  }\n  async [\"media-loop-request\"](event) {\n    try {\n      this.#request.looping = true;\n      this.#request.replaying = true;\n      await this.play(event);\n    } catch (error) {\n      this.#request.looping = false;\n    }\n  }\n  [\"media-user-loop-change-request\"](event) {\n    this.$state.userPrefersLoop.set(event.detail);\n  }\n  async [\"media-pause-request\"](event) {\n    if (this.$state.paused()) return;\n    try {\n      await this.pause(event);\n    } catch (error) {\n    }\n  }\n  async [\"media-play-request\"](event) {\n    if (!this.$state.paused()) return;\n    try {\n      await this.play(event);\n    } catch (e) {\n    }\n  }\n  [\"media-rate-change-request\"](event) {\n    const { playbackRate, canSetPlaybackRate } = this.$state;\n    if (playbackRate() === event.detail || !canSetPlaybackRate()) return;\n    const provider = this.#$provider();\n    if (!provider?.setPlaybackRate) return;\n    this.#request.queue.enqueue(\"media-rate-change-request\", event);\n    provider.setPlaybackRate(event.detail);\n  }\n  [\"media-audio-gain-change-request\"](event) {\n    try {\n      this.setAudioGain(event.detail, event);\n    } catch (e) {\n    }\n  }\n  [\"media-quality-change-request\"](event) {\n    const { qualities, storage, logger } = this.#media;\n    if (qualities.readonly) {\n      {\n        logger?.warnGroup(`[vidstack] attempted to change video quality but it is currently read-only`).labelledLog(\"Request Event\", event).dispatch();\n      }\n      return;\n    }\n    this.#request.queue.enqueue(\"media-quality-change-request\", event);\n    const index = event.detail;\n    if (index < 0) {\n      qualities.autoSelect(event);\n      if (event.isOriginTrusted) storage?.setVideoQuality?.(null);\n    } else {\n      const quality = qualities[index];\n      if (quality) {\n        quality.selected = true;\n        if (event.isOriginTrusted) {\n          storage?.setVideoQuality?.({\n            id: quality.id,\n            width: quality.width,\n            height: quality.height,\n            bitrate: quality.bitrate\n          });\n        }\n      } else {\n        logger?.warnGroup(\"[vidstack] failed quality change request (invalid index)\").labelledLog(\"Qualities\", qualities.toArray()).labelledLog(\"Index\", index).labelledLog(\"Request Event\", event).dispatch();\n      }\n    }\n  }\n  [\"media-pause-controls-request\"](event) {\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.controls.pause(event);\n  }\n  [\"media-resume-controls-request\"](event) {\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.controls.resume(event);\n  }\n  [\"media-seek-request\"](event) {\n    const { seekableStart, seekableEnd, ended, canSeek, live, userBehindLiveEdge, clipStartTime } = this.$state, seekTime = event.detail;\n    if (ended()) this.#request.replaying = true;\n    const key = event.type;\n    this.#request.seeking = false;\n    this.#request.queue.delete(key);\n    const clippedTime = seekTime + clipStartTime(), isStart = Math.floor(seekTime) === Math.floor(seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(seekableEnd()), boundTime = isStart ? seekableStart() : isEnd ? seekableEnd() : Math.min(Math.max(seekableStart() + 0.1, clippedTime), seekableEnd() - 0.1);\n    if (!Number.isFinite(boundTime) || !canSeek()) return;\n    this.#request.queue.enqueue(key, event);\n    this.#$provider().setCurrentTime(boundTime);\n    if (live() && event.isOriginTrusted && Math.abs(seekableEnd() - boundTime) >= 2) {\n      userBehindLiveEdge.set(true);\n    }\n  }\n  [\"media-seeking-request\"](event) {\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.$state.seeking.set(true);\n    this.#request.seeking = true;\n  }\n  [\"media-start-loading\"](event) {\n    if (this.$state.canLoad()) return;\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.#stateMgr.handle(this.createEvent(\"can-load\"));\n  }\n  [\"media-poster-start-loading\"](event) {\n    if (this.$state.canLoadPoster()) return;\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.#stateMgr.handle(this.createEvent(\"can-load-poster\"));\n  }\n  [\"media-text-track-change-request\"](event) {\n    const { index, mode } = event.detail, track = this.#media.textTracks[index];\n    if (track) {\n      const key = event.type;\n      this.#request.queue.enqueue(key, event);\n      track.setMode(mode, event);\n    } else {\n      this.#media.logger?.warnGroup(\"[vidstack] failed text track change request (invalid index)\").labelledLog(\"Text Tracks\", this.#media.textTracks.toArray()).labelledLog(\"Index\", index).labelledLog(\"Request Event\", event).dispatch();\n    }\n  }\n  [\"media-mute-request\"](event) {\n    if (this.$state.muted()) return;\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.#$provider().setMuted(true);\n  }\n  [\"media-unmute-request\"](event) {\n    const { muted, volume } = this.$state;\n    if (!muted()) return;\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.#media.$provider().setMuted(false);\n    if (volume() === 0) {\n      this.#request.queue.enqueue(key, event);\n      this.#$provider().setVolume(0.25);\n    }\n  }\n  [\"media-volume-change-request\"](event) {\n    const { muted, volume } = this.$state;\n    const newVolume = event.detail;\n    if (volume() === newVolume) return;\n    const key = event.type;\n    this.#request.queue.enqueue(key, event);\n    this.#$provider().setVolume(newVolume);\n    if (newVolume > 0 && muted()) {\n      this.#request.queue.enqueue(key, event);\n      this.#$provider().setMuted(false);\n    }\n  }\n  #logError(title, error, request) {\n    this.#media.logger?.errorGroup(`[vidstack] ${title}`).labelledLog(\"Error\", error).labelledLog(\"Media Context\", { ...this.#media }).labelledLog(\"Trigger Event\", request).dispatch();\n  }\n}\nfunction throwIfNotReadyForPlayback(provider, canPlay) {\n  if (provider && canPlay) return;\n  throw Error(\n    `[vidstack] media is not ready - wait for \\`can-play\\` event.` \n  );\n}\nfunction throwIfFullscreenNotSupported(target, fullscreen) {\n  if (fullscreen?.supported) return;\n  throw Error(\n    `[vidstack] fullscreen is not currently available on target \\`${target}\\`` \n  );\n}\nclass MediaRequestContext {\n  seeking = false;\n  looping = false;\n  replaying = false;\n  queue = new Queue();\n}\n\nconst TRACKED_EVENT = /* @__PURE__ */ new Set([\n  \"auto-play\",\n  \"auto-play-fail\",\n  \"can-load\",\n  \"sources-change\",\n  \"source-change\",\n  \"load-start\",\n  \"abort\",\n  \"error\",\n  \"loaded-metadata\",\n  \"loaded-data\",\n  \"can-play\",\n  \"play\",\n  \"play-fail\",\n  \"pause\",\n  \"playing\",\n  \"seeking\",\n  \"seeked\",\n  \"waiting\"\n]);\n\nclass MediaStateManager extends MediaPlayerController {\n  #request;\n  #media;\n  #trackedEvents = /* @__PURE__ */ new Map();\n  #clipEnded = false;\n  #playedIntervals = [];\n  #playedInterval = [-1, -1];\n  #firingWaiting = false;\n  #waitingTrigger;\n  constructor(request, media) {\n    super();\n    this.#request = request;\n    this.#media = media;\n  }\n  onAttach(el) {\n    el.setAttribute(\"aria-busy\", \"true\");\n    new EventsController(this).add(\"fullscreen-change\", this[\"fullscreen-change\"].bind(this)).add(\"fullscreen-error\", this[\"fullscreen-error\"].bind(this)).add(\"orientation-change\", this[\"orientation-change\"].bind(this));\n  }\n  onConnect(el) {\n    effect(this.#watchCanSetVolume.bind(this));\n    this.#addTextTrackListeners();\n    this.#addQualityListeners();\n    this.#addAudioTrackListeners();\n    this.#resumePlaybackOnConnect();\n    onDispose(this.#pausePlaybackOnDisconnect.bind(this));\n  }\n  onDestroy() {\n    const { audioTracks, qualities, textTracks } = this.#media;\n    audioTracks[ListSymbol.reset]();\n    qualities[ListSymbol.reset]();\n    textTracks[ListSymbol.reset]();\n    this.#stopWatchingQualityResize();\n  }\n  handle(event) {\n    if (!this.scope) return;\n    const type = event.type;\n    untrack(() => this[event.type]?.(event));\n    {\n      if (TRACKED_EVENT.has(type)) this.#trackedEvents.set(type, event);\n      this.dispatch(event);\n    }\n  }\n  #isPlayingOnDisconnect = false;\n  #resumePlaybackOnConnect() {\n    if (!this.#isPlayingOnDisconnect) return;\n    requestAnimationFrame(() => {\n      if (!this.scope) return;\n      this.#media.remote.play(new DOMEvent(\"dom-connect\"));\n    });\n    this.#isPlayingOnDisconnect = false;\n  }\n  #pausePlaybackOnDisconnect() {\n    if (this.#isPlayingOnDisconnect) return;\n    this.#isPlayingOnDisconnect = !this.$state.paused();\n    this.#media.$provider()?.pause();\n  }\n  #resetTracking() {\n    this.#stopWaiting();\n    this.#clipEnded = false;\n    this.#request.replaying = false;\n    this.#request.looping = false;\n    this.#firingWaiting = false;\n    this.#waitingTrigger = void 0;\n    this.#trackedEvents.clear();\n  }\n  #satisfyRequest(request, event) {\n    const requestEvent = this.#request.queue.serve(request);\n    if (!requestEvent) return;\n    event.request = requestEvent;\n    event.triggers.add(requestEvent);\n  }\n  #addTextTrackListeners() {\n    this.#onTextTracksChange();\n    this.#onTextTrackModeChange();\n    const textTracks = this.#media.textTracks;\n    new EventsController(textTracks).add(\"add\", this.#onTextTracksChange.bind(this)).add(\"remove\", this.#onTextTracksChange.bind(this)).add(\"mode-change\", this.#onTextTrackModeChange.bind(this));\n  }\n  #addQualityListeners() {\n    const qualities = this.#media.qualities;\n    new EventsController(qualities).add(\"add\", this.#onQualitiesChange.bind(this)).add(\"remove\", this.#onQualitiesChange.bind(this)).add(\"change\", this.#onQualityChange.bind(this)).add(\"auto-change\", this.#onAutoQualityChange.bind(this)).add(\"readonly-change\", this.#onCanSetQualityChange.bind(this));\n  }\n  #addAudioTrackListeners() {\n    const audioTracks = this.#media.audioTracks;\n    new EventsController(audioTracks).add(\"add\", this.#onAudioTracksChange.bind(this)).add(\"remove\", this.#onAudioTracksChange.bind(this)).add(\"change\", this.#onAudioTrackChange.bind(this));\n  }\n  #onTextTracksChange(event) {\n    const { textTracks } = this.$state;\n    textTracks.set(this.#media.textTracks.toArray());\n    this.dispatch(\"text-tracks-change\", {\n      detail: textTracks(),\n      trigger: event\n    });\n  }\n  #onTextTrackModeChange(event) {\n    if (event) this.#satisfyRequest(\"media-text-track-change-request\", event);\n    const current = this.#media.textTracks.selected, { textTrack } = this.$state;\n    if (textTrack() !== current) {\n      textTrack.set(current);\n      this.dispatch(\"text-track-change\", {\n        detail: current,\n        trigger: event\n      });\n    }\n  }\n  #onAudioTracksChange(event) {\n    const { audioTracks } = this.$state;\n    audioTracks.set(this.#media.audioTracks.toArray());\n    this.dispatch(\"audio-tracks-change\", {\n      detail: audioTracks(),\n      trigger: event\n    });\n  }\n  #onAudioTrackChange(event) {\n    const { audioTrack } = this.$state;\n    audioTrack.set(this.#media.audioTracks.selected);\n    if (event) this.#satisfyRequest(\"media-audio-track-change-request\", event);\n    this.dispatch(\"audio-track-change\", {\n      detail: audioTrack(),\n      trigger: event\n    });\n  }\n  #onQualitiesChange(event) {\n    const { qualities } = this.$state;\n    qualities.set(this.#media.qualities.toArray());\n    this.dispatch(\"qualities-change\", {\n      detail: qualities(),\n      trigger: event\n    });\n  }\n  #onQualityChange(event) {\n    const { quality } = this.$state;\n    quality.set(this.#media.qualities.selected);\n    if (event) this.#satisfyRequest(\"media-quality-change-request\", event);\n    this.dispatch(\"quality-change\", {\n      detail: quality(),\n      trigger: event\n    });\n  }\n  #onAutoQualityChange() {\n    const { qualities } = this.#media, isAuto = qualities.auto;\n    this.$state.autoQuality.set(isAuto);\n    if (!isAuto) this.#stopWatchingQualityResize();\n  }\n  #stopQualityResizeEffect = null;\n  #watchQualityResize() {\n    this.#stopWatchingQualityResize();\n    this.#stopQualityResizeEffect = effect(() => {\n      const { qualities } = this.#media, { mediaWidth, mediaHeight } = this.$state, w = mediaWidth(), h = mediaHeight();\n      if (w === 0 || h === 0) return;\n      let selectedQuality = null, minScore = Infinity;\n      for (const quality of qualities) {\n        const score = Math.abs(quality.width - w) + Math.abs(quality.height - h);\n        if (score < minScore) {\n          minScore = score;\n          selectedQuality = quality;\n        }\n      }\n      if (selectedQuality) {\n        qualities[ListSymbol.select](\n          selectedQuality,\n          true,\n          new DOMEvent(\"resize\", { detail: { width: w, height: h } })\n        );\n      }\n    });\n  }\n  #stopWatchingQualityResize() {\n    this.#stopQualityResizeEffect?.();\n    this.#stopQualityResizeEffect = null;\n  }\n  #onCanSetQualityChange() {\n    this.$state.canSetQuality.set(!this.#media.qualities.readonly);\n  }\n  #watchCanSetVolume() {\n    const { canSetVolume, isGoogleCastConnected } = this.$state;\n    if (isGoogleCastConnected()) {\n      canSetVolume.set(false);\n      return;\n    }\n    canChangeVolume().then(canSetVolume.set);\n  }\n  [\"provider-change\"](event) {\n    const prevProvider = this.#media.$provider(), newProvider = event.detail;\n    if (prevProvider?.type === newProvider?.type) return;\n    prevProvider?.destroy?.();\n    prevProvider?.scope?.dispose();\n    this.#media.$provider.set(event.detail);\n    if (prevProvider && event.detail === null) {\n      this.#resetMediaState(event);\n    }\n  }\n  [\"provider-loader-change\"](event) {\n    {\n      this.#media.logger?.infoGroup(`Loader change \\`${event.detail?.constructor.name}\\``).labelledLog(\"Event\", event).dispatch();\n    }\n  }\n  [\"auto-play\"](event) {\n    this.$state.autoPlayError.set(null);\n  }\n  [\"auto-play-fail\"](event) {\n    this.$state.autoPlayError.set(event.detail);\n    this.#resetTracking();\n  }\n  [\"can-load\"](event) {\n    this.$state.canLoad.set(true);\n    this.#trackedEvents.set(\"can-load\", event);\n    this.#media.textTracks[TextTrackSymbol.canLoad]();\n    this.#satisfyRequest(\"media-start-loading\", event);\n  }\n  [\"can-load-poster\"](event) {\n    this.$state.canLoadPoster.set(true);\n    this.#trackedEvents.set(\"can-load-poster\", event);\n    this.#satisfyRequest(\"media-poster-start-loading\", event);\n  }\n  [\"media-type-change\"](event) {\n    const sourceChangeEvent = this.#trackedEvents.get(\"source-change\");\n    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);\n    const viewType = this.$state.viewType();\n    this.$state.mediaType.set(event.detail);\n    const providedViewType = this.$state.providedViewType(), currentViewType = providedViewType === \"unknown\" ? event.detail : providedViewType;\n    if (viewType !== currentViewType) {\n      {\n        setTimeout(() => {\n          requestAnimationFrame(() => {\n            if (!this.scope) return;\n            this.$state.inferredViewType.set(event.detail);\n            this.dispatch(\"view-type-change\", {\n              detail: currentViewType,\n              trigger: event\n            });\n          });\n        }, 0);\n      }\n    }\n  }\n  [\"stream-type-change\"](event) {\n    const sourceChangeEvent = this.#trackedEvents.get(\"source-change\");\n    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);\n    const { streamType, inferredStreamType } = this.$state;\n    inferredStreamType.set(event.detail);\n    event.detail = streamType();\n  }\n  [\"rate-change\"](event) {\n    const { storage } = this.#media, { canPlay } = this.$state;\n    this.$state.playbackRate.set(event.detail);\n    this.#satisfyRequest(\"media-rate-change-request\", event);\n    if (canPlay()) {\n      storage?.setPlaybackRate?.(event.detail);\n    }\n  }\n  [\"remote-playback-change\"](event) {\n    const { remotePlaybackState, remotePlaybackType } = this.$state, { type, state } = event.detail, isConnected = state === \"connected\";\n    remotePlaybackType.set(type);\n    remotePlaybackState.set(state);\n    const key = type === \"airplay\" ? \"media-airplay-request\" : \"media-google-cast-request\";\n    if (isConnected) {\n      this.#satisfyRequest(key, event);\n    } else {\n      const requestEvent = this.#request.queue.peek(key);\n      if (requestEvent) {\n        event.request = requestEvent;\n        event.triggers.add(requestEvent);\n      }\n    }\n  }\n  [\"sources-change\"](event) {\n    const prevSources = this.$state.sources(), newSources = event.detail;\n    this.$state.sources.set(newSources);\n    this.#onSourceQualitiesChange(prevSources, newSources, event);\n  }\n  #onSourceQualitiesChange(prevSources, newSources, trigger) {\n    let { qualities } = this.#media, added = false, removed = false;\n    for (const prevSrc of prevSources) {\n      if (!isVideoQualitySrc(prevSrc)) continue;\n      const exists = newSources.some((s) => s.src === prevSrc.src);\n      if (!exists) {\n        const quality = qualities.getBySrc(prevSrc.src);\n        if (quality) {\n          qualities[ListSymbol.remove](quality, trigger);\n          removed = true;\n        }\n      }\n    }\n    if (removed && !qualities.length) {\n      this.$state.savedState.set(null);\n      qualities[ListSymbol.reset](trigger);\n    }\n    for (const src of newSources) {\n      if (!isVideoQualitySrc(src) || qualities.getBySrc(src.src)) continue;\n      const quality = {\n        id: src.id ?? src.height + \"p\",\n        bitrate: null,\n        codec: null,\n        ...src,\n        selected: false\n      };\n      qualities[ListSymbol.add](quality, trigger);\n      added = true;\n    }\n    if (added && !qualities[QualitySymbol.enableAuto]) {\n      this.#watchQualityResize();\n      qualities[QualitySymbol.enableAuto] = this.#watchQualityResize.bind(this);\n      qualities[QualitySymbol.setAuto](true, trigger);\n    }\n  }\n  [\"source-change\"](event) {\n    event.isQualityChange = event.originEvent?.type === \"quality-change\";\n    const source = event.detail;\n    this.#resetMediaState(event, event.isQualityChange);\n    this.#trackedEvents.set(event.type, event);\n    this.$state.source.set(source);\n    this.el?.setAttribute(\"aria-busy\", \"true\");\n    {\n      this.#media.logger?.infoGroup(\"\\u{1F4FC} Media source change\").labelledLog(\"Source\", source).dispatch();\n    }\n  }\n  #resetMediaState(event, isSourceQualityChange = false) {\n    const { audioTracks, qualities } = this.#media;\n    if (!isSourceQualityChange) {\n      this.#playedIntervals = [];\n      this.#playedInterval = [-1, -1];\n      audioTracks[ListSymbol.reset](event);\n      qualities[ListSymbol.reset](event);\n      softResetMediaState(this.$state, isSourceQualityChange);\n      this.#resetTracking();\n      return;\n    }\n    softResetMediaState(this.$state, isSourceQualityChange);\n    this.#resetTracking();\n  }\n  [\"abort\"](event) {\n    const sourceChangeEvent = this.#trackedEvents.get(\"source-change\");\n    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);\n    const canLoadEvent = this.#trackedEvents.get(\"can-load\");\n    if (canLoadEvent && !event.triggers.hasType(\"can-load\")) {\n      event.triggers.add(canLoadEvent);\n    }\n  }\n  [\"load-start\"](event) {\n    const sourceChangeEvent = this.#trackedEvents.get(\"source-change\");\n    if (sourceChangeEvent) event.triggers.add(sourceChangeEvent);\n  }\n  [\"error\"](event) {\n    this.$state.error.set(event.detail);\n    const abortEvent = this.#trackedEvents.get(\"abort\");\n    if (abortEvent) event.triggers.add(abortEvent);\n    {\n      this.#media.logger?.errorGroup(\"Media Error\").labelledLog(\"Error\", event.detail).labelledLog(\"Event\", event).labelledLog(\"Context\", this.#media).dispatch();\n    }\n  }\n  [\"loaded-metadata\"](event) {\n    const loadStartEvent = this.#trackedEvents.get(\"load-start\");\n    if (loadStartEvent) event.triggers.add(loadStartEvent);\n  }\n  [\"loaded-data\"](event) {\n    const loadStartEvent = this.#trackedEvents.get(\"load-start\");\n    if (loadStartEvent) event.triggers.add(loadStartEvent);\n  }\n  [\"can-play\"](event) {\n    const loadedMetadata = this.#trackedEvents.get(\"loaded-metadata\");\n    if (loadedMetadata) event.triggers.add(loadedMetadata);\n    this.#onCanPlayDetail(event.detail);\n    this.el?.setAttribute(\"aria-busy\", \"false\");\n  }\n  [\"can-play-through\"](event) {\n    this.#onCanPlayDetail(event.detail);\n    const canPlay = this.#trackedEvents.get(\"can-play\");\n    if (canPlay) event.triggers.add(canPlay);\n  }\n  #onCanPlayDetail(detail) {\n    const { seekable, buffered, intrinsicDuration, canPlay } = this.$state;\n    canPlay.set(true);\n    buffered.set(detail.buffered);\n    seekable.set(detail.seekable);\n    const seekableEnd = getTimeRangesEnd(detail.seekable) ?? Infinity;\n    intrinsicDuration.set(seekableEnd);\n  }\n  [\"duration-change\"](event) {\n    const { live, intrinsicDuration, providedDuration, clipEndTime, ended } = this.$state, time = event.detail;\n    if (!live()) {\n      const duration = !Number.isNaN(time) ? time : 0;\n      intrinsicDuration.set(duration);\n      if (ended()) this.#onEndPrecisionChange(event);\n    }\n    if (providedDuration() > 0 || clipEndTime() > 0) {\n      event.stopImmediatePropagation();\n    }\n  }\n  [\"progress\"](event) {\n    const { buffered, bufferedEnd, seekable, seekableEnd, live, intrinsicDuration } = this.$state, { buffered: newBuffered, seekable: newSeekable } = event.detail, newBufferedEnd = getTimeRangesEnd(newBuffered) ?? Infinity, hasBufferedLengthChanged = newBuffered.length !== buffered().length, hasBufferedEndChanged = newBufferedEnd > bufferedEnd(), newSeekableEnd = getTimeRangesEnd(newSeekable) ?? Infinity, hasSeekableLengthChanged = newSeekable.length !== seekable().length, hasSeekableEndChanged = newSeekableEnd > seekableEnd();\n    if (hasBufferedLengthChanged || hasBufferedEndChanged) {\n      buffered.set(newBuffered);\n    }\n    if (hasSeekableLengthChanged || hasSeekableEndChanged) {\n      seekable.set(newSeekable);\n    }\n    if (live()) {\n      intrinsicDuration.set(newSeekableEnd);\n      this.dispatch(\"duration-change\", {\n        detail: newSeekableEnd,\n        trigger: event\n      });\n    }\n  }\n  [\"play\"](event) {\n    const {\n      paused,\n      autoPlayError,\n      ended,\n      autoPlaying,\n      playsInline,\n      pointer,\n      muted,\n      viewType,\n      live,\n      userBehindLiveEdge\n    } = this.$state;\n    this.#resetPlaybackIfNeeded();\n    if (!paused()) {\n      event.stopImmediatePropagation();\n      return;\n    }\n    event.autoPlay = autoPlaying();\n    const waitingEvent = this.#trackedEvents.get(\"waiting\");\n    if (waitingEvent) event.triggers.add(waitingEvent);\n    this.#satisfyRequest(\"media-play-request\", event);\n    this.#trackedEvents.set(\"play\", event);\n    paused.set(false);\n    autoPlayError.set(null);\n    if (event.autoPlay) {\n      this.handle(\n        this.createEvent(\"auto-play\", {\n          detail: { muted: muted() },\n          trigger: event\n        })\n      );\n      autoPlaying.set(false);\n    }\n    if (ended() || this.#request.replaying) {\n      this.#request.replaying = false;\n      ended.set(false);\n      this.handle(this.createEvent(\"replay\", { trigger: event }));\n    }\n    if (!playsInline() && viewType() === \"video\" && pointer() === \"coarse\") {\n      this.#media.remote.enterFullscreen(\"prefer-media\", event);\n    }\n    if (live() && !userBehindLiveEdge()) {\n      this.#media.remote.seekToLiveEdge(event);\n    }\n  }\n  #resetPlaybackIfNeeded(trigger) {\n    const provider = peek(this.#media.$provider);\n    if (!provider) return;\n    const {\n      ended,\n      seekableStart,\n      clipStartTime,\n      clipEndTime,\n      currentTime,\n      realCurrentTime,\n      duration\n    } = this.$state;\n    const shouldReset = ended() || realCurrentTime() < clipStartTime() || clipEndTime() > 0 && realCurrentTime() >= clipEndTime() || Math.abs(currentTime() - duration()) < 0.1;\n    if (shouldReset) {\n      this.dispatch(\"media-seek-request\", {\n        detail: seekableStart(),\n        trigger\n      });\n    }\n    return shouldReset;\n  }\n  [\"play-fail\"](event) {\n    const { muted, autoPlaying } = this.$state;\n    const playEvent = this.#trackedEvents.get(\"play\");\n    if (playEvent) event.triggers.add(playEvent);\n    this.#satisfyRequest(\"media-play-request\", event);\n    const { paused, playing } = this.$state;\n    paused.set(true);\n    playing.set(false);\n    this.#resetTracking();\n    this.#trackedEvents.set(\"play-fail\", event);\n    if (event.autoPlay) {\n      this.handle(\n        this.createEvent(\"auto-play-fail\", {\n          detail: {\n            muted: muted(),\n            error: event.detail\n          },\n          trigger: event\n        })\n      );\n      autoPlaying.set(false);\n    }\n  }\n  [\"playing\"](event) {\n    const playEvent = this.#trackedEvents.get(\"play\"), seekedEvent = this.#trackedEvents.get(\"seeked\");\n    if (playEvent) event.triggers.add(playEvent);\n    else if (seekedEvent) event.triggers.add(seekedEvent);\n    setTimeout(() => this.#resetTracking(), 0);\n    const {\n      paused,\n      playing,\n      live,\n      liveSyncPosition,\n      seekableEnd,\n      started,\n      currentTime,\n      seeking,\n      ended\n    } = this.$state;\n    paused.set(false);\n    playing.set(true);\n    seeking.set(false);\n    ended.set(false);\n    if (this.#request.looping) {\n      this.#request.looping = false;\n      return;\n    }\n    if (live() && !started() && currentTime() === 0) {\n      const end = liveSyncPosition() ?? seekableEnd() - 2;\n      if (Number.isFinite(end)) this.#media.$provider().setCurrentTime(end);\n    }\n    this[\"started\"](event);\n  }\n  [\"started\"](event) {\n    const { started } = this.$state;\n    if (!started()) {\n      started.set(true);\n      this.handle(this.createEvent(\"started\", { trigger: event }));\n    }\n  }\n  [\"pause\"](event) {\n    if (!this.el?.isConnected) {\n      this.#isPlayingOnDisconnect = true;\n    }\n    this.#satisfyRequest(\"media-pause-request\", event);\n    const seekedEvent = this.#trackedEvents.get(\"seeked\");\n    if (seekedEvent) event.triggers.add(seekedEvent);\n    const { paused, playing } = this.$state;\n    paused.set(true);\n    playing.set(false);\n    if (this.#clipEnded) {\n      setTimeout(() => {\n        this.handle(this.createEvent(\"end\", { trigger: event }));\n        this.#clipEnded = false;\n      }, 0);\n    }\n    this.#resetTracking();\n  }\n  [\"time-change\"](event) {\n    if (this.#request.looping) {\n      event.stopImmediatePropagation();\n      return;\n    }\n    let { waiting, played, clipEndTime, realCurrentTime, currentTime } = this.$state, newTime = event.detail, endTime = clipEndTime();\n    realCurrentTime.set(newTime);\n    this.#updatePlayed();\n    waiting.set(false);\n    for (const track of this.#media.textTracks) {\n      track[TextTrackSymbol.updateActiveCues](newTime, event);\n    }\n    if (endTime > 0 && newTime >= endTime) {\n      this.#clipEnded = true;\n      this.dispatch(\"media-pause-request\", { trigger: event });\n    }\n    this.#saveTime();\n    this.dispatch(\"time-update\", {\n      detail: { currentTime: currentTime(), played: played() },\n      trigger: event\n    });\n  }\n  #updatePlayed() {\n    const { currentTime, played, paused } = this.$state;\n    if (paused()) return;\n    this.#playedInterval = updateTimeIntervals(\n      this.#playedIntervals,\n      this.#playedInterval,\n      currentTime()\n    );\n    played.set(new TimeRange(this.#playedIntervals));\n  }\n  // Called to update time again incase duration precision has changed.\n  #onEndPrecisionChange(trigger) {\n    const { clipStartTime, clipEndTime, duration } = this.$state, isClipped = clipStartTime() > 0 || clipEndTime() > 0;\n    if (isClipped) return;\n    this.handle(\n      this.createEvent(\"time-change\", {\n        detail: duration(),\n        trigger\n      })\n    );\n  }\n  #saveTime() {\n    const { storage } = this.#media, { canPlay, realCurrentTime } = this.$state;\n    if (canPlay()) {\n      storage?.setTime?.(realCurrentTime());\n    }\n  }\n  [\"audio-gain-change\"](event) {\n    const { storage } = this.#media, { canPlay, audioGain } = this.$state;\n    audioGain.set(event.detail);\n    this.#satisfyRequest(\"media-audio-gain-change-request\", event);\n    if (canPlay()) storage?.setAudioGain?.(audioGain());\n  }\n  [\"volume-change\"](event) {\n    const { storage } = this.#media, { volume, muted, canPlay } = this.$state, detail = event.detail;\n    volume.set(detail.volume);\n    muted.set(detail.muted || detail.volume === 0);\n    this.#satisfyRequest(\"media-volume-change-request\", event);\n    this.#satisfyRequest(detail.muted ? \"media-mute-request\" : \"media-unmute-request\", event);\n    if (canPlay()) {\n      storage?.setVolume?.(volume());\n      storage?.setMuted?.(muted());\n    }\n  }\n  [\"seeking\"] = functionThrottle(\n    (event) => {\n      const { seeking, realCurrentTime, paused } = this.$state;\n      seeking.set(true);\n      realCurrentTime.set(event.detail);\n      this.#satisfyRequest(\"media-seeking-request\", event);\n      if (paused()) {\n        this.#waitingTrigger = event;\n        this.#fireWaiting();\n      }\n      this.#playedInterval = [-1, -1];\n    },\n    150,\n    { leading: true }\n  );\n  [\"seeked\"](event) {\n    const { seeking, currentTime, realCurrentTime, paused, seekableEnd, ended } = this.$state;\n    if (this.#request.seeking) {\n      seeking.set(true);\n      event.stopImmediatePropagation();\n    } else if (seeking()) {\n      const waitingEvent = this.#trackedEvents.get(\"waiting\");\n      if (waitingEvent) event.triggers.add(waitingEvent);\n      const seekingEvent = this.#trackedEvents.get(\"seeking\");\n      if (seekingEvent && !event.triggers.has(seekingEvent)) {\n        event.triggers.add(seekingEvent);\n      }\n      if (paused()) this.#stopWaiting();\n      seeking.set(false);\n      realCurrentTime.set(event.detail);\n      this.#satisfyRequest(\"media-seek-request\", event);\n      const origin = event?.originEvent;\n      if (origin?.isTrusted && !(origin instanceof MessageEvent) && !/seek/.test(origin.type)) {\n        this[\"started\"](event);\n      }\n    }\n    if (Math.floor(currentTime()) !== Math.floor(seekableEnd())) {\n      ended.set(false);\n    } else {\n      this.end(event);\n    }\n  }\n  [\"waiting\"](event) {\n    if (this.#firingWaiting || this.#request.seeking) return;\n    event.stopImmediatePropagation();\n    this.#waitingTrigger = event;\n    this.#fireWaiting();\n  }\n  #fireWaiting = functionDebounce(() => {\n    if (!this.#waitingTrigger) return;\n    this.#firingWaiting = true;\n    const { waiting, playing } = this.$state;\n    waiting.set(true);\n    playing.set(false);\n    const event = this.createEvent(\"waiting\", { trigger: this.#waitingTrigger });\n    this.#trackedEvents.set(\"waiting\", event);\n    this.dispatch(event);\n    this.#waitingTrigger = void 0;\n    this.#firingWaiting = false;\n  }, 300);\n  [\"end\"](event) {\n    const { loop, ended } = this.$state;\n    if (!loop() && ended()) return;\n    if (loop()) {\n      setTimeout(() => {\n        requestAnimationFrame(() => {\n          this.#resetPlaybackIfNeeded(event);\n          this.dispatch(\"media-loop-request\", { trigger: event });\n        });\n      }, 10);\n      return;\n    }\n    setTimeout(() => this.#onEnded(event), 0);\n  }\n  #onEnded(event) {\n    const { storage } = this.#media, { paused, seeking, ended, duration } = this.$state;\n    this.#onEndPrecisionChange(event);\n    if (!paused()) {\n      this.dispatch(\"pause\", { trigger: event });\n    }\n    if (seeking()) {\n      this.dispatch(\"seeked\", {\n        detail: duration(),\n        trigger: event\n      });\n    }\n    ended.set(true);\n    this.#resetTracking();\n    storage?.setTime?.(duration(), true);\n    this.dispatch(\"ended\", {\n      trigger: event\n    });\n  }\n  #stopWaiting() {\n    this.#fireWaiting.cancel();\n    this.$state.waiting.set(false);\n  }\n  [\"fullscreen-change\"](event) {\n    const isFullscreen = event.detail;\n    this.$state.fullscreen.set(isFullscreen);\n    this.#satisfyRequest(\n      isFullscreen ? \"media-enter-fullscreen-request\" : \"media-exit-fullscreen-request\",\n      event\n    );\n  }\n  [\"fullscreen-error\"](event) {\n    this.#satisfyRequest(\"media-enter-fullscreen-request\", event);\n    this.#satisfyRequest(\"media-exit-fullscreen-request\", event);\n  }\n  [\"orientation-change\"](event) {\n    const isLocked = event.detail.lock;\n    this.#satisfyRequest(\n      isLocked ? \"media-orientation-lock-request\" : \"media-orientation-unlock-request\",\n      event\n    );\n  }\n  [\"picture-in-picture-change\"](event) {\n    const isPiP = event.detail;\n    this.$state.pictureInPicture.set(isPiP);\n    this.#satisfyRequest(isPiP ? \"media-enter-pip-request\" : \"media-exit-pip-request\", event);\n  }\n  [\"picture-in-picture-error\"](event) {\n    this.#satisfyRequest(\"media-enter-pip-request\", event);\n    this.#satisfyRequest(\"media-exit-pip-request\", event);\n  }\n  [\"title-change\"](event) {\n    if (!event.trigger) return;\n    event.stopImmediatePropagation();\n    this.$state.inferredTitle.set(event.detail);\n  }\n  [\"poster-change\"](event) {\n    if (!event.trigger) return;\n    event.stopImmediatePropagation();\n    this.$state.inferredPoster.set(event.detail);\n  }\n}\n\nclass MediaStateSync extends MediaPlayerController {\n  onSetup() {\n    this.#init();\n    effect(this.#watchLogLevel.bind(this));\n    const effects = [\n      this.#watchMetadata,\n      this.#watchAutoplay,\n      this.#watchClipStartTime,\n      this.#watchClipEndTime,\n      this.#watchControls,\n      this.#watchCrossOrigin,\n      this.#watchDuration,\n      this.#watchLive,\n      this.#watchLiveEdge,\n      this.#watchLiveTolerance,\n      this.#watchLoop,\n      this.#watchPlaysInline,\n      this.#watchPoster,\n      this.#watchProvidedTypes,\n      this.#watchTitle\n    ];\n    for (const callback of effects) {\n      effect(callback.bind(this));\n    }\n  }\n  #init() {\n    const providedProps = {\n      duration: \"providedDuration\",\n      loop: \"providedLoop\",\n      poster: \"providedPoster\",\n      streamType: \"providedStreamType\",\n      title: \"providedTitle\",\n      viewType: \"providedViewType\"\n    };\n    const skip = /* @__PURE__ */ new Set([\n      \"currentTime\",\n      \"paused\",\n      \"playbackRate\",\n      \"volume\"\n    ]);\n    for (const prop of Object.keys(this.$props)) {\n      if (skip.has(prop)) continue;\n      this.$state[providedProps[prop] ?? prop]?.set(this.$props[prop]());\n    }\n    this.$state.muted.set(this.$props.muted() || this.$props.volume() === 0);\n  }\n  // Sync \"provided\" props with internal state. Provided props are used to differentiate from\n  // provider inferred values.\n  #watchProvidedTypes() {\n    const { viewType, streamType, title, poster, loop } = this.$props, $state = this.$state;\n    $state.providedPoster.set(poster());\n    $state.providedStreamType.set(streamType());\n    $state.providedViewType.set(viewType());\n    $state.providedTitle.set(title());\n    $state.providedLoop.set(loop());\n  }\n  #watchLogLevel() {\n    this.$state.logLevel.set(this.$props.logLevel());\n  }\n  #watchMetadata() {\n    const { artist, artwork } = this.$props;\n    this.$state.artist.set(artist());\n    this.$state.artwork.set(artwork());\n  }\n  #watchTitle() {\n    const { title } = this.$state;\n    this.dispatch(\"title-change\", { detail: title() });\n  }\n  #watchAutoplay() {\n    const autoPlay = this.$props.autoPlay() || this.$props.autoplay();\n    this.$state.autoPlay.set(autoPlay);\n    this.dispatch(\"auto-play-change\", { detail: autoPlay });\n  }\n  #watchLoop() {\n    const loop = this.$state.loop();\n    this.dispatch(\"loop-change\", { detail: loop });\n  }\n  #watchControls() {\n    const controls = this.$props.controls();\n    this.$state.controls.set(controls);\n  }\n  #watchPoster() {\n    const { poster } = this.$state;\n    this.dispatch(\"poster-change\", { detail: poster() });\n  }\n  #watchCrossOrigin() {\n    const crossOrigin = this.$props.crossOrigin() ?? this.$props.crossorigin(), value = crossOrigin === true ? \"\" : crossOrigin;\n    this.$state.crossOrigin.set(value);\n  }\n  #watchDuration() {\n    const { duration } = this.$props;\n    this.dispatch(\"media-duration-change-request\", {\n      detail: duration()\n    });\n  }\n  #watchPlaysInline() {\n    const inline = this.$props.playsInline() || this.$props.playsinline();\n    this.$state.playsInline.set(inline);\n    this.dispatch(\"plays-inline-change\", { detail: inline });\n  }\n  #watchClipStartTime() {\n    const { clipStartTime } = this.$props;\n    this.dispatch(\"media-clip-start-change-request\", {\n      detail: clipStartTime()\n    });\n  }\n  #watchClipEndTime() {\n    const { clipEndTime } = this.$props;\n    this.dispatch(\"media-clip-end-change-request\", {\n      detail: clipEndTime()\n    });\n  }\n  #watchLive() {\n    this.dispatch(\"live-change\", { detail: this.$state.live() });\n  }\n  #watchLiveTolerance() {\n    this.$state.liveEdgeTolerance.set(this.$props.liveEdgeTolerance());\n    this.$state.minLiveDVRWindow.set(this.$props.minLiveDVRWindow());\n  }\n  #watchLiveEdge() {\n    this.dispatch(\"live-edge-change\", { detail: this.$state.liveEdge() });\n  }\n}\n\nconst actions = [\"play\", \"pause\", \"seekforward\", \"seekbackward\", \"seekto\"];\nclass NavigatorMediaSession extends MediaPlayerController {\n  onConnect() {\n    effect(this.#onMetadataChange.bind(this));\n    effect(this.#onPlaybackStateChange.bind(this));\n    const handleAction = this.#handleAction.bind(this);\n    for (const action of actions) {\n      navigator.mediaSession.setActionHandler(action, handleAction);\n    }\n    onDispose(this.#onDisconnect.bind(this));\n  }\n  #onDisconnect() {\n    for (const action of actions) {\n      navigator.mediaSession.setActionHandler(action, null);\n    }\n  }\n  #onMetadataChange() {\n    const { title, artist, artwork, poster } = this.$state;\n    navigator.mediaSession.metadata = new MediaMetadata({\n      title: title(),\n      artist: artist(),\n      artwork: artwork() ?? [{ src: poster() }]\n    });\n  }\n  #onPlaybackStateChange() {\n    const { canPlay, paused } = this.$state;\n    navigator.mediaSession.playbackState = !canPlay() ? \"none\" : paused() ? \"paused\" : \"playing\";\n  }\n  #handleAction(details) {\n    const trigger = new DOMEvent(`media-session-action`, { detail: details });\n    switch (details.action) {\n      case \"play\":\n        this.dispatch(\"media-play-request\", { trigger });\n        break;\n      case \"pause\":\n        this.dispatch(\"media-pause-request\", { trigger });\n        break;\n      case \"seekto\":\n      case \"seekforward\":\n      case \"seekbackward\":\n        this.dispatch(\"media-seek-request\", {\n          detail: isNumber(details.seekTime) ? details.seekTime : this.$state.currentTime() + (details.seekOffset ?? (details.action === \"seekforward\" ? 10 : -10)),\n          trigger\n        });\n        break;\n    }\n  }\n}\n\nconst LOCAL_STORAGE_KEY = \"@vidstack/log-colors\";\nconst savedColors = init();\nfunction getLogColor(key) {\n  return savedColors.get(key);\n}\nfunction saveLogColor(key, { color = generateColor(), overwrite = false } = {}) {\n  if (!savedColors.has(key) || overwrite) {\n    savedColors.set(key, color);\n    localStorage.setItem(LOCAL_STORAGE_KEY, JSON.stringify(Object.entries(savedColors)));\n  }\n}\nfunction generateColor() {\n  return `hsl(${Math.random() * 360}, 55%, 70%)`;\n}\nfunction init() {\n  let colors;\n  try {\n    colors = JSON.parse(localStorage.getItem(LOCAL_STORAGE_KEY));\n  } catch {\n  }\n  return new Map(Object.entries(colors ?? {}));\n}\n\nconst LogLevelValue = Object.freeze({\n  silent: 0,\n  error: 1,\n  warn: 2,\n  info: 3,\n  debug: 4\n});\nconst LogLevelColor = Object.freeze({\n  silent: \"white\",\n  error: \"hsl(6, 58%, 50%)\",\n  warn: \"hsl(51, 58%, 50%)\",\n  info: \"hsl(219, 58%, 50%)\",\n  debug: \"hsl(280, 58%, 50%)\"\n});\n\nconst s = 1e3;\nconst m = s * 60;\nconst h = m * 60;\nconst d = h * 24;\nfunction ms(val) {\n  const msAbs = Math.abs(val);\n  if (msAbs >= d) {\n    return Math.round(val / d) + \"d\";\n  }\n  if (msAbs >= h) {\n    return Math.round(val / h) + \"h\";\n  }\n  if (msAbs >= m) {\n    return Math.round(val / m) + \"m\";\n  }\n  if (msAbs >= s) {\n    return Math.round(val / s) + \"s\";\n  }\n  return round(val, 2) + \"ms\";\n}\n\nclass LogPrinter extends ViewController {\n  #level = \"warn\" ;\n  #lastLogged;\n  /**\n   * The current log level.\n   */\n  get logLevel() {\n    return this.#level ;\n  }\n  set logLevel(level) {\n    this.#level = level;\n  }\n  onConnect() {\n    this.listen(\"vds-log\", (event) => {\n      event.stopPropagation();\n      const element = event.path?.[0] ?? (event.target instanceof ViewController ? event.target.el : event.target), eventTargetName = element?.$$COMPONENT_NAME?.replace(/^_/, \"\").replace(/Instance$/, \"\") ?? element?.tagName.toLowerCase() ?? \"unknown\";\n      const { level = \"warn\", data } = event.detail ?? {};\n      if (LogLevelValue[this.#level] < LogLevelValue[level]) {\n        return;\n      }\n      saveLogColor(eventTargetName);\n      const hint = data?.length === 1 && isGroupedLog(data[0]) ? data[0].title : isString(data?.[0]) ? data[0] : \"\";\n      console.groupCollapsed(\n        `%c${level.toUpperCase()}%c ${eventTargetName}%c ${hint.slice(0, 50)}${hint.length > 50 ? \"...\" : \"\"}`,\n        `background: ${LogLevelColor[level]}; color: white; padding: 1.5px 2.2px; border-radius: 2px; font-size: 11px;`,\n        `color: ${getLogColor(eventTargetName)}; padding: 4px 0px; font-size: 11px;`,\n        \"color: gray; font-size: 11px; padding-left: 4px;\"\n      );\n      if (data?.length === 1 && isGroupedLog(data[0])) {\n        if (element) data[0].logs.unshift({ label: \"Element\", data: [element] });\n        printGroup(level, data[0]);\n      } else if (data) {\n        print(level, ...data);\n      }\n      this.#printTimeDiff();\n      printStackTrace();\n      console.groupEnd();\n    });\n    onDispose(() => {\n      this.#lastLogged = void 0;\n    });\n  }\n  #printTimeDiff() {\n    labelledPrint(\"Time since last log\", this.#calcLastLogTimeDiff());\n  }\n  #calcLastLogTimeDiff() {\n    const time = performance.now();\n    const diff = time - (this.#lastLogged ?? (this.#lastLogged = performance.now()));\n    this.#lastLogged = time;\n    return ms(diff);\n  }\n}\nfunction print(level, ...data) {\n  console[level](...data);\n}\nfunction labelledPrint(label, ...data) {\n  console.log(`%c${label}:`, \"color: gray\", ...data);\n}\nfunction printStackTrace() {\n  console.groupCollapsed(\"%cStack Trace\", \"color: gray\");\n  console.trace();\n  console.groupEnd();\n}\nfunction printGroup(level, groupedLog) {\n  for (const log of groupedLog.logs) {\n    if (isGroupedLog(log)) {\n      console.groupCollapsed(groupedLog.title);\n      printGroup(level, log);\n      console.groupEnd();\n    } else if (\"label\" in log && !isUndefined(log.label)) {\n      labelledPrint(log.label, ...log.data);\n    } else {\n      print(level, ...log.data);\n    }\n  }\n}\n\nclass MediaPlayer extends Component {\n  static props = mediaPlayerProps;\n  static state = mediaState;\n  #media;\n  #stateMgr;\n  #requestMgr;\n  canPlayQueue = new RequestQueue();\n  remoteControl;\n  get #provider() {\n    return this.#media.$provider();\n  }\n  get #props() {\n    return this.$props;\n  }\n  constructor() {\n    super();\n    new MediaStateSync();\n    const context = {\n      player: this,\n      qualities: new VideoQualityList(),\n      audioTracks: new AudioTrackList(),\n      storage: null,\n      $provider: signal(null),\n      $providerSetup: signal(false),\n      $props: this.$props,\n      $state: this.$state\n    };\n    {\n      const logPrinter = new LogPrinter();\n      effect(() => {\n        logPrinter.logLevel = this.$props.logLevel();\n      });\n    }\n    context.logger = new Logger();\n    context.remote = this.remoteControl = new MediaRemoteControl(\n      context.logger \n    );\n    context.remote.setPlayer(this);\n    context.textTracks = new TextTrackList();\n    context.textTracks[TextTrackSymbol.crossOrigin] = this.$state.crossOrigin;\n    context.textRenderers = new TextRenderers(context);\n    context.ariaKeys = {};\n    this.#media = context;\n    provideContext(mediaContext, context);\n    this.orientation = new ScreenOrientationController();\n    new FocusVisibleController();\n    new MediaKeyboardController(context);\n    new MediaEventsLogger(context);\n    const request = new MediaRequestContext();\n    this.#stateMgr = new MediaStateManager(request, context);\n    this.#requestMgr = new MediaRequestManager(this.#stateMgr, request, context);\n    context.delegate = new MediaPlayerDelegate(this.#stateMgr.handle.bind(this.#stateMgr), context);\n    context.notify = context.delegate.notify.bind(context.delegate);\n    if (typeof navigator !== \"undefined\" && \"mediaSession\" in navigator) {\n      new NavigatorMediaSession();\n    }\n    new MediaLoadController(\"load\", this.startLoading.bind(this));\n    new MediaLoadController(\"posterLoad\", this.startLoadingPoster.bind(this));\n  }\n  onSetup() {\n    this.#setupMediaAttributes();\n    effect(this.#watchCanPlay.bind(this));\n    effect(this.#watchMuted.bind(this));\n    effect(this.#watchPaused.bind(this));\n    effect(this.#watchVolume.bind(this));\n    effect(this.#watchCurrentTime.bind(this));\n    effect(this.#watchPlaysInline.bind(this));\n    effect(this.#watchPlaybackRate.bind(this));\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-player\", \"\");\n    setAttributeIfEmpty(el, \"tabindex\", \"0\");\n    setAttributeIfEmpty(el, \"role\", \"region\");\n    effect(this.#watchStorage.bind(this));\n    effect(this.#watchTitle.bind(this));\n    effect(this.#watchOrientation.bind(this));\n    listenEvent(el, \"find-media-player\", this.#onFindPlayer.bind(this));\n  }\n  onConnect(el) {\n    if (IS_IPHONE) setAttribute(el, \"data-iphone\", \"\");\n    const pointerQuery = window.matchMedia(\"(pointer: coarse)\");\n    this.#onPointerChange(pointerQuery);\n    pointerQuery.onchange = this.#onPointerChange.bind(this);\n    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));\n    resize.observe(el);\n    effect(this.#onResize.bind(this));\n    this.dispatch(\"media-player-connect\", {\n      detail: this,\n      bubbles: true,\n      composed: true\n    });\n    this.#media.logger.setTarget(el);\n    onDispose(() => {\n      resize.disconnect();\n      pointerQuery.onchange = null;\n      this.#media.logger.setTarget(null);\n    });\n  }\n  onDestroy() {\n    this.#media.player = null;\n    this.canPlayQueue.reset();\n  }\n  #skipTitleUpdate = false;\n  #watchTitle() {\n    const el = this.$el, { title, live, viewType, providedTitle } = this.$state, isLive = live(), type = uppercaseFirstChar(viewType()), typeText = type !== \"Unknown\" ? `${isLive ? \"Live \" : \"\"}${type}` : isLive ? \"Live\" : \"Media\", currentTitle = title();\n    setAttribute(\n      this.el,\n      \"aria-label\",\n      `${typeText} Player` + (currentTitle ? ` - ${currentTitle}` : \"\")\n    );\n    if (el?.hasAttribute(\"title\")) {\n      this.#skipTitleUpdate = true;\n      el?.removeAttribute(\"title\");\n    }\n  }\n  #watchOrientation() {\n    const orientation = this.orientation.landscape ? \"landscape\" : \"portrait\";\n    this.$state.orientation.set(orientation);\n    setAttribute(this.el, \"data-orientation\", orientation);\n    this.#onResize();\n  }\n  #watchCanPlay() {\n    if (this.$state.canPlay() && this.#provider) this.canPlayQueue.start();\n    else this.canPlayQueue.stop();\n  }\n  #setupMediaAttributes() {\n    if (MediaPlayer[MEDIA_ATTRIBUTES]) {\n      this.setAttributes(MediaPlayer[MEDIA_ATTRIBUTES]);\n      return;\n    }\n    const $attrs = {\n      \"data-load\": function() {\n        return this.$props.load();\n      },\n      \"data-captions\": function() {\n        const track = this.$state.textTrack();\n        return !!track && isTrackCaptionKind(track);\n      },\n      \"data-ios-controls\": function() {\n        return this.$state.iOSControls();\n      },\n      \"data-controls\": function() {\n        return this.controls.showing;\n      },\n      \"data-buffering\": function() {\n        const { canLoad, canPlay, waiting } = this.$state;\n        return canLoad() && (!canPlay() || waiting());\n      },\n      \"data-error\": function() {\n        const { error } = this.$state;\n        return !!error();\n      },\n      \"data-autoplay-error\": function() {\n        const { autoPlayError } = this.$state;\n        return !!autoPlayError();\n      }\n    };\n    const alias = {\n      autoPlay: \"autoplay\",\n      canAirPlay: \"can-airplay\",\n      canPictureInPicture: \"can-pip\",\n      pictureInPicture: \"pip\",\n      playsInline: \"playsinline\",\n      remotePlaybackState: \"remote-state\",\n      remotePlaybackType: \"remote-type\",\n      isAirPlayConnected: \"airplay\",\n      isGoogleCastConnected: \"google-cast\"\n    };\n    for (const prop2 of mediaAttributes) {\n      const attrName = \"data-\" + (alias[prop2] ?? camelToKebabCase(prop2));\n      $attrs[attrName] = function() {\n        return this.$state[prop2]();\n      };\n    }\n    delete $attrs.title;\n    MediaPlayer[MEDIA_ATTRIBUTES] = $attrs;\n    this.setAttributes($attrs);\n  }\n  #onFindPlayer(event) {\n    event.detail(this);\n  }\n  #onResize() {\n    if (!this.el) return;\n    const width = this.el.clientWidth, height = this.el.clientHeight;\n    this.$state.width.set(width);\n    this.$state.height.set(height);\n    setStyle(this.el, \"--player-width\", width + \"px\");\n    setStyle(this.el, \"--player-height\", height + \"px\");\n  }\n  #onPointerChange(queryList) {\n    const pointer = queryList.matches ? \"coarse\" : \"fine\";\n    setAttribute(this.el, \"data-pointer\", pointer);\n    this.$state.pointer.set(pointer);\n    this.#onResize();\n  }\n  /**\n   * The current media provider.\n   */\n  get provider() {\n    return this.#provider;\n  }\n  /**\n   * Media controls settings.\n   */\n  get controls() {\n    return this.#requestMgr.controls;\n  }\n  set controls(controls) {\n    this.#props.controls.set(controls);\n  }\n  /**\n   * Controls the screen orientation of the current browser window and dispatches orientation\n   * change events on the player.\n   */\n  orientation;\n  /**\n   * The title of the current media.\n   */\n  get title() {\n    return peek(this.$state.title);\n  }\n  set title(newTitle) {\n    if (this.#skipTitleUpdate) {\n      this.#skipTitleUpdate = false;\n      return;\n    }\n    this.#props.title.set(newTitle);\n  }\n  /**\n   * A list of all `VideoQuality` objects representing the set of available video renditions.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/video-quality}\n   */\n  get qualities() {\n    return this.#media.qualities;\n  }\n  /**\n   * A list of all `AudioTrack` objects representing the set of available audio tracks.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/audio-tracks}\n   */\n  get audioTracks() {\n    return this.#media.audioTracks;\n  }\n  /**\n   * A list of all `TextTrack` objects representing the set of available text tracks.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/text-tracks}\n   */\n  get textTracks() {\n    return this.#media.textTracks;\n  }\n  /**\n   * Contains text renderers which are responsible for loading, parsing, and rendering text\n   * tracks.\n   */\n  get textRenderers() {\n    return this.#media.textRenderers;\n  }\n  get duration() {\n    return this.$state.duration();\n  }\n  set duration(duration) {\n    this.#props.duration.set(duration);\n  }\n  get paused() {\n    return peek(this.$state.paused);\n  }\n  set paused(paused) {\n    this.#queuePausedUpdate(paused);\n  }\n  #watchPaused() {\n    this.#queuePausedUpdate(this.$props.paused());\n  }\n  #queuePausedUpdate(paused) {\n    if (paused) {\n      this.canPlayQueue.enqueue(\"paused\", () => this.#requestMgr.pause());\n    } else this.canPlayQueue.enqueue(\"paused\", () => this.#requestMgr.play());\n  }\n  get muted() {\n    return peek(this.$state.muted);\n  }\n  set muted(muted) {\n    this.#queueMutedUpdate(muted);\n  }\n  #watchMuted() {\n    this.#queueMutedUpdate(this.$props.muted());\n  }\n  #queueMutedUpdate(muted) {\n    this.canPlayQueue.enqueue(\"muted\", () => {\n      if (this.#provider) this.#provider.setMuted(muted);\n    });\n  }\n  get currentTime() {\n    return peek(this.$state.currentTime);\n  }\n  set currentTime(time) {\n    this.#queueCurrentTimeUpdate(time);\n  }\n  #watchCurrentTime() {\n    this.#queueCurrentTimeUpdate(this.$props.currentTime());\n  }\n  #queueCurrentTimeUpdate(time) {\n    this.canPlayQueue.enqueue(\"currentTime\", () => {\n      const { currentTime, clipStartTime, seekableStart, seekableEnd } = this.$state;\n      if (time === peek(currentTime)) return;\n      peek(() => {\n        if (!this.#provider) return;\n        const clippedTime = time + clipStartTime(), isStart = Math.floor(time) === Math.floor(seekableStart()), isEnd = Math.floor(clippedTime) === Math.floor(seekableEnd()), boundTime = isStart ? seekableStart() : isEnd ? seekableEnd() : Math.min(Math.max(seekableStart() + 0.1, clippedTime), seekableEnd() - 0.1);\n        if (Number.isFinite(boundTime)) {\n          this.#provider.setCurrentTime(boundTime);\n        }\n      });\n    });\n  }\n  get volume() {\n    return peek(this.$state.volume);\n  }\n  set volume(volume) {\n    this.#queueVolumeUpdate(volume);\n  }\n  #watchVolume() {\n    this.#queueVolumeUpdate(this.$props.volume());\n  }\n  #queueVolumeUpdate(volume) {\n    const clampedVolume = clampNumber(0, volume, 1);\n    this.canPlayQueue.enqueue(\"volume\", () => {\n      if (this.#provider) this.#provider.setVolume(clampedVolume);\n    });\n  }\n  get playbackRate() {\n    return peek(this.$state.playbackRate);\n  }\n  set playbackRate(rate) {\n    this.#queuePlaybackRateUpdate(rate);\n  }\n  #watchPlaybackRate() {\n    this.#queuePlaybackRateUpdate(this.$props.playbackRate());\n  }\n  #queuePlaybackRateUpdate(rate) {\n    this.canPlayQueue.enqueue(\"rate\", () => {\n      if (this.#provider) this.#provider.setPlaybackRate?.(rate);\n    });\n  }\n  #watchPlaysInline() {\n    this.#queuePlaysInlineUpdate(this.$props.playsInline());\n  }\n  #queuePlaysInlineUpdate(inline) {\n    this.canPlayQueue.enqueue(\"playsinline\", () => {\n      if (this.#provider) this.#provider.setPlaysInline?.(inline);\n    });\n  }\n  #watchStorage() {\n    let storageValue = this.$props.storage(), storage = isString(storageValue) ? new LocalMediaStorage() : storageValue;\n    if (storage?.onChange) {\n      const { source } = this.$state, playerId = isString(storageValue) ? storageValue : this.el?.id, mediaId = computed(this.#computeMediaId.bind(this));\n      effect(() => storage.onChange(source(), mediaId(), playerId || void 0));\n    }\n    this.#media.storage = storage;\n    this.#media.textTracks.setStorage(storage);\n    onDispose(() => {\n      storage?.onDestroy?.();\n      this.#media.storage = null;\n      this.#media.textTracks.setStorage(null);\n    });\n  }\n  #computeMediaId() {\n    const { clipStartTime, clipEndTime } = this.$props, { source } = this.$state, src = source();\n    return src.src ? `${src.src}:${clipStartTime()}:${clipEndTime()}` : null;\n  }\n  /**\n   * Begins/resumes playback of the media. If this method is called programmatically before the\n   * user has interacted with the player, the promise may be rejected subject to the browser's\n   * autoplay policies. This method will throw if called before media is ready for playback.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/play}\n   */\n  async play(trigger) {\n    return this.#requestMgr.play(trigger);\n  }\n  /**\n   * Pauses playback of the media. This method will throw if called before media is ready for\n   * playback.\n   *\n   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/pause}\n   */\n  async pause(trigger) {\n    return this.#requestMgr.pause(trigger);\n  }\n  /**\n   * Attempts to display the player in fullscreen. The promise will resolve if successful, and\n   * reject if not. This method will throw if any fullscreen API is _not_ currently available.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/fullscreen}\n   */\n  async enterFullscreen(target, trigger) {\n    return this.#requestMgr.enterFullscreen(target, trigger);\n  }\n  /**\n   * Attempts to display the player inline by exiting fullscreen. This method will throw if any\n   * fullscreen API is _not_ currently available.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/fullscreen}\n   */\n  async exitFullscreen(target, trigger) {\n    return this.#requestMgr.exitFullscreen(target, trigger);\n  }\n  /**\n   * Attempts to display the player in picture-in-picture mode. This method will throw if PIP is\n   * not supported. This method will also return a `PictureInPictureWindow` if the current\n   * provider supports it.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}\n   */\n  enterPictureInPicture(trigger) {\n    return this.#requestMgr.enterPictureInPicture(trigger);\n  }\n  /**\n   * Attempts to display the player in inline by exiting picture-in-picture mode. This method\n   * will throw if not supported.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/picture-in-picture}\n   */\n  exitPictureInPicture(trigger) {\n    return this.#requestMgr.exitPictureInPicture(trigger);\n  }\n  /**\n   * Sets the current time to the live edge (i.e., `duration`). This is a no-op for non-live\n   * streams and will throw if called before media is ready for playback.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/live}\n   */\n  seekToLiveEdge(trigger) {\n    this.#requestMgr.seekToLiveEdge(trigger);\n  }\n  /**\n   * Called when media can begin loading. Calling this method will trigger the initial provider\n   * loading process. Calling it more than once has no effect.\n   *\n   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}\n   */\n  startLoading(trigger) {\n    this.#media.notify(\"can-load\", void 0, trigger);\n  }\n  /**\n   * Called when the poster image can begin loading. Calling it more than once has no effect.\n   *\n   * @see {@link https://vidstack.io/docs/player/core-concepts/loading#load-strategies}\n   */\n  startLoadingPoster(trigger) {\n    this.#media.notify(\"can-load-poster\", void 0, trigger);\n  }\n  /**\n   * Request Apple AirPlay picker to open.\n   */\n  requestAirPlay(trigger) {\n    return this.#requestMgr.requestAirPlay(trigger);\n  }\n  /**\n   * Request Google Cast device picker to open. The Google Cast framework will be loaded if it\n   * hasn't yet.\n   */\n  requestGoogleCast(trigger) {\n    return this.#requestMgr.requestGoogleCast(trigger);\n  }\n  /**\n   * Set the audio gain, amplifying volume and enabling a maximum volume above 100%.\n   *\n   * @see {@link https://vidstack.io/docs/player/api/audio-gain}\n   */\n  setAudioGain(gain, trigger) {\n    return this.#requestMgr.setAudioGain(gain, trigger);\n  }\n  destroy() {\n    super.destroy();\n    this.#media.remote.setPlayer(null);\n    this.dispatch(\"destroy\");\n  }\n}\nconst mediaplayer__proto = MediaPlayer.prototype;\nprop(mediaplayer__proto, \"canPlayQueue\");\nprop(mediaplayer__proto, \"remoteControl\");\nprop(mediaplayer__proto, \"provider\");\nprop(mediaplayer__proto, \"controls\");\nprop(mediaplayer__proto, \"orientation\");\nprop(mediaplayer__proto, \"title\");\nprop(mediaplayer__proto, \"qualities\");\nprop(mediaplayer__proto, \"audioTracks\");\nprop(mediaplayer__proto, \"textTracks\");\nprop(mediaplayer__proto, \"textRenderers\");\nprop(mediaplayer__proto, \"duration\");\nprop(mediaplayer__proto, \"paused\");\nprop(mediaplayer__proto, \"muted\");\nprop(mediaplayer__proto, \"currentTime\");\nprop(mediaplayer__proto, \"volume\");\nprop(mediaplayer__proto, \"playbackRate\");\nmethod(mediaplayer__proto, \"play\");\nmethod(mediaplayer__proto, \"pause\");\nmethod(mediaplayer__proto, \"enterFullscreen\");\nmethod(mediaplayer__proto, \"exitFullscreen\");\nmethod(mediaplayer__proto, \"enterPictureInPicture\");\nmethod(mediaplayer__proto, \"exitPictureInPicture\");\nmethod(mediaplayer__proto, \"seekToLiveEdge\");\nmethod(mediaplayer__proto, \"startLoading\");\nmethod(mediaplayer__proto, \"startLoadingPoster\");\nmethod(mediaplayer__proto, \"requestAirPlay\");\nmethod(mediaplayer__proto, \"requestGoogleCast\");\nmethod(mediaplayer__proto, \"setAudioGain\");\n\nfunction resolveStreamTypeFromDASHManifest(manifestSrc, requestInit) {\n  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {\n    return /type=\"static\"/.test(manifest) ? \"on-demand\" : \"live\";\n  });\n}\nfunction resolveStreamTypeFromHLSManifest(manifestSrc, requestInit) {\n  return fetch(manifestSrc, requestInit).then((res) => res.text()).then((manifest) => {\n    const renditionURI = resolveHLSRenditionURI(manifest);\n    if (renditionURI) {\n      return resolveStreamTypeFromHLSManifest(\n        /^https?:/.test(renditionURI) ? renditionURI : new URL(renditionURI, manifestSrc).href,\n        requestInit\n      );\n    }\n    const streamType = /EXT-X-PLAYLIST-TYPE:\\s*VOD/.test(manifest) ? \"on-demand\" : \"live\";\n    if (streamType === \"live\" && resolveTargetDuration(manifest) >= 10 && (/#EXT-X-DVR-ENABLED:\\s*true/.test(manifest) || manifest.includes(\"#EXT-X-DISCONTINUITY\"))) {\n      return \"live:dvr\";\n    }\n    return streamType;\n  });\n}\nfunction resolveHLSRenditionURI(manifest) {\n  const matches = manifest.match(/#EXT-X-STREAM-INF:[^\\n]+(\\n[^\\n]+)*/g);\n  return matches ? matches[0].split(\"\\n\")[1].trim() : null;\n}\nfunction resolveTargetDuration(manifest) {\n  const lines = manifest.split(\"\\n\");\n  for (const line of lines) {\n    if (line.startsWith(\"#EXT-X-TARGETDURATION\")) {\n      const duration = parseFloat(line.split(\":\")[1]);\n      if (!isNaN(duration)) {\n        return duration;\n      }\n    }\n  }\n  return -1;\n}\n\nlet warned = /* @__PURE__ */ new Set() ;\nconst sourceTypes = /* @__PURE__ */ new Map();\nclass SourceSelection {\n  #initialize = false;\n  #loaders;\n  #domSources;\n  #media;\n  #loader;\n  constructor(domSources, media, loader, customLoaders = []) {\n    this.#domSources = domSources;\n    this.#media = media;\n    this.#loader = loader;\n    const DASH_LOADER = new DASHProviderLoader(), HLS_LOADER = new HLSProviderLoader(), VIDEO_LOADER = new VideoProviderLoader(), AUDIO_LOADER = new AudioProviderLoader(), YOUTUBE_LOADER = new YouTubeProviderLoader(), VIMEO_LOADER = new VimeoProviderLoader(), EMBED_LOADERS = [YOUTUBE_LOADER, VIMEO_LOADER];\n    this.#loaders = computed(() => {\n      const remoteLoader = media.$state.remotePlaybackLoader();\n      const loaders = media.$props.preferNativeHLS() ? [VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, HLS_LOADER, ...EMBED_LOADERS, ...customLoaders] : [HLS_LOADER, VIDEO_LOADER, AUDIO_LOADER, DASH_LOADER, ...EMBED_LOADERS, ...customLoaders];\n      return remoteLoader ? [remoteLoader, ...loaders] : loaders;\n    });\n    const { $state } = media;\n    $state.sources.set(normalizeSrc(media.$props.src()));\n    for (const src of $state.sources()) {\n      const loader2 = this.#loaders().find((loader3) => loader3.canPlay(src));\n      if (!loader2) continue;\n      const mediaType = loader2.mediaType(src);\n      media.$state.source.set(src);\n      media.$state.mediaType.set(mediaType);\n      media.$state.inferredViewType.set(mediaType);\n      this.#loader.set(loader2);\n      this.#initialize = true;\n      break;\n    }\n  }\n  connect() {\n    const loader = this.#loader();\n    if (this.#initialize) {\n      this.#notifySourceChange(this.#media.$state.source(), loader);\n      this.#notifyLoaderChange(loader);\n      this.#initialize = false;\n    }\n    effect(this.#onSourcesChange.bind(this));\n    effect(this.#onSourceChange.bind(this));\n    effect(this.#onSetup.bind(this));\n    effect(this.#onLoadSource.bind(this));\n    effect(this.#onLoadPoster.bind(this));\n  }\n  #onSourcesChange() {\n    this.#media.notify(\"sources-change\", [\n      ...normalizeSrc(this.#media.$props.src()),\n      ...this.#domSources()\n    ]);\n  }\n  #onSourceChange() {\n    const { $state } = this.#media;\n    const sources = $state.sources(), currentSource = peek($state.source), newSource = this.#findNewSource(currentSource, sources), noMatch = sources[0]?.src && !newSource.src && !newSource.type;\n    if (noMatch && !warned.has(newSource.src) && !peek(this.#loader)) {\n      const source = sources[0];\n      console.warn(\n        `[vidstack] could not find a loader for any of the given media sources, consider providing \\`type\\`:\n\n--- HTML ---\n\n<media-provider>\n  <source src=\"${source.src}\" type=\"video/mp4\" />\n</media-provider>\"\n\n--- React ---\n\n<MediaPlayer src={{ src: \"${source.src}\", type: \"video/mp4\" }}>\n\n---\n\nFalling back to fetching source headers...`\n      );\n      warned.add(newSource.src);\n    }\n    if (noMatch) {\n      const { crossOrigin } = $state, credentials = getRequestCredentials(crossOrigin()), abort = new AbortController();\n      Promise.all(\n        sources.map(\n          (source) => isString(source.src) && source.type === \"?\" ? fetch(source.src, {\n            method: \"HEAD\",\n            credentials,\n            signal: abort.signal\n          }).then((res) => {\n            source.type = res.headers.get(\"content-type\") || \"??\";\n            sourceTypes.set(source.src, source.type);\n            return source;\n          }).catch(() => source) : source\n        )\n      ).then((sources2) => {\n        if (abort.signal.aborted) return;\n        const newSource2 = this.#findNewSource(peek($state.source), sources2);\n        tick();\n        if (!newSource2.src) {\n          this.#media.notify(\"error\", {\n            message: \"Failed to load resource.\",\n            code: 4\n          });\n        }\n      });\n      return () => abort.abort();\n    }\n    tick();\n  }\n  #findNewSource(currentSource, sources) {\n    let newSource = { src: \"\", type: \"\" }, newLoader = null, triggerEvent = new DOMEvent(\"sources-change\", { detail: { sources } }), loaders = this.#loaders(), { started, paused, currentTime, quality, savedState } = this.#media.$state;\n    for (const src of sources) {\n      const loader = loaders.find((loader2) => loader2.canPlay(src));\n      if (loader) {\n        newSource = src;\n        newLoader = loader;\n        break;\n      }\n    }\n    if (isVideoQualitySrc(newSource)) {\n      const currentQuality = quality(), sourceQuality = sources.find((s) => s.src === currentQuality?.src);\n      if (peek(started)) {\n        savedState.set({\n          paused: peek(paused),\n          currentTime: peek(currentTime)\n        });\n      } else {\n        savedState.set(null);\n      }\n      if (sourceQuality) {\n        newSource = sourceQuality;\n        triggerEvent = new DOMEvent(\"quality-change\", {\n          detail: { quality: currentQuality }\n        });\n      }\n    }\n    if (!isSameSrc(currentSource, newSource)) {\n      this.#notifySourceChange(newSource, newLoader, triggerEvent);\n    }\n    if (newLoader !== peek(this.#loader)) {\n      this.#notifyLoaderChange(newLoader, triggerEvent);\n    }\n    return newSource;\n  }\n  #notifySourceChange(src, loader, trigger) {\n    this.#media.notify(\"source-change\", src, trigger);\n    this.#media.notify(\"media-type-change\", loader?.mediaType(src) || \"unknown\", trigger);\n  }\n  #notifyLoaderChange(loader, trigger) {\n    this.#media.$providerSetup.set(false);\n    this.#media.notify(\"provider-change\", null, trigger);\n    loader && peek(() => loader.preconnect?.(this.#media));\n    this.#loader.set(loader);\n    this.#media.notify(\"provider-loader-change\", loader, trigger);\n  }\n  #onSetup() {\n    const provider = this.#media.$provider();\n    if (!provider || peek(this.#media.$providerSetup)) return;\n    if (this.#media.$state.canLoad()) {\n      scoped(() => provider.setup(), provider.scope);\n      this.#media.$providerSetup.set(true);\n      return;\n    }\n    peek(() => provider.preconnect?.());\n  }\n  #onLoadSource() {\n    if (!this.#media.$providerSetup()) return;\n    const provider = this.#media.$provider(), source = this.#media.$state.source(), crossOrigin = peek(this.#media.$state.crossOrigin), preferNativeHLS = peek(this.#media.$props.preferNativeHLS);\n    if (isSameSrc(provider?.currentSrc, source)) {\n      return;\n    }\n    if (this.#media.$state.canLoad()) {\n      const abort = new AbortController();\n      if (isHLSSrc(source)) {\n        if (preferNativeHLS || !isHLSSupported()) {\n          resolveStreamTypeFromHLSManifest(source.src, {\n            credentials: getRequestCredentials(crossOrigin),\n            signal: abort.signal\n          }).then((streamType) => {\n            this.#media.notify(\"stream-type-change\", streamType);\n          }).catch(noop);\n        }\n      } else if (isDASHSrc(source)) {\n        resolveStreamTypeFromDASHManifest(source.src, {\n          credentials: getRequestCredentials(crossOrigin),\n          signal: abort.signal\n        }).then((streamType) => {\n          this.#media.notify(\"stream-type-change\", streamType);\n        }).catch(noop);\n      } else {\n        this.#media.notify(\"stream-type-change\", \"on-demand\");\n      }\n      peek(() => {\n        const preload = peek(this.#media.$state.preload);\n        return provider?.loadSource(source, preload).catch((error) => {\n          {\n            this.#media.logger?.errorGroup(\"[vidstack] failed to load source\").labelledLog(\"Error\", error).labelledLog(\"Source\", source).labelledLog(\"Provider\", provider).labelledLog(\"Media Context\", { ...this.#media }).dispatch();\n          }\n        });\n      });\n      return () => abort.abort();\n    }\n    try {\n      isString(source.src) && preconnect(new URL(source.src).origin);\n    } catch (error) {\n      {\n        this.#media.logger?.infoGroup(`Failed to preconnect to source: ${source.src}`).labelledLog(\"Error\", error).dispatch();\n      }\n    }\n  }\n  #onLoadPoster() {\n    const loader = this.#loader(), { providedPoster, source, canLoadPoster } = this.#media.$state;\n    if (!loader || !loader.loadPoster || !source() || !canLoadPoster() || providedPoster()) return;\n    const abort = new AbortController(), trigger = new DOMEvent(\"source-change\", { detail: source });\n    loader.loadPoster(source(), this.#media, abort).then((url) => {\n      this.#media.notify(\"poster-change\", url || \"\", trigger);\n    }).catch(() => {\n      this.#media.notify(\"poster-change\", \"\", trigger);\n    });\n    return () => {\n      abort.abort();\n    };\n  }\n}\nfunction normalizeSrc(src) {\n  return (isArray(src) ? src : [src]).map((src2) => {\n    if (isString(src2)) {\n      return { src: src2, type: inferType(src2) };\n    } else {\n      return { ...src2, type: inferType(src2.src, src2.type) };\n    }\n  });\n}\nfunction inferType(src, type) {\n  if (isString(type) && type.length) {\n    return type;\n  } else if (isString(src) && sourceTypes.has(src)) {\n    return sourceTypes.get(src);\n  } else if (!type && isHLSSrc({ src, type: \"\" })) {\n    return \"application/x-mpegurl\";\n  } else if (!type && isDASHSrc({ src, type: \"\" })) {\n    return \"application/dash+xml\";\n  } else if (!isString(src) || src.startsWith(\"blob:\")) {\n    return \"video/object\";\n  } else if (src.includes(\"youtube\") || src.includes(\"youtu.be\")) {\n    return \"video/youtube\";\n  } else if (src.includes(\"vimeo\") && !src.includes(\"progressive_redirect\") && !src.includes(\".m3u8\")) {\n    return \"video/vimeo\";\n  }\n  return \"?\";\n}\nfunction isSameSrc(a, b) {\n  return a?.src === b?.src && a?.type === b?.type;\n}\n\nclass Tracks {\n  #domTracks;\n  #media;\n  #prevTracks = [];\n  constructor(domTracks, media) {\n    this.#domTracks = domTracks;\n    this.#media = media;\n    effect(this.#onTracksChange.bind(this));\n  }\n  #onTracksChange() {\n    const newTracks = this.#domTracks();\n    for (const oldTrack of this.#prevTracks) {\n      if (!newTracks.some((t) => t.id === oldTrack.id)) {\n        const track = oldTrack.id && this.#media.textTracks.getById(oldTrack.id);\n        if (track) this.#media.textTracks.remove(track);\n      }\n    }\n    for (const newTrack of newTracks) {\n      const id = newTrack.id || TextTrack.createId(newTrack);\n      if (!this.#media.textTracks.getById(id)) {\n        newTrack.id = id;\n        this.#media.textTracks.add(newTrack);\n      }\n    }\n    this.#prevTracks = newTracks;\n  }\n}\n\nclass MediaProvider extends Component {\n  static props = {\n    loaders: []\n  };\n  static state = new State({\n    loader: null\n  });\n  #media;\n  #sources;\n  #domSources = signal([]);\n  #domTracks = signal([]);\n  #loader = null;\n  onSetup() {\n    this.#media = useMediaContext();\n    this.#sources = new SourceSelection(\n      this.#domSources,\n      this.#media,\n      this.$state.loader,\n      this.$props.loaders()\n    );\n  }\n  onAttach(el) {\n    el.setAttribute(\"data-media-provider\", \"\");\n  }\n  onConnect(el) {\n    this.#sources.connect();\n    new Tracks(this.#domTracks, this.#media);\n    const resize = new ResizeObserver(animationFrameThrottle(this.#onResize.bind(this)));\n    resize.observe(el);\n    const mutations = new MutationObserver(this.#onMutation.bind(this));\n    mutations.observe(el, { attributes: true, childList: true });\n    this.#onResize();\n    this.#onMutation();\n    onDispose(() => {\n      resize.disconnect();\n      mutations.disconnect();\n    });\n  }\n  #loadRafId = -1;\n  load(target) {\n    target?.setAttribute(\"aria-hidden\", \"true\");\n    window.cancelAnimationFrame(this.#loadRafId);\n    this.#loadRafId = requestAnimationFrame(() => this.#runLoader(target));\n    onDispose(() => {\n      window.cancelAnimationFrame(this.#loadRafId);\n    });\n  }\n  #runLoader(target) {\n    if (!this.scope) return;\n    const loader = this.$state.loader(), { $provider } = this.#media;\n    if (this.#loader === loader && loader?.target === target && peek($provider)) return;\n    this.#destroyProvider();\n    this.#loader = loader;\n    if (loader) loader.target = target || null;\n    if (!loader || !target) return;\n    loader.load(this.#media).then((provider) => {\n      if (!this.scope) return;\n      if (peek(this.$state.loader) !== loader) return;\n      this.#media.notify(\"provider-change\", provider);\n    });\n  }\n  onDestroy() {\n    this.#loader = null;\n    this.#destroyProvider();\n  }\n  #destroyProvider() {\n    this.#media?.notify(\"provider-change\", null);\n  }\n  #onResize() {\n    if (!this.el) return;\n    const { player, $state } = this.#media, width = this.el.offsetWidth, height = this.el.offsetHeight;\n    if (!player) return;\n    $state.mediaWidth.set(width);\n    $state.mediaHeight.set(height);\n    if (player.el) {\n      setStyle(player.el, \"--media-width\", width + \"px\");\n      setStyle(player.el, \"--media-height\", height + \"px\");\n    }\n  }\n  #onMutation() {\n    const sources = [], tracks = [], children = this.el.children;\n    for (const el of children) {\n      if (el.hasAttribute(\"data-vds\")) continue;\n      if (el instanceof HTMLSourceElement) {\n        const src = {\n          id: el.id,\n          src: el.src,\n          type: el.type\n        };\n        for (const prop of [\"id\", \"src\", \"width\", \"height\", \"bitrate\", \"codec\"]) {\n          const value = el.getAttribute(`data-${prop}`);\n          if (isString(value)) src[prop] = /id|src|codec/.test(prop) ? value : Number(value);\n        }\n        sources.push(src);\n      } else if (el instanceof HTMLTrackElement) {\n        const track = {\n          src: el.src,\n          kind: el.track.kind,\n          language: el.srclang,\n          label: el.label,\n          default: el.default,\n          type: el.getAttribute(\"data-type\")\n        };\n        tracks.push({\n          id: el.id || TextTrack.createId(track),\n          ...track\n        });\n      }\n    }\n    this.#domSources.set(sources);\n    this.#domTracks.set(tracks);\n    tick();\n  }\n}\nconst mediaprovider__proto = MediaProvider.prototype;\nmethod(mediaprovider__proto, \"load\");\n\nexport { AudioProviderLoader, AudioTrackList, DASHProviderLoader, FullscreenController, HLSProviderLoader, List, LocalMediaStorage, Logger, MEDIA_KEY_SHORTCUTS, MediaControls, MediaPlayer, MediaProvider, MediaRemoteControl, ScreenOrientationController, TextRenderers, TextTrackList, VideoProviderLoader, VideoQualityList, VimeoProviderLoader, YouTubeProviderLoader, canFullscreen, isAudioProvider, isDASHProvider, isGoogleCastProvider, isHLSProvider, isHTMLAudioElement, isHTMLIFrameElement, isHTMLMediaElement, isHTMLVideoElement, isVideoProvider, isVideoQualitySrc, isVimeoProvider, isYouTubeProvider, mediaState, softResetMediaState };\n","const ADD = Symbol(\"LIST_ADD\" ), REMOVE = Symbol(\"LIST_REMOVE\" ), RESET = Symbol(\"LIST_RESET\" ), SELECT = Symbol(\"LIST_SELECT\" ), READONLY = Symbol(\"LIST_READONLY\" ), SET_READONLY = Symbol(\"LIST_SET_READONLY\" ), ON_RESET = Symbol(\"LIST_ON_RESET\" ), ON_REMOVE = Symbol(\"LIST_ON_REMOVE\" ), ON_USER_SELECT = Symbol(\"LIST_ON_USER_SELECT\" );\nconst ListSymbol = {\n  add: ADD,\n  remove: REMOVE,\n  reset: RESET,\n  select: SELECT,\n  readonly: READONLY,\n  setReadonly: SET_READONLY,\n  onReset: ON_RESET,\n  onRemove: ON_REMOVE,\n  onUserSelect: ON_USER_SELECT\n};\n\nexport { ListSymbol };\n","import { useContext, createContext, prop, Component, computed, provideContext, signal, isBoolean, effect, setAttribute, uppercaseFirstChar, isNil, noop, isString, isFunction, unwrap, camelToKebabCase, onDispose, scoped, keysOf, isArray, tick, peek, isKeyboardClick } from './vidstack-DVpy0IqK.js';\nimport { useMediaContext, useMediaState } from './vidstack-CUYciP40.js';\nimport { watchColorScheme, useResizeObserver, useActive } from './vidstack-CGUlKgT8.js';\nimport { html } from 'lit-html';\nimport { $signal, LayoutIconsLoader, Icon } from './vidstack-mJNGvZNe.js';\nimport { watchActiveTextTrack } from './vidstack-C1THCRTj.js';\nimport { $ariaBool, sortVideoQualities } from './vidstack-BOTZD4tC.js';\nimport { ifDefined } from 'lit-html/directives/if-defined.js';\nimport { ref } from 'lit-html/directives/ref.js';\nimport { getDownloadFile } from './vidstack-BgIVvpNy.js';\n\nconst defaultLayoutContext = createContext();\nfunction useDefaultLayoutContext() {\n  return useContext(defaultLayoutContext);\n}\n\nconst defaultLayoutProps = {\n  colorScheme: \"system\",\n  download: null,\n  customIcons: false,\n  disableTimeSlider: false,\n  menuContainer: null,\n  menuGroup: \"bottom\",\n  noAudioGain: false,\n  noGestures: false,\n  noKeyboardAnimations: false,\n  noModal: false,\n  noScrubGesture: false,\n  playbackRates: { min: 0, max: 2, step: 0.25 },\n  audioGains: { min: 0, max: 300, step: 25 },\n  seekStep: 10,\n  sliderChaptersMinWidth: 325,\n  hideQualityBitrate: false,\n  smallWhen: false,\n  thumbnails: null,\n  translations: null,\n  when: false\n};\n\nclass DefaultLayout extends Component {\n  static props = defaultLayoutProps;\n  #media;\n  #when = computed(() => {\n    const when = this.$props.when();\n    return this.#matches(when);\n  });\n  #smallWhen = computed(() => {\n    const when = this.$props.smallWhen();\n    return this.#matches(when);\n  });\n  get isMatch() {\n    return this.#when();\n  }\n  get isSmallLayout() {\n    return this.#smallWhen();\n  }\n  onSetup() {\n    this.#media = useMediaContext();\n    this.setAttributes({\n      \"data-match\": this.#when,\n      \"data-sm\": () => this.#smallWhen() ? \"\" : null,\n      \"data-lg\": () => !this.#smallWhen() ? \"\" : null,\n      \"data-size\": () => this.#smallWhen() ? \"sm\" : \"lg\",\n      \"data-no-scrub-gesture\": this.$props.noScrubGesture\n    });\n    provideContext(defaultLayoutContext, {\n      ...this.$props,\n      when: this.#when,\n      smallWhen: this.#smallWhen,\n      userPrefersAnnouncements: signal(true),\n      userPrefersKeyboardAnimations: signal(true),\n      menuPortal: signal(null)\n    });\n  }\n  onAttach(el) {\n    watchColorScheme(el, this.$props.colorScheme);\n  }\n  #matches(query) {\n    return query !== \"never\" && (isBoolean(query) ? query : computed(() => query(this.#media.player.state))());\n  }\n}\nconst defaultlayout__proto = DefaultLayout.prototype;\nprop(defaultlayout__proto, \"isMatch\");\nprop(defaultlayout__proto, \"isSmallLayout\");\n\nfunction setLayoutName(name, isMatch) {\n  effect(() => {\n    const { player } = useMediaContext(), el = player.el;\n    el && setAttribute(el, \"data-layout\", isMatch() && name);\n    return () => el?.removeAttribute(\"data-layout\");\n  });\n}\n\nfunction i18n(translations, word) {\n  return translations()?.[word] ?? word;\n}\n\nfunction DefaultAnnouncer() {\n  return $signal(() => {\n    const { translations, userPrefersAnnouncements } = useDefaultLayoutContext();\n    if (!userPrefersAnnouncements()) return null;\n    return html`<media-announcer .translations=${$signal(translations)}></media-announcer>`;\n  });\n}\n\nfunction IconSlot(name, classes = \"\") {\n  return html`<slot\n    name=${`${name}-icon`}\n    data-class=${`vds-icon vds-${name}-icon${classes ? ` ${classes}` : \"\"}`}\n  ></slot>`;\n}\nfunction IconSlots(names) {\n  return names.map((name) => IconSlot(name));\n}\n\nfunction $i18n(translations, word) {\n  return $signal(() => i18n(translations, word));\n}\n\nfunction DefaultAirPlayButton({ tooltip }) {\n  const { translations } = useDefaultLayoutContext(), { remotePlaybackState } = useMediaState(), $label = $signal(() => {\n    const airPlayText = i18n(translations, \"AirPlay\"), stateText = uppercaseFirstChar(remotePlaybackState());\n    return `${airPlayText} ${stateText}`;\n  }), $airPlayText = $i18n(translations, \"AirPlay\");\n  return html`\n    <media-tooltip class=\"vds-airplay-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-airplay-button class=\"vds-airplay-button vds-button\" aria-label=${$label}>\n          ${IconSlot(\"airplay\")}\n        </media-airplay-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\" placement=${tooltip}>\n        <span class=\"vds-airplay-tooltip-text\">${$airPlayText}</span>\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultGoogleCastButton({ tooltip }) {\n  const { translations } = useDefaultLayoutContext(), { remotePlaybackState } = useMediaState(), $label = $signal(() => {\n    const googleCastText = i18n(translations, \"Google Cast\"), stateText = uppercaseFirstChar(remotePlaybackState());\n    return `${googleCastText} ${stateText}`;\n  }), $googleCastText = $i18n(translations, \"Google Cast\");\n  return html`\n    <media-tooltip class=\"vds-google-cast-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-google-cast-button class=\"vds-google-cast-button vds-button\" aria-label=${$label}>\n          ${IconSlot(\"google-cast\")}\n        </media-google-cast-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\" placement=${tooltip}>\n        <span class=\"vds-google-cast-tooltip-text\">${$googleCastText}</span>\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultPlayButton({ tooltip }) {\n  const { translations } = useDefaultLayoutContext(), $playText = $i18n(translations, \"Play\"), $pauseText = $i18n(translations, \"Pause\");\n  return html`\n    <media-tooltip class=\"vds-play-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-play-button\n          class=\"vds-play-button vds-button\"\n          aria-label=${$i18n(translations, \"Play\")}\n        >\n          ${IconSlots([\"play\", \"pause\", \"replay\"])}\n        </media-play-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\" placement=${tooltip}>\n        <span class=\"vds-play-tooltip-text\">${$playText}</span>\n        <span class=\"vds-pause-tooltip-text\">${$pauseText}</span>\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultMuteButton({\n  tooltip,\n  ref: ref$1 = noop\n}) {\n  const { translations } = useDefaultLayoutContext(), $muteText = $i18n(translations, \"Mute\"), $unmuteText = $i18n(translations, \"Unmute\");\n  return html`\n    <media-tooltip class=\"vds-mute-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-mute-button\n          class=\"vds-mute-button vds-button\"\n          aria-label=${$i18n(translations, \"Mute\")}\n          ${ref(ref$1)}\n        >\n          ${IconSlots([\"mute\", \"volume-low\", \"volume-high\"])}\n        </media-mute-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\" placement=${tooltip}>\n        <span class=\"vds-mute-tooltip-text\">${$unmuteText}</span>\n        <span class=\"vds-unmute-tooltip-text\">${$muteText}</span>\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultCaptionButton({ tooltip }) {\n  const { translations } = useDefaultLayoutContext(), $ccOnText = $i18n(translations, \"Closed-Captions On\"), $ccOffText = $i18n(translations, \"Closed-Captions Off\");\n  return html`\n    <media-tooltip class=\"vds-caption-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-caption-button\n          class=\"vds-caption-button vds-button\"\n          aria-label=${$i18n(translations, \"Captions\")}\n        >\n          ${IconSlots([\"cc-on\", \"cc-off\"])}\n        </media-caption-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\" placement=${tooltip}>\n        <span class=\"vds-cc-on-tooltip-text\">${$ccOffText}</span>\n        <span class=\"vds-cc-off-tooltip-text\">${$ccOnText}</span>\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultPIPButton() {\n  const { translations } = useDefaultLayoutContext(), $enterText = $i18n(translations, \"Enter PiP\"), $exitText = $i18n(translations, \"Exit PiP\");\n  return html`\n    <media-tooltip class=\"vds-pip-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-pip-button\n          class=\"vds-pip-button vds-button\"\n          aria-label=${$i18n(translations, \"PiP\")}\n        >\n          ${IconSlots([\"pip-enter\", \"pip-exit\"])}\n        </media-pip-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\">\n        <span class=\"vds-pip-enter-tooltip-text\">${$enterText}</span>\n        <span class=\"vds-pip-exit-tooltip-text\">${$exitText}</span>\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultFullscreenButton({ tooltip }) {\n  const { translations } = useDefaultLayoutContext(), $enterText = $i18n(translations, \"Enter Fullscreen\"), $exitText = $i18n(translations, \"Exit Fullscreen\");\n  return html`\n    <media-tooltip class=\"vds-fullscreen-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-fullscreen-button\n          class=\"vds-fullscreen-button vds-button\"\n          aria-label=${$i18n(translations, \"Fullscreen\")}\n        >\n          ${IconSlots([\"fs-enter\", \"fs-exit\"])}\n        </media-fullscreen-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\" placement=${tooltip}>\n        <span class=\"vds-fs-enter-tooltip-text\">${$enterText}</span>\n        <span class=\"vds-fs-exit-tooltip-text\">${$exitText}</span>\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultSeekButton({\n  backward,\n  tooltip\n}) {\n  const { translations, seekStep } = useDefaultLayoutContext(), seekText = !backward ? \"Seek Forward\" : \"Seek Backward\", $label = $i18n(translations, seekText), $seconds = () => (backward ? -1 : 1) * seekStep();\n  return html`\n    <media-tooltip class=\"vds-seek-tooltip vds-tooltip\">\n      <media-tooltip-trigger>\n        <media-seek-button\n          class=\"vds-seek-button vds-button\"\n          seconds=${$signal($seconds)}\n          aria-label=${$label}\n        >\n          ${!backward ? IconSlot(\"seek-forward\") : IconSlot(\"seek-backward\")}\n        </media-seek-button>\n      </media-tooltip-trigger>\n      <media-tooltip-content class=\"vds-tooltip-content\" placement=${tooltip}>\n        ${$i18n(translations, seekText)}\n      </media-tooltip-content>\n    </media-tooltip>\n  `;\n}\nfunction DefaultLiveButton() {\n  const { translations } = useDefaultLayoutContext(), { live } = useMediaState(), $label = $i18n(translations, \"Skip To Live\"), $liveText = $i18n(translations, \"LIVE\");\n  return live() ? html`\n        <media-live-button class=\"vds-live-button\" aria-label=${$label}>\n          <span class=\"vds-live-button-text\">${$liveText}</span>\n        </media-live-button>\n      ` : null;\n}\nfunction DefaultDownloadButton() {\n  return $signal(() => {\n    const { download, translations } = useDefaultLayoutContext(), $download = download();\n    if (isNil($download)) return null;\n    const { source, title } = useMediaState(), $src = source(), file = getDownloadFile({\n      title: title(),\n      src: $src,\n      download: $download\n    });\n    return file ? html`\n          <media-tooltip class=\"vds-download-tooltip vds-tooltip\">\n            <media-tooltip-trigger>\n              <a\n                role=\"button\"\n                class=\"vds-download-button vds-button\"\n                aria-label=${$i18n(translations, \"Download\")}\n                href=${file.url + `?download=${file.name}`}\n                download=${file.name}\n                target=\"_blank\"\n              >\n                <slot name=\"download-icon\" data-class=\"vds-icon\" />\n              </a>\n            </media-tooltip-trigger>\n            <media-tooltip-content class=\"vds-tooltip-content\" placement=\"top\">\n              ${$i18n(translations, \"Download\")}\n            </media-tooltip-content>\n          </media-tooltip>\n        ` : null;\n  });\n}\n\nfunction DefaultCaptions() {\n  const { translations } = useDefaultLayoutContext();\n  return html`\n    <media-captions\n      class=\"vds-captions\"\n      .exampleText=${$i18n(translations, \"Captions look like this\")}\n    ></media-captions>\n  `;\n}\n\nfunction DefaultControlsSpacer() {\n  return html`<div class=\"vds-controls-spacer\"></div>`;\n}\n\nfunction MenuPortal(container, template) {\n  return html`\n    <media-menu-portal .container=${$signal(container)} disabled=\"fullscreen\">\n      ${template}\n    </media-menu-portal>\n  `;\n}\nfunction createMenuContainer(layoutEl, rootSelector, className, isSmallLayout) {\n  let root = isString(rootSelector) ? document.querySelector(rootSelector) : rootSelector;\n  if (!root) root = layoutEl?.closest(\"dialog\");\n  if (!root) root = document.body;\n  const container = document.createElement(\"div\");\n  container.style.display = \"contents\";\n  container.classList.add(className);\n  root.append(container);\n  effect(() => {\n    if (!container) return;\n    const { viewType } = useMediaState(), isSmall = isSmallLayout();\n    setAttribute(container, \"data-view-type\", viewType());\n    setAttribute(container, \"data-sm\", isSmall);\n    setAttribute(container, \"data-lg\", !isSmall);\n    setAttribute(container, \"data-size\", isSmall ? \"sm\" : \"lg\");\n  });\n  const { colorScheme } = useDefaultLayoutContext();\n  watchColorScheme(container, colorScheme);\n  return container;\n}\n\nfunction DefaultChaptersMenu({\n  placement,\n  tooltip,\n  portal\n}) {\n  const { textTracks } = useMediaContext(), { viewType, clipStartTime, clipEndTime } = useMediaState(), {\n    translations,\n    thumbnails,\n    menuPortal,\n    noModal,\n    menuGroup,\n    smallWhen: smWhen\n  } = useDefaultLayoutContext(), $disabled = computed(() => {\n    const $startTime = clipStartTime(), $endTime = clipEndTime() || Infinity, $track = signal(null);\n    watchActiveTextTrack(textTracks, \"chapters\", $track.set);\n    const cues = $track()?.cues.filter(\n      (cue) => cue.startTime <= $endTime && cue.endTime >= $startTime\n    );\n    return !cues?.length;\n  });\n  if ($disabled()) return null;\n  const $placement = computed(\n    () => noModal() ? unwrap(placement) : !smWhen() ? unwrap(placement) : null\n  ), $offset = computed(\n    () => !smWhen() && menuGroup() === \"bottom\" && viewType() === \"video\" ? 26 : 0\n  ), $isOpen = signal(false);\n  function onOpen() {\n    $isOpen.set(true);\n  }\n  function onClose() {\n    $isOpen.set(false);\n  }\n  const items = html`\n    <media-menu-items\n      class=\"vds-chapters-menu-items vds-menu-items\"\n      placement=${$signal($placement)}\n      offset=${$signal($offset)}\n    >\n      ${$signal(() => {\n    if (!$isOpen()) return null;\n    return html`\n          <media-chapters-radio-group\n            class=\"vds-chapters-radio-group vds-radio-group\"\n            .thumbnails=${$signal(thumbnails)}\n          >\n            <template>\n              <media-radio class=\"vds-chapter-radio vds-radio\">\n                <media-thumbnail class=\"vds-thumbnail\"></media-thumbnail>\n                <div class=\"vds-chapter-radio-content\">\n                  <span class=\"vds-chapter-radio-label\" data-part=\"label\"></span>\n                  <span class=\"vds-chapter-radio-start-time\" data-part=\"start-time\"></span>\n                  <span class=\"vds-chapter-radio-duration\" data-part=\"duration\"></span>\n                </div>\n              </media-radio>\n            </template>\n          </media-chapters-radio-group>\n        `;\n  })}\n    </media-menu-items>\n  `;\n  return html`\n    <media-menu class=\"vds-chapters-menu vds-menu\" @open=${onOpen} @close=${onClose}>\n      <media-tooltip class=\"vds-tooltip\">\n        <media-tooltip-trigger>\n          <media-menu-button\n            class=\"vds-menu-button vds-button\"\n            aria-label=${$i18n(translations, \"Chapters\")}\n          >\n            ${IconSlot(\"menu-chapters\")}\n          </media-menu-button>\n        </media-tooltip-trigger>\n        <media-tooltip-content\n          class=\"vds-tooltip-content\"\n          placement=${isFunction(tooltip) ? $signal(tooltip) : tooltip}\n        >\n          ${$i18n(translations, \"Chapters\")}\n        </media-tooltip-content>\n      </media-tooltip>\n      ${portal ? MenuPortal(menuPortal, items) : items}\n    </media-menu>\n  `;\n}\n\nfunction hexToRgb(hex) {\n  const { style } = new Option();\n  style.color = hex;\n  return style.color.match(/\\((.*?)\\)/)[1].replace(/,/g, \" \");\n}\n\nconst FONT_COLOR_OPTION = {\n  type: \"color\"\n};\nconst FONT_FAMILY_OPTION = {\n  type: \"radio\",\n  values: {\n    \"Monospaced Serif\": \"mono-serif\",\n    \"Proportional Serif\": \"pro-serif\",\n    \"Monospaced Sans-Serif\": \"mono-sans\",\n    \"Proportional Sans-Serif\": \"pro-sans\",\n    Casual: \"casual\",\n    Cursive: \"cursive\",\n    \"Small Capitals\": \"capitals\"\n  }\n};\nconst FONT_SIZE_OPTION = {\n  type: \"slider\",\n  min: 0,\n  max: 400,\n  step: 25,\n  upIcon: null,\n  downIcon: null\n};\nconst FONT_OPACITY_OPTION = {\n  type: \"slider\",\n  min: 0,\n  max: 100,\n  step: 5,\n  upIcon: null,\n  downIcon: null\n};\nconst FONT_TEXT_SHADOW_OPTION = {\n  type: \"radio\",\n  values: [\"None\", \"Drop Shadow\", \"Raised\", \"Depressed\", \"Outline\"]\n};\nconst FONT_DEFAULTS = {\n  fontFamily: \"pro-sans\",\n  fontSize: \"100%\",\n  textColor: \"#ffffff\",\n  textOpacity: \"100%\",\n  textShadow: \"none\",\n  textBg: \"#000000\",\n  textBgOpacity: \"100%\",\n  displayBg: \"#000000\",\n  displayBgOpacity: \"0%\"\n};\nconst FONT_SIGNALS = Object.keys(FONT_DEFAULTS).reduce(\n  (prev, type) => ({\n    ...prev,\n    [type]: signal(FONT_DEFAULTS[type])\n  }),\n  {}\n);\n{\n  for (const type of Object.keys(FONT_SIGNALS)) {\n    const value = localStorage.getItem(`vds-player:${camelToKebabCase(type)}`);\n    if (isString(value)) FONT_SIGNALS[type].set(value);\n  }\n}\nfunction onFontReset() {\n  for (const type of Object.keys(FONT_SIGNALS)) {\n    const defaultValue = FONT_DEFAULTS[type];\n    FONT_SIGNALS[type].set(defaultValue);\n  }\n}\n\nlet isWatchingVars = false, players = /* @__PURE__ */ new Set();\nfunction updateFontCssVars() {\n  const { player } = useMediaContext();\n  players.add(player);\n  onDispose(() => players.delete(player));\n  if (!isWatchingVars) {\n    scoped(() => {\n      for (const type of keysOf(FONT_SIGNALS)) {\n        const $value = FONT_SIGNALS[type], defaultValue = FONT_DEFAULTS[type], varName = `--media-user-${camelToKebabCase(type)}`, storageKey = `vds-player:${camelToKebabCase(type)}`;\n        effect(() => {\n          const value = $value(), isDefaultVarValue = value === defaultValue, varValue = !isDefaultVarValue ? getCssVarValue(player, type, value) : null;\n          for (const player2 of players) {\n            player2.el?.style.setProperty(varName, varValue);\n          }\n          if (isDefaultVarValue) {\n            localStorage.removeItem(storageKey);\n          } else {\n            localStorage.setItem(storageKey, value);\n          }\n        });\n      }\n    }, null);\n    isWatchingVars = true;\n  }\n}\nfunction getCssVarValue(player, type, value) {\n  switch (type) {\n    case \"fontFamily\":\n      const fontVariant = value === \"capitals\" ? \"small-caps\" : \"\";\n      player.el?.style.setProperty(\"--media-user-font-variant\", fontVariant);\n      return getFontFamilyCSSVarValue(value);\n    case \"fontSize\":\n    case \"textOpacity\":\n    case \"textBgOpacity\":\n    case \"displayBgOpacity\":\n      return percentToRatio(value);\n    case \"textColor\":\n      return `rgb(${hexToRgb(value)} / var(--media-user-text-opacity, 1))`;\n    case \"textShadow\":\n      return getTextShadowCssVarValue(value);\n    case \"textBg\":\n      return `rgb(${hexToRgb(value)} / var(--media-user-text-bg-opacity, 1))`;\n    case \"displayBg\":\n      return `rgb(${hexToRgb(value)} / var(--media-user-display-bg-opacity, 1))`;\n  }\n}\nfunction percentToRatio(value) {\n  return (parseInt(value) / 100).toString();\n}\nfunction getFontFamilyCSSVarValue(value) {\n  switch (value) {\n    case \"mono-serif\":\n      return '\"Courier New\", Courier, \"Nimbus Mono L\", \"Cutive Mono\", monospace';\n    case \"mono-sans\":\n      return '\"Deja Vu Sans Mono\", \"Lucida Console\", Monaco, Consolas, \"PT Mono\", monospace';\n    case \"pro-sans\":\n      return 'Roboto, \"Arial Unicode Ms\", Arial, Helvetica, Verdana, \"PT Sans Caption\", sans-serif';\n    case \"casual\":\n      return '\"Comic Sans MS\", Impact, Handlee, fantasy';\n    case \"cursive\":\n      return '\"Monotype Corsiva\", \"URW Chancery L\", \"Apple Chancery\", \"Dancing Script\", cursive';\n    case \"capitals\":\n      return '\"Arial Unicode Ms\", Arial, Helvetica, Verdana, \"Marcellus SC\", sans-serif + font-variant=small-caps';\n    default:\n      return '\"Times New Roman\", Times, Georgia, Cambria, \"PT Serif Caption\", serif';\n  }\n}\nfunction getTextShadowCssVarValue(value) {\n  switch (value) {\n    case \"drop shadow\":\n      return \"rgb(34, 34, 34) 1.86389px 1.86389px 2.79583px, rgb(34, 34, 34) 1.86389px 1.86389px 3.72778px, rgb(34, 34, 34) 1.86389px 1.86389px 4.65972px\";\n    case \"raised\":\n      return \"rgb(34, 34, 34) 1px 1px, rgb(34, 34, 34) 2px 2px\";\n    case \"depressed\":\n      return \"rgb(204, 204, 204) 1px 1px, rgb(34, 34, 34) -1px -1px\";\n    case \"outline\":\n      return \"rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px, rgb(34, 34, 34) 0px 0px 1.86389px\";\n    default:\n      return \"\";\n  }\n}\n\nlet sectionId = 0;\nfunction DefaultMenuSection({ label = \"\", value = \"\", children }) {\n  if (!label) {\n    return html`\n      <div class=\"vds-menu-section\">\n        <div class=\"vds-menu-section-body\">${children}</div>\n      </div>\n    `;\n  }\n  const id = `vds-menu-section-${++sectionId}`;\n  return html`\n    <section class=\"vds-menu-section\" role=\"group\" aria-labelledby=${id}>\n      <div class=\"vds-menu-section-title\">\n        <header id=${id}>${label}</header>\n        ${value ? html`<div class=\"vds-menu-section-value\">${value}</div>` : null}\n      </div>\n      <div class=\"vds-menu-section-body\">${children}</div>\n    </section>\n  `;\n}\nfunction DefaultMenuItem({ label, children }) {\n  return html`\n    <div class=\"vds-menu-item\">\n      <div class=\"vds-menu-item-label\">${label}</div>\n      ${children}\n    </div>\n  `;\n}\nfunction DefaultMenuButton({\n  label,\n  icon,\n  hint\n}) {\n  return html`\n    <media-menu-button class=\"vds-menu-item\">\n      ${IconSlot(\"menu-arrow-left\", \"vds-menu-close-icon\")}\n      ${icon ? IconSlot(icon, \"vds-menu-item-icon\") : null}\n      <span class=\"vds-menu-item-label\">${$signal(label)}</span>\n      <span class=\"vds-menu-item-hint\" data-part=\"hint\">${hint ? $signal(hint) : null} </span>\n      ${IconSlot(\"menu-arrow-right\", \"vds-menu-open-icon\")}\n    </media-menu-button>\n  `;\n}\nfunction DefaultRadioGroup({\n  value = null,\n  options,\n  hideLabel = false,\n  children = null,\n  onChange = null\n}) {\n  function renderRadio(option) {\n    const { value: value2, label: content } = option;\n    return html`\n      <media-radio class=\"vds-radio\" value=${value2}>\n        ${IconSlot(\"menu-radio-check\")}\n        ${!hideLabel ? html`\n              <span class=\"vds-radio-label\" data-part=\"label\">\n                ${isString(content) ? content : $signal(content)}\n              </span>\n            ` : null}\n        ${isFunction(children) ? children(option) : children}\n      </media-radio>\n    `;\n  }\n  return html`\n    <media-radio-group\n      class=\"vds-radio-group\"\n      value=${isString(value) ? value : value ? $signal(value) : \"\"}\n      @change=${onChange}\n    >\n      ${isArray(options) ? options.map(renderRadio) : $signal(() => options().map(renderRadio))}\n    </media-radio-group>\n  `;\n}\nfunction createRadioOptions(entries) {\n  return isArray(entries) ? entries.map((entry) => ({ label: entry, value: entry.toLowerCase() })) : Object.keys(entries).map((label) => ({ label, value: entries[label] }));\n}\n\nfunction DefaultSliderParts() {\n  return html`\n    <div class=\"vds-slider-track\"></div>\n    <div class=\"vds-slider-track-fill vds-slider-track\"></div>\n    <div class=\"vds-slider-thumb\"></div>\n  `;\n}\nfunction DefaultSliderSteps() {\n  return html`\n    <media-slider-steps class=\"vds-slider-steps\">\n      <template>\n        <div class=\"vds-slider-step\"></div>\n      </template>\n    </media-slider-steps>\n  `;\n}\nfunction DefaultMenuSliderItem({\n  label = null,\n  value = null,\n  upIcon = \"\",\n  downIcon = \"\",\n  children,\n  isMin,\n  isMax\n}) {\n  const hasTitle = label || value, content = [\n    downIcon ? IconSlot(downIcon, \"down\") : null,\n    children,\n    upIcon ? IconSlot(upIcon, \"up\") : null\n  ];\n  return html`\n    <div\n      class=${`vds-menu-item vds-menu-slider-item${hasTitle ? \" group\" : \"\"}`}\n      data-min=${$signal(() => isMin() ? \"\" : null)}\n      data-max=${$signal(() => isMax() ? \"\" : null)}\n    >\n      ${hasTitle ? html`\n            <div class=\"vds-menu-slider-title\">\n              ${[\n    label ? html`<div>${label}</div>` : null,\n    value ? html`<div>${value}</div>` : null\n  ]}\n            </div>\n            <div class=\"vds-menu-slider-body\">${content}</div>\n          ` : content}\n    </div>\n  `;\n}\n\nconst FONT_SIZE_OPTION_WITH_ICONS = {\n  ...FONT_SIZE_OPTION,\n  upIcon: \"menu-opacity-up\",\n  downIcon: \"menu-opacity-down\"\n};\nconst FONT_OPACITY_OPTION_WITH_ICONS = {\n  ...FONT_OPACITY_OPTION,\n  upIcon: \"menu-opacity-up\",\n  downIcon: \"menu-opacity-down\"\n};\nfunction DefaultFontMenu() {\n  return $signal(() => {\n    const { hasCaptions } = useMediaState(), { translations } = useDefaultLayoutContext();\n    if (!hasCaptions()) return null;\n    return html`\n      <media-menu class=\"vds-font-menu vds-menu\">\n        ${DefaultMenuButton({\n      label: () => i18n(translations, \"Caption Styles\")\n    })}\n        <media-menu-items class=\"vds-menu-items\">\n          ${[\n      DefaultMenuSection({\n        label: $i18n(translations, \"Font\"),\n        children: [DefaultFontFamilyMenu(), DefaultFontSizeSlider()]\n      }),\n      DefaultMenuSection({\n        label: $i18n(translations, \"Text\"),\n        children: [\n          DefaultTextColorInput(),\n          DefaultTextShadowMenu(),\n          DefaultTextOpacitySlider()\n        ]\n      }),\n      DefaultMenuSection({\n        label: $i18n(translations, \"Text Background\"),\n        children: [DefaultTextBgInput(), DefaultTextBgOpacitySlider()]\n      }),\n      DefaultMenuSection({\n        label: $i18n(translations, \"Display Background\"),\n        children: [DefaultDisplayBgInput(), DefaultDisplayOpacitySlider()]\n      }),\n      DefaultMenuSection({\n        children: [DefaultResetMenuItem()]\n      })\n    ]}\n        </media-menu-items>\n      </media-menu>\n    `;\n  });\n}\nfunction DefaultFontFamilyMenu() {\n  return DefaultFontSetting({\n    label: \"Family\",\n    option: FONT_FAMILY_OPTION,\n    type: \"fontFamily\"\n  });\n}\nfunction DefaultFontSizeSlider() {\n  return DefaultFontSetting({\n    label: \"Size\",\n    option: FONT_SIZE_OPTION_WITH_ICONS,\n    type: \"fontSize\"\n  });\n}\nfunction DefaultTextColorInput() {\n  return DefaultFontSetting({\n    label: \"Color\",\n    option: FONT_COLOR_OPTION,\n    type: \"textColor\"\n  });\n}\nfunction DefaultTextOpacitySlider() {\n  return DefaultFontSetting({\n    label: \"Opacity\",\n    option: FONT_OPACITY_OPTION_WITH_ICONS,\n    type: \"textOpacity\"\n  });\n}\nfunction DefaultTextShadowMenu() {\n  return DefaultFontSetting({\n    label: \"Shadow\",\n    option: FONT_TEXT_SHADOW_OPTION,\n    type: \"textShadow\"\n  });\n}\nfunction DefaultTextBgInput() {\n  return DefaultFontSetting({\n    label: \"Color\",\n    option: FONT_COLOR_OPTION,\n    type: \"textBg\"\n  });\n}\nfunction DefaultTextBgOpacitySlider() {\n  return DefaultFontSetting({\n    label: \"Opacity\",\n    option: FONT_OPACITY_OPTION_WITH_ICONS,\n    type: \"textBgOpacity\"\n  });\n}\nfunction DefaultDisplayBgInput() {\n  return DefaultFontSetting({\n    label: \"Color\",\n    option: FONT_COLOR_OPTION,\n    type: \"displayBg\"\n  });\n}\nfunction DefaultDisplayOpacitySlider() {\n  return DefaultFontSetting({\n    label: \"Opacity\",\n    option: FONT_OPACITY_OPTION_WITH_ICONS,\n    type: \"displayBgOpacity\"\n  });\n}\nfunction DefaultResetMenuItem() {\n  const { translations } = useDefaultLayoutContext(), $label = () => i18n(translations, \"Reset\");\n  return html`\n    <button class=\"vds-menu-item\" role=\"menuitem\" @click=${onFontReset}>\n      <span class=\"vds-menu-item-label\">${$signal($label)}</span>\n    </button>\n  `;\n}\nfunction DefaultFontSetting({ label, option, type }) {\n  const { player } = useMediaContext(), { translations } = useDefaultLayoutContext(), $currentValue = FONT_SIGNALS[type], $label = () => i18n(translations, label);\n  function notify() {\n    tick();\n    player.dispatchEvent(new Event(\"vds-font-change\"));\n  }\n  if (option.type === \"color\") {\n    let onColorChange2 = function(event) {\n      $currentValue.set(event.target.value);\n      notify();\n    };\n    return DefaultMenuItem({\n      label: $signal($label),\n      children: html`\n        <input\n          class=\"vds-color-picker\"\n          type=\"color\"\n          .value=${$signal($currentValue)}\n          @input=${onColorChange2}\n        />\n      `\n    });\n  }\n  if (option.type === \"slider\") {\n    let onSliderValueChange2 = function(event) {\n      $currentValue.set(event.detail + \"%\");\n      notify();\n    };\n    const { min, max, step, upIcon, downIcon } = option;\n    return DefaultMenuSliderItem({\n      label: $signal($label),\n      value: $signal($currentValue),\n      upIcon,\n      downIcon,\n      isMin: () => $currentValue() === min + \"%\",\n      isMax: () => $currentValue() === max + \"%\",\n      children: html`\n        <media-slider\n          class=\"vds-slider\"\n          min=${min}\n          max=${max}\n          step=${step}\n          key-step=${step}\n          .value=${$signal(() => parseInt($currentValue()))}\n          aria-label=${$signal($label)}\n          @value-change=${onSliderValueChange2}\n          @drag-value-change=${onSliderValueChange2}\n        >\n          ${DefaultSliderParts()}${DefaultSliderSteps()}\n        </media-slider>\n      `\n    });\n  }\n  const radioOptions = createRadioOptions(option.values), $hint = () => {\n    const value = $currentValue(), label2 = radioOptions.find((radio) => radio.value === value)?.label || \"\";\n    return i18n(translations, isString(label2) ? label2 : label2());\n  };\n  return html`\n    <media-menu class=${`vds-${camelToKebabCase(type)}-menu vds-menu`}>\n      ${DefaultMenuButton({ label: $label, hint: $hint })}\n      <media-menu-items class=\"vds-menu-items\">\n        ${DefaultRadioGroup({\n    value: $currentValue,\n    options: radioOptions,\n    onChange({ detail: value }) {\n      $currentValue.set(value);\n      notify();\n    }\n  })}\n      </media-menu-items>\n    </media-menu>\n  `;\n}\n\nfunction DefaultMenuCheckbox({\n  label,\n  checked,\n  defaultChecked = false,\n  storageKey,\n  onChange\n}) {\n  const { translations } = useDefaultLayoutContext(), savedValue = storageKey ? localStorage.getItem(storageKey) : null, $checked = signal(!!(savedValue ?? defaultChecked)), $active = signal(false), $ariaChecked = $signal($ariaBool($checked)), $label = $i18n(translations, label);\n  if (storageKey) onChange(peek($checked));\n  if (checked) {\n    effect(() => void $checked.set(checked()));\n  }\n  function onPress(event) {\n    if (event?.button === 1) return;\n    $checked.set((checked2) => !checked2);\n    if (storageKey) localStorage.setItem(storageKey, $checked() ? \"1\" : \"\");\n    onChange($checked(), event);\n    $active.set(false);\n  }\n  function onKeyDown(event) {\n    if (isKeyboardClick(event)) onPress();\n  }\n  function onActive(event) {\n    if (event.button !== 0) return;\n    $active.set(true);\n  }\n  return html`\n    <div\n      class=\"vds-menu-checkbox\"\n      role=\"menuitemcheckbox\"\n      tabindex=\"0\"\n      aria-label=${$label}\n      aria-checked=${$ariaChecked}\n      data-active=${$signal(() => $active() ? \"\" : null)}\n      @pointerup=${onPress}\n      @pointerdown=${onActive}\n      @keydown=${onKeyDown}\n    ></div>\n  `;\n}\n\nfunction DefaultAccessibilityMenu() {\n  return $signal(() => {\n    const { translations } = useDefaultLayoutContext();\n    return html`\n      <media-menu class=\"vds-accessibility-menu vds-menu\">\n        ${DefaultMenuButton({\n      label: () => i18n(translations, \"Accessibility\"),\n      icon: \"menu-accessibility\"\n    })}\n        <media-menu-items class=\"vds-menu-items\">\n          ${[\n      DefaultMenuSection({\n        children: [\n          DefaultAnnouncementsMenuCheckbox(),\n          DefaultKeyboardAnimationsMenuCheckbox()\n        ]\n      }),\n      DefaultMenuSection({\n        children: [DefaultFontMenu()]\n      })\n    ]}\n        </media-menu-items>\n      </media-menu>\n    `;\n  });\n}\nfunction DefaultAnnouncementsMenuCheckbox() {\n  const { userPrefersAnnouncements, translations } = useDefaultLayoutContext(), label = \"Announcements\";\n  return DefaultMenuItem({\n    label: $i18n(translations, label),\n    children: DefaultMenuCheckbox({\n      label,\n      storageKey: \"vds-player::announcements\",\n      onChange(checked) {\n        userPrefersAnnouncements.set(checked);\n      }\n    })\n  });\n}\nfunction DefaultKeyboardAnimationsMenuCheckbox() {\n  return $signal(() => {\n    const { translations, userPrefersKeyboardAnimations, noKeyboardAnimations } = useDefaultLayoutContext(), { viewType } = useMediaState(), $disabled = computed(() => viewType() !== \"video\" || noKeyboardAnimations());\n    if ($disabled()) return null;\n    const label = \"Keyboard Animations\";\n    return DefaultMenuItem({\n      label: $i18n(translations, label),\n      children: DefaultMenuCheckbox({\n        label,\n        defaultChecked: true,\n        storageKey: \"vds-player::keyboard-animations\",\n        onChange(checked) {\n          userPrefersKeyboardAnimations.set(checked);\n        }\n      })\n    });\n  });\n}\n\nfunction DefaultAudioMenu() {\n  return $signal(() => {\n    const { noAudioGain, translations } = useDefaultLayoutContext(), { audioTracks, canSetAudioGain } = useMediaState(), $disabled = computed(() => {\n      const hasGainSlider = canSetAudioGain() && !noAudioGain();\n      return !hasGainSlider && audioTracks().length <= 1;\n    });\n    if ($disabled()) return null;\n    return html`\n      <media-menu class=\"vds-audio-menu vds-menu\">\n        ${DefaultMenuButton({\n      label: () => i18n(translations, \"Audio\"),\n      icon: \"menu-audio\"\n    })}\n        <media-menu-items class=\"vds-menu-items\">\n          ${[DefaultAudioTracksMenu(), DefaultAudioBoostSection()]}\n        </media-menu-items>\n      </media-menu>\n    `;\n  });\n}\nfunction DefaultAudioTracksMenu() {\n  return $signal(() => {\n    const { translations } = useDefaultLayoutContext(), { audioTracks } = useMediaState(), $defaultText = $i18n(translations, \"Default\"), $disabled = computed(() => audioTracks().length <= 1);\n    if ($disabled()) return null;\n    return DefaultMenuSection({\n      children: html`\n        <media-menu class=\"vds-audio-tracks-menu vds-menu\">\n          ${DefaultMenuButton({\n        label: () => i18n(translations, \"Track\")\n      })}\n          <media-menu-items class=\"vds-menu-items\">\n            <media-audio-radio-group\n              class=\"vds-audio-track-radio-group vds-radio-group\"\n              empty-label=${$defaultText}\n            >\n              <template>\n                <media-radio class=\"vds-audio-track-radio vds-radio\">\n                  <slot name=\"menu-radio-check-icon\" data-class=\"vds-icon\"></slot>\n                  <span class=\"vds-radio-label\" data-part=\"label\"></span>\n                </media-radio>\n              </template>\n            </media-audio-radio-group>\n          </media-menu-items>\n        </media-menu>\n      `\n    });\n  });\n}\nfunction DefaultAudioBoostSection() {\n  return $signal(() => {\n    const { noAudioGain, translations } = useDefaultLayoutContext(), { canSetAudioGain } = useMediaState(), $disabled = computed(() => !canSetAudioGain() || noAudioGain());\n    if ($disabled()) return null;\n    const { audioGain } = useMediaState();\n    return DefaultMenuSection({\n      label: $i18n(translations, \"Boost\"),\n      value: $signal(() => Math.round(((audioGain() ?? 1) - 1) * 100) + \"%\"),\n      children: [\n        DefaultMenuSliderItem({\n          upIcon: \"menu-audio-boost-up\",\n          downIcon: \"menu-audio-boost-down\",\n          children: DefaultAudioGainSlider(),\n          isMin: () => ((audioGain() ?? 1) - 1) * 100 <= getGainMin(),\n          isMax: () => ((audioGain() ?? 1) - 1) * 100 === getGainMax()\n        })\n      ]\n    });\n  });\n}\nfunction DefaultAudioGainSlider() {\n  const { translations } = useDefaultLayoutContext(), $label = $i18n(translations, \"Boost\"), $min = getGainMin, $max = getGainMax, $step = getGainStep;\n  return html`\n    <media-audio-gain-slider\n      class=\"vds-audio-gain-slider vds-slider\"\n      aria-label=${$label}\n      min=${$signal($min)}\n      max=${$signal($max)}\n      step=${$signal($step)}\n      key-step=${$signal($step)}\n    >\n      ${DefaultSliderParts()}${DefaultSliderSteps()}\n    </media-audio-gain-slider>\n  `;\n}\nfunction getGainMin() {\n  const { audioGains } = useDefaultLayoutContext(), gains = audioGains();\n  return isArray(gains) ? gains[0] ?? 0 : gains.min;\n}\nfunction getGainMax() {\n  const { audioGains } = useDefaultLayoutContext(), gains = audioGains();\n  return isArray(gains) ? gains[gains.length - 1] ?? 300 : gains.max;\n}\nfunction getGainStep() {\n  const { audioGains } = useDefaultLayoutContext(), gains = audioGains();\n  return isArray(gains) ? gains[1] - gains[0] || 25 : gains.step;\n}\n\nfunction DefaultCaptionsMenu() {\n  return $signal(() => {\n    const { translations } = useDefaultLayoutContext(), { hasCaptions } = useMediaState(), $offText = $i18n(translations, \"Off\");\n    if (!hasCaptions()) return null;\n    return html`\n      <media-menu class=\"vds-captions-menu vds-menu\">\n        ${DefaultMenuButton({\n      label: () => i18n(translations, \"Captions\"),\n      icon: \"menu-captions\"\n    })}\n        <media-menu-items class=\"vds-menu-items\">\n          <media-captions-radio-group\n            class=\"vds-captions-radio-group vds-radio-group\"\n            off-label=${$offText}\n          >\n            <template>\n              <media-radio class=\"vds-caption-radio vds-radio\">\n                <slot name=\"menu-radio-check-icon\" data-class=\"vds-icon\"></slot>\n                <span class=\"vds-radio-label\" data-part=\"label\"></span>\n              </media-radio>\n            </template>\n          </media-captions-radio-group>\n        </media-menu-items>\n      </media-menu>\n    `;\n  });\n}\n\nfunction DefaultPlaybackMenu() {\n  return $signal(() => {\n    const { translations } = useDefaultLayoutContext();\n    return html`\n      <media-menu class=\"vds-playback-menu vds-menu\">\n        ${DefaultMenuButton({\n      label: () => i18n(translations, \"Playback\"),\n      icon: \"menu-playback\"\n    })}\n        <media-menu-items class=\"vds-menu-items\">\n          ${[\n      DefaultMenuSection({\n        children: DefaultLoopCheckbox()\n      }),\n      DefaultSpeedMenuSection(),\n      DefaultQualityMenuSection()\n    ]}\n        </media-menu-items>\n      </media-menu>\n    `;\n  });\n}\nfunction DefaultLoopCheckbox() {\n  const { remote } = useMediaContext(), { translations } = useDefaultLayoutContext(), label = \"Loop\";\n  return DefaultMenuItem({\n    label: $i18n(translations, label),\n    children: DefaultMenuCheckbox({\n      label,\n      storageKey: \"vds-player::user-loop\",\n      onChange(checked, trigger) {\n        remote.userPrefersLoopChange(checked, trigger);\n      }\n    })\n  });\n}\nfunction DefaultSpeedMenuSection() {\n  return $signal(() => {\n    const { translations } = useDefaultLayoutContext(), { canSetPlaybackRate, playbackRate } = useMediaState();\n    if (!canSetPlaybackRate()) return null;\n    return DefaultMenuSection({\n      label: $i18n(translations, \"Speed\"),\n      value: $signal(\n        () => playbackRate() === 1 ? i18n(translations, \"Normal\") : playbackRate() + \"x\"\n      ),\n      children: [\n        DefaultMenuSliderItem({\n          upIcon: \"menu-speed-up\",\n          downIcon: \"menu-speed-down\",\n          children: DefaultSpeedSlider(),\n          isMin: () => playbackRate() === getSpeedMin(),\n          isMax: () => playbackRate() === getSpeedMax()\n        })\n      ]\n    });\n  });\n}\nfunction getSpeedMin() {\n  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates();\n  return isArray(rates) ? rates[0] ?? 0 : rates.min;\n}\nfunction getSpeedMax() {\n  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates();\n  return isArray(rates) ? rates[rates.length - 1] ?? 2 : rates.max;\n}\nfunction getSpeedStep() {\n  const { playbackRates } = useDefaultLayoutContext(), rates = playbackRates();\n  return isArray(rates) ? rates[1] - rates[0] || 0.25 : rates.step;\n}\nfunction DefaultSpeedSlider() {\n  const { translations } = useDefaultLayoutContext(), $label = $i18n(translations, \"Speed\"), $min = getSpeedMin, $max = getSpeedMax, $step = getSpeedStep;\n  return html`\n    <media-speed-slider\n      class=\"vds-speed-slider vds-slider\"\n      aria-label=${$label}\n      min=${$signal($min)}\n      max=${$signal($max)}\n      step=${$signal($step)}\n      key-step=${$signal($step)}\n    >\n      ${DefaultSliderParts()}${DefaultSliderSteps()}\n    </media-speed-slider>\n  `;\n}\nfunction DefaultAutoQualityCheckbox() {\n  const { remote, qualities } = useMediaContext(), { autoQuality, canSetQuality, qualities: $qualities } = useMediaState(), { translations } = useDefaultLayoutContext(), label = \"Auto\", $disabled = computed(() => !canSetQuality() || $qualities().length <= 1);\n  if ($disabled()) return null;\n  return DefaultMenuItem({\n    label: $i18n(translations, label),\n    children: DefaultMenuCheckbox({\n      label,\n      checked: autoQuality,\n      onChange(checked, trigger) {\n        if (checked) {\n          remote.requestAutoQuality(trigger);\n        } else {\n          remote.changeQuality(qualities.selectedIndex, trigger);\n        }\n      }\n    })\n  });\n}\nfunction DefaultQualityMenuSection() {\n  return $signal(() => {\n    const { hideQualityBitrate, translations } = useDefaultLayoutContext(), { canSetQuality, qualities, quality } = useMediaState(), $disabled = computed(() => !canSetQuality() || qualities().length <= 1), $sortedQualities = computed(() => sortVideoQualities(qualities()));\n    if ($disabled()) return null;\n    return DefaultMenuSection({\n      label: $i18n(translations, \"Quality\"),\n      value: $signal(() => {\n        const height = quality()?.height, bitrate = !hideQualityBitrate() ? quality()?.bitrate : null, bitrateText = bitrate && bitrate > 0 ? `${(bitrate / 1e6).toFixed(2)} Mbps` : null, autoText = i18n(translations, \"Auto\");\n        return height ? `${height}p${bitrateText ? ` (${bitrateText})` : \"\"}` : autoText;\n      }),\n      children: [\n        DefaultMenuSliderItem({\n          upIcon: \"menu-quality-up\",\n          downIcon: \"menu-quality-down\",\n          children: DefaultQualitySlider(),\n          isMin: () => $sortedQualities()[0] === quality(),\n          isMax: () => $sortedQualities().at(-1) === quality()\n        }),\n        DefaultAutoQualityCheckbox()\n      ]\n    });\n  });\n}\nfunction DefaultQualitySlider() {\n  const { translations } = useDefaultLayoutContext(), $label = $i18n(translations, \"Quality\");\n  return html`\n    <media-quality-slider class=\"vds-quality-slider vds-slider\" aria-label=${$label}>\n      ${DefaultSliderParts()}${DefaultSliderSteps()}\n    </media-quality-slider>\n  `;\n}\n\nfunction DefaultSettingsMenu({\n  placement,\n  portal,\n  tooltip\n}) {\n  return $signal(() => {\n    const { viewType } = useMediaState(), {\n      translations,\n      menuPortal,\n      noModal,\n      menuGroup,\n      smallWhen: smWhen\n    } = useDefaultLayoutContext(), $placement = computed(\n      () => noModal() ? unwrap(placement) : !smWhen() ? unwrap(placement) : null\n    ), $offset = computed(\n      () => !smWhen() && menuGroup() === \"bottom\" && viewType() === \"video\" ? 26 : 0\n    ), $isOpen = signal(false);\n    updateFontCssVars();\n    function onOpen() {\n      $isOpen.set(true);\n    }\n    function onClose() {\n      $isOpen.set(false);\n    }\n    const items = html`\n      <media-menu-items\n        class=\"vds-settings-menu-items vds-menu-items\"\n        placement=${$signal($placement)}\n        offset=${$signal($offset)}\n      >\n        ${$signal(() => {\n      if (!$isOpen()) {\n        return null;\n      }\n      return [\n        DefaultPlaybackMenu(),\n        DefaultAccessibilityMenu(),\n        DefaultAudioMenu(),\n        DefaultCaptionsMenu()\n      ];\n    })}\n      </media-menu-items>\n    `;\n    return html`\n      <media-menu class=\"vds-settings-menu vds-menu\" @open=${onOpen} @close=${onClose}>\n        <media-tooltip class=\"vds-tooltip\">\n          <media-tooltip-trigger>\n            <media-menu-button\n              class=\"vds-menu-button vds-button\"\n              aria-label=${$i18n(translations, \"Settings\")}\n            >\n              ${IconSlot(\"menu-settings\", \"vds-rotate-icon\")}\n            </media-menu-button>\n          </media-tooltip-trigger>\n          <media-tooltip-content\n            class=\"vds-tooltip-content\"\n            placement=${isFunction(tooltip) ? $signal(tooltip) : tooltip}\n          >\n            ${$i18n(translations, \"Settings\")}\n          </media-tooltip-content>\n        </media-tooltip>\n        ${portal ? MenuPortal(menuPortal, items) : items}\n      </media-menu>\n    `;\n  });\n}\n\nfunction DefaultVolumePopup({\n  orientation,\n  tooltip\n}) {\n  return $signal(() => {\n    const { pointer, muted, canSetVolume } = useMediaState();\n    if (pointer() === \"coarse\" && !muted()) return null;\n    if (!canSetVolume()) {\n      return DefaultMuteButton({ tooltip });\n    }\n    const $rootRef = signal(void 0), $isRootActive = useActive($rootRef);\n    return html`\n      <div class=\"vds-volume\" ?data-active=${$signal($isRootActive)} ${ref($rootRef.set)}>\n        ${DefaultMuteButton({ tooltip })}\n        <div class=\"vds-volume-popup\">${DefaultVolumeSlider({ orientation })}</div>\n      </div>\n    `;\n  });\n}\nfunction DefaultVolumeSlider({ orientation } = {}) {\n  const { translations } = useDefaultLayoutContext(), $label = $i18n(translations, \"Volume\");\n  return html`\n    <media-volume-slider\n      class=\"vds-volume-slider vds-slider\"\n      aria-label=${$label}\n      orientation=${ifDefined(orientation)}\n    >\n      <div class=\"vds-slider-track\"></div>\n      <div class=\"vds-slider-track-fill vds-slider-track\"></div>\n      <media-slider-preview class=\"vds-slider-preview\" no-clamp>\n        <media-slider-value class=\"vds-slider-value\"></media-slider-value>\n      </media-slider-preview>\n      <div class=\"vds-slider-thumb\"></div>\n    </media-volume-slider>\n  `;\n}\nfunction DefaultTimeSlider() {\n  const $ref = signal(void 0), $width = signal(0), {\n    thumbnails,\n    translations,\n    sliderChaptersMinWidth,\n    disableTimeSlider,\n    seekStep,\n    noScrubGesture\n  } = useDefaultLayoutContext(), $label = $i18n(translations, \"Seek\"), $isDisabled = $signal(disableTimeSlider), $isChaptersDisabled = $signal(() => $width() < sliderChaptersMinWidth()), $thumbnails = $signal(thumbnails);\n  useResizeObserver($ref, () => {\n    const el = $ref();\n    el && $width.set(el.clientWidth);\n  });\n  return html`\n    <media-time-slider\n      class=\"vds-time-slider vds-slider\"\n      aria-label=${$label}\n      key-step=${$signal(seekStep)}\n      ?disabled=${$isDisabled}\n      ?no-swipe-gesture=${$signal(noScrubGesture)}\n      ${ref($ref.set)}\n    >\n      <media-slider-chapters class=\"vds-slider-chapters\" ?disabled=${$isChaptersDisabled}>\n        <template>\n          <div class=\"vds-slider-chapter\">\n            <div class=\"vds-slider-track\"></div>\n            <div class=\"vds-slider-track-fill vds-slider-track\"></div>\n            <div class=\"vds-slider-progress vds-slider-track\"></div>\n          </div>\n        </template>\n      </media-slider-chapters>\n      <div class=\"vds-slider-thumb\"></div>\n      <media-slider-preview class=\"vds-slider-preview\">\n        <media-slider-thumbnail\n          class=\"vds-slider-thumbnail vds-thumbnail\"\n          .src=${$thumbnails}\n        ></media-slider-thumbnail>\n        <div class=\"vds-slider-chapter-title\" data-part=\"chapter-title\"></div>\n        <media-slider-value class=\"vds-slider-value\"></media-slider-value>\n      </media-slider-preview>\n    </media-time-slider>\n  `;\n}\n\nfunction DefaultTimeGroup() {\n  return html`\n    <div class=\"vds-time-group\">\n      ${$signal(() => {\n    const { duration } = useMediaState();\n    if (!duration()) return null;\n    return [\n      html`<media-time class=\"vds-time\" type=\"current\"></media-time>`,\n      html`<div class=\"vds-time-divider\">/</div>`,\n      html`<media-time class=\"vds-time\" type=\"duration\"></media-time>`\n    ];\n  })}\n    </div>\n  `;\n}\nfunction DefaultTimeInvert() {\n  return $signal(() => {\n    const { live, duration } = useMediaState();\n    return live() ? DefaultLiveButton() : duration() ? html`<media-time class=\"vds-time\" type=\"current\" toggle remainder></media-time>` : null;\n  });\n}\nfunction DefaultTimeInfo() {\n  return $signal(() => {\n    const { live } = useMediaState();\n    return live() ? DefaultLiveButton() : DefaultTimeGroup();\n  });\n}\n\nfunction DefaultTitle() {\n  return $signal(() => {\n    const { textTracks } = useMediaContext(), { title, started } = useMediaState(), $hasChapters = signal(null);\n    watchActiveTextTrack(textTracks, \"chapters\", $hasChapters.set);\n    return $hasChapters() && (started() || !title()) ? DefaultChapterTitle() : html`<media-title class=\"vds-chapter-title\"></media-title>`;\n  });\n}\nfunction DefaultChapterTitle() {\n  return html`<media-chapter-title class=\"vds-chapter-title\"></media-chapter-title>`;\n}\n\nclass DefaultLayoutIconsLoader extends LayoutIconsLoader {\n  async loadIcons() {\n    const paths = (await import('./vidstack-EJfqPvHB.js')).icons, icons = {};\n    for (const iconName of Object.keys(paths)) {\n      icons[iconName] = Icon({ name: iconName, paths: paths[iconName] });\n    }\n    return icons;\n  }\n}\n\nexport { DefaultAirPlayButton, DefaultAnnouncer, DefaultCaptionButton, DefaultCaptions, DefaultChapterTitle, DefaultChaptersMenu, DefaultControlsSpacer, DefaultDownloadButton, DefaultFullscreenButton, DefaultGoogleCastButton, DefaultLayout, DefaultLayoutIconsLoader, DefaultPIPButton, DefaultPlayButton, DefaultSeekButton, DefaultSettingsMenu, DefaultTimeInfo, DefaultTimeInvert, DefaultTimeSlider, DefaultTitle, DefaultVolumePopup, createMenuContainer, i18n, setLayoutName, useDefaultLayoutContext };\n","import { Host, effect, setAttribute, isString, useState, BOOLEAN } from './vidstack-DVpy0IqK.js';\nimport { Thumbnail, Time, AirPlayButton, CaptionButton, FullscreenButton, LiveButton, MuteButton, PIPButton, PlayButton, SeekButton, AudioRadioGroup, CaptionsRadioGroup, Menu, MenuButton, MenuItem, MenuItems, SpeedRadioGroup, QualityRadioGroup, Slider, SliderValue, TimeSlider, SliderPreview, VolumeSlider } from './vidstack-CWb-Pl1C.js';\nimport { cloneTemplateContent, createTemplate, requestScopedAnimationFrame, cloneTemplate } from './vidstack-CGUlKgT8.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\n\nconst imgTemplate = /* @__PURE__ */ createTemplate(\n  '<img loading=\"eager\" decoding=\"async\" aria-hidden=\"true\">'\n);\nclass MediaThumbnailElement extends Host(HTMLElement, Thumbnail) {\n  static tagName = \"media-thumbnail\";\n  static attrs = {\n    crossOrigin: \"crossorigin\"\n  };\n  #media;\n  #img = this.#createImg();\n  onSetup() {\n    this.#media = useMediaContext();\n    this.$state.img.set(this.#img);\n  }\n  onConnect() {\n    const { src, crossOrigin } = this.$state;\n    if (this.#img.parentNode !== this) {\n      this.prepend(this.#img);\n    }\n    effect(() => {\n      setAttribute(this.#img, \"src\", src());\n      setAttribute(this.#img, \"crossorigin\", crossOrigin());\n    });\n  }\n  #createImg() {\n    return cloneTemplateContent(imgTemplate);\n  }\n}\n\nclass MediaTimeElement extends Host(HTMLElement, Time) {\n  static tagName = \"media-time\";\n  onConnect() {\n    effect(() => {\n      this.textContent = this.$state.timeText();\n    });\n  }\n}\n\nclass MediaAirPlayButtonElement extends Host(HTMLElement, AirPlayButton) {\n  static tagName = \"media-airplay-button\";\n}\n\nclass MediaCaptionButtonElement extends Host(HTMLElement, CaptionButton) {\n  static tagName = \"media-caption-button\";\n}\n\nclass MediaFullscreenButtonElement extends Host(HTMLElement, FullscreenButton) {\n  static tagName = \"media-fullscreen-button\";\n}\n\nclass MediaLiveButtonElement extends Host(HTMLElement, LiveButton) {\n  static tagName = \"media-live-button\";\n}\n\nclass MediaMuteButtonElement extends Host(HTMLElement, MuteButton) {\n  static tagName = \"media-mute-button\";\n}\n\nclass MediaPIPButtonElement extends Host(HTMLElement, PIPButton) {\n  static tagName = \"media-pip-button\";\n}\n\nclass MediaPlayButtonElement extends Host(HTMLElement, PlayButton) {\n  static tagName = \"media-play-button\";\n}\n\nclass MediaSeekButtonElement extends Host(HTMLElement, SeekButton) {\n  static tagName = \"media-seek-button\";\n}\n\nfunction renderMenuItemsTemplate(el, onCreate) {\n  requestScopedAnimationFrame(() => {\n    if (!el.connectScope) return;\n    const template = el.querySelector(\"template\");\n    if (!template) return;\n    effect(() => {\n      if (!template.content.firstElementChild?.localName && !template.firstElementChild) {\n        throw Error(\"[vidstack] menu items template requires root element\");\n      }\n      const options = el.getOptions();\n      cloneTemplate(template, options.length, (radio, i) => {\n        const { label, value } = options[i], labelEl = radio.querySelector(`[data-part=\"label\"]`);\n        radio.setAttribute(\"value\", value);\n        if (labelEl) {\n          if (isString(label)) {\n            labelEl.textContent = label;\n          } else {\n            effect(() => {\n              labelEl.textContent = label();\n            });\n          }\n        }\n        onCreate?.(radio, options[i], i);\n      });\n    });\n  });\n}\n\nclass MediaAudioRadioGroupElement extends Host(HTMLElement, AudioRadioGroup) {\n  static tagName = \"media-audio-radio-group\";\n  onConnect() {\n    renderMenuItemsTemplate(this);\n  }\n}\n\nclass MediaCaptionsRadioGroupElement extends Host(HTMLElement, CaptionsRadioGroup) {\n  static tagName = \"media-captions-radio-group\";\n  onConnect() {\n    renderMenuItemsTemplate(this);\n  }\n}\n\nclass MediaMenuElement extends Host(HTMLElement, Menu) {\n  static tagName = \"media-menu\";\n}\n\nclass MediaMenuButtonElement extends Host(HTMLElement, MenuButton) {\n  static tagName = \"media-menu-button\";\n}\n\nclass MediaMenuItemElement extends Host(HTMLElement, MenuItem) {\n  static tagName = \"media-menu-item\";\n}\n\nclass MediaMenuItemsElement extends Host(HTMLElement, MenuItems) {\n  static tagName = \"media-menu-items\";\n}\n\nclass MediaSpeedRadioGroupElement extends Host(HTMLElement, SpeedRadioGroup) {\n  static tagName = \"media-speed-radio-group\";\n  onConnect() {\n    renderMenuItemsTemplate(this);\n  }\n}\n\nclass MediaQualityRadioGroupElement extends Host(HTMLElement, QualityRadioGroup) {\n  static tagName = \"media-quality-radio-group\";\n  onConnect() {\n    renderMenuItemsTemplate(this, (el, option) => {\n      const bitrate = option.bitrate, bitrateEl = el.querySelector('[data-part=\"bitrate\"]');\n      if (bitrate && bitrateEl) {\n        effect(() => {\n          bitrateEl.textContent = bitrate() || \"\";\n        });\n      }\n    });\n  }\n}\n\nclass MediaSliderThumbnailElement extends MediaThumbnailElement {\n  static tagName = \"media-slider-thumbnail\";\n  #media;\n  #slider;\n  onSetup() {\n    super.onSetup();\n    this.#media = useMediaContext();\n    this.#slider = useState(Slider.state);\n  }\n  onConnect() {\n    super.onConnect();\n    effect(this.#watchTime.bind(this));\n  }\n  #watchTime() {\n    const { duration, clipStartTime } = this.#media.$state;\n    this.time = clipStartTime() + this.#slider.pointerRate() * duration();\n  }\n}\n\nclass MediaSliderValueElement extends Host(HTMLElement, SliderValue) {\n  static tagName = \"media-slider-value\";\n  static attrs = {\n    padMinutes: {\n      converter: BOOLEAN\n    }\n  };\n  onConnect() {\n    effect(() => {\n      this.textContent = this.getValueText();\n    });\n  }\n}\n\nclass MediaTimeSliderElement extends Host(HTMLElement, TimeSlider) {\n  static tagName = \"media-time-slider\";\n}\n\nclass MediaSliderPreviewElement extends Host(HTMLElement, SliderPreview) {\n  static tagName = \"media-slider-preview\";\n}\n\nclass MediaVolumeSliderElement extends Host(HTMLElement, VolumeSlider) {\n  static tagName = \"media-volume-slider\";\n}\n\nexport { MediaAirPlayButtonElement, MediaAudioRadioGroupElement, MediaCaptionButtonElement, MediaCaptionsRadioGroupElement, MediaFullscreenButtonElement, MediaLiveButtonElement, MediaMenuButtonElement, MediaMenuElement, MediaMenuItemElement, MediaMenuItemsElement, MediaMuteButtonElement, MediaPIPButtonElement, MediaPlayButtonElement, MediaQualityRadioGroupElement, MediaSeekButtonElement, MediaSliderPreviewElement, MediaSliderThumbnailElement, MediaSliderValueElement, MediaSpeedRadioGroupElement, MediaThumbnailElement, MediaTimeElement, MediaTimeSliderElement, MediaVolumeSliderElement, renderMenuItemsTemplate };\n","import { computed, peek, effect, onDispose, isDOMNode, animationFrameThrottle, isString } from './vidstack-DVpy0IqK.js';\nimport { nothing, render, html } from 'lit-html';\nimport { ifDefined } from 'lit-html/directives/if-defined.js';\nimport { unsafeSVG } from 'lit-html/directives/unsafe-svg.js';\nimport { directive, AsyncDirective, PartType } from 'lit-html/async-directive.js';\nimport { useMediaContext } from './vidstack-CUYciP40.js';\n\nclass SignalDirective extends AsyncDirective {\n  #signal = null;\n  #isAttr = false;\n  #stop = null;\n  constructor(part) {\n    super(part);\n    this.#isAttr = part.type === PartType.ATTRIBUTE || part.type === PartType.BOOLEAN_ATTRIBUTE;\n  }\n  render(signal) {\n    if (signal !== this.#signal) {\n      this.disconnected();\n      this.#signal = signal;\n      if (this.isConnected) this.#watch();\n    }\n    return this.#signal ? this.#resolveValue(peek(this.#signal)) : nothing;\n  }\n  reconnected() {\n    this.#watch();\n  }\n  disconnected() {\n    this.#stop?.();\n    this.#stop = null;\n  }\n  #watch() {\n    if (!this.#signal) return;\n    this.#stop = effect(this.#onValueChange.bind(this));\n  }\n  #resolveValue(value) {\n    return this.#isAttr ? ifDefined(value) : value;\n  }\n  #setValue(value) {\n    this.setValue(this.#resolveValue(value));\n  }\n  #onValueChange() {\n    {\n      try {\n        this.#setValue(this.#signal?.());\n      } catch (error) {\n        if (error instanceof Error && error.message.includes(\"This `ChildPart` has no `parentNode`\")) {\n          const svelteDynamicImportExample = [\n            \"{#await import('./Player.svelte') then {default: Player}}\",\n            \"  <svelte:component this={Player} />\",\n            \"{/await}\"\n          ].join(\"\\n\");\n          console.warn(\n            `[vidstack] Failed to render most likely due to a hydration issue with your framework. Dynamically importing the player should resolve the issue.\n\nSvelte Example:\n\n${svelteDynamicImportExample}`\n          );\n        } else {\n          console.error(error);\n        }\n      }\n    }\n  }\n}\nfunction $signal(compute) {\n  return directive(SignalDirective)(computed(compute));\n}\n\nclass SlotObserver {\n  #roots;\n  #callback;\n  elements = /* @__PURE__ */ new Set();\n  constructor(roots, callback) {\n    this.#roots = roots;\n    this.#callback = callback;\n  }\n  connect() {\n    this.#update();\n    const observer = new MutationObserver(this.#onMutation);\n    for (const root of this.#roots) observer.observe(root, { childList: true, subtree: true });\n    onDispose(() => observer.disconnect());\n    onDispose(this.disconnect.bind(this));\n  }\n  disconnect() {\n    this.elements.clear();\n  }\n  assign(template, slot) {\n    if (isDOMNode(template)) {\n      slot.textContent = \"\";\n      slot.append(template);\n    } else {\n      render(null, slot);\n      render(template, slot);\n    }\n    if (!slot.style.display) {\n      slot.style.display = \"contents\";\n    }\n    const el = slot.firstElementChild;\n    if (!el) return;\n    const classList = slot.getAttribute(\"data-class\");\n    if (classList) el.classList.add(...classList.split(\" \"));\n  }\n  #onMutation = animationFrameThrottle(this.#update.bind(this));\n  #update(entries) {\n    if (entries && !entries.some((e) => e.addedNodes.length)) return;\n    let changed = false, slots = this.#roots.flatMap((root) => [...root.querySelectorAll(\"slot\")]);\n    for (const slot of slots) {\n      if (!slot.hasAttribute(\"name\") || this.elements.has(slot)) continue;\n      this.elements.add(slot);\n      changed = true;\n    }\n    if (changed) this.#callback(this.elements);\n  }\n}\n\nlet id = 0, slotIdAttr = \"data-slot-id\";\nclass SlotManager {\n  #roots;\n  slots;\n  constructor(roots) {\n    this.#roots = roots;\n    this.slots = new SlotObserver(roots, this.#update.bind(this));\n  }\n  connect() {\n    this.slots.connect();\n    this.#update();\n    const mutations = new MutationObserver(this.#onMutation);\n    for (const root of this.#roots) mutations.observe(root, { childList: true });\n    onDispose(() => mutations.disconnect());\n  }\n  #onMutation = animationFrameThrottle(this.#update.bind(this));\n  #update() {\n    for (const root of this.#roots) {\n      for (const node of root.children) {\n        if (node.nodeType !== 1) continue;\n        const name = node.getAttribute(\"slot\");\n        if (!name) continue;\n        node.style.display = \"none\";\n        let slotId = node.getAttribute(slotIdAttr);\n        if (!slotId) {\n          node.setAttribute(slotIdAttr, slotId = ++id + \"\");\n        }\n        for (const slot of this.slots.elements) {\n          if (slot.getAttribute(\"name\") !== name || slot.getAttribute(slotIdAttr) === slotId) {\n            continue;\n          }\n          const clone = document.importNode(node, true);\n          if (name.includes(\"-icon\")) clone.classList.add(\"vds-icon\");\n          clone.style.display = \"\";\n          clone.removeAttribute(\"slot\");\n          this.slots.assign(clone, slot);\n          slot.setAttribute(slotIdAttr, slotId);\n        }\n      }\n    }\n  }\n}\n\nfunction Icon({ name, class: _class, state, paths, viewBox = \"0 0 32 32\" }) {\n  return html`<svg\n    class=\"${\"vds-icon\" + (_class ? ` ${_class}` : \"\")}\"\n    viewBox=\"${viewBox}\"\n    fill=\"none\"\n    aria-hidden=\"true\"\n    focusable=\"false\"\n    xmlns=\"http://www.w3.org/2000/svg\"\n    data-icon=${ifDefined(name ?? state)}\n  >\n    ${!isString(paths) ? $signal(paths) : unsafeSVG(paths)}\n  </svg>`;\n}\n\nclass IconsLoader {\n  #icons = {};\n  #loaded = false;\n  slots;\n  constructor(roots) {\n    this.slots = new SlotObserver(roots, this.#insertIcons.bind(this));\n  }\n  connect() {\n    this.slots.connect();\n  }\n  load() {\n    this.loadIcons().then((icons) => {\n      this.#icons = icons;\n      this.#loaded = true;\n      this.#insertIcons();\n    });\n  }\n  *#iterate() {\n    for (const iconName of Object.keys(this.#icons)) {\n      const slotName = `${iconName}-icon`;\n      for (const slot of this.slots.elements) {\n        if (slot.name !== slotName) continue;\n        yield { icon: this.#icons[iconName], slot };\n      }\n    }\n  }\n  #insertIcons() {\n    if (!this.#loaded) return;\n    for (const { icon, slot } of this.#iterate()) {\n      this.slots.assign(icon, slot);\n    }\n  }\n}\n\nclass LayoutIconsLoader extends IconsLoader {\n  connect() {\n    super.connect();\n    const { player } = useMediaContext();\n    if (!player.el) return;\n    let dispose, observer = new IntersectionObserver((entries) => {\n      if (!entries[0]?.isIntersecting) return;\n      dispose?.();\n      dispose = void 0;\n      this.load();\n    });\n    observer.observe(player.el);\n    dispose = onDispose(() => observer.disconnect());\n  }\n}\n\nexport { $signal, Icon, LayoutIconsLoader, SlotManager };\n","import { html } from 'lit-html';\nimport { computed, signal, effect, listenEvent, peek, isKeyboardEvent, isKeyboardClick, Host, onDispose } from '../../chunks/vidstack-DVpy0IqK.js';\nimport { usePlyrLayoutContext, usePlyrLayoutClasses, PlyrLayout } from '../../chunks/vidstack-CuDKkHai.js';\nimport { useMediaContext } from '../../chunks/vidstack-CUYciP40.js';\nimport { LayoutIconsLoader, Icon, $signal, SlotManager } from '../../chunks/vidstack-mJNGvZNe.js';\nimport { LitElement } from '../../chunks/vidstack-CwTj4H1w.js';\nimport { unsafeHTML } from 'lit-html/directives/unsafe-html.js';\nimport { getDownloadFile } from '../../chunks/vidstack-BgIVvpNy.js';\nimport 'lit-html/directives/if-defined.js';\nimport 'lit-html/directives/unsafe-svg.js';\nimport 'lit-html/async-directive.js';\nimport '../../chunks/vidstack-CrZuJYaH.js';\n\nclass PlyrLayoutIconsLoader extends LayoutIconsLoader {\n  async loadIcons() {\n    const paths = (await import('../../chunks/vidstack-DXxIKXmd.js')).icons, icons = {};\n    for (const iconName of Object.keys(paths)) {\n      icons[iconName] = Icon({\n        name: iconName,\n        paths: paths[iconName],\n        viewBox: \"0 0 18 18\"\n      });\n    }\n    return icons;\n  }\n}\n\nfunction i18n(translations, word) {\n  return translations()?.[word] ?? word;\n}\n\nfunction PlyrAudioLayout() {\n  return AudioControls();\n}\nfunction PlyrVideoLayout() {\n  const media = useMediaContext(), { load } = media.$props, { canLoad } = media.$state, showLoadScreen = computed(() => load() === \"play\" && !canLoad());\n  if (showLoadScreen()) {\n    return [PlayLargeButton(), Poster()];\n  }\n  return [\n    OptionalPlayLarge(),\n    PreviewScrubbing(),\n    Poster(),\n    VideoControls(),\n    Gestures(),\n    Captions()\n  ];\n}\nfunction PlayLargeButton() {\n  const media = useMediaContext(), { translations } = usePlyrLayoutContext(), { title } = media.$state, $label = $signal(() => `${i18n(translations, \"Play\")}, ${title()}`);\n  return html`\n    <media-play-button\n      class=\"plyr__control plyr__control--overlaid\"\n      aria-label=${$label}\n      data-plyr=\"play\"\n    >\n      <slot name=\"play-icon\"></slot>\n    </button>\n  `;\n}\nfunction OptionalPlayLarge() {\n  const { controls } = usePlyrLayoutContext();\n  return $signal(() => controls().includes(\"play-large\") ? PlayLargeButton() : null);\n}\nfunction PreviewScrubbing() {\n  const { thumbnails, previewTime } = usePlyrLayoutContext();\n  return html`\n    <media-thumbnail\n      .src=${$signal(thumbnails)}\n      class=\"plyr__preview-scrubbing\"\n      time=${$signal(() => previewTime())}\n    ></media-thumbnail>\n  `;\n}\nfunction Poster() {\n  const media = useMediaContext(), { poster } = media.$state, $style = $signal(() => `background-image: url(\"${poster()}\");`);\n  return html`<div class=\"plyr__poster\" style=${$style}></div>`;\n}\nfunction AudioControls() {\n  const ignore = /* @__PURE__ */ new Set([\"captions\", \"pip\", \"airplay\", \"fullscreen\"]), { controls } = usePlyrLayoutContext(), $controls = $signal(\n    () => controls().filter((type) => !ignore.has(type)).map(Control)\n  );\n  return html`<div class=\"plyr__controls\">${$controls}</div>`;\n}\nfunction VideoControls() {\n  const { controls } = usePlyrLayoutContext(), $controls = $signal(() => controls().map(Control));\n  return html`<div class=\"plyr__controls\">${$controls}</div>`;\n}\nfunction Control(type) {\n  switch (type) {\n    case \"airplay\":\n      return AirPlayButton();\n    case \"captions\":\n      return CaptionsButton();\n    case \"current-time\":\n      return CurrentTime();\n    case \"download\":\n      return DownloadButton();\n    case \"duration\":\n      return Duration();\n    case \"fast-forward\":\n      return FastForwardButton();\n    case \"fullscreen\":\n      return FullscreenButton();\n    case \"mute\":\n    case \"volume\":\n    case \"mute+volume\":\n      return Volume(type);\n    case \"pip\":\n      return PIPButton();\n    case \"play\":\n      return PlayButton();\n    case \"progress\":\n      return TimeSlider();\n    case \"restart\":\n      return RestartButton();\n    case \"rewind\":\n      return RewindButton();\n    case \"settings\":\n      return Settings();\n    default:\n      return null;\n  }\n}\nfunction AirPlayButton() {\n  const { translations } = usePlyrLayoutContext();\n  return html`\n    <media-airplay-button class=\"plyr__controls__item plyr__control\" data-plyr=\"airplay\">\n      <slot name=\"airplay-icon\"></slot>\n      <span class=\"plyr__tooltip\">${$i18n(translations, \"AirPlay\")}</span>\n    </media-airplay-button>\n  `;\n}\nfunction CaptionsButton() {\n  const { translations } = usePlyrLayoutContext(), $disableText = $i18n(translations, \"Disable captions\"), $enableText = $i18n(translations, \"Enable captions\");\n  return html`\n    <media-caption-button\n      class=\"plyr__controls__item plyr__control\"\n      data-no-label\n      data-plyr=\"captions\"\n    >\n      <slot name=\"captions-on-icon\" data-class=\"icon--pressed\"></slot>\n      <slot name=\"captions-off-icon\" data-class=\"icon--not-pressed\"></slot>\n      <span class=\"label--pressed plyr__tooltip\">${$disableText}</span>\n      <span class=\"label--not-pressed plyr__tooltip\">${$enableText}</span>\n    </media-caption-button>\n  `;\n}\nfunction FullscreenButton() {\n  const { translations } = usePlyrLayoutContext(), $enterText = $i18n(translations, \"Enter Fullscreen\"), $exitText = $i18n(translations, \"Exit Fullscreen\");\n  return html`\n    <media-fullscreen-button\n      class=\"plyr__controls__item plyr__control\"\n      data-no-label\n      data-plyr=\"fullscreen\"\n    >\n      <slot name=\"enter-fullscreen-icon\" data-class=\"icon--pressed\"></slot>\n      <slot name=\"exit-fullscreen-icon\" data-class=\"icon--not-pressed\"></slot>\n      <span class=\"label--pressed plyr__tooltip\">${$exitText}</span>\n      <span class=\"label--not-pressed plyr__tooltip\">${$enterText}</span>\n    </media-fullscreen-button>\n  `;\n}\nfunction MuteButton() {\n  const { translations } = usePlyrLayoutContext(), $muteText = $i18n(translations, \"Mute\"), $unmuteText = $i18n(translations, \"Unmute\");\n  return html`\n    <media-mute-button class=\"plyr__control\" data-no-label data-plyr=\"mute\">\n      <slot name=\"muted-icon\" data-class=\"icon--pressed\"></slot>\n      <slot name=\"volume-icon\" data-class=\"icon--not-pressed\"></slot>\n      <span class=\"label--pressed plyr__tooltip\">${$unmuteText}</span>\n      <span class=\"label--not-pressed plyr__tooltip\">${$muteText}</span>\n    </media-mute-button>\n  `;\n}\nfunction PIPButton() {\n  const { translations } = usePlyrLayoutContext(), $enterText = $i18n(translations, \"Enter PiP\"), $exitText = $i18n(translations, \"Exit PiP\");\n  return html`\n    <media-pip-button class=\"plyr__controls__item plyr__control\" data-no-label data-plyr=\"pip\">\n      <slot name=\"pip-icon\"></slot>\n      <slot name=\"enter-pip-icon\" data-class=\"icon--pressed\"></slot>\n      <slot name=\"exit-pip-icon\" data-class=\"icon--not-pressed\"></slot>\n      <span class=\"label--pressed plyr__tooltip\">${$exitText}</span>\n      <span class=\"label--not-pressed plyr__tooltip\">${$enterText}</span>\n    </media-pip-button>\n  `;\n}\nfunction PlayButton() {\n  const { translations } = usePlyrLayoutContext(), $playText = $i18n(translations, \"Play\"), $pauseText = $i18n(translations, \"Pause\");\n  return html`\n    <media-play-button class=\"plyr__controls__item plyr__control\" data-no-label data-plyr=\"play\">\n      <slot name=\"pause-icon\" data-class=\"icon--pressed\"></slot>\n      <slot name=\"play-icon\" data-class=\"icon--not-pressed\"></slot>\n      <span class=\"label--pressed plyr__tooltip\">${$pauseText}</span>\n      <span class=\"label--not-pressed plyr__tooltip\">${$playText}</span>\n    </media-play-button>\n  `;\n}\nfunction RestartButton() {\n  const { translations } = usePlyrLayoutContext(), { remote } = useMediaContext(), $restartText = $i18n(translations, \"Restart\");\n  function onPress(event) {\n    if (isKeyboardEvent(event) && !isKeyboardClick(event)) return;\n    remote.seek(0, event);\n  }\n  return html`\n    <button\n      type=\"button\"\n      class=\"plyr__control\"\n      data-plyr=\"restart\"\n      @pointerup=${onPress}\n      @keydown=${onPress}\n    >\n      <slot name=\"restart-icon\"></slot>\n      <span class=\"plyr__tooltip\">${$restartText}</span>\n    </button>\n  `;\n}\nfunction RewindButton() {\n  const { translations, seekTime } = usePlyrLayoutContext(), $label = $signal(() => `${i18n(translations, \"Rewind\")} ${seekTime()}s`), $seconds = $signal(() => -1 * seekTime());\n  return html`\n    <media-seek-button\n      class=\"plyr__controls__item plyr__control\"\n      seconds=${$seconds}\n      data-no-label\n      data-plyr=\"rewind\"\n    >\n      <slot name=\"rewind-icon\"></slot>\n      <span class=\"plyr__tooltip\">${$label}</span>\n    </media-seek-button>\n  `;\n}\nfunction FastForwardButton() {\n  const { translations, seekTime } = usePlyrLayoutContext(), $label = $signal(() => `${i18n(translations, \"Forward\")} ${seekTime()}s`), $seconds = $signal(seekTime);\n  return html`\n    <media-seek-button\n      class=\"plyr__controls__item plyr__control\"\n      seconds=${$seconds}\n      data-no-label\n      data-plyr=\"fast-forward\"\n    >\n      <slot name=\"fast-forward-icon\"></slot>\n      <span class=\"plyr__tooltip\">${$label}</span>\n    </media-seek-button>\n  `;\n}\nfunction TimeSlider() {\n  let media = useMediaContext(), { duration, viewType } = media.$state, { translations, markers, thumbnails, seekTime, previewTime } = usePlyrLayoutContext(), $seekText = $i18n(translations, \"Seek\"), activeMarker = signal(null), $markerLabel = $signal(() => {\n    const marker = activeMarker();\n    return marker ? html`<span class=\"plyr__progress__marker-label\">${unsafeHTML(marker.label)}<br /></span>` : null;\n  });\n  function onSeekingRequest(event) {\n    previewTime.set(event.detail);\n  }\n  function onMarkerEnter() {\n    activeMarker.set(this);\n  }\n  function onMarkerLeave() {\n    activeMarker.set(null);\n  }\n  function Preview() {\n    const src = thumbnails(), $noClamp = $signal(() => viewType() === \"audio\");\n    return !src ? html`\n          <span class=\"plyr__tooltip\">\n            ${$markerLabel}\n            <media-slider-value></media-slider-value>\n          </span>\n        ` : html`\n          <media-slider-preview class=\"plyr__slider__preview\" ?no-clamp=${$noClamp}>\n            <media-slider-thumbnail .src=${src} class=\"plyr__slider__preview__thumbnail\">\n              <span class=\"plyr__slider__preview__time-container\">\n                ${$markerLabel}\n                <media-slider-value class=\"plyr__slider__preview__time\"></media-slider-value>\n              </span>\n            </media-slider-thumbnail>\n          </media-slider-preview>\n        `;\n  }\n  function Markers() {\n    const endTime = duration();\n    if (!Number.isFinite(endTime)) return null;\n    return markers()?.map(\n      (marker) => html`\n        <span\n          class=\"plyr__progress__marker\"\n          @mouseenter=${onMarkerEnter.bind(marker)}\n          @mouseleave=${onMarkerLeave}\n          style=${`left: ${marker.time / endTime * 100}%;`}\n        ></span>\n      `\n    );\n  }\n  return html`\n    <div class=\"plyr__controls__item plyr__progress__container\">\n      <div class=\"plyr__progress\">\n        <media-time-slider\n          class=\"plyr__slider\"\n          data-plyr=\"seek\"\n          pause-while-dragging\n          key-step=${$signal(seekTime)}\n          aria-label=${$seekText}\n          @media-seeking-request=${onSeekingRequest}\n        >\n          <div class=\"plyr__slider__track\"></div>\n          <div class=\"plyr__slider__thumb\"></div>\n          <div class=\"plyr__slider__buffer\"></div>\n          ${$signal(Preview)}${$signal(Markers)}\n        </media-time-slider>\n      </div>\n    </div>\n  `;\n}\nfunction Volume(type) {\n  return $signal(() => {\n    const hasMuteButton = type === \"mute\" || type === \"mute+volume\", hasVolumeSlider = type === \"volume\" || type === \"mute+volume\";\n    return html`\n      <div class=\"plyr__controls__item plyr__volume\">\n        ${[hasMuteButton ? MuteButton() : null, hasVolumeSlider ? VolumeSlider() : null]}\n      </div>\n    `;\n  });\n}\nfunction VolumeSlider() {\n  const { translations } = usePlyrLayoutContext(), $volumeText = $i18n(translations, \"Volume\");\n  return html`\n    <media-volume-slider class=\"plyr__slider\" data-plyr=\"volume\" aria-label=${$volumeText}>\n      <div class=\"plyr__slider__track\"></div>\n      <div class=\"plyr__slider__thumb\"></div>\n    </media-volume-slider>\n  `;\n}\nfunction CurrentTime() {\n  const media = useMediaContext(), { translations, invertTime, toggleTime, displayDuration } = usePlyrLayoutContext(), invert = signal(peek(invertTime));\n  function onPress(event) {\n    if (!toggleTime() || displayDuration() || isKeyboardEvent(event) && !isKeyboardClick(event)) {\n      return;\n    }\n    invert.set((n) => !n);\n  }\n  function MaybeDuration() {\n    return $signal(() => displayDuration() ? Duration() : null);\n  }\n  return $signal(() => {\n    const { streamType } = media.$state, $liveText = $i18n(translations, \"LIVE\"), $currentTimeText = $i18n(translations, \"Current time\"), $remainder = $signal(() => !displayDuration() && invert());\n    return streamType() === \"live\" || streamType() === \"ll-live\" ? html`\n          <media-live-button\n            class=\"plyr__controls__item plyr__control plyr__live-button\"\n            data-plyr=\"live\"\n          >\n            <span class=\"plyr__live-button__text\">${$liveText}</span>\n          </media-live-button>\n        ` : html`\n          <media-time\n            type=\"current\"\n            class=\"plyr__controls__item plyr__time plyr__time--current\"\n            tabindex=\"0\"\n            role=\"timer\"\n            aria-label=${$currentTimeText}\n            ?remainder=${$remainder}\n            @pointerup=${onPress}\n            @keydown=${onPress}\n          ></media-time>\n          ${MaybeDuration()}\n        `;\n  });\n}\nfunction Duration() {\n  const { translations } = usePlyrLayoutContext(), $durationText = $i18n(translations, \"Duration\");\n  return html`\n    <media-time\n      type=\"duration\"\n      class=\"plyr__controls__item plyr__time plyr__time--duration\"\n      role=\"timer\"\n      tabindex=\"0\"\n      aria-label=${$durationText}\n    ></media-time>\n  `;\n}\nfunction DownloadButton() {\n  return $signal(() => {\n    const media = useMediaContext(), { translations, download } = usePlyrLayoutContext(), { title, source } = media.$state, $src = source(), $download = download(), file = getDownloadFile({\n      title: title(),\n      src: $src,\n      download: $download\n    }), $downloadText = $i18n(translations, \"Download\");\n    return file ? html`\n          <a\n            class=\"plyr__controls__item plyr__control\"\n            href=${file.url + `?download=${file.name}`}\n            download=${file.name}\n            target=\"_blank\"\n          >\n            <slot name=\"download-icon\" />\n            <span class=\"plyr__tooltip\">${$downloadText}</span>\n          </a>\n        ` : null;\n  });\n}\nfunction Gestures() {\n  return $signal(() => {\n    const { clickToPlay, clickToFullscreen } = usePlyrLayoutContext();\n    return [\n      clickToPlay() ? html`\n            <media-gesture\n              class=\"plyr__gesture\"\n              event=\"pointerup\"\n              action=\"toggle:paused\"\n            ></media-gesture>\n          ` : null,\n      clickToFullscreen() ? html`\n            <media-gesture\n              class=\"plyr__gesture\"\n              event=\"dblpointerup\"\n              action=\"toggle:fullscreen\"\n            ></media-gesture>\n          ` : null\n    ];\n  });\n}\nfunction Captions() {\n  const media = useMediaContext(), activeCue = signal(void 0), $cueText = $signal(() => unsafeHTML(activeCue()?.text));\n  effect(() => {\n    const track = media.$state.textTrack();\n    if (!track) return;\n    function onCueChange() {\n      activeCue.set(track?.activeCues[0]);\n    }\n    onCueChange();\n    return listenEvent(track, \"cue-change\", onCueChange);\n  });\n  return html`\n    <div class=\"plyr__captions\" dir=\"auto\">\n      <span class=\"plyr__caption\">${$cueText}</span>\n    </div>\n  `;\n}\nfunction Settings() {\n  const { translations } = usePlyrLayoutContext(), $settingsText = $i18n(translations, \"Settings\");\n  return html`\n    <div class=\"plyr__controls__item plyr__menu\">\n      <media-menu>\n        <media-menu-button class=\"plyr__control\" data-plyr=\"settings\">\n          <slot name=\"settings-icon\" />\n          <span class=\"plyr__tooltip\">${$settingsText}</span>\n        </media-menu-button>\n        <media-menu-items class=\"plyr__menu__container\" placement=\"top end\">\n          <div><div>${[AudioMenu(), CaptionsMenu(), QualityMenu(), SpeedMenu()]}</div></div>\n        </media-menu-items>\n      </media-menu>\n    </div>\n  `;\n}\nfunction Menu({ label, children }) {\n  const open = signal(false), onOpen = () => open.set(true), onClose = () => open.set(false);\n  return html`\n    <media-menu @open=${onOpen} @close=${onClose}>\n      ${MenuButton({ label, open })}\n      <media-menu-items>${children}</media-menu-items>\n    </media-menu>\n  `;\n}\nfunction MenuButton({ open, label }) {\n  const { translations } = usePlyrLayoutContext(), $class = $signal(() => `plyr__control plyr__control--${open() ? \"back\" : \"forward\"}`);\n  function GoBackText() {\n    const $text = $i18n(translations, \"Go back to previous menu\");\n    return $signal(() => open() ? html`<span class=\"plyr__sr-only\">${$text}</span>` : null);\n  }\n  return html`\n    <media-menu-button class=${$class} data-plyr=\"settings\">\n      <span class=\"plyr__menu__label\" aria-hidden=${$aria(open)}>\n        ${$i18n(translations, label)}\n      </span>\n      <span class=\"plyr__menu__value\" data-part=\"hint\"></span>\n      ${GoBackText()}\n    </media-menu-button>\n  `;\n}\nfunction AudioMenu() {\n  return Menu({ label: \"Audio\", children: AudioRadioGroup() });\n}\nfunction AudioRadioGroup() {\n  const { translations } = usePlyrLayoutContext();\n  return html`\n    <media-audio-radio-group empty-label=${$i18n(translations, \"Default\")}>\n      <template>\n        <media-radio class=\"plyr__control\" data-plyr=\"audio\">\n          <span data-part=\"label\"></span>\n        </media-radio>\n      </template>\n    </media-audio-radio-group>\n  `;\n}\nfunction SpeedMenu() {\n  return Menu({ label: \"Speed\", children: SpeedRadioGroup() });\n}\nfunction SpeedRadioGroup() {\n  const { translations, speed } = usePlyrLayoutContext();\n  return html`\n    <media-speed-radio-group .rates=${speed} normal-label=${$i18n(translations, \"Normal\")}>\n      <template>\n        <media-radio class=\"plyr__control\" data-plyr=\"speed\">\n          <span data-part=\"label\"></span>\n        </media-radio>\n      </template>\n    </media-speed-radio-group>\n  `;\n}\nfunction CaptionsMenu() {\n  return Menu({ label: \"Captions\", children: CaptionsRadioGroup() });\n}\nfunction CaptionsRadioGroup() {\n  const { translations } = usePlyrLayoutContext();\n  return html`\n    <media-captions-radio-group off-label=${$i18n(translations, \"Disabled\")}>\n      <template>\n        <media-radio class=\"plyr__control\" data-plyr=\"captions\">\n          <span data-part=\"label\"></span>\n        </media-radio>\n      </template>\n    </media-captions-radio-group>\n  `;\n}\nfunction QualityMenu() {\n  return Menu({ label: \"Quality\", children: QualityRadioGroup() });\n}\nfunction QualityRadioGroup() {\n  const { translations } = usePlyrLayoutContext();\n  return html`\n    <media-quality-radio-group auto-label=${$i18n(translations, \"Auto\")}>\n      <template>\n        <media-radio class=\"plyr__control\" data-plyr=\"quality\">\n          <span data-part=\"label\"></span>\n        </media-radio>\n      </template>\n    </media-quality-radio-group>\n  `;\n}\nfunction $aria(signal2) {\n  return $signal(() => signal2() ? \"true\" : \"false\");\n}\nfunction $i18n(translations, word) {\n  return $signal(() => i18n(translations, word));\n}\n\nclass MediaPlyrLayoutElement extends Host(LitElement, PlyrLayout) {\n  static tagName = \"media-plyr-layout\";\n  #media;\n  onSetup() {\n    this.forwardKeepAlive = false;\n    this.#media = useMediaContext();\n  }\n  onConnect() {\n    this.#media.player.el?.setAttribute(\"data-layout\", \"plyr\");\n    onDispose(() => this.#media.player.el?.removeAttribute(\"data-layout\"));\n    usePlyrLayoutClasses(this, this.#media);\n    effect(() => {\n      if (this.$props.customIcons()) {\n        new SlotManager([this]).connect();\n      } else {\n        new PlyrLayoutIconsLoader([this]).connect();\n      }\n    });\n  }\n  render() {\n    return $signal(this.#render.bind(this));\n  }\n  #render() {\n    const { viewType } = this.#media.$state;\n    return viewType() === \"audio\" ? PlyrAudioLayout() : viewType() === \"video\" ? PlyrVideoLayout() : null;\n  }\n}\n\nexport { MediaPlyrLayoutElement };\n","import { signal, effect, toggleClass, Host, listenEvent } from '../../chunks/vidstack-DVpy0IqK.js';\nimport { DefaultLayout, DefaultAnnouncer, DefaultCaptions, DefaultSeekButton, DefaultPlayButton, DefaultTimeSlider, DefaultTimeInvert, DefaultVolumePopup, DefaultCaptionButton, DefaultDownloadButton, DefaultAirPlayButton, DefaultChaptersMenu, DefaultSettingsMenu, useDefaultLayoutContext, DefaultControlsSpacer, i18n, DefaultChapterTitle, setLayoutName, createMenuContainer, DefaultLayoutIconsLoader } from '../../chunks/vidstack-Tte9uVV_.js';\nimport { useMediaContext, useMediaState } from '../../chunks/vidstack-CUYciP40.js';\nimport { useTransitionActive, useResizeObserver, isHTMLElement } from '../../chunks/vidstack-CGUlKgT8.js';\nimport { $signal, SlotManager } from '../../chunks/vidstack-mJNGvZNe.js';\nimport { LitElement } from '../../chunks/vidstack-CwTj4H1w.js';\nimport { html } from 'lit-html';\nimport { ref } from 'lit-html/directives/ref.js';\nimport '../../chunks/vidstack-C1THCRTj.js';\nimport '../../chunks/vidstack-BOTZD4tC.js';\nimport 'lit-html/directives/if-defined.js';\nimport '../../chunks/vidstack-BgIVvpNy.js';\nimport '../../chunks/vidstack-CrZuJYaH.js';\nimport '@floating-ui/dom';\nimport 'lit-html/directives/unsafe-svg.js';\nimport 'lit-html/async-directive.js';\n\nlet DefaultAudioLayout$1 = class DefaultAudioLayout extends DefaultLayout {\n  static props = {\n    ...super.props,\n    when: ({ viewType }) => viewType === \"audio\",\n    smallWhen: ({ width }) => width < 576\n  };\n};\n\nfunction DefaultAudioLayout() {\n  return [\n    DefaultAnnouncer(),\n    DefaultCaptions(),\n    html`\n      <media-controls class=\"vds-controls\">\n        <media-controls-group class=\"vds-controls-group\">\n          ${[\n      DefaultSeekButton({ backward: true, tooltip: \"top start\" }),\n      DefaultPlayButton({ tooltip: \"top\" }),\n      DefaultSeekButton({ tooltip: \"top\" }),\n      DefaultAudioTitle(),\n      DefaultTimeSlider(),\n      DefaultTimeInvert(),\n      DefaultVolumePopup({ orientation: \"vertical\", tooltip: \"top\" }),\n      DefaultCaptionButton({ tooltip: \"top\" }),\n      DefaultDownloadButton(),\n      DefaultAirPlayButton({ tooltip: \"top\" }),\n      DefaultAudioMenus()\n    ]}\n        </media-controls-group>\n      </media-controls>\n    `\n  ];\n}\nfunction DefaultAudioTitle() {\n  return $signal(() => {\n    let $ref = signal(void 0), $isTextOverflowing = signal(false), media = useMediaContext(), { title, started, currentTime, ended } = useMediaState(), { translations } = useDefaultLayoutContext(), $isTransitionActive = useTransitionActive($ref), $isContinued = () => started() || currentTime() > 0;\n    const $title = () => {\n      const word = ended() ? \"Replay\" : $isContinued() ? \"Continue\" : \"Play\";\n      return `${i18n(translations, word)}: ${title()}`;\n    };\n    effect(() => {\n      if ($isTransitionActive() && document.activeElement === document.body) {\n        media.player.el?.focus({ preventScroll: true });\n      }\n    });\n    function onResize() {\n      const el = $ref(), isOverflowing = !!el && !$isTransitionActive() && el.clientWidth < el.children[0].clientWidth;\n      el && toggleClass(el, \"vds-marquee\", isOverflowing);\n      $isTextOverflowing.set(isOverflowing);\n    }\n    function Title() {\n      return html`\n        <span class=\"vds-title-text\">\n          ${$signal($title)}${$signal(() => $isContinued() ? DefaultChapterTitle() : null)}\n        </span>\n      `;\n    }\n    useResizeObserver($ref, onResize);\n    return title() ? html`\n          <span class=\"vds-title\" title=${$signal($title)} ${ref($ref.set)}>\n            ${[\n      Title(),\n      $signal(() => $isTextOverflowing() && !$isTransitionActive() ? Title() : null)\n    ]}\n          </span>\n        ` : DefaultControlsSpacer();\n  });\n}\nfunction DefaultAudioMenus() {\n  const placement = \"top end\";\n  return [\n    DefaultChaptersMenu({ tooltip: \"top\", placement, portal: true }),\n    DefaultSettingsMenu({ tooltip: \"top end\", placement, portal: true })\n  ];\n}\n\nclass MediaAudioLayoutElement extends Host(LitElement, DefaultAudioLayout$1) {\n  static tagName = \"media-audio-layout\";\n  static attrs = {\n    smallWhen: {\n      converter(value) {\n        return value !== \"never\" && !!value;\n      }\n    }\n  };\n  #media;\n  #scrubbing = signal(false);\n  onSetup() {\n    this.forwardKeepAlive = false;\n    this.#media = useMediaContext();\n    this.classList.add(\"vds-audio-layout\");\n    this.#setupWatchScrubbing();\n  }\n  onConnect() {\n    setLayoutName(\"audio\", () => this.isMatch);\n    this.#setupMenuContainer();\n  }\n  render() {\n    return $signal(this.#render.bind(this));\n  }\n  #render() {\n    return this.isMatch ? DefaultAudioLayout() : null;\n  }\n  #setupMenuContainer() {\n    const { menuPortal } = useDefaultLayoutContext();\n    effect(() => {\n      if (!this.isMatch) return;\n      const container = createMenuContainer(\n        this,\n        this.menuContainer,\n        \"vds-audio-layout\",\n        () => this.isSmallLayout\n      ), roots = container ? [this, container] : [this];\n      const iconsManager = this.$props.customIcons() ? new SlotManager(roots) : new DefaultLayoutIconsLoader(roots);\n      iconsManager.connect();\n      menuPortal.set(container);\n      return () => {\n        container.remove();\n        menuPortal.set(null);\n      };\n    });\n  }\n  #setupWatchScrubbing() {\n    const { pointer } = this.#media.$state;\n    effect(() => {\n      if (pointer() !== \"coarse\") return;\n      effect(this.#watchScrubbing.bind(this));\n    });\n  }\n  #watchScrubbing() {\n    if (!this.#scrubbing()) {\n      listenEvent(this, \"pointerdown\", this.#onStartScrubbing.bind(this), { capture: true });\n      return;\n    }\n    listenEvent(this, \"pointerdown\", (e) => e.stopPropagation());\n    listenEvent(window, \"pointerdown\", this.#onStopScrubbing.bind(this));\n  }\n  #onStartScrubbing(event) {\n    const { target } = event, hasTimeSlider = !!(isHTMLElement(target) && target.closest(\".vds-time-slider\"));\n    if (!hasTimeSlider) return;\n    event.stopImmediatePropagation();\n    this.setAttribute(\"data-scrubbing\", \"\");\n    this.#scrubbing.set(true);\n  }\n  #onStopScrubbing() {\n    this.#scrubbing.set(false);\n    this.removeAttribute(\"data-scrubbing\");\n  }\n}\n\nexport { MediaAudioLayoutElement };\n","import { computed, signal, effect, camelToKebabCase, Host } from '../../chunks/vidstack-DVpy0IqK.js';\nimport { DefaultLayout, useDefaultLayoutContext, DefaultAnnouncer, DefaultCaptions, DefaultControlsSpacer, DefaultTimeSlider, DefaultPlayButton, DefaultVolumePopup, DefaultTimeInfo, DefaultTitle, DefaultCaptionButton, DefaultAirPlayButton, DefaultGoogleCastButton, DefaultDownloadButton, DefaultPIPButton, DefaultFullscreenButton, DefaultChaptersMenu, DefaultSettingsMenu, setLayoutName, createMenuContainer, DefaultLayoutIconsLoader } from '../../chunks/vidstack-Tte9uVV_.js';\nimport { useMediaContext, useMediaState } from '../../chunks/vidstack-CUYciP40.js';\nimport { $signal, SlotManager } from '../../chunks/vidstack-mJNGvZNe.js';\nimport { LitElement } from '../../chunks/vidstack-CwTj4H1w.js';\nimport { html } from 'lit-html';\nimport { keyed } from 'lit-html/directives/keyed.js';\nimport { createSlot } from '../../chunks/vidstack-CGUlKgT8.js';\nimport '../../chunks/vidstack-C1THCRTj.js';\nimport '../../chunks/vidstack-BOTZD4tC.js';\nimport 'lit-html/directives/if-defined.js';\nimport 'lit-html/directives/ref.js';\nimport '../../chunks/vidstack-BgIVvpNy.js';\nimport '../../chunks/vidstack-CrZuJYaH.js';\nimport 'lit-html/directives/unsafe-svg.js';\nimport 'lit-html/async-directive.js';\nimport '@floating-ui/dom';\n\nclass DefaultVideoLayout extends DefaultLayout {\n  static props = {\n    ...super.props,\n    when: ({ viewType }) => viewType === \"video\",\n    smallWhen: ({ width, height }) => width < 576 || height < 380\n  };\n}\n\nfunction DefaultKeyboardDisplay() {\n  return $signal(() => {\n    const media = useMediaContext(), { noKeyboardAnimations, userPrefersKeyboardAnimations } = useDefaultLayoutContext(), $disabled = computed(() => noKeyboardAnimations() || !userPrefersKeyboardAnimations());\n    if ($disabled()) {\n      return null;\n    }\n    const visible = signal(false), { lastKeyboardAction } = media.$state;\n    effect(() => {\n      visible.set(!!lastKeyboardAction());\n      const id = setTimeout(() => visible.set(false), 500);\n      return () => {\n        visible.set(false);\n        window.clearTimeout(id);\n      };\n    });\n    const $actionDataAttr = computed(() => {\n      const action = lastKeyboardAction()?.action;\n      return action && visible() ? camelToKebabCase(action) : null;\n    });\n    const $classList = computed(() => `vds-kb-action${!visible() ? \" hidden\" : \"\"}`), $text = computed(getText), $iconSlot = computed(() => {\n      const name = getIconName();\n      return name ? createSlot(name) : null;\n    });\n    function Icon() {\n      const $slot = $iconSlot();\n      if (!$slot) return null;\n      return html`\n        <div class=\"vds-kb-bezel\">\n          <div class=\"vds-kb-icon\">${$slot}</div>\n        </div>\n      `;\n    }\n    return html`\n      <div class=${$signal($classList)} data-action=${$signal($actionDataAttr)}>\n        <div class=\"vds-kb-text-wrapper\">\n          <div class=\"vds-kb-text\">${$signal($text)}</div>\n        </div>\n        ${$signal(() => keyed(lastKeyboardAction(), Icon()))}\n      </div>\n    `;\n  });\n}\nfunction getText() {\n  const { $state } = useMediaContext(), action = $state.lastKeyboardAction()?.action, audioGain = $state.audioGain() ?? 1;\n  switch (action) {\n    case \"toggleMuted\":\n      return $state.muted() ? \"0%\" : getVolumeText($state.volume(), audioGain);\n    case \"volumeUp\":\n    case \"volumeDown\":\n      return getVolumeText($state.volume(), audioGain);\n    default:\n      return \"\";\n  }\n}\nfunction getVolumeText(volume, gain) {\n  return `${Math.round(volume * gain * 100)}%`;\n}\nfunction getIconName() {\n  const { $state } = useMediaContext(), action = $state.lastKeyboardAction()?.action;\n  switch (action) {\n    case \"togglePaused\":\n      return !$state.paused() ? \"kb-play-icon\" : \"kb-pause-icon\";\n    case \"toggleMuted\":\n      return $state.muted() || $state.volume() === 0 ? \"kb-mute-icon\" : $state.volume() >= 0.5 ? \"kb-volume-up-icon\" : \"kb-volume-down-icon\";\n    case \"toggleFullscreen\":\n      return `kb-fs-${$state.fullscreen() ? \"enter\" : \"exit\"}-icon`;\n    case \"togglePictureInPicture\":\n      return `kb-pip-${$state.pictureInPicture() ? \"enter\" : \"exit\"}-icon`;\n    case \"toggleCaptions\":\n      return $state.hasCaptions() ? `kb-cc-${$state.textTrack() ? \"on\" : \"off\"}-icon` : null;\n    case \"volumeUp\":\n      return \"kb-volume-up-icon\";\n    case \"volumeDown\":\n      return \"kb-volume-down-icon\";\n    case \"seekForward\":\n      return \"kb-seek-forward-icon\";\n    case \"seekBackward\":\n      return \"kb-seek-backward-icon\";\n    default:\n      return null;\n  }\n}\n\nfunction DefaultVideoLayoutLarge() {\n  return [\n    DefaultAnnouncer(),\n    DefaultVideoGestures(),\n    DefaultBufferingIndicator(),\n    DefaultKeyboardDisplay(),\n    DefaultCaptions(),\n    html`<div class=\"vds-scrim\"></div>`,\n    html`\n      <media-controls class=\"vds-controls\">\n        ${[\n      DefaultControlsGroupTop(),\n      DefaultControlsSpacer(),\n      html`<media-controls-group class=\"vds-controls-group\"></media-controls-group>`,\n      DefaultControlsSpacer(),\n      html`\n            <media-controls-group class=\"vds-controls-group\">\n              ${DefaultTimeSlider()}\n            </media-controls-group>\n          `,\n      html`\n            <media-controls-group class=\"vds-controls-group\">\n              ${[\n        DefaultPlayButton({ tooltip: \"top start\" }),\n        DefaultVolumePopup({ orientation: \"horizontal\", tooltip: \"top\" }),\n        DefaultTimeInfo(),\n        DefaultTitle(),\n        DefaultCaptionButton({ tooltip: \"top\" }),\n        DefaultBottomMenuGroup(),\n        DefaultAirPlayButton({ tooltip: \"top\" }),\n        DefaultGoogleCastButton({ tooltip: \"top\" }),\n        DefaultDownloadButton(),\n        DefaultPIPButton(),\n        DefaultFullscreenButton({ tooltip: \"top end\" })\n      ]}\n            </media-controls-group>\n          `\n    ]}\n      </media-controls>\n    `\n  ];\n}\nfunction DefaultBottomMenuGroup() {\n  return $signal(() => {\n    const { menuGroup } = useDefaultLayoutContext();\n    return menuGroup() === \"bottom\" ? DefaultVideoMenus() : null;\n  });\n}\nfunction DefaultControlsGroupTop() {\n  return html`\n    <media-controls-group class=\"vds-controls-group\">\n      ${$signal(() => {\n    const { menuGroup } = useDefaultLayoutContext();\n    return menuGroup() === \"top\" ? [DefaultControlsSpacer(), DefaultVideoMenus()] : null;\n  })}\n    </media-controls-group>\n  `;\n}\nfunction DefaultVideoLayoutSmall() {\n  return [\n    DefaultAnnouncer(),\n    DefaultVideoGestures(),\n    DefaultBufferingIndicator(),\n    DefaultCaptions(),\n    DefaultKeyboardDisplay(),\n    html`<div class=\"vds-scrim\"></div>`,\n    html`\n      <media-controls class=\"vds-controls\">\n        <media-controls-group class=\"vds-controls-group\">\n          ${[\n      DefaultAirPlayButton({ tooltip: \"top start\" }),\n      DefaultGoogleCastButton({ tooltip: \"bottom start\" }),\n      DefaultControlsSpacer(),\n      DefaultCaptionButton({ tooltip: \"bottom\" }),\n      DefaultDownloadButton(),\n      DefaultVideoMenus(),\n      DefaultVolumePopup({ orientation: \"vertical\", tooltip: \"bottom end\" })\n    ]}\n        </media-controls-group>\n\n        ${DefaultControlsSpacer()}\n\n        <media-controls-group class=\"vds-controls-group\" style=\"pointer-events: none;\">\n          ${[\n      DefaultControlsSpacer(),\n      DefaultPlayButton({ tooltip: \"top\" }),\n      DefaultControlsSpacer()\n    ]}\n        </media-controls-group>\n\n        ${DefaultControlsSpacer()}\n\n        <media-controls-group class=\"vds-controls-group\">\n          ${[DefaultTimeInfo(), DefaultTitle(), DefaultFullscreenButton({ tooltip: \"top end\" })]}\n        </media-controls-group>\n\n        <media-controls-group class=\"vds-controls-group\">\n          ${DefaultTimeSlider()}\n        </media-controls-group>\n      </media-controls>\n    `,\n    StartDuration()\n  ];\n}\nfunction DefaultVideoLoadLayout() {\n  return html`\n    <div class=\"vds-load-container\">\n      ${[DefaultBufferingIndicator(), DefaultPlayButton({ tooltip: \"top\" })]}\n    </div>\n  `;\n}\nfunction StartDuration() {\n  return $signal(() => {\n    const { duration } = useMediaState();\n    if (duration() === 0) return null;\n    return html`\n      <div class=\"vds-start-duration\">\n        <media-time class=\"vds-time\" type=\"duration\"></media-time>\n      </div>\n    `;\n  });\n}\nfunction DefaultBufferingIndicator() {\n  return html`\n    <div class=\"vds-buffering-indicator\">\n      <media-spinner class=\"vds-buffering-spinner\"></media-spinner>\n    </div>\n  `;\n}\nfunction DefaultVideoMenus() {\n  const { menuGroup, smallWhen: smWhen } = useDefaultLayoutContext(), $side = () => menuGroup() === \"top\" || smWhen() ? \"bottom\" : \"top\", $tooltip = computed(() => `${$side()} ${menuGroup() === \"top\" ? \"end\" : \"center\"}`), $placement = computed(() => `${$side()} end`);\n  return [\n    DefaultChaptersMenu({ tooltip: $tooltip, placement: $placement, portal: true }),\n    DefaultSettingsMenu({ tooltip: $tooltip, placement: $placement, portal: true })\n  ];\n}\nfunction DefaultVideoGestures() {\n  return $signal(() => {\n    const { noGestures } = useDefaultLayoutContext();\n    if (noGestures()) return null;\n    return html`\n      <div class=\"vds-gestures\">\n        <media-gesture class=\"vds-gesture\" event=\"pointerup\" action=\"toggle:paused\"></media-gesture>\n        <media-gesture\n          class=\"vds-gesture\"\n          event=\"pointerup\"\n          action=\"toggle:controls\"\n        ></media-gesture>\n        <media-gesture\n          class=\"vds-gesture\"\n          event=\"dblpointerup\"\n          action=\"toggle:fullscreen\"\n        ></media-gesture>\n        <media-gesture class=\"vds-gesture\" event=\"dblpointerup\" action=\"seek:-10\"></media-gesture>\n        <media-gesture class=\"vds-gesture\" event=\"dblpointerup\" action=\"seek:10\"></media-gesture>\n      </div>\n    `;\n  });\n}\n\nclass MediaVideoLayoutElement extends Host(LitElement, DefaultVideoLayout) {\n  static tagName = \"media-video-layout\";\n  static attrs = {\n    smallWhen: {\n      converter(value) {\n        return value !== \"never\" && !!value;\n      }\n    }\n  };\n  #media;\n  onSetup() {\n    this.forwardKeepAlive = false;\n    this.#media = useMediaContext();\n    this.classList.add(\"vds-video-layout\");\n  }\n  onConnect() {\n    setLayoutName(\"video\", () => this.isMatch);\n    this.#setupMenuContainer();\n  }\n  render() {\n    return $signal(this.#render.bind(this));\n  }\n  #setupMenuContainer() {\n    const { menuPortal } = useDefaultLayoutContext();\n    effect(() => {\n      if (!this.isMatch) return;\n      const container = createMenuContainer(\n        this,\n        this.menuContainer,\n        \"vds-video-layout\",\n        () => this.isSmallLayout\n      ), roots = container ? [this, container] : [this];\n      const iconsManager = this.$props.customIcons() ? new SlotManager(roots) : new DefaultLayoutIconsLoader(roots);\n      iconsManager.connect();\n      menuPortal.set(container);\n      return () => {\n        container.remove();\n        menuPortal.set(null);\n      };\n    });\n  }\n  #render() {\n    const { load } = this.#media.$props, { canLoad, streamType, nativeControls } = this.#media.$state;\n    return !nativeControls() && this.isMatch ? load() === \"play\" && !canLoad() ? DefaultVideoLoadLayout() : streamType() === \"unknown\" ? DefaultBufferingIndicator() : this.isSmallLayout ? DefaultVideoLayoutSmall() : DefaultVideoLayoutLarge() : null;\n  }\n}\n\nexport { MediaVideoLayoutElement };\n","import { defineCustomElement } from '../chunks/vidstack-DVpy0IqK.js';\nimport { MediaAudioLayoutElement } from './templates/vidstack-audio-layout.js';\nimport { MediaVideoLayoutElement } from './templates/vidstack-video-layout.js';\nimport { MediaPlyrLayoutElement } from './templates/plyr-layout.js';\nimport '../chunks/vidstack-Tte9uVV_.js';\nimport '../chunks/vidstack-CUYciP40.js';\nimport '../chunks/vidstack-CGUlKgT8.js';\nimport '@floating-ui/dom';\nimport 'lit-html';\nimport '../chunks/vidstack-mJNGvZNe.js';\nimport 'lit-html/directives/if-defined.js';\nimport 'lit-html/directives/unsafe-svg.js';\nimport 'lit-html/async-directive.js';\nimport '../chunks/vidstack-C1THCRTj.js';\nimport '../chunks/vidstack-BOTZD4tC.js';\nimport 'lit-html/directives/ref.js';\nimport '../chunks/vidstack-BgIVvpNy.js';\nimport '../chunks/vidstack-CrZuJYaH.js';\nimport '../chunks/vidstack-CwTj4H1w.js';\nimport 'lit-html/directives/keyed.js';\nimport '../chunks/vidstack-CuDKkHai.js';\nimport 'lit-html/directives/unsafe-html.js';\n\ndefineCustomElement(MediaAudioLayoutElement);\ndefineCustomElement(MediaVideoLayoutElement);\ndefineCustomElement(MediaPlyrLayoutElement);\n","import { defineCustomElement } from '../chunks/vidstack-DVpy0IqK.js';\nimport { MediaLayoutElement, MediaControlsElement, MediaControlsGroupElement, MediaAnnouncerElement, MediaTooltipElement, MediaTooltipTriggerElement, MediaTooltipContentElement, MediaGoogleCastButtonElement, MediaToggleButtonElement, MediaSliderElement, MediaAudioGainSliderElement, MediaSpeedSliderElement, MediaQualitySliderElement, MediaSliderChaptersElement, MediaSliderStepsElement, MediaSliderVideoElement, MediaMenuPortalElement, MediaAudioGainRadioGroupElement, MediaChaptersRadioGroupElement, MediaRadioGroupElement, MediaRadioElement, MediaGestureElement, MediaCaptionsElement, MediaTitleElement, MediaChapterTitleElement, MediaSpinnerElement } from '../chunks/vidstack-DUJY8d_d.js';\nimport { MediaPlayButtonElement, MediaMuteButtonElement, MediaCaptionButtonElement, MediaFullscreenButtonElement, MediaPIPButtonElement, MediaSeekButtonElement, MediaAirPlayButtonElement, MediaVolumeSliderElement, MediaTimeSliderElement, MediaSliderPreviewElement, MediaSliderValueElement, MediaSliderThumbnailElement, MediaMenuElement, MediaMenuButtonElement, MediaMenuItemsElement, MediaMenuItemElement, MediaAudioRadioGroupElement, MediaCaptionsRadioGroupElement, MediaSpeedRadioGroupElement, MediaQualityRadioGroupElement, MediaThumbnailElement, MediaLiveButtonElement, MediaTimeElement } from '../chunks/vidstack-U09LnPQC.js';\nimport { MediaPosterElement } from '../chunks/vidstack-BrQmGphD.js';\nimport '../chunks/vidstack-CK0M3MJg.js';\nimport '../chunks/vidstack-CUYciP40.js';\nimport '../chunks/vidstack-CGUlKgT8.js';\nimport '@floating-ui/dom';\nimport '../chunks/vidstack-CWb-Pl1C.js';\nimport '../chunks/vidstack-BOTZD4tC.js';\nimport '../chunks/vidstack-DghpoXbA.js';\nimport '../chunks/vidstack-BgIVvpNy.js';\nimport '../chunks/vidstack-CrZuJYaH.js';\nimport '../chunks/vidstack-C1THCRTj.js';\nimport '../chunks/vidstack-9MhB-Ya7.js';\nimport '../chunks/vidstack-DbBJlz7I.js';\nimport '../chunks/vidstack-Dihypf8P.js';\nimport 'lit-html';\nimport '../chunks/vidstack-CwTj4H1w.js';\nimport '../chunks/vidstack-DB2Hlarx.js';\n\ndefineCustomElement(MediaLayoutElement);\ndefineCustomElement(MediaControlsElement);\ndefineCustomElement(MediaControlsGroupElement);\ndefineCustomElement(MediaPosterElement);\ndefineCustomElement(MediaAnnouncerElement);\ndefineCustomElement(MediaTooltipElement);\ndefineCustomElement(MediaTooltipTriggerElement);\ndefineCustomElement(MediaTooltipContentElement);\ndefineCustomElement(MediaPlayButtonElement);\ndefineCustomElement(MediaMuteButtonElement);\ndefineCustomElement(MediaCaptionButtonElement);\ndefineCustomElement(MediaFullscreenButtonElement);\ndefineCustomElement(MediaPIPButtonElement);\ndefineCustomElement(MediaSeekButtonElement);\ndefineCustomElement(MediaAirPlayButtonElement);\ndefineCustomElement(MediaGoogleCastButtonElement);\ndefineCustomElement(MediaToggleButtonElement);\ndefineCustomElement(MediaSliderElement);\ndefineCustomElement(MediaAudioGainSliderElement);\ndefineCustomElement(MediaVolumeSliderElement);\ndefineCustomElement(MediaTimeSliderElement);\ndefineCustomElement(MediaSpeedSliderElement);\ndefineCustomElement(MediaQualitySliderElement);\ndefineCustomElement(MediaSliderChaptersElement);\ndefineCustomElement(MediaSliderStepsElement);\ndefineCustomElement(MediaSliderPreviewElement);\ndefineCustomElement(MediaSliderValueElement);\ndefineCustomElement(MediaSliderThumbnailElement);\ndefineCustomElement(MediaSliderVideoElement);\ndefineCustomElement(MediaMenuElement);\ndefineCustomElement(MediaMenuButtonElement);\ndefineCustomElement(MediaMenuPortalElement);\ndefineCustomElement(MediaMenuItemsElement);\ndefineCustomElement(MediaMenuItemElement);\ndefineCustomElement(MediaAudioRadioGroupElement);\ndefineCustomElement(MediaCaptionsRadioGroupElement);\ndefineCustomElement(MediaSpeedRadioGroupElement);\ndefineCustomElement(MediaAudioGainRadioGroupElement);\ndefineCustomElement(MediaQualityRadioGroupElement);\ndefineCustomElement(MediaChaptersRadioGroupElement);\ndefineCustomElement(MediaRadioGroupElement);\ndefineCustomElement(MediaRadioElement);\ndefineCustomElement(MediaGestureElement);\ndefineCustomElement(MediaThumbnailElement);\ndefineCustomElement(MediaCaptionsElement);\ndefineCustomElement(MediaLiveButtonElement);\ndefineCustomElement(MediaTimeElement);\ndefineCustomElement(MediaTitleElement);\ndefineCustomElement(MediaChapterTitleElement);\ndefineCustomElement(MediaSpinnerElement);\n","import { defineCustomElement } from '../chunks/vidstack-DVpy0IqK.js';\nimport { MediaPlayerElement, MediaProviderElement } from '../chunks/vidstack-3JWzcpEe.js';\nimport '../chunks/vidstack-Dn9nMoEW.js';\nimport '../chunks/vidstack-CUYciP40.js';\nimport '../chunks/vidstack-CrZuJYaH.js';\nimport '../chunks/vidstack-B5ElR9su.js';\nimport '../chunks/vidstack-DghpoXbA.js';\nimport '../chunks/vidstack-BgIVvpNy.js';\nimport '../chunks/vidstack-C1THCRTj.js';\nimport '../chunks/vidstack-Dv_LIPFu.js';\nimport '../chunks/vidstack-Bpr4fI4n.js';\nimport '../chunks/vidstack-DbBJlz7I.js';\nimport '../chunks/vidstack-CGUlKgT8.js';\nimport '@floating-ui/dom';\nimport '../chunks/vidstack-Dihypf8P.js';\nimport '../chunks/vidstack-9MhB-Ya7.js';\n\ndefineCustomElement(MediaPlayerElement);\ndefineCustomElement(MediaProviderElement);\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = (chunkId) => {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce((promises, key) => {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks\n__webpack_require__.u = (chunkId) => {\n\t// return url for filenames based on template\n\treturn \"\" + chunkId + \".js\";\n};","// This function allow to reference async chunks\n__webpack_require__.miniCssF = (chunkId) => {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","var inProgress = {};\nvar dataWebpackPrefix = \"rrze-video:\";\n// loadScript function to load a script via script tag\n__webpack_require__.l = (url, done, key, chunkId) => {\n\tif(inProgress[url]) { inProgress[url].push(done); return; }\n\tvar script, needAttach;\n\tif(key !== undefined) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tfor(var i = 0; i < scripts.length; i++) {\n\t\t\tvar s = scripts[i];\n\t\t\tif(s.getAttribute(\"src\") == url || s.getAttribute(\"data-webpack\") == dataWebpackPrefix + key) { script = s; break; }\n\t\t}\n\t}\n\tif(!script) {\n\t\tneedAttach = true;\n\t\tscript = document.createElement('script');\n\n\t\tscript.charset = 'utf-8';\n\t\tscript.timeout = 120;\n\t\tif (__webpack_require__.nc) {\n\t\t\tscript.setAttribute(\"nonce\", __webpack_require__.nc);\n\t\t}\n\t\tscript.setAttribute(\"data-webpack\", dataWebpackPrefix + key);\n\n\t\tscript.src = url;\n\t}\n\tinProgress[url] = [done];\n\tvar onScriptComplete = (prev, event) => {\n\t\t// avoid mem leaks in IE.\n\t\tscript.onerror = script.onload = null;\n\t\tclearTimeout(timeout);\n\t\tvar doneFns = inProgress[url];\n\t\tdelete inProgress[url];\n\t\tscript.parentNode && script.parentNode.removeChild(script);\n\t\tdoneFns && doneFns.forEach((fn) => (fn(event)));\n\t\tif(prev) return prev(event);\n\t}\n\tvar timeout = setTimeout(onScriptComplete.bind(null, undefined, { type: 'timeout', target: script }), 120000);\n\tscript.onerror = onScriptComplete.bind(null, script.onerror);\n\tscript.onload = onScriptComplete.bind(null, script.onload);\n\tneedAttach && document.head.appendChild(script);\n};","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","var scriptUrl;\nif (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + \"\";\nvar document = __webpack_require__.g.document;\nif (!scriptUrl && document) {\n\tif (document.currentScript)\n\t\tscriptUrl = document.currentScript.src;\n\tif (!scriptUrl) {\n\t\tvar scripts = document.getElementsByTagName(\"script\");\n\t\tif(scripts.length) {\n\t\t\tvar i = scripts.length - 1;\n\t\t\twhile (i > -1 && (!scriptUrl || !/^http(s?):/.test(scriptUrl))) scriptUrl = scripts[i--].src;\n\t\t}\n\t}\n}\n// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration\n// or pass an empty string (\"\") and set the __webpack_public_path__ variable from your code to use your own logic.\nif (!scriptUrl) throw new Error(\"Automatic publicPath is not supported in this browser\");\nscriptUrl = scriptUrl.replace(/#.*$/, \"\").replace(/\\?.*$/, \"\").replace(/\\/[^\\/]+$/, \"/\");\n__webpack_require__.p = scriptUrl;","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"front\": 0\n};\n\n__webpack_require__.f.j = (chunkId, promises) => {\n\t\t// JSONP chunk loading for javascript\n\t\tvar installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : undefined;\n\t\tif(installedChunkData !== 0) { // 0 means \"already installed\".\n\n\t\t\t// a Promise means \"currently loading\".\n\t\t\tif(installedChunkData) {\n\t\t\t\tpromises.push(installedChunkData[2]);\n\t\t\t} else {\n\t\t\t\tif(true) { // all chunks have JS\n\t\t\t\t\t// setup Promise in chunk cache\n\t\t\t\t\tvar promise = new Promise((resolve, reject) => (installedChunkData = installedChunks[chunkId] = [resolve, reject]));\n\t\t\t\t\tpromises.push(installedChunkData[2] = promise);\n\n\t\t\t\t\t// start chunk loading\n\t\t\t\t\tvar url = __webpack_require__.p + __webpack_require__.u(chunkId);\n\t\t\t\t\t// create error before stack unwound to get useful stacktrace later\n\t\t\t\t\tvar error = new Error();\n\t\t\t\t\tvar loadingEnded = (event) => {\n\t\t\t\t\t\tif(__webpack_require__.o(installedChunks, chunkId)) {\n\t\t\t\t\t\t\tinstalledChunkData = installedChunks[chunkId];\n\t\t\t\t\t\t\tif(installedChunkData !== 0) installedChunks[chunkId] = undefined;\n\t\t\t\t\t\t\tif(installedChunkData) {\n\t\t\t\t\t\t\t\tvar errorType = event && (event.type === 'load' ? 'missing' : event.type);\n\t\t\t\t\t\t\t\tvar realSrc = event && event.target && event.target.src;\n\t\t\t\t\t\t\t\terror.message = 'Loading chunk ' + chunkId + ' failed.\\n(' + errorType + ': ' + realSrc + ')';\n\t\t\t\t\t\t\t\terror.name = 'ChunkLoadError';\n\t\t\t\t\t\t\t\terror.type = errorType;\n\t\t\t\t\t\t\t\terror.request = realSrc;\n\t\t\t\t\t\t\t\tinstalledChunkData[1](error);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t\t__webpack_require__.l(url, loadingEnded, \"chunk-\" + chunkId, chunkId);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n};\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n// no on chunks loaded\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkrrze_video\"] = self[\"webpackChunkrrze_video\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","// Import styles.\nimport './styles.scss';\nimport { MediaProviderAdapter} from 'vidstack';\nimport 'vidstack/player/styles/default/theme.css';\nimport 'vidstack/player/styles/default/layouts/video.css';\n\n// Import necessary libraries.\nimport Hls from 'hls.js';\nimport 'vidstack/player';\nimport 'vidstack/player/layouts';\nimport 'vidstack/player/ui';\n\n// Run code when the DOM is fully loaded.\ndocument.addEventListener('DOMContentLoaded', () => {\n  // Check if HLS is supported in the current environment.\n  if (!Hls.isSupported()) {\n    console.error('HLS is not supported in this environment.');\n    return;\n  }\n\n  // Select all media-player elements on the page.\n  const players = document.querySelectorAll('media-player');\n\n  if (!players.length) {\n    console.error('No media player elements found!');\n    return;\n  }\n\n  // Extend the MediaProviderAdapter type to include the HLS-specific `library` property.\n  interface HLSProviderAdapter extends MediaProviderAdapter {\n    library?: typeof Hls | (() => Promise<typeof Hls>);\n  }\n\n  players.forEach((player) => {\n    // Attach the provider-change event listener to each player.\n    player.addEventListener('provider-change', async (event: CustomEvent) => {\n      const provider = event.detail as HLSProviderAdapter;\n\n      // Check if the provider type is 'hls'.\n      if (provider?.type === 'hls') {\n        // Optionally, use dynamic import for HLS.js if preferred.\n        provider.library = Hls; // Static assignment as per the example.\n\n        // Initialize HLS.js with the video element within the media player.\n        const videoElement = player.querySelector('video');\n        if (videoElement) {\n          // Initialize the HLS instance.\n          const hls = new Hls();\n          hls.attachMedia(videoElement);\n\n          // Listen to the event when media is attached to HLS.js.\n          hls.on(Hls.Events.MEDIA_ATTACHED, () => {\n            // Load the video source from the video element's src attribute.\n            const videoSrc = videoElement.getAttribute('src');\n            if (videoSrc) {\n              hls.loadSource(videoSrc);\n\n              // Listen for when the HLS manifest is parsed and ready.\n              hls.on(Hls.Events.MANIFEST_PARSED, () => {\n                // Automatically play the video when ready.\n                videoElement.play();\n              });\n            } else {\n              console.error('No video source found.');\n            }\n          });\n\n          // Error handling for HLS.js.\n          hls.on(Hls.Events.ERROR, (event, data) => {\n            console.error('HLS.js error:', data);\n          });\n        } else {\n          console.error('No video element found in media player.');\n        }\n      }\n    });\n  });\n});\n"],"names":["Hls","document","addEventListener","isSupported","console","error","players","querySelectorAll","length","forEach","player","event","provider","detail","type","library","videoElement","querySelector","hls","attachMedia","on","Events","MEDIA_ATTACHED","videoSrc","getAttribute","loadSource","MANIFEST_PARSED","play","ERROR","data"],"sourceRoot":""}